{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/icarus/source/css/cyberpunk.styl","path":"css/cyberpunk.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/css/default.styl","path":"css/default.styl","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/favicon.svg","path":"img/favicon.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/og_image.png","path":"img/og_image.png","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","path":"img/razor-bottom-black.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/img/razor-top-black.svg","path":"img/razor-top-black.svg","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/animation.js","path":"js/animation.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/back_to_top.js","path":"js/back_to_top.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/column.js","path":"js/column.js","modified":0,"renderable":1},{"_id":"themes/icarus/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"source/img/site/avatar.png","path":"img/site/avatar.png","modified":0,"renderable":0},{"_id":"source/img/1.png","path":"img/1.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1647529441633},{"_id":"themes/icarus/layout/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1647530558505},{"_id":"themes/icarus/layout/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1647530558508},{"_id":"themes/icarus/layout/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1647530558508},{"_id":"themes/icarus/layout/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1647530558510},{"_id":"themes/icarus/layout/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1647530558510},{"_id":"themes/icarus/include/schema/comment/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1647530558495},{"_id":"themes/icarus/include/schema/donate/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1647530558497},{"_id":"themes/icarus/include/schema/misc/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1647530558497},{"_id":"themes/icarus/include/schema/search/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1647530558498},{"_id":"themes/icarus/include/schema/share/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1647530558498},{"_id":"themes/icarus/.eslintignore","hash":"5410a1bef9807f666cd92a0d2020f700e67e4096","modified":1647530558490},{"_id":"themes/icarus/.eslintrc.json","hash":"43c7740158c8690242720b4ff7fa11426fc20c79","modified":1647530558490},{"_id":"themes/icarus/.gitignore","hash":"36084c0851a22bfd393933abb8e262562ffc6802","modified":1647530558493},{"_id":"themes/icarus/.npmignore","hash":"42242c8da7a020a3295e7dd3d18bf022cb08b661","modified":1647530558493},{"_id":"themes/icarus/CONTRIBUTING.md","hash":"70254c6778c1e41bb2ff222bbf3a70b2239b9bc1","modified":1647530558494},{"_id":"themes/icarus/LICENSE","hash":"86037e5335a49321fa73b7815cab542057fac944","modified":1647530558494},{"_id":"themes/icarus/README.md","hash":"32f9f4fc8cd7ec60b30544bd2e558b593519ae5d","modified":1647530558494},{"_id":"themes/icarus/package.json","hash":"3b9185171dfb65c70e400bede24d175202eb7809","modified":1647530558511},{"_id":"themes/icarus/.github/dependabot.yml","hash":"d532d0db30e42211f35823b9885f3ed1b2d51777","modified":1647530558492},{"_id":"themes/icarus/.github/stale.yml","hash":"88c73f6216c5666d2f60b1e8fe690a3f6e561e42","modified":1647530558492},{"_id":"themes/icarus/include/config.js","hash":"1ff0f174e9670074ad2bee890d5b6da486800c9a","modified":1647530558494},{"_id":"themes/icarus/include/dependency.js","hash":"d30dbcefd58619f6705d6369b644bc7ba44d2421","modified":1647530558494},{"_id":"themes/icarus/include/register.js","hash":"ec6596b63bfb4349ba61792d905abe8e06fea625","modified":1647530558495},{"_id":"themes/icarus/languages/de.yml","hash":"78421f09961ca0b24756a0688fb2cb2e2696e25f","modified":1647530558501},{"_id":"themes/icarus/languages/en.yml","hash":"3d674204d9f723c829226da745afddd180c1131d","modified":1647530558502},{"_id":"themes/icarus/languages/es.yml","hash":"38579b8fad4b6997362acc770615bcd85ff20f68","modified":1647530558502},{"_id":"themes/icarus/languages/fr.yml","hash":"06d5c819d6108a42b28cff7b52e5410d0bed55d1","modified":1647530558502},{"_id":"themes/icarus/languages/id.yml","hash":"5e48b1d62378cadeb64b88349477726a5c1bae47","modified":1647530558502},{"_id":"themes/icarus/languages/ja.yml","hash":"801d9930fef48d6a3f80470d5bed4f3eb78147e6","modified":1647530558502},{"_id":"themes/icarus/languages/ko.yml","hash":"e3374265377809c1518114cf352b595840c0b416","modified":1647530558502},{"_id":"themes/icarus/languages/pl.yml","hash":"2e7debb44cd91096f30efc87bf8d6b1d0d0214c9","modified":1647530558503},{"_id":"themes/icarus/languages/pt-BR.yml","hash":"ee8f73350e4c6e2f63b7fc72b34472a6b1e21244","modified":1647530558503},{"_id":"themes/icarus/languages/tr.yml","hash":"dd0a7bfe14848d6e1aa229198fe1db03e08e305e","modified":1647530558503},{"_id":"themes/icarus/languages/ru.yml","hash":"9d91358c2acbe7a0f2a25daf7f65b999ff32d068","modified":1647530558503},{"_id":"themes/icarus/languages/tk.yml","hash":"ca583168bd2025124a1cd0e977da475d7a7496fd","modified":1647530558503},{"_id":"themes/icarus/languages/zh-CN.yml","hash":"02475ba14afc70dfeaf5678467cee307835e4efa","modified":1647530558504},{"_id":"themes/icarus/languages/vn.yml","hash":"5f2fffa642110c81d8f529949711c9d19ad6bbbe","modified":1647530558504},{"_id":"themes/icarus/languages/zh-TW.yml","hash":"a6826e0c8cdb9ad286324b682b466a9e2ad78e6f","modified":1647530558504},{"_id":"themes/icarus/layout/archive.jsx","hash":"05677e93d4a43f417dbbf0d63ca37a99e6349e3b","modified":1647530558504},{"_id":"themes/icarus/layout/categories.jsx","hash":"b8ad43e28a4990d222bfbb95b032f88555492347","modified":1647530558505},{"_id":"themes/icarus/layout/category.jsx","hash":"fd15e4eac32de9ac8687aeb3dbe179ab61375700","modified":1647530558505},{"_id":"themes/icarus/layout/index.jsx","hash":"0a84a2348394fa9fc5080dd396bd28d357594f47","modified":1647530558508},{"_id":"themes/icarus/layout/layout.jsx","hash":"ac7c4e3465a116c7f05f8c2e09ee6d6b9467abf1","modified":1647530558508},{"_id":"themes/icarus/layout/page.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1647530558509},{"_id":"themes/icarus/layout/post.jsx","hash":"d26c2db57e5a88d6483a03aeb51cda9d191d8cea","modified":1647530558509},{"_id":"themes/icarus/layout/tag.jsx","hash":"d2f18cac32ca2725d34ccff3f2051c623be6c892","modified":1647530558510},{"_id":"themes/icarus/layout/tags.jsx","hash":"2c42cb64778235dd220c563a27a92108ddc50cc4","modified":1647530558510},{"_id":"themes/icarus/scripts/index.js","hash":"0c666db6fcb4ffc4d300f4e108c00ee42b1cbbe6","modified":1647530558511},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/Bug反馈.md","hash":"d801be6937df21e63113be8840b2e23c465db87b","modified":1647530558491},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/bug_report.md","hash":"5d3abdc1a2a79ef9822865184eced6e31066d8f6","modified":1647530558491},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/config.yml","hash":"b49270a202d839c298e584b5d017f56140c7e7a0","modified":1647530558491},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/feature_request.md","hash":"05313e241a3d43fdadb0f74390b562c07c25d4d0","modified":1647530558491},{"_id":"themes/icarus/.github/ISSUE_TEMPLATE/功能建议.md","hash":"c6f60f37e6cd0bc21a81b3b07f84e04e9e80fb57","modified":1647530558492},{"_id":"themes/icarus/.github/PULL_REQUEST_TEMPLATE/pull_request_template.md","hash":"e106fa240c24c8bfbdd623549651600c6d786c9c","modified":1647530558492},{"_id":"themes/icarus/.github/workflows/lint.yml","hash":"54f7052519f7a380708713ceef5c4a561832edc8","modified":1647530558493},{"_id":"themes/icarus/.github/workflows/github-release.yml","hash":"48b6bd2cc567687a7b1648c55c8f9de9d44fa9e1","modified":1647530558493},{"_id":"themes/icarus/.github/workflows/npm-publish.yml","hash":"4eabc0c60cb7102fdd5e4b0fbd8c0ac4c17cc8d0","modified":1647530558493},{"_id":"themes/icarus/.github/workflows/test.yml","hash":"f59a677dbdfa9085c38ff4fbc48ddfbe3c7615df","modified":1647530558493},{"_id":"themes/icarus/include/migration/head.js","hash":"75bb762d715aa3b27037512051641a06fc31fb5d","modified":1647530558494},{"_id":"themes/icarus/include/migration/v2_v3.js","hash":"3ccb2d2ce11018bebd7172da66faecc3983bff00","modified":1647530558494},{"_id":"themes/icarus/include/migration/v4_v5.js","hash":"6342310892d113763b5544789b45d44c0ccf2854","modified":1647530558495},{"_id":"themes/icarus/include/migration/v3_v4.js","hash":"9faf2184d7fe87debfbe007f3fc9079dcbcafcfe","modified":1647530558495},{"_id":"themes/icarus/include/schema/config.json","hash":"b949c52d02d5ee520ae4666a016ce91faf6fb350","modified":1647530558497},{"_id":"themes/icarus/include/style/article.styl","hash":"105c983871b6c9148d97a0f756886e56411572bd","modified":1647530558498},{"_id":"themes/icarus/include/style/button.styl","hash":"0fb35b4786be1b387c751fa2849bc71523fcedd4","modified":1647530558499},{"_id":"themes/icarus/include/style/base.styl","hash":"2bca6ad099949d52236c87db8db1002ffb99774c","modified":1647530558499},{"_id":"themes/icarus/include/style/card.styl","hash":"f78674422eb408cd17c17bbdc3ee1ebe4a453e05","modified":1647530558499},{"_id":"themes/icarus/include/style/codeblock.styl","hash":"30bee4cf6792e9665eb648cc20b352d9eaff1207","modified":1647530558499},{"_id":"themes/icarus/include/style/donate.styl","hash":"8d0af00628c13134b5f30a558608e7bebf18c2ec","modified":1647530558499},{"_id":"themes/icarus/include/style/helper.styl","hash":"9f3393e6122cc9f351091bfab960674e962da343","modified":1647530558500},{"_id":"themes/icarus/include/style/footer.styl","hash":"a4ad715dee38b249538ac6cce94efc9b355a904b","modified":1647530558500},{"_id":"themes/icarus/include/style/pagination.styl","hash":"b81bcd7ff915b4e9299533addc01bc4575ec35e3","modified":1647530558500},{"_id":"themes/icarus/include/style/navbar.styl","hash":"34f09b144cb46a25ec2cc7260a6c207dd34ff1fe","modified":1647530558500},{"_id":"themes/icarus/include/style/plugin.styl","hash":"679b61b5fc5b3281735a21c37aeb64229d9c51ea","modified":1647530558500},{"_id":"themes/icarus/include/style/responsive.styl","hash":"207083fe287612cddee6608b541861b14ac8de81","modified":1647530558500},{"_id":"themes/icarus/include/style/search.styl","hash":"416737e1da4e7e907bd03609b0fee9e2aacfe56c","modified":1647530558500},{"_id":"themes/icarus/include/style/timeline.styl","hash":"ea61798a09bffdda07efb93c2ff800b63bddc4c4","modified":1647530558501},{"_id":"themes/icarus/include/style/widget.styl","hash":"c746902251136544eb3fe523235b3183f4189460","modified":1647530558501},{"_id":"themes/icarus/include/util/console.js","hash":"59cf9d277d3ac85a496689bd811b1c316001641d","modified":1647530558501},{"_id":"themes/icarus/layout/common/article.jsx","hash":"e2765287c6bc6eb97975a1bb4e325b046e95b392","modified":1647530558505},{"_id":"themes/icarus/layout/common/comment.jsx","hash":"427089c33002707b76e2f38709459a6824fd0f9b","modified":1647530558506},{"_id":"themes/icarus/layout/common/donates.jsx","hash":"889fb0a7ccc502f0a43b4a18eb330e351e50493c","modified":1647530558506},{"_id":"themes/icarus/layout/common/footer.jsx","hash":"baa8e40e036a3ec0114d96893b708435104b4ba9","modified":1647530558506},{"_id":"themes/icarus/layout/common/head.jsx","hash":"2ec1f511f32e3a9c86d49f1338f57ae5ece18898","modified":1647530558506},{"_id":"themes/icarus/layout/common/navbar.jsx","hash":"d96e501e52861056474659f96ee0206588d8c93a","modified":1647530558506},{"_id":"themes/icarus/layout/common/plugins.jsx","hash":"f6826c1a5f5f59f4a0aa00c63bdb0ad4ff4eab69","modified":1647530558507},{"_id":"themes/icarus/layout/common/scripts.jsx","hash":"0fe1fddab431fb9f63906d8c480d5cd6b33abc32","modified":1647530558507},{"_id":"themes/icarus/layout/common/search.jsx","hash":"6f244a37293031670a2964fe424ecd062e591d7b","modified":1647530558507},{"_id":"themes/icarus/layout/common/share.jsx","hash":"c9fb0319ad5e5a10ad3636b26a6c2afed14c590f","modified":1647530558507},{"_id":"themes/icarus/layout/common/widgets.jsx","hash":"251263b97de12f2b8d1fce2514e83430f2515b94","modified":1647530558508},{"_id":"themes/icarus/layout/plugin/animejs.jsx","hash":"e2aa27c3501a58ef1e91e511557b77395c2c02aa","modified":1647530558509},{"_id":"themes/icarus/layout/plugin/back_to_top.jsx","hash":"7fc0c5aaabd7d0eaff04cb68ec139442dc3414e8","modified":1647530558509},{"_id":"themes/icarus/layout/widget/profile.jsx","hash":"0d3a7fd922c12cc45d2c8d26a8f4d3a9a6ed0ae0","modified":1647530558510},{"_id":"themes/icarus/source/css/cyberpunk.styl","hash":"ae17d3528df0c3f089df14a06b7bd82f1bc5fed9","modified":1647530558511},{"_id":"themes/icarus/source/css/style.styl","hash":"5b9815586e993a6ccbe8cdcfc0c65ea38fc315ac","modified":1647530558512},{"_id":"themes/icarus/source/css/default.styl","hash":"b01da3028e5a1267a40aaae5c86a11187a2259e3","modified":1647530558512},{"_id":"themes/icarus/source/img/avatar.png","hash":"0d8236dcca871735500e9d06bbdbe0853ed6775b","modified":1647530558512},{"_id":"themes/icarus/source/img/favicon.svg","hash":"16fd847265845063a16596761cddb32926073dd2","modified":1647530558512},{"_id":"themes/icarus/source/img/logo.svg","hash":"e9b5c1438ddb576693a15d0713b2a1d9ceda4be9","modified":1647530558513},{"_id":"themes/icarus/source/img/og_image.png","hash":"b03f163096ca9c350ec962feee9836277b5c2509","modified":1647530558513},{"_id":"themes/icarus/source/img/razor-top-black.svg","hash":"201f1171a43ce667a39091fe47c0f278857f18f0","modified":1647530558514},{"_id":"themes/icarus/source/img/razor-bottom-black.svg","hash":"a3eda07b1c605b456da9cdf335a1075db5e5d72c","modified":1647530558513},{"_id":"themes/icarus/source/js/.eslintrc.json","hash":"6bf0641cb69dffac97f69baea192d7fa3ab612cb","modified":1647530558514},{"_id":"themes/icarus/source/js/animation.js","hash":"12cedd5caaf9109eed97e50eeab8f883f6e49be3","modified":1647530558514},{"_id":"themes/icarus/source/js/back_to_top.js","hash":"d91f10c08c726135a13dfa1f422c49d8764ef03f","modified":1647530558514},{"_id":"themes/icarus/source/js/column.js","hash":"0baee024ab67474c073a4c41b495f3e7f0df4505","modified":1647530558515},{"_id":"themes/icarus/source/js/main.js","hash":"13e4b1c4fa287f3db61aae329ad093a81992f23d","modified":1647530558515},{"_id":"themes/icarus/include/schema/common/comment.json","hash":"7d744391a8abee9a2c450b6fdd36a3866a488025","modified":1647530558495},{"_id":"themes/icarus/include/schema/common/article.json","hash":"e2502c39045c6a26ccd8e880858f93e78c7bda35","modified":1647530558495},{"_id":"themes/icarus/include/schema/common/donates.json","hash":"ae86e6f177bedf4afbe638502c12635027539305","modified":1647530558495},{"_id":"themes/icarus/include/schema/common/head.json","hash":"98889f059c635e6bdbd51effd04cf1cf44968a66","modified":1647530558496},{"_id":"themes/icarus/include/schema/common/footer.json","hash":"09d706cbb94d6da9a0d15c719ce7139325cae1c7","modified":1647530558496},{"_id":"themes/icarus/include/schema/common/providers.json","hash":"97ec953d497fb53594227ae98acaef8a8baa91da","modified":1647530558496},{"_id":"themes/icarus/include/schema/common/navbar.json","hash":"6691e587284c4cf450e0288680d5ff0f3565f090","modified":1647530558496},{"_id":"themes/icarus/include/schema/common/plugins.json","hash":"6036a805749816416850d944f7d64aaae62e5e75","modified":1647530558496},{"_id":"themes/icarus/include/schema/common/search.json","hash":"985fbcbf47054af714ead1a124869d54f2a8b607","modified":1647530558496},{"_id":"themes/icarus/include/schema/common/share.json","hash":"cf4f9ff4fb27c3541b35f57db355c228fa6873e4","modified":1647530558496},{"_id":"themes/icarus/include/schema/common/sidebar.json","hash":"eb241beaec4c73e3085dfb3139ce72e827e20549","modified":1647530558496},{"_id":"themes/icarus/include/schema/common/widgets.json","hash":"cadd9dc942740ecd5037d3943e72f8b6a8399bbe","modified":1647530558497},{"_id":"themes/icarus/include/schema/plugin/animejs.json","hash":"e62ab6e20bd8862efa1ed32e7c0db0f8acbcfdec","modified":1647530558497},{"_id":"themes/icarus/include/schema/plugin/back_to_top.json","hash":"dc0febab7e7b67075d0ad3f80f5ec8b798b68dea","modified":1647530558498},{"_id":"themes/icarus/include/schema/widget/profile.json","hash":"690ee1b0791cab47ea03cf42b5b4932ed2aa5675","modified":1647530558498},{"_id":"themes/icarus/package-lock.json","hash":"56e2fb5abeb9f490e173336b0f8cb078477dd357","modified":1647530780053},{"_id":"source/_posts/blogs-Ajax.md","hash":"2834ef2e787507be460c271f473790d68899e066","modified":1647791446778},{"_id":"source/_posts/blogs-Arduino语音天气预报（一）.md","hash":"7eb432ae962479d6d8c2c79fc578b5c649a16bbc","modified":1647450584058},{"_id":"source/.DS_Store","hash":"cc75fbdb977a72e3c33a32b977ec965c1597d5c5","modified":1647532927042},{"_id":"source/_posts/blogs-Arduino小游戏集合（俄罗斯方块）.md","hash":"a73b65576c6fa1052475ea914fd7145f98d3e7c4","modified":1647450585294},{"_id":"source/_posts/blogs-Arduino语音天气预报（三）.md","hash":"f855f7aa22ef9c620da0d5a7b28a67c215d8bb99","modified":1647450581620},{"_id":"source/_posts/blogs-Django rest framework  认证组件源码分析.md","hash":"3d580c990b81716102e011d865e5e8ac1abf4c0f","modified":1647450345059},{"_id":"source/_posts/blogs-Django+Vue前后端分离项目的部署.md","hash":"3656ef9ef31073b83e082a8a17d9ec70d2e22428","modified":1647450341451},{"_id":"source/_posts/blogs-Arduino语音天气预报（二）.md","hash":"52c7ed338657449bdaa7a2887bd2b6c1b1704d1c","modified":1647450582837},{"_id":"source/_posts/blogs-Django 实现Websocket.md","hash":"16f83c525f6320a66fd0c0f3a344092593b252e8","modified":1647450542783},{"_id":"source/_posts/blogs-Django中间件执行流程和CSRF验证.md","hash":"2192fbc3243b5a093d47891bd228ee25b133ce68","modified":1647450343824},{"_id":"source/_posts/blogs-Django使用中间件实现用户登录功能出现重复跳转的问题及解决方法.md","hash":"4c86e5b1152a61d9da21e1ae414fbb77a5bd48fb","modified":1647450553677},{"_id":"source/_posts/blogs-Django使用邮箱进行验证操作的实现方法.md","hash":"fe07e54ad8d152566d35021c5a41315171f5aa67","modified":1647450554866},{"_id":"source/_posts/blogs-Django常用配置.md","hash":"9930a1b174afda19356e3fcab0af9106d2e9e028","modified":1647450541577},{"_id":"source/_posts/blogs-Django发送邮件.md","hash":"34ddd00a3b63c3b237329c2c50a0a5abdddefdcd","modified":1647450556038},{"_id":"source/_posts/blogs-Django支付宝自动转账功能（一）.md","hash":"d249645b191415f76d281d3ecd93ea80539e24ab","modified":1647450551323},{"_id":"source/_posts/blogs-Django支付宝自动转账功能（二）.md","hash":"fcef3e8cdbb3cdef3b8e04b5e227e4018a869ba3","modified":1647450550150},{"_id":"source/_posts/blogs-Django的template自定义函数的创建和使用.md","hash":"abba3edfeec26481580fe35e128023af142f4b5f","modified":1647450564549},{"_id":"source/_posts/blogs-Django页面跳转但是不会显示出来？？？.md","hash":"1c99b860370682d707114a7c69295368eb6823f6","modified":1647450545379},{"_id":"source/_posts/blogs-Git命令.md","hash":"79e2fe4e393646b9fe112f45d5979384293920a9","modified":1647450375312},{"_id":"source/_posts/blogs-Excel文件的创建和下载.md","hash":"a1506c8f6897df2986c66530473df50ede263d26","modified":1647450546557},{"_id":"source/_posts/blogs-Docker命令.md","hash":"88f56a7fd2d2242cce63cb68a1bdf96664b3db80","modified":1647450342652},{"_id":"source/_posts/blogs-HTTP协议基础.md","hash":"022e6b41c16fb7b914d9b1b34cd86c78f3004e96","modified":1647450334162},{"_id":"source/_posts/blogs-Leet Code OJ  简单（一）.md","hash":"80402d8c120361bbbdb7116f2cb91d384b3e666f","modified":1647450371697},{"_id":"source/_posts/blogs-Leet Code OJ 简单（二）.md","hash":"de617a4fae32f199035b40f6f1de95aa964a5650","modified":1647450370473},{"_id":"source/_posts/blogs-Leet Code OJ 简单（四）.md","hash":"322978a1f808f0f4f9a6c38a01fb3fcc96dc2bfb","modified":1647450347439},{"_id":"source/_posts/blogs-Leet Code OJ 简单（三）.md","hash":"6b341c7eaef7d9c46805411affb097adf2fcfa64","modified":1647450369267},{"_id":"source/_posts/blogs-MySQL常用命令总结.md","hash":"e6cda5ee48c15d01f44cf37eb4ba2111a8861bb4","modified":1647450547787},{"_id":"source/_posts/blogs-MySQL必知必会总结（一）.md","hash":"f0ce252cff9cf309fe90fa7d966c7010586e3dbb","modified":1647450336580},{"_id":"source/_posts/blogs-Postgresql的全文检索功能.md","hash":"0ffac9b069c22564c73c7ea548a053f395c0c332","modified":1647450327856},{"_id":"source/_posts/blogs-MySQL必知必会总结（二）.md","hash":"ffa5c9ae2f0cc1c83c08f67acbddd1bcb682d02d","modified":1647450335381},{"_id":"source/_posts/blogs-PyQt5显示GIF图片.md","hash":"5aeb88d9c0389edcfa840824bc7332f6b9c4937f","modified":1647450576621},{"_id":"source/_posts/blogs-PyQt5之SQLite数据库操作（1）.md","hash":"5b3385a800d21e8fe2777d4abc600612f0693dfb","modified":1647450574215},{"_id":"source/_posts/blogs-PyQt5无边框后窗口的移动方法.md","hash":"156ab231e6b2144ba711820f0360e4345582075a","modified":1647450575436},{"_id":"source/_posts/blogs-Python---RabbitMQ的使用.md","hash":"5d044de2f017eadb333145ee54f6b19a8fe63f34","modified":1647450563340},{"_id":"source/_posts/blogs-Python3面向对象编程总结.md","hash":"fb72a30be2dba5a4cded7019e499e57a094953a0","modified":1647450562024},{"_id":"source/_posts/blogs-Python基础---协程.md","hash":"ad16430637fc1fc5ae86c4fbf296b98efc0947e7","modified":1647450566935},{"_id":"source/_posts/blogs-Python基础---线程.md","hash":"144da0f39a816ef3a079804e874833a97ab46eea","modified":1647450570490},{"_id":"source/_posts/blogs-Python基础---进程.md","hash":"2ce87c501a3c43d7881e87db544157199c5dc5b4","modified":1647450568107},{"_id":"source/_posts/blogs-Python基础---队列.md","hash":"57f6208943cf8961b23c49c6cd59bb3e5a3b91b3","modified":1647450569278},{"_id":"source/_posts/blogs-Python字典的实现原理.md","hash":"9895bd6ff88fd71ac6019bf32ecc83a4314c71e4","modified":1647450372959},{"_id":"source/_posts/blogs-Python实现支付宝转账接口.md","hash":"bc3c51eaf4472dab64b37202cebea541e0ab53c5","modified":1647450552495},{"_id":"source/_posts/blogs-Python显示进度条的方法.md","hash":"d141d42d6bead31465902746dc4ad5730e53e5bb","modified":1647450577937},{"_id":"source/_posts/blogs-WinSCP默认使用root用户登录的方法.md","hash":"d006a559b140af55167c47c05fd23c348c525a40","modified":1647450579165},{"_id":"source/_posts/blogs-Redis基础.md","hash":"f4a03c5baa92c83ff1d3232199d4d1e31484ee89","modified":1647450565758},{"_id":"source/_posts/blogs-__repr__和__str__的区别.md","hash":"dea6f449303d13e9f0fa55a8c291287aeceb3cce","modified":1647793221709},{"_id":"source/_posts/blogs-configparser模块的简单使用.md","hash":"ba2aa190152775c411922449ffb5bae1debeb7b3","modified":1647450559654},{"_id":"source/_posts/blogs-cookie和session.md","hash":"eb7dcd4f362cb9b29ba4e77d3d01c7254ce70e26","modified":1647450558485},{"_id":"source/_posts/blogs-list.sort方法和内置函数sorted.md","hash":"c5a4c79dda7222e9a252200af5ec34086daf0025","modified":1647450374146},{"_id":"source/_posts/blogs-jieba+whoosh实现简单的商品搜索功能.md","hash":"6ab5a33658c458e96bd4db40c1481e82dd3c854f","modified":1647450329079},{"_id":"source/_posts/blogs-virtualenv和virtualenvwrapper的安装和使用.md","hash":"61c413bbd944ff07f16119a495ab239dc5321776","modified":1647450571668},{"_id":"source/_posts/blogs-从零开始搭建物联网平台（10）：微信登录和用户绑定.md","hash":"b0a5a80c5060135cc12b0116ed1e020a1c65e786","modified":1647450330251},{"_id":"source/_posts/blogs-从零开始搭建物联网平台（1）：开篇.md","hash":"ff2c8c2e9be261189bf38c3195da61d5f33be136","modified":1647450356012},{"_id":"source/_posts/blogs-从零开始搭建物联网平台（2）：MQTT服务的搭建.md","hash":"1d2463c52ebf0818c8b9d6f8bf1b5807808cca37","modified":1647450354797},{"_id":"source/_posts/blogs-从零开始搭建物联网平台（3）：硬件部分的连接测试.md","hash":"77292d648057a3d2a652235dba71a2e9024e3bad","modified":1647450353585},{"_id":"source/_posts/blogs-从零开始搭建物联网平台（4）：订阅系统主题获取设备上下线消息.md","hash":"7ad6ea8f060a5f86db6e44ea03ad983a6b9845a9","modified":1647450352299},{"_id":"source/_posts/blogs-从零开始搭建物联网平台（6）：消息的持久化.md","hash":"134b0493b526b9e62080a246b3bbc4595886843a","modified":1647450349921},{"_id":"source/_posts/blogs-从零开始搭建物联网平台（5）：搭建后台服务(一）.md","hash":"6e97695f288cd152ab184e6001a5171ee38b3abf","modified":1647450351090},{"_id":"source/_posts/blogs-从零开始搭建物联网平台（7）：使用Vue编写前端页面.md","hash":"e10ecbcb8869d406ac5ba80892f423629df7ccc5","modified":1647450348629},{"_id":"source/_posts/blogs-从零开始搭建物联网平台（8）：邮箱通知服务.md","hash":"e714ae0b1e5dba4955719fe72968c4c119c729f5","modified":1647450339004},{"_id":"source/_posts/blogs-从零开始搭建物联网平台（9）：快捷指令和指令发送.md","hash":"0b402eefc7882f9a0918c4046f597e4808f6034c","modified":1647450331517},{"_id":"source/_posts/blogs-使用CDN优化首页加载速度.md","hash":"253364a98a29b9c837dabd5f2baa24ace565b8f0","modified":1647450340196},{"_id":"source/_posts/blogs-列表中的陷阱.md","hash":"42c05f397552e4a2ece623a911bfdb847b5a4072","modified":1647450560829},{"_id":"source/_posts/blogs-对Python装饰器的理解.md","hash":"a9a98b4f010de1aaf1152f762ac9c3ae9c07400a","modified":1647450332837},{"_id":"source/_posts/blogs-对于Python闭包的理解.md","hash":"628968bed6e754cb4704dc86eb47c4f9eb579e07","modified":1647450346258},{"_id":"source/_posts/blogs-常用排序算法：冒泡排序.md","hash":"3608c532d8aac76521be34dcfcd2d49f8b9dae48","modified":1647450368024},{"_id":"source/_posts/blogs-常用排序算法：基数排序.md","hash":"a4889cf7e39621cb56bc798f15cd555f8e5b9e5e","modified":1647450357273},{"_id":"source/_posts/blogs-常用排序算法：堆排序.md","hash":"a1afd56e6ad17da99b9c4d6a9a8a4a34692045ea","modified":1647450363298},{"_id":"source/_posts/blogs-常用排序算法：希尔排序.md","hash":"a6c7af80dedb2b1f2867995453abab59726da559","modified":1647450360870},{"_id":"source/_posts/blogs-常用排序算法：归并排序.md","hash":"fb2f1dd2d45cdbde0d2125753cbe363295554368","modified":1647450362058},{"_id":"source/_posts/blogs-常用排序算法：快速排序.md","hash":"a9660c0abb59d42d72faacea5f9367bfdda488ee","modified":1647450364468},{"_id":"source/_posts/blogs-常用排序算法：桶排序.md","hash":"f9c9369c051a0d07726bcb5c10c49a111c9cbb09","modified":1647450358446},{"_id":"source/_posts/blogs-常用排序算法：直接插入排序.md","hash":"168118b47c4bcb7d24dee9fc7e49957051aa86a9","modified":1647450365669},{"_id":"source/_posts/blogs-常用排序算法：直接选择排序.md","hash":"7a23fb6f0b577c046a01d33640524539af2051c6","modified":1647450366831},{"_id":"source/_posts/blogs-常用排序算法：计数排序.md","hash":"d972b2a085e07ba5f1a3dc5760b6ccc831fc5af7","modified":1647450359640},{"_id":"source/_posts/blogs-微信公众号实现简易的物联网控制（一）.md","hash":"5a2006e56e9ba2903e485cf96d928b2088f76c95","modified":1647450580422},{"_id":"source/_posts/blogs-微信公众号实现简易的物联网控制（二）.md","hash":"517e995a7e6e9f9df6535f92141dca574b482dcf","modified":1647450572837},{"_id":"source/_posts/blogs-微信小程序开发总结.md","hash":"70f4834ed01bee7d763f00551fe9e61a75263b97","modified":1647450337840},{"_id":"source/_posts/blogs-沛齐的315面试题基础部分解答（一）.md","hash":"22db80191c0b96fef0b85052cf07911766caa0cf","modified":1647450544154},{"_id":"themes/icarus/site/avatar.png","hash":"b510ff632266da15f72f22f204c841f92ebe8bd5","modified":1647760936701},{"_id":"themes/icarus/images/site/avatar.png","hash":"b510ff632266da15f72f22f204c841f92ebe8bd5","modified":1647760936701},{"_id":"source/site/avatar.png","hash":"b510ff632266da15f72f22f204c841f92ebe8bd5","modified":1647760936701},{"_id":"source/img/site/avatar.png","hash":"b510ff632266da15f72f22f204c841f92ebe8bd5","modified":1647760936701},{"_id":"source/categories/index.md","hash":"4018a047d435f50a155e97ca0cb821647a6b253d","modified":1647790221626},{"_id":"source/tags/index.md","hash":"19a385e916c87120352bcd9d653111386755b664","modified":1647790236497},{"_id":"source/img/__repr__和__str__的区别/1.png","hash":"47a962a854a93b885f6c10785c1587463c73af38","modified":1647791642626},{"_id":"source/img/__repr__和__str__的区别/2.png","hash":"110e80e3ca115c6315867c057787cb60d27f83ee","modified":1647791903258},{"_id":"source/img/__repr__和__str__的区别/4.png","hash":"9771192dc0aef1fdeba6cdd9bb76018ee8b70fbf","modified":1647792010956},{"_id":"source/img/__repr__和__str__的区别/3.png","hash":"838477c757c18d5367cd67e9f0550ad8a58bf11a","modified":1647791973105},{"_id":"source/_posts/__repr__和__str__的区别/2.png","hash":"110e80e3ca115c6315867c057787cb60d27f83ee","modified":1647791903258},{"_id":"source/_posts/__repr__和__str__的区别/4.png","hash":"9771192dc0aef1fdeba6cdd9bb76018ee8b70fbf","modified":1647792010956},{"_id":"source/_posts/__repr__和__str__的区别/1.png","hash":"47a962a854a93b885f6c10785c1587463c73af38","modified":1647791642626},{"_id":"source/_posts/__repr__和__str__的区别/3.png","hash":"838477c757c18d5367cd67e9f0550ad8a58bf11a","modified":1647791973105},{"_id":"source/_posts/test.md","hash":"e994f2f30e162193b877128964478da3d2e499fa","modified":1647792683454},{"_id":"source/images/__repr__和__str__的区别/1.png","hash":"47a962a854a93b885f6c10785c1587463c73af38","modified":1647793190516},{"_id":"source/images/__repr__和__str__的区别/3.png","hash":"838477c757c18d5367cd67e9f0550ad8a58bf11a","modified":1647793190518},{"_id":"source/images/__repr__和__str__的区别/2.png","hash":"110e80e3ca115c6315867c057787cb60d27f83ee","modified":1647793190517},{"_id":"source/images/__repr__和__str__的区别/4.png","hash":"9771192dc0aef1fdeba6cdd9bb76018ee8b70fbf","modified":1647793190519},{"_id":"source/img/1.png","hash":"47a962a854a93b885f6c10785c1587463c73af38","modified":1647793051335}],"Category":[{"name":"Python","_id":"cl0zf5cgy0000eis4dp5xbsid"},{"name":"web前端","_id":"cl0zfry0b0000t1s47roqc26e"},{"name":"前端","_id":"cl0zfxgxb0008t1s4c0z758ay"}],"Data":[],"Page":[{"title":"标签","date":"2022-03-20T15:29:21.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2022-03-20 23:29:21\ntype: tags\n---\n","updated":"2022-03-20T15:30:36.497Z","path":"tags/index.html","_id":"cl0zfptov0000qls4eowrhgem","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2022-03-20T15:29:26.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2022-03-20 23:29:26\ntype: categories\n---\n","updated":"2022-03-20T15:30:21.626Z","path":"categories/index.html","_id":"cl0zfpxyq0001qls4d2491ekl","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-03-17T15:04:01.633Z","updated":"2022-03-17T15:04:01.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0v5cewi00000fs4cz9hbj0h","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"__repr__和__str__的区别","date":"2018-08-16T02:35:18.000Z","_content":"\n`__repr__`和`__str__`都是python中的特殊方法，都是用来输出实例对象的，如果没有定义这两个方法在打印的时候只会输出实例所在的内存地址,如图：\n![1](/images/__repr__和__str__的区别/1.png)\n![1](1.png)\n{% asset_img 1.png %}\n\n111\n\n这种方式的输出没有可读性，并不能直观的体现实例。\npython提供了`__repr__`和`__str__`这两种方法来改进，如下：\n![2](/img/1.png)\n![3](/img/__repr__和__str__的区别/3.png)\n\n在第二个例子中第一次直接输出实例并没有返回str,只改变了print的输出，由此可见`__repr__`改变的是所有的输出，而`__str__`改变的是print输出，所以当我们没有重构`__str__`只重构了`__repr__`同样是可以使用print来输出的\n![4](/img/__repr__和__str__的区别/4.png)\n\n这个例子里面同时包含了repr和str,print还是默认调用str，实例是调用repr\n借用他人的一句话 `__repr__`: 适用于开发人员，`__str__`:适用于客户。另外`__repr__`是明确无误的  `__str__` 是可读的但是不一定准确。","source":"_posts/blogs-__repr__和__str__的区别.md","raw":"---\ntitle: __repr__和__str__的区别\ndate: 2018-08-16 10:35:18\ncategories: \n- Python\n---\n\n`__repr__`和`__str__`都是python中的特殊方法，都是用来输出实例对象的，如果没有定义这两个方法在打印的时候只会输出实例所在的内存地址,如图：\n![1](/images/__repr__和__str__的区别/1.png)\n![1](1.png)\n{% asset_img 1.png %}\n\n111\n\n这种方式的输出没有可读性，并不能直观的体现实例。\npython提供了`__repr__`和`__str__`这两种方法来改进，如下：\n![2](/img/1.png)\n![3](/img/__repr__和__str__的区别/3.png)\n\n在第二个例子中第一次直接输出实例并没有返回str,只改变了print的输出，由此可见`__repr__`改变的是所有的输出，而`__str__`改变的是print输出，所以当我们没有重构`__str__`只重构了`__repr__`同样是可以使用print来输出的\n![4](/img/__repr__和__str__的区别/4.png)\n\n这个例子里面同时包含了repr和str,print还是默认调用str，实例是调用repr\n借用他人的一句话 `__repr__`: 适用于开发人员，`__str__`:适用于客户。另外`__repr__`是明确无误的  `__str__` 是可读的但是不一定准确。","slug":"blogs-__repr__和__str__的区别","published":1,"updated":"2022-03-20T16:20:21.709Z","_id":"cl0v6kepl0000yms4eflz2gus","comments":1,"layout":"post","photos":[],"link":"","content":"<p><code>__repr__</code>和<code>__str__</code>都是python中的特殊方法，都是用来输出实例对象的，如果没有定义这两个方法在打印的时候只会输出实例所在的内存地址,如图：<br><img src=\"/images/__repr__%E5%92%8C__str__%E7%9A%84%E5%8C%BA%E5%88%AB/1.png\" alt=\"1\"><br><img src=\"/.cn//1.png\" alt=\"1\"></p>\n\n\n<p>111</p>\n<p>这种方式的输出没有可读性，并不能直观的体现实例。<br>python提供了<code>__repr__</code>和<code>__str__</code>这两种方法来改进，如下：<br><img src=\"/.cn//1.png\" alt=\"2\"><br><img src=\"/.cn//__repr__%E5%92%8C__str__%E7%9A%84%E5%8C%BA%E5%88%AB/3.png\" alt=\"3\"></p>\n<p>在第二个例子中第一次直接输出实例并没有返回str,只改变了print的输出，由此可见<code>__repr__</code>改变的是所有的输出，而<code>__str__</code>改变的是print输出，所以当我们没有重构<code>__str__</code>只重构了<code>__repr__</code>同样是可以使用print来输出的<br><img src=\"/.cn//__repr__%E5%92%8C__str__%E7%9A%84%E5%8C%BA%E5%88%AB/4.png\" alt=\"4\"></p>\n<p>这个例子里面同时包含了repr和str,print还是默认调用str，实例是调用repr<br>借用他人的一句话 <code>__repr__</code>: 适用于开发人员，<code>__str__</code>:适用于客户。另外<code>__repr__</code>是明确无误的  <code>__str__</code> 是可读的但是不一定准确。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><code>__repr__</code>和<code>__str__</code>都是python中的特殊方法，都是用来输出实例对象的，如果没有定义这两个方法在打印的时候只会输出实例所在的内存地址,如图：<br><img src=\"/images/__repr__%E5%92%8C__str__%E7%9A%84%E5%8C%BA%E5%88%AB/1.png\" alt=\"1\"><br><img src=\"/.cn//1.png\" alt=\"1\"></p>\n\n\n<p>111</p>\n<p>这种方式的输出没有可读性，并不能直观的体现实例。<br>python提供了<code>__repr__</code>和<code>__str__</code>这两种方法来改进，如下：<br><img src=\"/.cn//1.png\" alt=\"2\"><br><img src=\"/.cn//__repr__%E5%92%8C__str__%E7%9A%84%E5%8C%BA%E5%88%AB/3.png\" alt=\"3\"></p>\n<p>在第二个例子中第一次直接输出实例并没有返回str,只改变了print的输出，由此可见<code>__repr__</code>改变的是所有的输出，而<code>__str__</code>改变的是print输出，所以当我们没有重构<code>__str__</code>只重构了<code>__repr__</code>同样是可以使用print来输出的<br><img src=\"/.cn//__repr__%E5%92%8C__str__%E7%9A%84%E5%8C%BA%E5%88%AB/4.png\" alt=\"4\"></p>\n<p>这个例子里面同时包含了repr和str,print还是默认调用str，实例是调用repr<br>借用他人的一句话 <code>__repr__</code>: 适用于开发人员，<code>__str__</code>:适用于客户。另外<code>__repr__</code>是明确无误的  <code>__str__</code> 是可读的但是不一定准确。</p>\n"},{"_content":"<h3>$SYS-系统主题</h3>\n\n<p style=\"text-indent:50px;\">先来看一段EMQ对于系统主题的介绍：EMQ 消息服务器周期性发布自身运行状态、MQTT 协议统计、客户端上下线状态到 $SYS/ 开头系统主题。$SYS 主题路径以 “$SYS/brokers/{node}/” 开头，’${node}’ 是 Erlang 节点名称</p>\n\n<p style=\"text-indent:50px;\">系统主题主要包括一下几大部分：<br />\n               1 ：服务器版本、启动时间与描述消息<br />\n               2 ：MQTT 客户端上下线状态消息<br />\n               3 ：系统统计消息</p>\n\n<p style=\"text-indent:50px;\">详细的介绍请看EMQ官方文档：<a href=\"http://www.emqtt.com/docs/v2/guide.html#sys\">http://www.emqtt.com/docs/v2/guide.html#sys</a>，就目前来说呢好像只有上下线状态有点用，另外两个以后要是用到了在详细说明。</p>\n\n<p style=\"text-indent:50px;\">客户端上下线状态消息的$SYS 主题前缀为: $SYS/brokers/${node}/clients/，可选择具体客户端${clientid}/connected的上下线消息，也可以选择所有设备的上下线消息：#，这里选择接收说有设备的上下线消息，那么需要订阅的主题为$SYS/brokers/emq@127.0.0.1/clients/#</p>\n\n<h3>修改访问控制规则</h3>\n\n<p style=\"text-indent:50px;\">EMQ默认情况下只有本地的dashboard才能订阅系统消息，因此还需要对EMQ配置做一些修改。方法很简单，以linux系统为例，首先进入到/etc/emqttd/目录下，找到acl.conf文件， 使用vim打开编辑<br /><img alt=\"\" class=\"has\" height=\"41\" src=\"https://img-blog.csdnimg.cn/2018110417264799.png\" width=\"440\" /></p>\n\n<p style=\"text-indent:50px;\">在文本末尾增加<span style=\"color:#f33b45;\">{allow, all, subscribe, [\"$SYS/brokers/+/clients/#\"]}. </span> 这一行的意思就是允许所有设备订阅$SYS/brokers/+/clients/#主题，也就是所有设备都能获取到其他设备的上下线消息，这里只是为了测试方便，以后为了安全考虑这部分可能会做出修改，保存退出，使用emqttd restart命令重启mqtt服务，至此控制访问规则的编辑完成。<br /><img alt=\"\" class=\"has\" height=\"164\" src=\"https://img-blog.csdnimg.cn/20181104172921446.png\" width=\"778\" /></p>\n\n<h3>测试代码</h3>\n\n<p style=\"text-indent:50px;\">这里我使用python进行编写，用的了paho-mqtt库实现mqtt通信，因为代码不是很复杂，暂时先不展看说明paho-mqtt的使用。通过订阅$SYS/brokers/emq@127.0.0.1/clients/#主题即可接收到其他设备上下线的消息</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import paho.mqtt.client as mqtt\n\ndef on_connect(client, userdata, flags, rc):\n    print(\"Connected with result code \" + str(rc))\n    client.subscribe(\"$SYS/brokers/emq@127.0.0.1/clients/#\")\n\ndef on_message(client, userdata, msg):\n    print(msg.topic + \" \" + str(msg.payload))\n\nclient = mqtt.Client(client_id='python_test')\nclient.username_pw_set('*****', '*****')  # 设置连接用户名\nclient.on_connect = on_connect\nclient.on_message = on_message\n\nclient.connect(\"your ip address\", 1883, 60)\n\nclient.loop_forever()</code></pre>\n\n<p style=\"text-indent:50px;\">运行这段代码，然后呢使用EMQ提供的websocket方式新建一个连接然后断开，看一下在控制台是否能够接收到上下线消息。如果成功将收到分别是上线和下线两条消息，不成功的话那就先在Dashboard的订阅页面查看是否成功订阅了系统消息。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"87\" src=\"https://img-blog.csdnimg.cn/2018110417530639.png\" width=\"1200\" /></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"155\" src=\"https://img-blog.csdnimg.cn/20181104175511362.png\" width=\"1177\" /></p>\n","source":"_posts/blogs-从零开始搭建物联网平台（4）：订阅系统主题获取设备上下线消息.md","raw":"<h3>$SYS-系统主题</h3>\n\n<p style=\"text-indent:50px;\">先来看一段EMQ对于系统主题的介绍：EMQ 消息服务器周期性发布自身运行状态、MQTT 协议统计、客户端上下线状态到 $SYS/ 开头系统主题。$SYS 主题路径以 “$SYS/brokers/{node}/” 开头，’${node}’ 是 Erlang 节点名称</p>\n\n<p style=\"text-indent:50px;\">系统主题主要包括一下几大部分：<br />\n               1 ：服务器版本、启动时间与描述消息<br />\n               2 ：MQTT 客户端上下线状态消息<br />\n               3 ：系统统计消息</p>\n\n<p style=\"text-indent:50px;\">详细的介绍请看EMQ官方文档：<a href=\"http://www.emqtt.com/docs/v2/guide.html#sys\">http://www.emqtt.com/docs/v2/guide.html#sys</a>，就目前来说呢好像只有上下线状态有点用，另外两个以后要是用到了在详细说明。</p>\n\n<p style=\"text-indent:50px;\">客户端上下线状态消息的$SYS 主题前缀为: $SYS/brokers/${node}/clients/，可选择具体客户端${clientid}/connected的上下线消息，也可以选择所有设备的上下线消息：#，这里选择接收说有设备的上下线消息，那么需要订阅的主题为$SYS/brokers/emq@127.0.0.1/clients/#</p>\n\n<h3>修改访问控制规则</h3>\n\n<p style=\"text-indent:50px;\">EMQ默认情况下只有本地的dashboard才能订阅系统消息，因此还需要对EMQ配置做一些修改。方法很简单，以linux系统为例，首先进入到/etc/emqttd/目录下，找到acl.conf文件， 使用vim打开编辑<br /><img alt=\"\" class=\"has\" height=\"41\" src=\"https://img-blog.csdnimg.cn/2018110417264799.png\" width=\"440\" /></p>\n\n<p style=\"text-indent:50px;\">在文本末尾增加<span style=\"color:#f33b45;\">{allow, all, subscribe, [\"$SYS/brokers/+/clients/#\"]}. </span> 这一行的意思就是允许所有设备订阅$SYS/brokers/+/clients/#主题，也就是所有设备都能获取到其他设备的上下线消息，这里只是为了测试方便，以后为了安全考虑这部分可能会做出修改，保存退出，使用emqttd restart命令重启mqtt服务，至此控制访问规则的编辑完成。<br /><img alt=\"\" class=\"has\" height=\"164\" src=\"https://img-blog.csdnimg.cn/20181104172921446.png\" width=\"778\" /></p>\n\n<h3>测试代码</h3>\n\n<p style=\"text-indent:50px;\">这里我使用python进行编写，用的了paho-mqtt库实现mqtt通信，因为代码不是很复杂，暂时先不展看说明paho-mqtt的使用。通过订阅$SYS/brokers/emq@127.0.0.1/clients/#主题即可接收到其他设备上下线的消息</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import paho.mqtt.client as mqtt\n\ndef on_connect(client, userdata, flags, rc):\n    print(\"Connected with result code \" + str(rc))\n    client.subscribe(\"$SYS/brokers/emq@127.0.0.1/clients/#\")\n\ndef on_message(client, userdata, msg):\n    print(msg.topic + \" \" + str(msg.payload))\n\nclient = mqtt.Client(client_id='python_test')\nclient.username_pw_set('*****', '*****')  # 设置连接用户名\nclient.on_connect = on_connect\nclient.on_message = on_message\n\nclient.connect(\"your ip address\", 1883, 60)\n\nclient.loop_forever()</code></pre>\n\n<p style=\"text-indent:50px;\">运行这段代码，然后呢使用EMQ提供的websocket方式新建一个连接然后断开，看一下在控制台是否能够接收到上下线消息。如果成功将收到分别是上线和下线两条消息，不成功的话那就先在Dashboard的订阅页面查看是否成功订阅了系统消息。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"87\" src=\"https://img-blog.csdnimg.cn/2018110417530639.png\" width=\"1200\" /></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"155\" src=\"https://img-blog.csdnimg.cn/20181104175511362.png\" width=\"1177\" /></p>\n","slug":"blogs-从零开始搭建物联网平台（4）：订阅系统主题获取设备上下线消息","published":1,"date":"2022-03-16T17:01:02.779Z","updated":"2022-03-16T17:05:52.299Z","_id":"cl0v6kepr0001yms41v2t2gmu","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>$SYS-系统主题</h3>\n\n<p style=\"text-indent:50px;\">先来看一段EMQ对于系统主题的介绍：EMQ 消息服务器周期性发布自身运行状态、MQTT 协议统计、客户端上下线状态到 $SYS/ 开头系统主题。$SYS 主题路径以 “$SYS/brokers/{node}/” 开头，’${node}’ 是 Erlang 节点名称</p>\n\n<p style=\"text-indent:50px;\">系统主题主要包括一下几大部分：<br />\n               1 ：服务器版本、启动时间与描述消息<br />\n               2 ：MQTT 客户端上下线状态消息<br />\n               3 ：系统统计消息</p>\n\n<p style=\"text-indent:50px;\">详细的介绍请看EMQ官方文档：<a href=\"http://www.emqtt.com/docs/v2/guide.html#sys\">http://www.emqtt.com/docs/v2/guide.html#sys</a>，就目前来说呢好像只有上下线状态有点用，另外两个以后要是用到了在详细说明。</p>\n\n<p style=\"text-indent:50px;\">客户端上下线状态消息的$SYS 主题前缀为: $SYS/brokers/${node}/clients/，可选择具体客户端${clientid}/connected的上下线消息，也可以选择所有设备的上下线消息：#，这里选择接收说有设备的上下线消息，那么需要订阅的主题为$SYS/brokers/emq@127.0.0.1/clients/#</p>\n\n<h3>修改访问控制规则</h3>\n\n<p style=\"text-indent:50px;\">EMQ默认情况下只有本地的dashboard才能订阅系统消息，因此还需要对EMQ配置做一些修改。方法很简单，以linux系统为例，首先进入到/etc/emqttd/目录下，找到acl.conf文件， 使用vim打开编辑<br /><img alt=\"\" class=\"has\" height=\"41\" src=\"https://img-blog.csdnimg.cn/2018110417264799.png\" width=\"440\" /></p>\n\n<p style=\"text-indent:50px;\">在文本末尾增加<span style=\"color:#f33b45;\">{allow, all, subscribe, [\"$SYS/brokers/+/clients/#\"]}. </span> 这一行的意思就是允许所有设备订阅$SYS/brokers/+/clients/#主题，也就是所有设备都能获取到其他设备的上下线消息，这里只是为了测试方便，以后为了安全考虑这部分可能会做出修改，保存退出，使用emqttd restart命令重启mqtt服务，至此控制访问规则的编辑完成。<br /><img alt=\"\" class=\"has\" height=\"164\" src=\"https://img-blog.csdnimg.cn/20181104172921446.png\" width=\"778\" /></p>\n\n<h3>测试代码</h3>\n\n<p style=\"text-indent:50px;\">这里我使用python进行编写，用的了paho-mqtt库实现mqtt通信，因为代码不是很复杂，暂时先不展看说明paho-mqtt的使用。通过订阅$SYS/brokers/emq@127.0.0.1/clients/#主题即可接收到其他设备上下线的消息</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import paho.mqtt.client as mqtt\n\ndef on_connect(client, userdata, flags, rc):\n    print(\"Connected with result code \" + str(rc))\n    client.subscribe(\"$SYS/brokers/emq@127.0.0.1/clients/#\")\n\ndef on_message(client, userdata, msg):\n    print(msg.topic + \" \" + str(msg.payload))\n\nclient = mqtt.Client(client_id='python_test')\nclient.username_pw_set('*****', '*****')  # 设置连接用户名\nclient.on_connect = on_connect\nclient.on_message = on_message\n\nclient.connect(\"your ip address\", 1883, 60)\n\nclient.loop_forever()</code></pre>\n\n<p style=\"text-indent:50px;\">运行这段代码，然后呢使用EMQ提供的websocket方式新建一个连接然后断开，看一下在控制台是否能够接收到上下线消息。如果成功将收到分别是上线和下线两条消息，不成功的话那就先在Dashboard的订阅页面查看是否成功订阅了系统消息。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"87\" src=\"https://img-blog.csdnimg.cn/2018110417530639.png\" width=\"1200\" /></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"155\" src=\"https://img-blog.csdnimg.cn/20181104175511362.png\" width=\"1177\" /></p>\n","site":{"data":{}},"excerpt":"","more":"<h3>$SYS-系统主题</h3>\n\n<p style=\"text-indent:50px;\">先来看一段EMQ对于系统主题的介绍：EMQ 消息服务器周期性发布自身运行状态、MQTT 协议统计、客户端上下线状态到 $SYS/ 开头系统主题。$SYS 主题路径以 “$SYS/brokers/{node}/” 开头，’${node}’ 是 Erlang 节点名称</p>\n\n<p style=\"text-indent:50px;\">系统主题主要包括一下几大部分：<br />\n               1 ：服务器版本、启动时间与描述消息<br />\n               2 ：MQTT 客户端上下线状态消息<br />\n               3 ：系统统计消息</p>\n\n<p style=\"text-indent:50px;\">详细的介绍请看EMQ官方文档：<a href=\"http://www.emqtt.com/docs/v2/guide.html#sys\">http://www.emqtt.com/docs/v2/guide.html#sys</a>，就目前来说呢好像只有上下线状态有点用，另外两个以后要是用到了在详细说明。</p>\n\n<p style=\"text-indent:50px;\">客户端上下线状态消息的$SYS 主题前缀为: $SYS/brokers/${node}/clients/，可选择具体客户端${clientid}/connected的上下线消息，也可以选择所有设备的上下线消息：#，这里选择接收说有设备的上下线消息，那么需要订阅的主题为$SYS/brokers/emq@127.0.0.1/clients/#</p>\n\n<h3>修改访问控制规则</h3>\n\n<p style=\"text-indent:50px;\">EMQ默认情况下只有本地的dashboard才能订阅系统消息，因此还需要对EMQ配置做一些修改。方法很简单，以linux系统为例，首先进入到/etc/emqttd/目录下，找到acl.conf文件， 使用vim打开编辑<br /><img alt=\"\" class=\"has\" height=\"41\" src=\"https://img-blog.csdnimg.cn/2018110417264799.png\" width=\"440\" /></p>\n\n<p style=\"text-indent:50px;\">在文本末尾增加<span style=\"color:#f33b45;\">{allow, all, subscribe, [\"$SYS/brokers/+/clients/#\"]}. </span> 这一行的意思就是允许所有设备订阅$SYS/brokers/+/clients/#主题，也就是所有设备都能获取到其他设备的上下线消息，这里只是为了测试方便，以后为了安全考虑这部分可能会做出修改，保存退出，使用emqttd restart命令重启mqtt服务，至此控制访问规则的编辑完成。<br /><img alt=\"\" class=\"has\" height=\"164\" src=\"https://img-blog.csdnimg.cn/20181104172921446.png\" width=\"778\" /></p>\n\n<h3>测试代码</h3>\n\n<p style=\"text-indent:50px;\">这里我使用python进行编写，用的了paho-mqtt库实现mqtt通信，因为代码不是很复杂，暂时先不展看说明paho-mqtt的使用。通过订阅$SYS/brokers/emq@127.0.0.1/clients/#主题即可接收到其他设备上下线的消息</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import paho.mqtt.client as mqtt\n\ndef on_connect(client, userdata, flags, rc):\n    print(\"Connected with result code \" + str(rc))\n    client.subscribe(\"$SYS/brokers/emq@127.0.0.1/clients/#\")\n\ndef on_message(client, userdata, msg):\n    print(msg.topic + \" \" + str(msg.payload))\n\nclient = mqtt.Client(client_id='python_test')\nclient.username_pw_set('*****', '*****')  # 设置连接用户名\nclient.on_connect = on_connect\nclient.on_message = on_message\n\nclient.connect(\"your ip address\", 1883, 60)\n\nclient.loop_forever()</code></pre>\n\n<p style=\"text-indent:50px;\">运行这段代码，然后呢使用EMQ提供的websocket方式新建一个连接然后断开，看一下在控制台是否能够接收到上下线消息。如果成功将收到分别是上线和下线两条消息，不成功的话那就先在Dashboard的订阅页面查看是否成功订阅了系统消息。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"87\" src=\"https://img-blog.csdnimg.cn/2018110417530639.png\" width=\"1200\" /></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"155\" src=\"https://img-blog.csdnimg.cn/20181104175511362.png\" width=\"1177\" /></p>\n"},{"_content":"<h3>前言：</h3>\n\n<p style=\"text-indent:50px;\">读大学的时候学的是物联网工程，大概是在大二的时候开始接触单片机，那时候特喜欢捣鼓那些东西，就觉得特别酷有极客范。还记得第一次做物联网相关的是一个远程控制的开关，第一次调通的时候真的很兴奋，啥也没干就挂在那用手机控制继电器听咔嗒咔哒的声音，现在想想真的好小儿科，明明只是按照人家的教程改改代码却也能兴奋那么就。但是有一句话不是说所有的编程语言第一个代码都是Hello World，一切都要从最基础的开始，当我们有能力的时候才能做更大的事。</p>\n\n<p style=\"text-indent:50px;\">言归正传，之前也用过一些很成熟的物联网平台例如移动的OneNET、 Yeelink，做的都很好功能也很强大，我也做过一些扩展功能，例如那时候OneNET是没有手机端的，于是就根据OneNET提供的API实现了微信公众号的访问和控制（最开始的几篇博客有介绍），可是觉得这些一点也不极客，无非是在调用API。搭建一个个人的物联网平台这个想法很久之前就有了，只是一直迟迟未开始，现在我觉得是时候开始着手实现这个想法了。关于这个物联网平台我的想法是够用就好，也许它很简单，功能有点low，设计不合理等等，毕竟是我自己做出来的，开心就好【手动滑稽】，当然呢我也会尽力去完善。立一个Flag半年之内完成。</p>\n\n<p style=\"text-indent:50px;\"><span style=\"color:#f33b45;\">最后也是最重要的一点，这不是一个教程，只是我个人的一些开发记录，里面可能会有很多漏洞，不合理的地方，而且之前的操作可能会在后面给推翻重做，所以啊，参考就行了不要当真。</span></p>\n\n<h3>整体构思：</h3>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"431\" src=\"https://img-blog.csdnimg.cn/20181104024403255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"805\" /></p>\n\n<p style=\"text-indent:0;\">图画的有点low不要介意，简单说一下<br />\n        硬件：这里选择Arduino平台开发，之所以不先考虑stm32或者51之类的，是因为那两个我都没完整的了解过，等以后会提供更多的连接例程，目前手上现有一个NodeMCU、和一个ArduinoMEGA2560，考虑到Arduino和ESP8266连线太麻烦了，就以NodeMCU为例。<br />\n        平台：协议就使用MQTT好了，后台用Django，数据库MySQL。<br />\n        手机：还是借助微信公众号之前也有一些经验，最主要的是APP开发不会。<br />\n        电脑：应该会和OneNET类似，前端大概率会用vue开发，这个应该会放到最后实现，vue还在学习阶段。<br />\n        大致功能包括： 用户注册、添加设备、上传数据、查看历史数据、发送控制指令、微信提醒，目前想到的就只有这么多了，以后还有新的再来添加。</p>\n\n<p style=\"text-indent:0;\"> </p>\n\n<h3 style=\"text-indent:0px;\"><strong>更新一下：</strong></h3>\n\n<p><strong>项目差不多完成了75%左右，在制作过程中对原有的一些设计做了优化和调整目前项目的整个架构图如下</strong></p>\n\n<p><img alt=\"\" class=\"has\" height=\"567\" src=\"https://img-blog.csdnimg.cn/20190218132744174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"918\" /></p>","source":"_posts/blogs-从零开始搭建物联网平台（1）：开篇.md","raw":"<h3>前言：</h3>\n\n<p style=\"text-indent:50px;\">读大学的时候学的是物联网工程，大概是在大二的时候开始接触单片机，那时候特喜欢捣鼓那些东西，就觉得特别酷有极客范。还记得第一次做物联网相关的是一个远程控制的开关，第一次调通的时候真的很兴奋，啥也没干就挂在那用手机控制继电器听咔嗒咔哒的声音，现在想想真的好小儿科，明明只是按照人家的教程改改代码却也能兴奋那么就。但是有一句话不是说所有的编程语言第一个代码都是Hello World，一切都要从最基础的开始，当我们有能力的时候才能做更大的事。</p>\n\n<p style=\"text-indent:50px;\">言归正传，之前也用过一些很成熟的物联网平台例如移动的OneNET、 Yeelink，做的都很好功能也很强大，我也做过一些扩展功能，例如那时候OneNET是没有手机端的，于是就根据OneNET提供的API实现了微信公众号的访问和控制（最开始的几篇博客有介绍），可是觉得这些一点也不极客，无非是在调用API。搭建一个个人的物联网平台这个想法很久之前就有了，只是一直迟迟未开始，现在我觉得是时候开始着手实现这个想法了。关于这个物联网平台我的想法是够用就好，也许它很简单，功能有点low，设计不合理等等，毕竟是我自己做出来的，开心就好【手动滑稽】，当然呢我也会尽力去完善。立一个Flag半年之内完成。</p>\n\n<p style=\"text-indent:50px;\"><span style=\"color:#f33b45;\">最后也是最重要的一点，这不是一个教程，只是我个人的一些开发记录，里面可能会有很多漏洞，不合理的地方，而且之前的操作可能会在后面给推翻重做，所以啊，参考就行了不要当真。</span></p>\n\n<h3>整体构思：</h3>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"431\" src=\"https://img-blog.csdnimg.cn/20181104024403255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"805\" /></p>\n\n<p style=\"text-indent:0;\">图画的有点low不要介意，简单说一下<br />\n        硬件：这里选择Arduino平台开发，之所以不先考虑stm32或者51之类的，是因为那两个我都没完整的了解过，等以后会提供更多的连接例程，目前手上现有一个NodeMCU、和一个ArduinoMEGA2560，考虑到Arduino和ESP8266连线太麻烦了，就以NodeMCU为例。<br />\n        平台：协议就使用MQTT好了，后台用Django，数据库MySQL。<br />\n        手机：还是借助微信公众号之前也有一些经验，最主要的是APP开发不会。<br />\n        电脑：应该会和OneNET类似，前端大概率会用vue开发，这个应该会放到最后实现，vue还在学习阶段。<br />\n        大致功能包括： 用户注册、添加设备、上传数据、查看历史数据、发送控制指令、微信提醒，目前想到的就只有这么多了，以后还有新的再来添加。</p>\n\n<p style=\"text-indent:0;\"> </p>\n\n<h3 style=\"text-indent:0px;\"><strong>更新一下：</strong></h3>\n\n<p><strong>项目差不多完成了75%左右，在制作过程中对原有的一些设计做了优化和调整目前项目的整个架构图如下</strong></p>\n\n<p><img alt=\"\" class=\"has\" height=\"567\" src=\"https://img-blog.csdnimg.cn/20190218132744174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"918\" /></p>","slug":"blogs-从零开始搭建物联网平台（1）：开篇","published":1,"date":"2022-03-16T17:01:06.370Z","updated":"2022-03-16T17:05:56.012Z","_id":"cl0v6kept0002yms479en07eq","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>前言：</h3>\n\n<p style=\"text-indent:50px;\">读大学的时候学的是物联网工程，大概是在大二的时候开始接触单片机，那时候特喜欢捣鼓那些东西，就觉得特别酷有极客范。还记得第一次做物联网相关的是一个远程控制的开关，第一次调通的时候真的很兴奋，啥也没干就挂在那用手机控制继电器听咔嗒咔哒的声音，现在想想真的好小儿科，明明只是按照人家的教程改改代码却也能兴奋那么就。但是有一句话不是说所有的编程语言第一个代码都是Hello World，一切都要从最基础的开始，当我们有能力的时候才能做更大的事。</p>\n\n<p style=\"text-indent:50px;\">言归正传，之前也用过一些很成熟的物联网平台例如移动的OneNET、 Yeelink，做的都很好功能也很强大，我也做过一些扩展功能，例如那时候OneNET是没有手机端的，于是就根据OneNET提供的API实现了微信公众号的访问和控制（最开始的几篇博客有介绍），可是觉得这些一点也不极客，无非是在调用API。搭建一个个人的物联网平台这个想法很久之前就有了，只是一直迟迟未开始，现在我觉得是时候开始着手实现这个想法了。关于这个物联网平台我的想法是够用就好，也许它很简单，功能有点low，设计不合理等等，毕竟是我自己做出来的，开心就好【手动滑稽】，当然呢我也会尽力去完善。立一个Flag半年之内完成。</p>\n\n<p style=\"text-indent:50px;\"><span style=\"color:#f33b45;\">最后也是最重要的一点，这不是一个教程，只是我个人的一些开发记录，里面可能会有很多漏洞，不合理的地方，而且之前的操作可能会在后面给推翻重做，所以啊，参考就行了不要当真。</span></p>\n\n<h3>整体构思：</h3>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"431\" src=\"https://img-blog.csdnimg.cn/20181104024403255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"805\" /></p>\n\n<p style=\"text-indent:0;\">图画的有点low不要介意，简单说一下<br />\n        硬件：这里选择Arduino平台开发，之所以不先考虑stm32或者51之类的，是因为那两个我都没完整的了解过，等以后会提供更多的连接例程，目前手上现有一个NodeMCU、和一个ArduinoMEGA2560，考虑到Arduino和ESP8266连线太麻烦了，就以NodeMCU为例。<br />\n        平台：协议就使用MQTT好了，后台用Django，数据库MySQL。<br />\n        手机：还是借助微信公众号之前也有一些经验，最主要的是APP开发不会。<br />\n        电脑：应该会和OneNET类似，前端大概率会用vue开发，这个应该会放到最后实现，vue还在学习阶段。<br />\n        大致功能包括： 用户注册、添加设备、上传数据、查看历史数据、发送控制指令、微信提醒，目前想到的就只有这么多了，以后还有新的再来添加。</p>\n\n<p style=\"text-indent:0;\"> </p>\n\n<h3 style=\"text-indent:0px;\"><strong>更新一下：</strong></h3>\n\n<p><strong>项目差不多完成了75%左右，在制作过程中对原有的一些设计做了优化和调整目前项目的整个架构图如下</strong></p>\n\n<p><img alt=\"\" class=\"has\" height=\"567\" src=\"https://img-blog.csdnimg.cn/20190218132744174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"918\" /></p>","site":{"data":{}},"excerpt":"","more":"<h3>前言：</h3>\n\n<p style=\"text-indent:50px;\">读大学的时候学的是物联网工程，大概是在大二的时候开始接触单片机，那时候特喜欢捣鼓那些东西，就觉得特别酷有极客范。还记得第一次做物联网相关的是一个远程控制的开关，第一次调通的时候真的很兴奋，啥也没干就挂在那用手机控制继电器听咔嗒咔哒的声音，现在想想真的好小儿科，明明只是按照人家的教程改改代码却也能兴奋那么就。但是有一句话不是说所有的编程语言第一个代码都是Hello World，一切都要从最基础的开始，当我们有能力的时候才能做更大的事。</p>\n\n<p style=\"text-indent:50px;\">言归正传，之前也用过一些很成熟的物联网平台例如移动的OneNET、 Yeelink，做的都很好功能也很强大，我也做过一些扩展功能，例如那时候OneNET是没有手机端的，于是就根据OneNET提供的API实现了微信公众号的访问和控制（最开始的几篇博客有介绍），可是觉得这些一点也不极客，无非是在调用API。搭建一个个人的物联网平台这个想法很久之前就有了，只是一直迟迟未开始，现在我觉得是时候开始着手实现这个想法了。关于这个物联网平台我的想法是够用就好，也许它很简单，功能有点low，设计不合理等等，毕竟是我自己做出来的，开心就好【手动滑稽】，当然呢我也会尽力去完善。立一个Flag半年之内完成。</p>\n\n<p style=\"text-indent:50px;\"><span style=\"color:#f33b45;\">最后也是最重要的一点，这不是一个教程，只是我个人的一些开发记录，里面可能会有很多漏洞，不合理的地方，而且之前的操作可能会在后面给推翻重做，所以啊，参考就行了不要当真。</span></p>\n\n<h3>整体构思：</h3>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"431\" src=\"https://img-blog.csdnimg.cn/20181104024403255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"805\" /></p>\n\n<p style=\"text-indent:0;\">图画的有点low不要介意，简单说一下<br />\n        硬件：这里选择Arduino平台开发，之所以不先考虑stm32或者51之类的，是因为那两个我都没完整的了解过，等以后会提供更多的连接例程，目前手上现有一个NodeMCU、和一个ArduinoMEGA2560，考虑到Arduino和ESP8266连线太麻烦了，就以NodeMCU为例。<br />\n        平台：协议就使用MQTT好了，后台用Django，数据库MySQL。<br />\n        手机：还是借助微信公众号之前也有一些经验，最主要的是APP开发不会。<br />\n        电脑：应该会和OneNET类似，前端大概率会用vue开发，这个应该会放到最后实现，vue还在学习阶段。<br />\n        大致功能包括： 用户注册、添加设备、上传数据、查看历史数据、发送控制指令、微信提醒，目前想到的就只有这么多了，以后还有新的再来添加。</p>\n\n<p style=\"text-indent:0;\"> </p>\n\n<h3 style=\"text-indent:0px;\"><strong>更新一下：</strong></h3>\n\n<p><strong>项目差不多完成了75%左右，在制作过程中对原有的一些设计做了优化和调整目前项目的整个架构图如下</strong></p>\n\n<p><img alt=\"\" class=\"has\" height=\"567\" src=\"https://img-blog.csdnimg.cn/20190218132744174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"918\" /></p>"},{"_content":"<h3 id=\"EMQ%EF%BC%9A\">EMQ：</h3>\n\n<p style=\"text-indent:50px;\">现有的MQTT服务器有很多，例如Mosquitto、Apache-Apollo、EMQ等等，最后呢选择了EMQ毕，国内公司的开源产品，中文资料相对要多一些。EMQ的官网宣称是百万级分布式开源物联网MQTT消息服务器，百不百万倒无所谓，反正是给自用的没有那么多的数据产生。</p>\n\n<h3 id=\"%E5%AE%89%E8%A3%85%EF%BC%9A\">安装：</h3>\n\n<p style=\"text-indent:50px;\">服务器系统版本为Ubuntu14.04，首先在EMQ官网下载对应的安装包<a href=\"http://emqtt.com/downloads/latest/ubuntu14_04-deb\">http://emqtt.com/downloads/latest/ubuntu14_04-deb</a>，进入目录 输入命令：sudo dpkg -i emqttd-ubuntu16.04_v2.0_amd64.deb进行安装。按照官方的说明完成上述操作之后还需要安装依赖lksctp-tools库apt-get install lksctp-tools。至此MQTT服务已经搭建好了，但是还需要一些配置方可使用。</p>\n\n<h3 id=\"%E9%85%8D%E7%BD%AE%EF%BC%9A\">配置：</h3>\n\n<p style=\"text-indent:50px;\">EMQ提供了Web 管理控制台，默认是开启的，URL 地址: <a href=\"http://localhost:18083/\">http://localhost:18083</a> ，缺省用户名/密码: admin/public。登陆成功之后就能可查询 EMQ 消息服务器基本信息、统计数据、度量数据，查询系统客户端(Client)、会话(Session)、主题(Topic)、订阅(Subscription)，以及对插件的管理。</p>\n\n<p style=\"text-indent:50px;\">插件里面我觉得最重要的应该是认证插件，当然了是可以不需要认证功能的，但是呢安全性和规范性还是需要认证功能的，EMQ提供了很种方式的认证功能，我选择MySQL认证访问插件。</p>\n\n<p style=\"text-indent:50px;\">进入到插件管理页面，打开MySQL配置，第一步填写 MySQL数据库的相关信息，还需要注意一下要把加密方式给去掉，这样连接的时候要方便一些。完成这些配置之后要到MySQL对应的数据库创建用户和访问控制表：</p>\n\n<pre class=\"has\">\n<code class=\"language-sql\">CREATE TABLE `mqtt_user` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n  `username` varchar(100) DEFAULT NULL,\n  `password` varchar(100) DEFAULT NULL,\n  `salt` varchar(35) DEFAULT NULL,\n  `is_superuser` tinyint(1) DEFAULT 0,\n  `created` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `mqtt_username` (`username`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;</code></pre>\n\n<pre class=\"has\">\n<code class=\"language-sql\">CREATE TABLE `mqtt_acl` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n  `allow` int(1) DEFAULT NULL COMMENT '0: deny, 1: allow',\n  `ipaddr` varchar(60) DEFAULT NULL COMMENT 'IpAddress',\n  `username` varchar(100) DEFAULT NULL COMMENT 'Username',\n  `clientid` varchar(100) DEFAULT NULL COMMENT 'ClientId',\n  `access` int(2) NOT NULL COMMENT '1: subscribe, 2: publish, 3: pubsub',\n  `topic` varchar(100) NOT NULL DEFAULT '' COMMENT 'Topic Filter',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `mqtt_acl` (`id`, `allow`, `ipaddr`, `username`, `clientid`, `access`, `topic`)\nVALUES\n    (1,1,NULL,'$all',NULL,2,'#'),\n    (2,0,NULL,'$all',NULL,1,'$SYS/#'),\n    (3,0,NULL,'$all',NULL,1,'eq #'),\n    (5,1,'127.0.0.1',NULL,NULL,2,'$SYS/#'),\n    (6,1,'127.0.0.1',NULL,NULL,2,'#'),\n    (7,1,NULL,'dashboard',NULL,1,'$SYS/#');</code></pre>\n\n<p style=\"text-indent:50px;\">为了测试方便先在用户表里面插入一个测试账户信息，例如username：admin 、password：123456，至此认证功能基本上配置好了。</p>\n\n<h3 id=\"%E6%B5%8B%E8%AF%95%EF%BC%9A\">测试：</h3>\n\n<p style=\"text-indent:50px;\">现在还没有完成硬件部分的设计，只能通过EMQ提供的Websocket工具来测试连通性，打开websocket页面，填写好之前在用户表里面的账户和密码，点击连接测试能否连接成功，如果成功了那么整个MQTT服务的搭建也就顺利完成了。</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>","source":"_posts/blogs-从零开始搭建物联网平台（2）：MQTT服务的搭建.md","raw":"<h3 id=\"EMQ%EF%BC%9A\">EMQ：</h3>\n\n<p style=\"text-indent:50px;\">现有的MQTT服务器有很多，例如Mosquitto、Apache-Apollo、EMQ等等，最后呢选择了EMQ毕，国内公司的开源产品，中文资料相对要多一些。EMQ的官网宣称是百万级分布式开源物联网MQTT消息服务器，百不百万倒无所谓，反正是给自用的没有那么多的数据产生。</p>\n\n<h3 id=\"%E5%AE%89%E8%A3%85%EF%BC%9A\">安装：</h3>\n\n<p style=\"text-indent:50px;\">服务器系统版本为Ubuntu14.04，首先在EMQ官网下载对应的安装包<a href=\"http://emqtt.com/downloads/latest/ubuntu14_04-deb\">http://emqtt.com/downloads/latest/ubuntu14_04-deb</a>，进入目录 输入命令：sudo dpkg -i emqttd-ubuntu16.04_v2.0_amd64.deb进行安装。按照官方的说明完成上述操作之后还需要安装依赖lksctp-tools库apt-get install lksctp-tools。至此MQTT服务已经搭建好了，但是还需要一些配置方可使用。</p>\n\n<h3 id=\"%E9%85%8D%E7%BD%AE%EF%BC%9A\">配置：</h3>\n\n<p style=\"text-indent:50px;\">EMQ提供了Web 管理控制台，默认是开启的，URL 地址: <a href=\"http://localhost:18083/\">http://localhost:18083</a> ，缺省用户名/密码: admin/public。登陆成功之后就能可查询 EMQ 消息服务器基本信息、统计数据、度量数据，查询系统客户端(Client)、会话(Session)、主题(Topic)、订阅(Subscription)，以及对插件的管理。</p>\n\n<p style=\"text-indent:50px;\">插件里面我觉得最重要的应该是认证插件，当然了是可以不需要认证功能的，但是呢安全性和规范性还是需要认证功能的，EMQ提供了很种方式的认证功能，我选择MySQL认证访问插件。</p>\n\n<p style=\"text-indent:50px;\">进入到插件管理页面，打开MySQL配置，第一步填写 MySQL数据库的相关信息，还需要注意一下要把加密方式给去掉，这样连接的时候要方便一些。完成这些配置之后要到MySQL对应的数据库创建用户和访问控制表：</p>\n\n<pre class=\"has\">\n<code class=\"language-sql\">CREATE TABLE `mqtt_user` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n  `username` varchar(100) DEFAULT NULL,\n  `password` varchar(100) DEFAULT NULL,\n  `salt` varchar(35) DEFAULT NULL,\n  `is_superuser` tinyint(1) DEFAULT 0,\n  `created` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `mqtt_username` (`username`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;</code></pre>\n\n<pre class=\"has\">\n<code class=\"language-sql\">CREATE TABLE `mqtt_acl` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n  `allow` int(1) DEFAULT NULL COMMENT '0: deny, 1: allow',\n  `ipaddr` varchar(60) DEFAULT NULL COMMENT 'IpAddress',\n  `username` varchar(100) DEFAULT NULL COMMENT 'Username',\n  `clientid` varchar(100) DEFAULT NULL COMMENT 'ClientId',\n  `access` int(2) NOT NULL COMMENT '1: subscribe, 2: publish, 3: pubsub',\n  `topic` varchar(100) NOT NULL DEFAULT '' COMMENT 'Topic Filter',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `mqtt_acl` (`id`, `allow`, `ipaddr`, `username`, `clientid`, `access`, `topic`)\nVALUES\n    (1,1,NULL,'$all',NULL,2,'#'),\n    (2,0,NULL,'$all',NULL,1,'$SYS/#'),\n    (3,0,NULL,'$all',NULL,1,'eq #'),\n    (5,1,'127.0.0.1',NULL,NULL,2,'$SYS/#'),\n    (6,1,'127.0.0.1',NULL,NULL,2,'#'),\n    (7,1,NULL,'dashboard',NULL,1,'$SYS/#');</code></pre>\n\n<p style=\"text-indent:50px;\">为了测试方便先在用户表里面插入一个测试账户信息，例如username：admin 、password：123456，至此认证功能基本上配置好了。</p>\n\n<h3 id=\"%E6%B5%8B%E8%AF%95%EF%BC%9A\">测试：</h3>\n\n<p style=\"text-indent:50px;\">现在还没有完成硬件部分的设计，只能通过EMQ提供的Websocket工具来测试连通性，打开websocket页面，填写好之前在用户表里面的账户和密码，点击连接测试能否连接成功，如果成功了那么整个MQTT服务的搭建也就顺利完成了。</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>","slug":"blogs-从零开始搭建物联网平台（2）：MQTT服务的搭建","published":1,"date":"2022-03-16T17:01:05.200Z","updated":"2022-03-16T17:05:54.797Z","_id":"cl0v6kepu0003yms4hgipbwq5","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"EMQ%EF%BC%9A\">EMQ：</h3>\n\n<p style=\"text-indent:50px;\">现有的MQTT服务器有很多，例如Mosquitto、Apache-Apollo、EMQ等等，最后呢选择了EMQ毕，国内公司的开源产品，中文资料相对要多一些。EMQ的官网宣称是百万级分布式开源物联网MQTT消息服务器，百不百万倒无所谓，反正是给自用的没有那么多的数据产生。</p>\n\n<h3 id=\"%E5%AE%89%E8%A3%85%EF%BC%9A\">安装：</h3>\n\n<p style=\"text-indent:50px;\">服务器系统版本为Ubuntu14.04，首先在EMQ官网下载对应的安装包<a href=\"http://emqtt.com/downloads/latest/ubuntu14_04-deb\">http://emqtt.com/downloads/latest/ubuntu14_04-deb</a>，进入目录 输入命令：sudo dpkg -i emqttd-ubuntu16.04_v2.0_amd64.deb进行安装。按照官方的说明完成上述操作之后还需要安装依赖lksctp-tools库apt-get install lksctp-tools。至此MQTT服务已经搭建好了，但是还需要一些配置方可使用。</p>\n\n<h3 id=\"%E9%85%8D%E7%BD%AE%EF%BC%9A\">配置：</h3>\n\n<p style=\"text-indent:50px;\">EMQ提供了Web 管理控制台，默认是开启的，URL 地址: <a href=\"http://localhost:18083/\">http://localhost:18083</a> ，缺省用户名/密码: admin/public。登陆成功之后就能可查询 EMQ 消息服务器基本信息、统计数据、度量数据，查询系统客户端(Client)、会话(Session)、主题(Topic)、订阅(Subscription)，以及对插件的管理。</p>\n\n<p style=\"text-indent:50px;\">插件里面我觉得最重要的应该是认证插件，当然了是可以不需要认证功能的，但是呢安全性和规范性还是需要认证功能的，EMQ提供了很种方式的认证功能，我选择MySQL认证访问插件。</p>\n\n<p style=\"text-indent:50px;\">进入到插件管理页面，打开MySQL配置，第一步填写 MySQL数据库的相关信息，还需要注意一下要把加密方式给去掉，这样连接的时候要方便一些。完成这些配置之后要到MySQL对应的数据库创建用户和访问控制表：</p>\n\n<pre class=\"has\">\n<code class=\"language-sql\">CREATE TABLE `mqtt_user` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n  `username` varchar(100) DEFAULT NULL,\n  `password` varchar(100) DEFAULT NULL,\n  `salt` varchar(35) DEFAULT NULL,\n  `is_superuser` tinyint(1) DEFAULT 0,\n  `created` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `mqtt_username` (`username`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;</code></pre>\n\n<pre class=\"has\">\n<code class=\"language-sql\">CREATE TABLE `mqtt_acl` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n  `allow` int(1) DEFAULT NULL COMMENT '0: deny, 1: allow',\n  `ipaddr` varchar(60) DEFAULT NULL COMMENT 'IpAddress',\n  `username` varchar(100) DEFAULT NULL COMMENT 'Username',\n  `clientid` varchar(100) DEFAULT NULL COMMENT 'ClientId',\n  `access` int(2) NOT NULL COMMENT '1: subscribe, 2: publish, 3: pubsub',\n  `topic` varchar(100) NOT NULL DEFAULT '' COMMENT 'Topic Filter',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `mqtt_acl` (`id`, `allow`, `ipaddr`, `username`, `clientid`, `access`, `topic`)\nVALUES\n    (1,1,NULL,'$all',NULL,2,'#'),\n    (2,0,NULL,'$all',NULL,1,'$SYS/#'),\n    (3,0,NULL,'$all',NULL,1,'eq #'),\n    (5,1,'127.0.0.1',NULL,NULL,2,'$SYS/#'),\n    (6,1,'127.0.0.1',NULL,NULL,2,'#'),\n    (7,1,NULL,'dashboard',NULL,1,'$SYS/#');</code></pre>\n\n<p style=\"text-indent:50px;\">为了测试方便先在用户表里面插入一个测试账户信息，例如username：admin 、password：123456，至此认证功能基本上配置好了。</p>\n\n<h3 id=\"%E6%B5%8B%E8%AF%95%EF%BC%9A\">测试：</h3>\n\n<p style=\"text-indent:50px;\">现在还没有完成硬件部分的设计，只能通过EMQ提供的Websocket工具来测试连通性，打开websocket页面，填写好之前在用户表里面的账户和密码，点击连接测试能否连接成功，如果成功了那么整个MQTT服务的搭建也就顺利完成了。</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"EMQ%EF%BC%9A\">EMQ：</h3>\n\n<p style=\"text-indent:50px;\">现有的MQTT服务器有很多，例如Mosquitto、Apache-Apollo、EMQ等等，最后呢选择了EMQ毕，国内公司的开源产品，中文资料相对要多一些。EMQ的官网宣称是百万级分布式开源物联网MQTT消息服务器，百不百万倒无所谓，反正是给自用的没有那么多的数据产生。</p>\n\n<h3 id=\"%E5%AE%89%E8%A3%85%EF%BC%9A\">安装：</h3>\n\n<p style=\"text-indent:50px;\">服务器系统版本为Ubuntu14.04，首先在EMQ官网下载对应的安装包<a href=\"http://emqtt.com/downloads/latest/ubuntu14_04-deb\">http://emqtt.com/downloads/latest/ubuntu14_04-deb</a>，进入目录 输入命令：sudo dpkg -i emqttd-ubuntu16.04_v2.0_amd64.deb进行安装。按照官方的说明完成上述操作之后还需要安装依赖lksctp-tools库apt-get install lksctp-tools。至此MQTT服务已经搭建好了，但是还需要一些配置方可使用。</p>\n\n<h3 id=\"%E9%85%8D%E7%BD%AE%EF%BC%9A\">配置：</h3>\n\n<p style=\"text-indent:50px;\">EMQ提供了Web 管理控制台，默认是开启的，URL 地址: <a href=\"http://localhost:18083/\">http://localhost:18083</a> ，缺省用户名/密码: admin/public。登陆成功之后就能可查询 EMQ 消息服务器基本信息、统计数据、度量数据，查询系统客户端(Client)、会话(Session)、主题(Topic)、订阅(Subscription)，以及对插件的管理。</p>\n\n<p style=\"text-indent:50px;\">插件里面我觉得最重要的应该是认证插件，当然了是可以不需要认证功能的，但是呢安全性和规范性还是需要认证功能的，EMQ提供了很种方式的认证功能，我选择MySQL认证访问插件。</p>\n\n<p style=\"text-indent:50px;\">进入到插件管理页面，打开MySQL配置，第一步填写 MySQL数据库的相关信息，还需要注意一下要把加密方式给去掉，这样连接的时候要方便一些。完成这些配置之后要到MySQL对应的数据库创建用户和访问控制表：</p>\n\n<pre class=\"has\">\n<code class=\"language-sql\">CREATE TABLE `mqtt_user` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n  `username` varchar(100) DEFAULT NULL,\n  `password` varchar(100) DEFAULT NULL,\n  `salt` varchar(35) DEFAULT NULL,\n  `is_superuser` tinyint(1) DEFAULT 0,\n  `created` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `mqtt_username` (`username`)\n) ENGINE=MyISAM DEFAULT CHARSET=utf8;</code></pre>\n\n<pre class=\"has\">\n<code class=\"language-sql\">CREATE TABLE `mqtt_acl` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n  `allow` int(1) DEFAULT NULL COMMENT '0: deny, 1: allow',\n  `ipaddr` varchar(60) DEFAULT NULL COMMENT 'IpAddress',\n  `username` varchar(100) DEFAULT NULL COMMENT 'Username',\n  `clientid` varchar(100) DEFAULT NULL COMMENT 'ClientId',\n  `access` int(2) NOT NULL COMMENT '1: subscribe, 2: publish, 3: pubsub',\n  `topic` varchar(100) NOT NULL DEFAULT '' COMMENT 'Topic Filter',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\nINSERT INTO `mqtt_acl` (`id`, `allow`, `ipaddr`, `username`, `clientid`, `access`, `topic`)\nVALUES\n    (1,1,NULL,'$all',NULL,2,'#'),\n    (2,0,NULL,'$all',NULL,1,'$SYS/#'),\n    (3,0,NULL,'$all',NULL,1,'eq #'),\n    (5,1,'127.0.0.1',NULL,NULL,2,'$SYS/#'),\n    (6,1,'127.0.0.1',NULL,NULL,2,'#'),\n    (7,1,NULL,'dashboard',NULL,1,'$SYS/#');</code></pre>\n\n<p style=\"text-indent:50px;\">为了测试方便先在用户表里面插入一个测试账户信息，例如username：admin 、password：123456，至此认证功能基本上配置好了。</p>\n\n<h3 id=\"%E6%B5%8B%E8%AF%95%EF%BC%9A\">测试：</h3>\n\n<p style=\"text-indent:50px;\">现在还没有完成硬件部分的设计，只能通过EMQ提供的Websocket工具来测试连通性，打开websocket页面，填写好之前在用户表里面的账户和密码，点击连接测试能否连接成功，如果成功了那么整个MQTT服务的搭建也就顺利完成了。</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>"},{"_content":"<h3>数据库的设计：</h3>\n\n<p style=\"text-indent:50px;\">后台使用Django web框架实现，Django和python怎么用就不介绍了，东西太多了，看完下面的这些博客就可以了，差不多就够了<a href=\"https://www.cnblogs.com/wupeiqi/articles/4938499.html\">https://www.cnblogs.com/wupeiqi/articles/4938499.html</a></p>\n\n<ol><li style=\"text-indent:0px;\">数据库设计：<br />\n\t        我是这样想的，首先会有一个主账户，也是登陆网站的账户，其下可创建设备，每个设备又都可以创建不同的数据流，数据流由设备publish的主题来区分，数据流又由设备发送过来的一个一个的数据点组成，这样一来共需要4张表存放信息，每张表又和下一级一对多的关系。<img alt=\"\" class=\"has\" height=\"363\" src=\"https://img-blog.csdnimg.cn/20181105155945264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"751\" /></li>\n\t<li style=\"text-indent:0px;\">使用Django models创建表结构，代码先不放上来因为后期可能会不断的调整，等项目整个完成之后再开源出来。对应的ER图如下\n\t<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"393\" src=\"https://img-blog.csdnimg.cn/2018110515492943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"861\" /></p>\n\t</li>\n</ol><h3 style=\"text-indent:0px;\">EMQ的MySQL插件配置：</h3>\n\n<p style=\"text-indent:50px;\">之前我们使用MySQL认证的时候使用的是官方给的示例数据库结构，现在为了和后台服务整合到一起还需要再次修改，首先打开dashboard的MySQL插件配置，只需要对两处进行修改，第一处修改认证使用的数据库，第二处修改认证的查询语句。示例：select password from website_userinfo where user_id = '%u' limit 1，修改完成后保存退出，重启插件。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"106\" src=\"https://img-blog.csdnimg.cn/20181105161204211.png\" width=\"542\" /></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"109\" src=\"https://img-blog.csdnimg.cn/2018110516132420.png\" width=\"505\" /></p>\n\n<h3 style=\"text-indent:0px;\">连接验证：</h3>\n\n<p style=\"text-indent:50px;\">在连接之前需要先在数据库里面创建一些伪造数据，在website_userinfo里面插入user_id=678518606，password=123然后使用EMQ的websocket连接测试，连接成功则上述的修改完成。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"351\" src=\"https://img-blog.csdnimg.cn/2018110516380229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"1056\" /></p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>","source":"_posts/blogs-从零开始搭建物联网平台（5）：搭建后台服务(一）.md","raw":"<h3>数据库的设计：</h3>\n\n<p style=\"text-indent:50px;\">后台使用Django web框架实现，Django和python怎么用就不介绍了，东西太多了，看完下面的这些博客就可以了，差不多就够了<a href=\"https://www.cnblogs.com/wupeiqi/articles/4938499.html\">https://www.cnblogs.com/wupeiqi/articles/4938499.html</a></p>\n\n<ol><li style=\"text-indent:0px;\">数据库设计：<br />\n\t        我是这样想的，首先会有一个主账户，也是登陆网站的账户，其下可创建设备，每个设备又都可以创建不同的数据流，数据流由设备publish的主题来区分，数据流又由设备发送过来的一个一个的数据点组成，这样一来共需要4张表存放信息，每张表又和下一级一对多的关系。<img alt=\"\" class=\"has\" height=\"363\" src=\"https://img-blog.csdnimg.cn/20181105155945264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"751\" /></li>\n\t<li style=\"text-indent:0px;\">使用Django models创建表结构，代码先不放上来因为后期可能会不断的调整，等项目整个完成之后再开源出来。对应的ER图如下\n\t<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"393\" src=\"https://img-blog.csdnimg.cn/2018110515492943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"861\" /></p>\n\t</li>\n</ol><h3 style=\"text-indent:0px;\">EMQ的MySQL插件配置：</h3>\n\n<p style=\"text-indent:50px;\">之前我们使用MySQL认证的时候使用的是官方给的示例数据库结构，现在为了和后台服务整合到一起还需要再次修改，首先打开dashboard的MySQL插件配置，只需要对两处进行修改，第一处修改认证使用的数据库，第二处修改认证的查询语句。示例：select password from website_userinfo where user_id = '%u' limit 1，修改完成后保存退出，重启插件。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"106\" src=\"https://img-blog.csdnimg.cn/20181105161204211.png\" width=\"542\" /></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"109\" src=\"https://img-blog.csdnimg.cn/2018110516132420.png\" width=\"505\" /></p>\n\n<h3 style=\"text-indent:0px;\">连接验证：</h3>\n\n<p style=\"text-indent:50px;\">在连接之前需要先在数据库里面创建一些伪造数据，在website_userinfo里面插入user_id=678518606，password=123然后使用EMQ的websocket连接测试，连接成功则上述的修改完成。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"351\" src=\"https://img-blog.csdnimg.cn/2018110516380229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"1056\" /></p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>","slug":"blogs-从零开始搭建物联网平台（5）：搭建后台服务(一）","published":1,"date":"2022-03-16T17:01:01.611Z","updated":"2022-03-16T17:05:51.090Z","_id":"cl0v6kepv0004yms47slv80wf","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>数据库的设计：</h3>\n\n<p style=\"text-indent:50px;\">后台使用Django web框架实现，Django和python怎么用就不介绍了，东西太多了，看完下面的这些博客就可以了，差不多就够了<a href=\"https://www.cnblogs.com/wupeiqi/articles/4938499.html\">https://www.cnblogs.com/wupeiqi/articles/4938499.html</a></p>\n\n<ol><li style=\"text-indent:0px;\">数据库设计：<br />\n            我是这样想的，首先会有一个主账户，也是登陆网站的账户，其下可创建设备，每个设备又都可以创建不同的数据流，数据流由设备publish的主题来区分，数据流又由设备发送过来的一个一个的数据点组成，这样一来共需要4张表存放信息，每张表又和下一级一对多的关系。<img alt=\"\" class=\"has\" height=\"363\" src=\"https://img-blog.csdnimg.cn/20181105155945264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"751\" /></li>\n    <li style=\"text-indent:0px;\">使用Django models创建表结构，代码先不放上来因为后期可能会不断的调整，等项目整个完成之后再开源出来。对应的ER图如下\n    <p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"393\" src=\"https://img-blog.csdnimg.cn/2018110515492943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"861\" /></p>\n    </li>\n</ol><h3 style=\"text-indent:0px;\">EMQ的MySQL插件配置：</h3>\n\n<p style=\"text-indent:50px;\">之前我们使用MySQL认证的时候使用的是官方给的示例数据库结构，现在为了和后台服务整合到一起还需要再次修改，首先打开dashboard的MySQL插件配置，只需要对两处进行修改，第一处修改认证使用的数据库，第二处修改认证的查询语句。示例：select password from website_userinfo where user_id = '%u' limit 1，修改完成后保存退出，重启插件。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"106\" src=\"https://img-blog.csdnimg.cn/20181105161204211.png\" width=\"542\" /></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"109\" src=\"https://img-blog.csdnimg.cn/2018110516132420.png\" width=\"505\" /></p>\n\n<h3 style=\"text-indent:0px;\">连接验证：</h3>\n\n<p style=\"text-indent:50px;\">在连接之前需要先在数据库里面创建一些伪造数据，在website_userinfo里面插入user_id=678518606，password=123然后使用EMQ的websocket连接测试，连接成功则上述的修改完成。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"351\" src=\"https://img-blog.csdnimg.cn/2018110516380229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"1056\" /></p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>","site":{"data":{}},"excerpt":"","more":"<h3>数据库的设计：</h3>\n\n<p style=\"text-indent:50px;\">后台使用Django web框架实现，Django和python怎么用就不介绍了，东西太多了，看完下面的这些博客就可以了，差不多就够了<a href=\"https://www.cnblogs.com/wupeiqi/articles/4938499.html\">https://www.cnblogs.com/wupeiqi/articles/4938499.html</a></p>\n\n<ol><li style=\"text-indent:0px;\">数据库设计：<br />\n            我是这样想的，首先会有一个主账户，也是登陆网站的账户，其下可创建设备，每个设备又都可以创建不同的数据流，数据流由设备publish的主题来区分，数据流又由设备发送过来的一个一个的数据点组成，这样一来共需要4张表存放信息，每张表又和下一级一对多的关系。<img alt=\"\" class=\"has\" height=\"363\" src=\"https://img-blog.csdnimg.cn/20181105155945264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"751\" /></li>\n    <li style=\"text-indent:0px;\">使用Django models创建表结构，代码先不放上来因为后期可能会不断的调整，等项目整个完成之后再开源出来。对应的ER图如下\n    <p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"393\" src=\"https://img-blog.csdnimg.cn/2018110515492943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"861\" /></p>\n    </li>\n</ol><h3 style=\"text-indent:0px;\">EMQ的MySQL插件配置：</h3>\n\n<p style=\"text-indent:50px;\">之前我们使用MySQL认证的时候使用的是官方给的示例数据库结构，现在为了和后台服务整合到一起还需要再次修改，首先打开dashboard的MySQL插件配置，只需要对两处进行修改，第一处修改认证使用的数据库，第二处修改认证的查询语句。示例：select password from website_userinfo where user_id = '%u' limit 1，修改完成后保存退出，重启插件。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"106\" src=\"https://img-blog.csdnimg.cn/20181105161204211.png\" width=\"542\" /></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"109\" src=\"https://img-blog.csdnimg.cn/2018110516132420.png\" width=\"505\" /></p>\n\n<h3 style=\"text-indent:0px;\">连接验证：</h3>\n\n<p style=\"text-indent:50px;\">在连接之前需要先在数据库里面创建一些伪造数据，在website_userinfo里面插入user_id=678518606，password=123然后使用EMQ的websocket连接测试，连接成功则上述的修改完成。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"351\" src=\"https://img-blog.csdnimg.cn/2018110516380229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"1056\" /></p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>"},{"_content":"<h3>搭建开发环境：</h3>\n\n<p style=\"text-indent:50px;\">在开篇的时候就说过硬件部分会使用Arduino平台和NodeMCU，只是Arduino平台不能直接对NodeMCU进开发，正好换电脑了也需要重新安装一遍，就顺便说一下。</p>\n\n<p style=\"text-indent:50px;\">首先下载ArduinoIDE安装包官网太慢可以用这个链接：<a href=\"https://coding.net/u/coloz/p/arduino-installer/git/raw/master/1.8.7/arduino-1.8.7-windows.exe\">Arduino 1.8.7</a>我使用的版本是1.8.7，安装完成之后进入到首选项在附加开发板管理器网址处填写：<a href=\"http://arduino.esp8266.com/stable/package_esp8266com_index.json\">http://arduino.esp8266.com/stable/package_esp8266com_index.json</a></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"156\" src=\"https://img-blog.csdnimg.cn/20181104030952144.png\" width=\"712\" /></p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\">填写完成之后关闭重启，在工具→开发板→开发板管理器中搜索ESP8266，下载安装，这一步可能会比较慢要等待一段时间。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"232\" src=\"https://img-blog.csdnimg.cn/20181104031257122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"951\" /></p>\n\n<p style=\"text-indent:50px;\">开发板添加完成之后，再次打开开发板会多出很多型号的开发板，其中就包括我们使用的NodeMCU，关于0.9和1.0两个暂时不知道有什么区别，应该是使用的ESP芯片型号的不同，目前来说选这两个中的任意一个都没有问题。至此NodeMCU开发环境搭建完成了。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"335\" src=\"https://img-blog.csdnimg.cn/20181104031528431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"301\" /></p>\n\n<h3 style=\"text-indent:0px;\">连接测试：</h3>\n\n<p style=\"text-indent:50px;\">物联网协议采用的是MQTT，本着不造轮子的原则，先看一下有没有对应的库可以使用，在项目→加载库→管理库搜索MQTT，会出现一大堆各种各样的库，根据使用的广泛程度最后选择PubSubClient，点击安装。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"186\" src=\"https://img-blog.csdnimg.cn/20181104032336364.png\" width=\"931\" /></p>\n\n<p style=\"text-indent:50px;\">安装成功后，在文件→示例中可以找到PubSubClient的一些使用例程，选择mqtt_esp8266打开，这个就是需要用到的测试代码。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"167\" src=\"https://img-blog.csdnimg.cn/20181104032509898.png\" width=\"633\" /></p>\n\n<p style=\"text-indent:50px;\">当然呢，代码需要简单的修改一下才可以使用，不出意外按照下面的修改应该是能连接成功的。点击上传等到代码烧录到NodeMCU中。</p>\n\n<pre class=\"has\">\n<code class=\"language-cpp\">//分别填写WIFI名、密码、mqtt服务器IP\nconst char* ssid = \"........\";\nconst char* password = \"........\";\nconst char* mqtt_server = \"broker.mqtt-dashboard.com\";\n\n//由于我们之前mqtt服务器开启了认证功能，这里连接的时候还需要携带用户名和密码\n//大概在95行附近\nif (client.connect(\"NodeMCU\",\"admin\",\"123456\")) {\n\n//如果返回值为4需要检查一下用户名和密码是否正确</code></pre>\n\n<p style=\"text-indent:50px;\">打开串口监视器，如果连接成功会得到下图信息。如果有错根据返回码去查看MQTT连接返回码对应什么问题在一步一步排查。至此硬件于MQTT服务器的连接测试完成，接下来应该会是后台的搭建，也是最困难的一步了。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"259\" src=\"https://img-blog.csdnimg.cn/20181104033727715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"840\" /></p>\n\n<p><img alt=\"\" class=\"has\" height=\"350\" src=\"https://img-blog.csdnimg.cn/20181104033847740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p> </p>\n\n<p style=\"text-indent:50px;\"> </p>","source":"_posts/blogs-从零开始搭建物联网平台（3）：硬件部分的连接测试.md","raw":"<h3>搭建开发环境：</h3>\n\n<p style=\"text-indent:50px;\">在开篇的时候就说过硬件部分会使用Arduino平台和NodeMCU，只是Arduino平台不能直接对NodeMCU进开发，正好换电脑了也需要重新安装一遍，就顺便说一下。</p>\n\n<p style=\"text-indent:50px;\">首先下载ArduinoIDE安装包官网太慢可以用这个链接：<a href=\"https://coding.net/u/coloz/p/arduino-installer/git/raw/master/1.8.7/arduino-1.8.7-windows.exe\">Arduino 1.8.7</a>我使用的版本是1.8.7，安装完成之后进入到首选项在附加开发板管理器网址处填写：<a href=\"http://arduino.esp8266.com/stable/package_esp8266com_index.json\">http://arduino.esp8266.com/stable/package_esp8266com_index.json</a></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"156\" src=\"https://img-blog.csdnimg.cn/20181104030952144.png\" width=\"712\" /></p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\">填写完成之后关闭重启，在工具→开发板→开发板管理器中搜索ESP8266，下载安装，这一步可能会比较慢要等待一段时间。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"232\" src=\"https://img-blog.csdnimg.cn/20181104031257122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"951\" /></p>\n\n<p style=\"text-indent:50px;\">开发板添加完成之后，再次打开开发板会多出很多型号的开发板，其中就包括我们使用的NodeMCU，关于0.9和1.0两个暂时不知道有什么区别，应该是使用的ESP芯片型号的不同，目前来说选这两个中的任意一个都没有问题。至此NodeMCU开发环境搭建完成了。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"335\" src=\"https://img-blog.csdnimg.cn/20181104031528431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"301\" /></p>\n\n<h3 style=\"text-indent:0px;\">连接测试：</h3>\n\n<p style=\"text-indent:50px;\">物联网协议采用的是MQTT，本着不造轮子的原则，先看一下有没有对应的库可以使用，在项目→加载库→管理库搜索MQTT，会出现一大堆各种各样的库，根据使用的广泛程度最后选择PubSubClient，点击安装。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"186\" src=\"https://img-blog.csdnimg.cn/20181104032336364.png\" width=\"931\" /></p>\n\n<p style=\"text-indent:50px;\">安装成功后，在文件→示例中可以找到PubSubClient的一些使用例程，选择mqtt_esp8266打开，这个就是需要用到的测试代码。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"167\" src=\"https://img-blog.csdnimg.cn/20181104032509898.png\" width=\"633\" /></p>\n\n<p style=\"text-indent:50px;\">当然呢，代码需要简单的修改一下才可以使用，不出意外按照下面的修改应该是能连接成功的。点击上传等到代码烧录到NodeMCU中。</p>\n\n<pre class=\"has\">\n<code class=\"language-cpp\">//分别填写WIFI名、密码、mqtt服务器IP\nconst char* ssid = \"........\";\nconst char* password = \"........\";\nconst char* mqtt_server = \"broker.mqtt-dashboard.com\";\n\n//由于我们之前mqtt服务器开启了认证功能，这里连接的时候还需要携带用户名和密码\n//大概在95行附近\nif (client.connect(\"NodeMCU\",\"admin\",\"123456\")) {\n\n//如果返回值为4需要检查一下用户名和密码是否正确</code></pre>\n\n<p style=\"text-indent:50px;\">打开串口监视器，如果连接成功会得到下图信息。如果有错根据返回码去查看MQTT连接返回码对应什么问题在一步一步排查。至此硬件于MQTT服务器的连接测试完成，接下来应该会是后台的搭建，也是最困难的一步了。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"259\" src=\"https://img-blog.csdnimg.cn/20181104033727715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"840\" /></p>\n\n<p><img alt=\"\" class=\"has\" height=\"350\" src=\"https://img-blog.csdnimg.cn/20181104033847740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p> </p>\n\n<p style=\"text-indent:50px;\"> </p>","slug":"blogs-从零开始搭建物联网平台（3）：硬件部分的连接测试","published":1,"date":"2022-03-16T17:01:03.989Z","updated":"2022-03-16T17:05:53.585Z","_id":"cl0v6kepw0005yms47h1l5scl","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>搭建开发环境：</h3>\n\n<p style=\"text-indent:50px;\">在开篇的时候就说过硬件部分会使用Arduino平台和NodeMCU，只是Arduino平台不能直接对NodeMCU进开发，正好换电脑了也需要重新安装一遍，就顺便说一下。</p>\n\n<p style=\"text-indent:50px;\">首先下载ArduinoIDE安装包官网太慢可以用这个链接：<a href=\"https://coding.net/u/coloz/p/arduino-installer/git/raw/master/1.8.7/arduino-1.8.7-windows.exe\">Arduino 1.8.7</a>我使用的版本是1.8.7，安装完成之后进入到首选项在附加开发板管理器网址处填写：<a href=\"http://arduino.esp8266.com/stable/package_esp8266com_index.json\">http://arduino.esp8266.com/stable/package_esp8266com_index.json</a></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"156\" src=\"https://img-blog.csdnimg.cn/20181104030952144.png\" width=\"712\" /></p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\">填写完成之后关闭重启，在工具→开发板→开发板管理器中搜索ESP8266，下载安装，这一步可能会比较慢要等待一段时间。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"232\" src=\"https://img-blog.csdnimg.cn/20181104031257122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"951\" /></p>\n\n<p style=\"text-indent:50px;\">开发板添加完成之后，再次打开开发板会多出很多型号的开发板，其中就包括我们使用的NodeMCU，关于0.9和1.0两个暂时不知道有什么区别，应该是使用的ESP芯片型号的不同，目前来说选这两个中的任意一个都没有问题。至此NodeMCU开发环境搭建完成了。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"335\" src=\"https://img-blog.csdnimg.cn/20181104031528431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"301\" /></p>\n\n<h3 style=\"text-indent:0px;\">连接测试：</h3>\n\n<p style=\"text-indent:50px;\">物联网协议采用的是MQTT，本着不造轮子的原则，先看一下有没有对应的库可以使用，在项目→加载库→管理库搜索MQTT，会出现一大堆各种各样的库，根据使用的广泛程度最后选择PubSubClient，点击安装。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"186\" src=\"https://img-blog.csdnimg.cn/20181104032336364.png\" width=\"931\" /></p>\n\n<p style=\"text-indent:50px;\">安装成功后，在文件→示例中可以找到PubSubClient的一些使用例程，选择mqtt_esp8266打开，这个就是需要用到的测试代码。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"167\" src=\"https://img-blog.csdnimg.cn/20181104032509898.png\" width=\"633\" /></p>\n\n<p style=\"text-indent:50px;\">当然呢，代码需要简单的修改一下才可以使用，不出意外按照下面的修改应该是能连接成功的。点击上传等到代码烧录到NodeMCU中。</p>\n\n<pre class=\"has\">\n<code class=\"language-cpp\">//分别填写WIFI名、密码、mqtt服务器IP\nconst char* ssid = \"........\";\nconst char* password = \"........\";\nconst char* mqtt_server = \"broker.mqtt-dashboard.com\";\n\n//由于我们之前mqtt服务器开启了认证功能，这里连接的时候还需要携带用户名和密码\n//大概在95行附近\nif (client.connect(\"NodeMCU\",\"admin\",\"123456\")) &#123;\n\n//如果返回值为4需要检查一下用户名和密码是否正确</code></pre>\n\n<p style=\"text-indent:50px;\">打开串口监视器，如果连接成功会得到下图信息。如果有错根据返回码去查看MQTT连接返回码对应什么问题在一步一步排查。至此硬件于MQTT服务器的连接测试完成，接下来应该会是后台的搭建，也是最困难的一步了。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"259\" src=\"https://img-blog.csdnimg.cn/20181104033727715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"840\" /></p>\n\n<p><img alt=\"\" class=\"has\" height=\"350\" src=\"https://img-blog.csdnimg.cn/20181104033847740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p> </p>\n\n<p style=\"text-indent:50px;\"> </p>","site":{"data":{}},"excerpt":"","more":"<h3>搭建开发环境：</h3>\n\n<p style=\"text-indent:50px;\">在开篇的时候就说过硬件部分会使用Arduino平台和NodeMCU，只是Arduino平台不能直接对NodeMCU进开发，正好换电脑了也需要重新安装一遍，就顺便说一下。</p>\n\n<p style=\"text-indent:50px;\">首先下载ArduinoIDE安装包官网太慢可以用这个链接：<a href=\"https://coding.net/u/coloz/p/arduino-installer/git/raw/master/1.8.7/arduino-1.8.7-windows.exe\">Arduino 1.8.7</a>我使用的版本是1.8.7，安装完成之后进入到首选项在附加开发板管理器网址处填写：<a href=\"http://arduino.esp8266.com/stable/package_esp8266com_index.json\">http://arduino.esp8266.com/stable/package_esp8266com_index.json</a></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"156\" src=\"https://img-blog.csdnimg.cn/20181104030952144.png\" width=\"712\" /></p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\">填写完成之后关闭重启，在工具→开发板→开发板管理器中搜索ESP8266，下载安装，这一步可能会比较慢要等待一段时间。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"232\" src=\"https://img-blog.csdnimg.cn/20181104031257122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"951\" /></p>\n\n<p style=\"text-indent:50px;\">开发板添加完成之后，再次打开开发板会多出很多型号的开发板，其中就包括我们使用的NodeMCU，关于0.9和1.0两个暂时不知道有什么区别，应该是使用的ESP芯片型号的不同，目前来说选这两个中的任意一个都没有问题。至此NodeMCU开发环境搭建完成了。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"335\" src=\"https://img-blog.csdnimg.cn/20181104031528431.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"301\" /></p>\n\n<h3 style=\"text-indent:0px;\">连接测试：</h3>\n\n<p style=\"text-indent:50px;\">物联网协议采用的是MQTT，本着不造轮子的原则，先看一下有没有对应的库可以使用，在项目→加载库→管理库搜索MQTT，会出现一大堆各种各样的库，根据使用的广泛程度最后选择PubSubClient，点击安装。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"186\" src=\"https://img-blog.csdnimg.cn/20181104032336364.png\" width=\"931\" /></p>\n\n<p style=\"text-indent:50px;\">安装成功后，在文件→示例中可以找到PubSubClient的一些使用例程，选择mqtt_esp8266打开，这个就是需要用到的测试代码。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"167\" src=\"https://img-blog.csdnimg.cn/20181104032509898.png\" width=\"633\" /></p>\n\n<p style=\"text-indent:50px;\">当然呢，代码需要简单的修改一下才可以使用，不出意外按照下面的修改应该是能连接成功的。点击上传等到代码烧录到NodeMCU中。</p>\n\n<pre class=\"has\">\n<code class=\"language-cpp\">//分别填写WIFI名、密码、mqtt服务器IP\nconst char* ssid = \"........\";\nconst char* password = \"........\";\nconst char* mqtt_server = \"broker.mqtt-dashboard.com\";\n\n//由于我们之前mqtt服务器开启了认证功能，这里连接的时候还需要携带用户名和密码\n//大概在95行附近\nif (client.connect(\"NodeMCU\",\"admin\",\"123456\")) &#123;\n\n//如果返回值为4需要检查一下用户名和密码是否正确</code></pre>\n\n<p style=\"text-indent:50px;\">打开串口监视器，如果连接成功会得到下图信息。如果有错根据返回码去查看MQTT连接返回码对应什么问题在一步一步排查。至此硬件于MQTT服务器的连接测试完成，接下来应该会是后台的搭建，也是最困难的一步了。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"259\" src=\"https://img-blog.csdnimg.cn/20181104033727715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"840\" /></p>\n\n<p><img alt=\"\" class=\"has\" height=\"350\" src=\"https://img-blog.csdnimg.cn/20181104033847740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p> </p>\n\n<p style=\"text-indent:50px;\"> </p>"},{"_content":"<h3>遇到的问题：</h3>\n\n<p style=\"text-indent:50px;\">查看了EMQ文档发现并不提供消息的持久化功能，MQTT协议是按照设备一直在线设计的，数据都是保存在内存里的，但是考虑到用户上传传感器数据不可能接收了就扔掉，那样就没法查看历史数据了，所以用户上传的消息必须要能够保存下来，以便查看历史数据，这样一来持久化功能就需要我们自己来实现。</p>\n\n<p style=\"text-indent:50px;\">另外还会出现一个问题，当两个设备注册的主题名一样的时候，不能分出是哪一个设备发出的消息，在接收订阅消息的时候发现没办法获取到发送消息的clientID，而且其他设备也可以订阅到任意设备的消息，对于敏感信息来说存在安全性。</p>\n\n<h3>解决方法：</h3>\n\n<p style=\"text-indent:50px;\">初步打算是，用户需要在后台注册自己的设备和数据流信息，后台会对所有注册的信息进行订阅接收到消息后，后台会把消息写入到对应的表中，另外设备发布主题只能使用（clientID/主题名）命名方式，以便后台能够区分是哪一个设备发送过来的消息。对于MQTT了解还是不够深，只能使用这样的笨办法来解决了，以后若是找到其他的方法在进行改进。</p>\n\n<h3>解决问题：</h3>\n\n<p style=\"text-indent:50px;\">首先需要通过python建立mqtt连接监听所有注册的主题信息，这里使用了paho-mqtt库来实现，为了方便以后的调用将其封装成一个类，最开始的时候想把一些常用的操作也封装进去，单独测试完全可以，但是一旦放到Django请求中处理的时候，mqtt能够正常返回成功信息，但是实际上并没有正确执行，这一点始终没有找到原因，最终只能简化，只包含最基础的功能。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class MqClient(object):\n    def __init__(self, client_id, username, password):\n        self.client = client.Client(client_id=client_id,\n                                    clean_session=True)  # 初始化,clean_session为false的时候EMQ会保存订阅状态，可以不再次订阅\n        self.client.username_pw_set(username, password)  # 设置连接用户名\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        self._client_status = False  # 连接状态\n        self._cloop = None\n        self._connect()  # 实例化会自动连接\n\n    def _connect(self, host=\"your IP \", port=1883, keepalive=60):\n        \"\"\"连接服务器\"\"\"\n        self.client.connect_async(host, port, keepalive)\n        # 开启线程执行\n        self._cloop = threading.Thread(target=self.client.loop_start())\n        self._cloop.start()\n\n    def on_connect(self, client, userdata, flags, rc):\n        \"\"\"连接成功的回调函数\"\"\"\n        # 修改客户端状态\n        if rc == 0:\n            self._client_status = True\n\n    def init_sub(self):\n        # 读取数据库中所有的已经注册过的topic并且订阅\n        for i in models.Device.objects.all():\n            for j in i.dev_stream.all():\n                self.client.subscribe(str(i.device_id) + '/' + j.name, j.qos)\n\n    @staticmethod\n    def on_message(client, userdata, msg):\n        client_id = msg.topic.split('/')[0]\n        stream = msg.topic.split('/')[1]\n        data = msg.payload.decode()\n        # 接收订阅信息写入到数据库中\n        models.DataStream.objects.filter(device__device_id=client_id).filter(name=stream).first().data.add(\n            models.Data.objects.create(data=data))</code></pre>\n\n<p style=\"text-indent:50px;\">有了封装好的类，现在我们需要做的是：在Django项目启动完成之后自动执行监听任务的，最开始的时候打算放到setting或者__init__里面，但是因为类里面封装了model操作，那时候项目还没有加载完model会报错，所以最终新建了一个app，然后放到其下的urls，这样当项目启动完成的时候就会自动加载了。</p>\n\n<pre class=\"has\">\n<code>from utils.mqtt_client import MqClient\n\nMQClient = MqClient(your client ID, username, password)\nMQClient.init_sub()</code></pre>\n\n<p style=\"text-indent:50px;\">接下来测试一下实时新增订阅的功能，先从urls文件导入示例化之后的对象，调用client的subscribe方法</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from mqtt.urls import MQClient\nclass Test(APIView):\n    def post(self, request):\n        topic = request.POST.get('topic')\n        qos = int(request.POST.get('qos'))\n        if topic:\n            MQClient.client.subscribe(topic,qos)\n        return HttpResponse(\"ok\")</code></pre>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"100\" src=\"https://img-blog.csdnimg.cn/20181107111120198.png\" width=\"1173\" /></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"86\" src=\"https://img-blog.csdnimg.cn/20181107111210936.png\" width=\"998\" /></p>\n\n<p style=\"text-indent:50px;\">最后就剩下把数据存入数据库中了，这个操作已经写在那个类中了。简单说明一下 ，当paho接收了mqtt请求的时候会产生一个回调，执行下面这个函数，接收到的类容包含在msg中，msg主要有topic和payload两个属性，topic是订阅的主题名，payload则是具体的消息内容，按照之前的规定，主题名为client/stream，对topic内容拆分获取到client_id和stream，最后就是数据库的插入操作了，涉及到多表操作，简单点说就是，先插入一个data数据，然后根据client_id和stream来确定stream，最后再通过add方法将两者关联起来，这样就完成了消息的保存了。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def on_message(client, userdata, msg):\n        client_id = msg.topic.split('/')[0]\n        stream = msg.topic.split('/')[1]\n        data = msg.payload.decode()\n        # 接收订阅信息写入到数据库中\n        models.DataStream.objects.filter(device__device_id=client_id).filter(name=stream).first().data.add(\n            models.Data.objects.create(data=data))</code></pre>\n\n<p style=\"text-indent:50px;\">测试一下，数据库里面已经准备一些client和stream数据，还是使用EMQ的websocket来测试，发送主题为123456/hum，消息内容为654321，在来看一下数据库中数据是否插入成功。</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"140\" src=\"https://img-blog.csdnimg.cn/20181107113047550.png\" width=\"785\" /></p>\n\n<div style=\"text-align:center;\">\n<figure class=\"image\"><img alt=\"\" height=\"51\" src=\"https://img-blog.csdnimg.cn/20181107113809200.png\" width=\"561\" /><figcaption>data表</figcaption></figure></div>\n\n<div style=\"text-align:center;\">\n<figure class=\"image\"><img alt=\"\" height=\"85\" src=\"https://img-blog.csdnimg.cn/20181107113844420.png\" width=\"822\" /><figcaption>stream表</figcaption></figure></div>\n\n<div style=\"text-align:center;\">\n<figure class=\"image\"><img alt=\"\" height=\"64\" src=\"https://img-blog.csdnimg.cn/20181107113941992.png\" width=\"536\" /><figcaption>stream和data关联表</figcaption></figure></div>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<h3 style=\"text-indent:0px;\">更新：</h3>\n\n<p style=\"text-indent:50px;\">最终对这一部分做了修改，没有将MQTT相关的东西放到Django里面，独立出来了，这样也方便日后的扩展和管理，数据库操作改用了sqlachemy实现，其他内容基本不变</p>\n\n<p style=\"text-indent:50px;\"> </p>","source":"_posts/blogs-从零开始搭建物联网平台（6）：消息的持久化.md","raw":"<h3>遇到的问题：</h3>\n\n<p style=\"text-indent:50px;\">查看了EMQ文档发现并不提供消息的持久化功能，MQTT协议是按照设备一直在线设计的，数据都是保存在内存里的，但是考虑到用户上传传感器数据不可能接收了就扔掉，那样就没法查看历史数据了，所以用户上传的消息必须要能够保存下来，以便查看历史数据，这样一来持久化功能就需要我们自己来实现。</p>\n\n<p style=\"text-indent:50px;\">另外还会出现一个问题，当两个设备注册的主题名一样的时候，不能分出是哪一个设备发出的消息，在接收订阅消息的时候发现没办法获取到发送消息的clientID，而且其他设备也可以订阅到任意设备的消息，对于敏感信息来说存在安全性。</p>\n\n<h3>解决方法：</h3>\n\n<p style=\"text-indent:50px;\">初步打算是，用户需要在后台注册自己的设备和数据流信息，后台会对所有注册的信息进行订阅接收到消息后，后台会把消息写入到对应的表中，另外设备发布主题只能使用（clientID/主题名）命名方式，以便后台能够区分是哪一个设备发送过来的消息。对于MQTT了解还是不够深，只能使用这样的笨办法来解决了，以后若是找到其他的方法在进行改进。</p>\n\n<h3>解决问题：</h3>\n\n<p style=\"text-indent:50px;\">首先需要通过python建立mqtt连接监听所有注册的主题信息，这里使用了paho-mqtt库来实现，为了方便以后的调用将其封装成一个类，最开始的时候想把一些常用的操作也封装进去，单独测试完全可以，但是一旦放到Django请求中处理的时候，mqtt能够正常返回成功信息，但是实际上并没有正确执行，这一点始终没有找到原因，最终只能简化，只包含最基础的功能。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class MqClient(object):\n    def __init__(self, client_id, username, password):\n        self.client = client.Client(client_id=client_id,\n                                    clean_session=True)  # 初始化,clean_session为false的时候EMQ会保存订阅状态，可以不再次订阅\n        self.client.username_pw_set(username, password)  # 设置连接用户名\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        self._client_status = False  # 连接状态\n        self._cloop = None\n        self._connect()  # 实例化会自动连接\n\n    def _connect(self, host=\"your IP \", port=1883, keepalive=60):\n        \"\"\"连接服务器\"\"\"\n        self.client.connect_async(host, port, keepalive)\n        # 开启线程执行\n        self._cloop = threading.Thread(target=self.client.loop_start())\n        self._cloop.start()\n\n    def on_connect(self, client, userdata, flags, rc):\n        \"\"\"连接成功的回调函数\"\"\"\n        # 修改客户端状态\n        if rc == 0:\n            self._client_status = True\n\n    def init_sub(self):\n        # 读取数据库中所有的已经注册过的topic并且订阅\n        for i in models.Device.objects.all():\n            for j in i.dev_stream.all():\n                self.client.subscribe(str(i.device_id) + '/' + j.name, j.qos)\n\n    @staticmethod\n    def on_message(client, userdata, msg):\n        client_id = msg.topic.split('/')[0]\n        stream = msg.topic.split('/')[1]\n        data = msg.payload.decode()\n        # 接收订阅信息写入到数据库中\n        models.DataStream.objects.filter(device__device_id=client_id).filter(name=stream).first().data.add(\n            models.Data.objects.create(data=data))</code></pre>\n\n<p style=\"text-indent:50px;\">有了封装好的类，现在我们需要做的是：在Django项目启动完成之后自动执行监听任务的，最开始的时候打算放到setting或者__init__里面，但是因为类里面封装了model操作，那时候项目还没有加载完model会报错，所以最终新建了一个app，然后放到其下的urls，这样当项目启动完成的时候就会自动加载了。</p>\n\n<pre class=\"has\">\n<code>from utils.mqtt_client import MqClient\n\nMQClient = MqClient(your client ID, username, password)\nMQClient.init_sub()</code></pre>\n\n<p style=\"text-indent:50px;\">接下来测试一下实时新增订阅的功能，先从urls文件导入示例化之后的对象，调用client的subscribe方法</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from mqtt.urls import MQClient\nclass Test(APIView):\n    def post(self, request):\n        topic = request.POST.get('topic')\n        qos = int(request.POST.get('qos'))\n        if topic:\n            MQClient.client.subscribe(topic,qos)\n        return HttpResponse(\"ok\")</code></pre>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"100\" src=\"https://img-blog.csdnimg.cn/20181107111120198.png\" width=\"1173\" /></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"86\" src=\"https://img-blog.csdnimg.cn/20181107111210936.png\" width=\"998\" /></p>\n\n<p style=\"text-indent:50px;\">最后就剩下把数据存入数据库中了，这个操作已经写在那个类中了。简单说明一下 ，当paho接收了mqtt请求的时候会产生一个回调，执行下面这个函数，接收到的类容包含在msg中，msg主要有topic和payload两个属性，topic是订阅的主题名，payload则是具体的消息内容，按照之前的规定，主题名为client/stream，对topic内容拆分获取到client_id和stream，最后就是数据库的插入操作了，涉及到多表操作，简单点说就是，先插入一个data数据，然后根据client_id和stream来确定stream，最后再通过add方法将两者关联起来，这样就完成了消息的保存了。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def on_message(client, userdata, msg):\n        client_id = msg.topic.split('/')[0]\n        stream = msg.topic.split('/')[1]\n        data = msg.payload.decode()\n        # 接收订阅信息写入到数据库中\n        models.DataStream.objects.filter(device__device_id=client_id).filter(name=stream).first().data.add(\n            models.Data.objects.create(data=data))</code></pre>\n\n<p style=\"text-indent:50px;\">测试一下，数据库里面已经准备一些client和stream数据，还是使用EMQ的websocket来测试，发送主题为123456/hum，消息内容为654321，在来看一下数据库中数据是否插入成功。</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"140\" src=\"https://img-blog.csdnimg.cn/20181107113047550.png\" width=\"785\" /></p>\n\n<div style=\"text-align:center;\">\n<figure class=\"image\"><img alt=\"\" height=\"51\" src=\"https://img-blog.csdnimg.cn/20181107113809200.png\" width=\"561\" /><figcaption>data表</figcaption></figure></div>\n\n<div style=\"text-align:center;\">\n<figure class=\"image\"><img alt=\"\" height=\"85\" src=\"https://img-blog.csdnimg.cn/20181107113844420.png\" width=\"822\" /><figcaption>stream表</figcaption></figure></div>\n\n<div style=\"text-align:center;\">\n<figure class=\"image\"><img alt=\"\" height=\"64\" src=\"https://img-blog.csdnimg.cn/20181107113941992.png\" width=\"536\" /><figcaption>stream和data关联表</figcaption></figure></div>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<h3 style=\"text-indent:0px;\">更新：</h3>\n\n<p style=\"text-indent:50px;\">最终对这一部分做了修改，没有将MQTT相关的东西放到Django里面，独立出来了，这样也方便日后的扩展和管理，数据库操作改用了sqlachemy实现，其他内容基本不变</p>\n\n<p style=\"text-indent:50px;\"> </p>","slug":"blogs-从零开始搭建物联网平台（6）：消息的持久化","published":1,"date":"2022-03-16T17:01:00.395Z","updated":"2022-03-16T17:05:49.921Z","_id":"cl0v6kepw0006yms415qy87ab","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>遇到的问题：</h3>\n\n<p style=\"text-indent:50px;\">查看了EMQ文档发现并不提供消息的持久化功能，MQTT协议是按照设备一直在线设计的，数据都是保存在内存里的，但是考虑到用户上传传感器数据不可能接收了就扔掉，那样就没法查看历史数据了，所以用户上传的消息必须要能够保存下来，以便查看历史数据，这样一来持久化功能就需要我们自己来实现。</p>\n\n<p style=\"text-indent:50px;\">另外还会出现一个问题，当两个设备注册的主题名一样的时候，不能分出是哪一个设备发出的消息，在接收订阅消息的时候发现没办法获取到发送消息的clientID，而且其他设备也可以订阅到任意设备的消息，对于敏感信息来说存在安全性。</p>\n\n<h3>解决方法：</h3>\n\n<p style=\"text-indent:50px;\">初步打算是，用户需要在后台注册自己的设备和数据流信息，后台会对所有注册的信息进行订阅接收到消息后，后台会把消息写入到对应的表中，另外设备发布主题只能使用（clientID/主题名）命名方式，以便后台能够区分是哪一个设备发送过来的消息。对于MQTT了解还是不够深，只能使用这样的笨办法来解决了，以后若是找到其他的方法在进行改进。</p>\n\n<h3>解决问题：</h3>\n\n<p style=\"text-indent:50px;\">首先需要通过python建立mqtt连接监听所有注册的主题信息，这里使用了paho-mqtt库来实现，为了方便以后的调用将其封装成一个类，最开始的时候想把一些常用的操作也封装进去，单独测试完全可以，但是一旦放到Django请求中处理的时候，mqtt能够正常返回成功信息，但是实际上并没有正确执行，这一点始终没有找到原因，最终只能简化，只包含最基础的功能。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class MqClient(object):\n    def __init__(self, client_id, username, password):\n        self.client = client.Client(client_id=client_id,\n                                    clean_session=True)  # 初始化,clean_session为false的时候EMQ会保存订阅状态，可以不再次订阅\n        self.client.username_pw_set(username, password)  # 设置连接用户名\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        self._client_status = False  # 连接状态\n        self._cloop = None\n        self._connect()  # 实例化会自动连接\n\n    def _connect(self, host=\"your IP \", port=1883, keepalive=60):\n        \"\"\"连接服务器\"\"\"\n        self.client.connect_async(host, port, keepalive)\n        # 开启线程执行\n        self._cloop = threading.Thread(target=self.client.loop_start())\n        self._cloop.start()\n\n    def on_connect(self, client, userdata, flags, rc):\n        \"\"\"连接成功的回调函数\"\"\"\n        # 修改客户端状态\n        if rc == 0:\n            self._client_status = True\n\n    def init_sub(self):\n        # 读取数据库中所有的已经注册过的topic并且订阅\n        for i in models.Device.objects.all():\n            for j in i.dev_stream.all():\n                self.client.subscribe(str(i.device_id) + '/' + j.name, j.qos)\n\n    @staticmethod\n    def on_message(client, userdata, msg):\n        client_id = msg.topic.split('/')[0]\n        stream = msg.topic.split('/')[1]\n        data = msg.payload.decode()\n        # 接收订阅信息写入到数据库中\n        models.DataStream.objects.filter(device__device_id=client_id).filter(name=stream).first().data.add(\n            models.Data.objects.create(data=data))</code></pre>\n\n<p style=\"text-indent:50px;\">有了封装好的类，现在我们需要做的是：在Django项目启动完成之后自动执行监听任务的，最开始的时候打算放到setting或者__init__里面，但是因为类里面封装了model操作，那时候项目还没有加载完model会报错，所以最终新建了一个app，然后放到其下的urls，这样当项目启动完成的时候就会自动加载了。</p>\n\n<pre class=\"has\">\n<code>from utils.mqtt_client import MqClient\n\nMQClient = MqClient(your client ID, username, password)\nMQClient.init_sub()</code></pre>\n\n<p style=\"text-indent:50px;\">接下来测试一下实时新增订阅的功能，先从urls文件导入示例化之后的对象，调用client的subscribe方法</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from mqtt.urls import MQClient\nclass Test(APIView):\n    def post(self, request):\n        topic = request.POST.get('topic')\n        qos = int(request.POST.get('qos'))\n        if topic:\n            MQClient.client.subscribe(topic,qos)\n        return HttpResponse(\"ok\")</code></pre>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"100\" src=\"https://img-blog.csdnimg.cn/20181107111120198.png\" width=\"1173\" /></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"86\" src=\"https://img-blog.csdnimg.cn/20181107111210936.png\" width=\"998\" /></p>\n\n<p style=\"text-indent:50px;\">最后就剩下把数据存入数据库中了，这个操作已经写在那个类中了。简单说明一下 ，当paho接收了mqtt请求的时候会产生一个回调，执行下面这个函数，接收到的类容包含在msg中，msg主要有topic和payload两个属性，topic是订阅的主题名，payload则是具体的消息内容，按照之前的规定，主题名为client/stream，对topic内容拆分获取到client_id和stream，最后就是数据库的插入操作了，涉及到多表操作，简单点说就是，先插入一个data数据，然后根据client_id和stream来确定stream，最后再通过add方法将两者关联起来，这样就完成了消息的保存了。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def on_message(client, userdata, msg):\n        client_id = msg.topic.split('/')[0]\n        stream = msg.topic.split('/')[1]\n        data = msg.payload.decode()\n        # 接收订阅信息写入到数据库中\n        models.DataStream.objects.filter(device__device_id=client_id).filter(name=stream).first().data.add(\n            models.Data.objects.create(data=data))</code></pre>\n\n<p style=\"text-indent:50px;\">测试一下，数据库里面已经准备一些client和stream数据，还是使用EMQ的websocket来测试，发送主题为123456/hum，消息内容为654321，在来看一下数据库中数据是否插入成功。</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"140\" src=\"https://img-blog.csdnimg.cn/20181107113047550.png\" width=\"785\" /></p>\n\n<div style=\"text-align:center;\">\n<figure class=\"image\"><img alt=\"\" height=\"51\" src=\"https://img-blog.csdnimg.cn/20181107113809200.png\" width=\"561\" /><figcaption>data表</figcaption></figure></div>\n\n<div style=\"text-align:center;\">\n<figure class=\"image\"><img alt=\"\" height=\"85\" src=\"https://img-blog.csdnimg.cn/20181107113844420.png\" width=\"822\" /><figcaption>stream表</figcaption></figure></div>\n\n<div style=\"text-align:center;\">\n<figure class=\"image\"><img alt=\"\" height=\"64\" src=\"https://img-blog.csdnimg.cn/20181107113941992.png\" width=\"536\" /><figcaption>stream和data关联表</figcaption></figure></div>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<h3 style=\"text-indent:0px;\">更新：</h3>\n\n<p style=\"text-indent:50px;\">最终对这一部分做了修改，没有将MQTT相关的东西放到Django里面，独立出来了，这样也方便日后的扩展和管理，数据库操作改用了sqlachemy实现，其他内容基本不变</p>\n\n<p style=\"text-indent:50px;\"> </p>","site":{"data":{}},"excerpt":"","more":"<h3>遇到的问题：</h3>\n\n<p style=\"text-indent:50px;\">查看了EMQ文档发现并不提供消息的持久化功能，MQTT协议是按照设备一直在线设计的，数据都是保存在内存里的，但是考虑到用户上传传感器数据不可能接收了就扔掉，那样就没法查看历史数据了，所以用户上传的消息必须要能够保存下来，以便查看历史数据，这样一来持久化功能就需要我们自己来实现。</p>\n\n<p style=\"text-indent:50px;\">另外还会出现一个问题，当两个设备注册的主题名一样的时候，不能分出是哪一个设备发出的消息，在接收订阅消息的时候发现没办法获取到发送消息的clientID，而且其他设备也可以订阅到任意设备的消息，对于敏感信息来说存在安全性。</p>\n\n<h3>解决方法：</h3>\n\n<p style=\"text-indent:50px;\">初步打算是，用户需要在后台注册自己的设备和数据流信息，后台会对所有注册的信息进行订阅接收到消息后，后台会把消息写入到对应的表中，另外设备发布主题只能使用（clientID/主题名）命名方式，以便后台能够区分是哪一个设备发送过来的消息。对于MQTT了解还是不够深，只能使用这样的笨办法来解决了，以后若是找到其他的方法在进行改进。</p>\n\n<h3>解决问题：</h3>\n\n<p style=\"text-indent:50px;\">首先需要通过python建立mqtt连接监听所有注册的主题信息，这里使用了paho-mqtt库来实现，为了方便以后的调用将其封装成一个类，最开始的时候想把一些常用的操作也封装进去，单独测试完全可以，但是一旦放到Django请求中处理的时候，mqtt能够正常返回成功信息，但是实际上并没有正确执行，这一点始终没有找到原因，最终只能简化，只包含最基础的功能。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class MqClient(object):\n    def __init__(self, client_id, username, password):\n        self.client = client.Client(client_id=client_id,\n                                    clean_session=True)  # 初始化,clean_session为false的时候EMQ会保存订阅状态，可以不再次订阅\n        self.client.username_pw_set(username, password)  # 设置连接用户名\n        self.client.on_connect = self.on_connect\n        self.client.on_message = self.on_message\n        self._client_status = False  # 连接状态\n        self._cloop = None\n        self._connect()  # 实例化会自动连接\n\n    def _connect(self, host=\"your IP \", port=1883, keepalive=60):\n        \"\"\"连接服务器\"\"\"\n        self.client.connect_async(host, port, keepalive)\n        # 开启线程执行\n        self._cloop = threading.Thread(target=self.client.loop_start())\n        self._cloop.start()\n\n    def on_connect(self, client, userdata, flags, rc):\n        \"\"\"连接成功的回调函数\"\"\"\n        # 修改客户端状态\n        if rc == 0:\n            self._client_status = True\n\n    def init_sub(self):\n        # 读取数据库中所有的已经注册过的topic并且订阅\n        for i in models.Device.objects.all():\n            for j in i.dev_stream.all():\n                self.client.subscribe(str(i.device_id) + '/' + j.name, j.qos)\n\n    @staticmethod\n    def on_message(client, userdata, msg):\n        client_id = msg.topic.split('/')[0]\n        stream = msg.topic.split('/')[1]\n        data = msg.payload.decode()\n        # 接收订阅信息写入到数据库中\n        models.DataStream.objects.filter(device__device_id=client_id).filter(name=stream).first().data.add(\n            models.Data.objects.create(data=data))</code></pre>\n\n<p style=\"text-indent:50px;\">有了封装好的类，现在我们需要做的是：在Django项目启动完成之后自动执行监听任务的，最开始的时候打算放到setting或者__init__里面，但是因为类里面封装了model操作，那时候项目还没有加载完model会报错，所以最终新建了一个app，然后放到其下的urls，这样当项目启动完成的时候就会自动加载了。</p>\n\n<pre class=\"has\">\n<code>from utils.mqtt_client import MqClient\n\nMQClient = MqClient(your client ID, username, password)\nMQClient.init_sub()</code></pre>\n\n<p style=\"text-indent:50px;\">接下来测试一下实时新增订阅的功能，先从urls文件导入示例化之后的对象，调用client的subscribe方法</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from mqtt.urls import MQClient\nclass Test(APIView):\n    def post(self, request):\n        topic = request.POST.get('topic')\n        qos = int(request.POST.get('qos'))\n        if topic:\n            MQClient.client.subscribe(topic,qos)\n        return HttpResponse(\"ok\")</code></pre>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"100\" src=\"https://img-blog.csdnimg.cn/20181107111120198.png\" width=\"1173\" /></p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"86\" src=\"https://img-blog.csdnimg.cn/20181107111210936.png\" width=\"998\" /></p>\n\n<p style=\"text-indent:50px;\">最后就剩下把数据存入数据库中了，这个操作已经写在那个类中了。简单说明一下 ，当paho接收了mqtt请求的时候会产生一个回调，执行下面这个函数，接收到的类容包含在msg中，msg主要有topic和payload两个属性，topic是订阅的主题名，payload则是具体的消息内容，按照之前的规定，主题名为client/stream，对topic内容拆分获取到client_id和stream，最后就是数据库的插入操作了，涉及到多表操作，简单点说就是，先插入一个data数据，然后根据client_id和stream来确定stream，最后再通过add方法将两者关联起来，这样就完成了消息的保存了。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def on_message(client, userdata, msg):\n        client_id = msg.topic.split('/')[0]\n        stream = msg.topic.split('/')[1]\n        data = msg.payload.decode()\n        # 接收订阅信息写入到数据库中\n        models.DataStream.objects.filter(device__device_id=client_id).filter(name=stream).first().data.add(\n            models.Data.objects.create(data=data))</code></pre>\n\n<p style=\"text-indent:50px;\">测试一下，数据库里面已经准备一些client和stream数据，还是使用EMQ的websocket来测试，发送主题为123456/hum，消息内容为654321，在来看一下数据库中数据是否插入成功。</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"140\" src=\"https://img-blog.csdnimg.cn/20181107113047550.png\" width=\"785\" /></p>\n\n<div style=\"text-align:center;\">\n<figure class=\"image\"><img alt=\"\" height=\"51\" src=\"https://img-blog.csdnimg.cn/20181107113809200.png\" width=\"561\" /><figcaption>data表</figcaption></figure></div>\n\n<div style=\"text-align:center;\">\n<figure class=\"image\"><img alt=\"\" height=\"85\" src=\"https://img-blog.csdnimg.cn/20181107113844420.png\" width=\"822\" /><figcaption>stream表</figcaption></figure></div>\n\n<div style=\"text-align:center;\">\n<figure class=\"image\"><img alt=\"\" height=\"64\" src=\"https://img-blog.csdnimg.cn/20181107113941992.png\" width=\"536\" /><figcaption>stream和data关联表</figcaption></figure></div>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<h3 style=\"text-indent:0px;\">更新：</h3>\n\n<p style=\"text-indent:50px;\">最终对这一部分做了修改，没有将MQTT相关的东西放到Django里面，独立出来了，这样也方便日后的扩展和管理，数据库操作改用了sqlachemy实现，其他内容基本不变</p>\n\n<p style=\"text-indent:50px;\"> </p>"},{"_content":"<h3>摘要：</h3>\n\n<p style=\"text-indent:50px;\">Vue我也是刚开始学的，看了两天的文档就开始着手做这件事了，所以对vue了解不太深入，没有能力说的的太详细万一是错误的不就误导别人了，所以只对几个相对来说比较主要的点说明一下。</p>\n\n<h3>搭建开发环境：</h3>\n\n<p style=\"text-indent:50px;\">老生常谈的话题！首先自然是要安装nodejs，这个直接去官网下载安装即可，再使用命令npm install vue、npm install -g vue-cli去安装vue和脚手架工具，完成之后再使用命令vue init webpack myproject来初始化项目，初始化完成之后会在目录下生成这些文件，到这一步的话环境差不多搭建好了。<br /><img alt=\"\" class=\"has\" height=\"351\" src=\"https://img-blog.csdnimg.cn/20181102150006888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"325\" /></p>\n\n<p style=\"text-indent:50px;\">接下来是安装依赖，在这个项目里面我用了以下几个库， 通过命令npm install  xxx --S 安装，环境差不多搭建完成。<br />\n                  \"axios\": \"^0.18.0\",         发送请求的类似ajax<br />\n                  \"echarts\": \"^4.2.0-rc.2\",      可视化工具，用于绘制数据曲线图<br />\n                  \"element-ui\": \"^2.4.9\",        网页UI<br />\n                  \"vue-router\": \"^3.0.1\",         路由，这个一般在初始化项目的时候就安装了，如果没有自己手动安装</p>\n\n<h3>开始我们的开发之旅：</h3>\n\n<p style=\"text-indent:50px;\">首先确定一下页面布局，分为三大块，其中顶栏和侧栏显示内容不变，只变主题部分，布局样式使用elementUI中的<code>&lt;el-header&gt;</code>：顶栏容器， <code>&lt;el-aside&gt;</code>：侧边栏容器，<code>&lt;el-main&gt;</code>：主要区域容器实现。</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181121122335392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p style=\"text-indent:50px;\">顶栏基本没啥内容就一个图标不说了，说一下侧边导航栏，导航栏使用el-menu组件实现，将el-menu的 route属性设置为true，或者使用router-link去做跳转，不过那样显得要麻烦一些，所以还是推荐第一种</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"62\" src=\"https://img-blog.csdnimg.cn/2018112217051257.png\" width=\"1020\" /></p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\"> &lt;el-menu class=\"el-menu-vertical-demo\"\n                 background-color=\"#304156\"\n                 text-color=\"#bfcbd9\"\n                 active-text-color=\"#409eff\"\n                 :default-active=\"$route.path\"\n                 router &gt;\n    &lt;el-menu-item index=\"/developer/dashboard\"&gt;\n      &lt;i class=\"el-icon-ump-18\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;主页&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/charts\"&gt;\n      &lt;i class=\"el-icon-ump-shuju2\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;历史数据&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/devices\"&gt;\n      &lt;i class=\"el-icon-ump-shebei2\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;设备管理&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/streams\"&gt;\n      &lt;i class=\"el-icon-ump-shuju1\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;数据流管理&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/triggers\"&gt;\n      &lt;i class=\"el-icon-ump-chufaqi\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;触发器管理&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/console\"&gt;\n      &lt;i class=\"el-icon-ump-kongzhitai1\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;控制台&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n&lt;/el-menu&gt;</code></pre>\n\n<p style=\"text-indent:50px;\">最后的效果：</p>\n\n<p style=\"text-indent:50px;\"><img alt=\"\" class=\"has\" height=\"403\" src=\"https://img-blog.csdnimg.cn/20181122170829897.png\" width=\"230\" /></p>\n\n<p style=\"text-indent:50px;\">下面开始内容主体，放个样图。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181122171312133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p style=\"text-indent:50px;\">样式部分就不说了看个人喜好，主要说一下如何获取后台的数据，数据的获取需要用到之前安装的axios插件，通过axios的get、post等方法访问后端的接口获取json数据例如get方法，then和catch是es6的语法，具体的我也解释明白。如果数据获取正常，后端返回的数据放在res.data里面，打印到控制台看看返回结果，post同理，只是参数不同</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">axios.get(url, {\n　　params: { 'key': 'value' }\n}).then((res)=&gt; {\n　　console.log(res.data);\n}).catch((error)=&gt; {\n　　console.log(error);\n});</code></pre>\n\n<p style=\"text-indent:50px;\">一般来说获取数据可以放在created()或者mounted()里面，看自己需求吧，created要先于mounted，created那时候还没有生成dom，如果需要操作dom那么还是放到mounted里面吧。</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\">算了就写这么多吧，自己都不专业还是不误导别人了</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>","source":"_posts/blogs-从零开始搭建物联网平台（7）：使用Vue编写前端页面.md","raw":"<h3>摘要：</h3>\n\n<p style=\"text-indent:50px;\">Vue我也是刚开始学的，看了两天的文档就开始着手做这件事了，所以对vue了解不太深入，没有能力说的的太详细万一是错误的不就误导别人了，所以只对几个相对来说比较主要的点说明一下。</p>\n\n<h3>搭建开发环境：</h3>\n\n<p style=\"text-indent:50px;\">老生常谈的话题！首先自然是要安装nodejs，这个直接去官网下载安装即可，再使用命令npm install vue、npm install -g vue-cli去安装vue和脚手架工具，完成之后再使用命令vue init webpack myproject来初始化项目，初始化完成之后会在目录下生成这些文件，到这一步的话环境差不多搭建好了。<br /><img alt=\"\" class=\"has\" height=\"351\" src=\"https://img-blog.csdnimg.cn/20181102150006888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"325\" /></p>\n\n<p style=\"text-indent:50px;\">接下来是安装依赖，在这个项目里面我用了以下几个库， 通过命令npm install  xxx --S 安装，环境差不多搭建完成。<br />\n                  \"axios\": \"^0.18.0\",         发送请求的类似ajax<br />\n                  \"echarts\": \"^4.2.0-rc.2\",      可视化工具，用于绘制数据曲线图<br />\n                  \"element-ui\": \"^2.4.9\",        网页UI<br />\n                  \"vue-router\": \"^3.0.1\",         路由，这个一般在初始化项目的时候就安装了，如果没有自己手动安装</p>\n\n<h3>开始我们的开发之旅：</h3>\n\n<p style=\"text-indent:50px;\">首先确定一下页面布局，分为三大块，其中顶栏和侧栏显示内容不变，只变主题部分，布局样式使用elementUI中的<code>&lt;el-header&gt;</code>：顶栏容器， <code>&lt;el-aside&gt;</code>：侧边栏容器，<code>&lt;el-main&gt;</code>：主要区域容器实现。</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181121122335392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p style=\"text-indent:50px;\">顶栏基本没啥内容就一个图标不说了，说一下侧边导航栏，导航栏使用el-menu组件实现，将el-menu的 route属性设置为true，或者使用router-link去做跳转，不过那样显得要麻烦一些，所以还是推荐第一种</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"62\" src=\"https://img-blog.csdnimg.cn/2018112217051257.png\" width=\"1020\" /></p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\"> &lt;el-menu class=\"el-menu-vertical-demo\"\n                 background-color=\"#304156\"\n                 text-color=\"#bfcbd9\"\n                 active-text-color=\"#409eff\"\n                 :default-active=\"$route.path\"\n                 router &gt;\n    &lt;el-menu-item index=\"/developer/dashboard\"&gt;\n      &lt;i class=\"el-icon-ump-18\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;主页&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/charts\"&gt;\n      &lt;i class=\"el-icon-ump-shuju2\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;历史数据&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/devices\"&gt;\n      &lt;i class=\"el-icon-ump-shebei2\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;设备管理&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/streams\"&gt;\n      &lt;i class=\"el-icon-ump-shuju1\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;数据流管理&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/triggers\"&gt;\n      &lt;i class=\"el-icon-ump-chufaqi\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;触发器管理&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/console\"&gt;\n      &lt;i class=\"el-icon-ump-kongzhitai1\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;控制台&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n&lt;/el-menu&gt;</code></pre>\n\n<p style=\"text-indent:50px;\">最后的效果：</p>\n\n<p style=\"text-indent:50px;\"><img alt=\"\" class=\"has\" height=\"403\" src=\"https://img-blog.csdnimg.cn/20181122170829897.png\" width=\"230\" /></p>\n\n<p style=\"text-indent:50px;\">下面开始内容主体，放个样图。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181122171312133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p style=\"text-indent:50px;\">样式部分就不说了看个人喜好，主要说一下如何获取后台的数据，数据的获取需要用到之前安装的axios插件，通过axios的get、post等方法访问后端的接口获取json数据例如get方法，then和catch是es6的语法，具体的我也解释明白。如果数据获取正常，后端返回的数据放在res.data里面，打印到控制台看看返回结果，post同理，只是参数不同</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">axios.get(url, {\n　　params: { 'key': 'value' }\n}).then((res)=&gt; {\n　　console.log(res.data);\n}).catch((error)=&gt; {\n　　console.log(error);\n});</code></pre>\n\n<p style=\"text-indent:50px;\">一般来说获取数据可以放在created()或者mounted()里面，看自己需求吧，created要先于mounted，created那时候还没有生成dom，如果需要操作dom那么还是放到mounted里面吧。</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\">算了就写这么多吧，自己都不专业还是不误导别人了</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>","slug":"blogs-从零开始搭建物联网平台（7）：使用Vue编写前端页面","published":1,"date":"2022-03-16T17:00:59.196Z","updated":"2022-03-16T17:05:48.629Z","_id":"cl0v6kepx0007yms44iim0sw8","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>摘要：</h3>\n\n<p style=\"text-indent:50px;\">Vue我也是刚开始学的，看了两天的文档就开始着手做这件事了，所以对vue了解不太深入，没有能力说的的太详细万一是错误的不就误导别人了，所以只对几个相对来说比较主要的点说明一下。</p>\n\n<h3>搭建开发环境：</h3>\n\n<p style=\"text-indent:50px;\">老生常谈的话题！首先自然是要安装nodejs，这个直接去官网下载安装即可，再使用命令npm install vue、npm install -g vue-cli去安装vue和脚手架工具，完成之后再使用命令vue init webpack myproject来初始化项目，初始化完成之后会在目录下生成这些文件，到这一步的话环境差不多搭建好了。<br /><img alt=\"\" class=\"has\" height=\"351\" src=\"https://img-blog.csdnimg.cn/20181102150006888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"325\" /></p>\n\n<p style=\"text-indent:50px;\">接下来是安装依赖，在这个项目里面我用了以下几个库， 通过命令npm install  xxx --S 安装，环境差不多搭建完成。<br />\n                  \"axios\": \"^0.18.0\",         发送请求的类似ajax<br />\n                  \"echarts\": \"^4.2.0-rc.2\",      可视化工具，用于绘制数据曲线图<br />\n                  \"element-ui\": \"^2.4.9\",        网页UI<br />\n                  \"vue-router\": \"^3.0.1\",         路由，这个一般在初始化项目的时候就安装了，如果没有自己手动安装</p>\n\n<h3>开始我们的开发之旅：</h3>\n\n<p style=\"text-indent:50px;\">首先确定一下页面布局，分为三大块，其中顶栏和侧栏显示内容不变，只变主题部分，布局样式使用elementUI中的<code>&lt;el-header&gt;</code>：顶栏容器， <code>&lt;el-aside&gt;</code>：侧边栏容器，<code>&lt;el-main&gt;</code>：主要区域容器实现。</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181121122335392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p style=\"text-indent:50px;\">顶栏基本没啥内容就一个图标不说了，说一下侧边导航栏，导航栏使用el-menu组件实现，将el-menu的 route属性设置为true，或者使用router-link去做跳转，不过那样显得要麻烦一些，所以还是推荐第一种</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"62\" src=\"https://img-blog.csdnimg.cn/2018112217051257.png\" width=\"1020\" /></p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\"> &lt;el-menu class=\"el-menu-vertical-demo\"\n                 background-color=\"#304156\"\n                 text-color=\"#bfcbd9\"\n                 active-text-color=\"#409eff\"\n                 :default-active=\"$route.path\"\n                 router &gt;\n    &lt;el-menu-item index=\"/developer/dashboard\"&gt;\n      &lt;i class=\"el-icon-ump-18\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;主页&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/charts\"&gt;\n      &lt;i class=\"el-icon-ump-shuju2\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;历史数据&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/devices\"&gt;\n      &lt;i class=\"el-icon-ump-shebei2\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;设备管理&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/streams\"&gt;\n      &lt;i class=\"el-icon-ump-shuju1\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;数据流管理&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/triggers\"&gt;\n      &lt;i class=\"el-icon-ump-chufaqi\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;触发器管理&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/console\"&gt;\n      &lt;i class=\"el-icon-ump-kongzhitai1\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;控制台&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n&lt;/el-menu&gt;</code></pre>\n\n<p style=\"text-indent:50px;\">最后的效果：</p>\n\n<p style=\"text-indent:50px;\"><img alt=\"\" class=\"has\" height=\"403\" src=\"https://img-blog.csdnimg.cn/20181122170829897.png\" width=\"230\" /></p>\n\n<p style=\"text-indent:50px;\">下面开始内容主体，放个样图。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181122171312133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p style=\"text-indent:50px;\">样式部分就不说了看个人喜好，主要说一下如何获取后台的数据，数据的获取需要用到之前安装的axios插件，通过axios的get、post等方法访问后端的接口获取json数据例如get方法，then和catch是es6的语法，具体的我也解释明白。如果数据获取正常，后端返回的数据放在res.data里面，打印到控制台看看返回结果，post同理，只是参数不同</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">axios.get(url, &#123;\n　　params: &#123; 'key': 'value' &#125;\n&#125;).then((res)=&gt; &#123;\n　　console.log(res.data);\n&#125;).catch((error)=&gt; &#123;\n　　console.log(error);\n&#125;);</code></pre>\n\n<p style=\"text-indent:50px;\">一般来说获取数据可以放在created()或者mounted()里面，看自己需求吧，created要先于mounted，created那时候还没有生成dom，如果需要操作dom那么还是放到mounted里面吧。</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\">算了就写这么多吧，自己都不专业还是不误导别人了</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>","site":{"data":{}},"excerpt":"","more":"<h3>摘要：</h3>\n\n<p style=\"text-indent:50px;\">Vue我也是刚开始学的，看了两天的文档就开始着手做这件事了，所以对vue了解不太深入，没有能力说的的太详细万一是错误的不就误导别人了，所以只对几个相对来说比较主要的点说明一下。</p>\n\n<h3>搭建开发环境：</h3>\n\n<p style=\"text-indent:50px;\">老生常谈的话题！首先自然是要安装nodejs，这个直接去官网下载安装即可，再使用命令npm install vue、npm install -g vue-cli去安装vue和脚手架工具，完成之后再使用命令vue init webpack myproject来初始化项目，初始化完成之后会在目录下生成这些文件，到这一步的话环境差不多搭建好了。<br /><img alt=\"\" class=\"has\" height=\"351\" src=\"https://img-blog.csdnimg.cn/20181102150006888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"325\" /></p>\n\n<p style=\"text-indent:50px;\">接下来是安装依赖，在这个项目里面我用了以下几个库， 通过命令npm install  xxx --S 安装，环境差不多搭建完成。<br />\n                  \"axios\": \"^0.18.0\",         发送请求的类似ajax<br />\n                  \"echarts\": \"^4.2.0-rc.2\",      可视化工具，用于绘制数据曲线图<br />\n                  \"element-ui\": \"^2.4.9\",        网页UI<br />\n                  \"vue-router\": \"^3.0.1\",         路由，这个一般在初始化项目的时候就安装了，如果没有自己手动安装</p>\n\n<h3>开始我们的开发之旅：</h3>\n\n<p style=\"text-indent:50px;\">首先确定一下页面布局，分为三大块，其中顶栏和侧栏显示内容不变，只变主题部分，布局样式使用elementUI中的<code>&lt;el-header&gt;</code>：顶栏容器， <code>&lt;el-aside&gt;</code>：侧边栏容器，<code>&lt;el-main&gt;</code>：主要区域容器实现。</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181121122335392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p style=\"text-indent:50px;\">顶栏基本没啥内容就一个图标不说了，说一下侧边导航栏，导航栏使用el-menu组件实现，将el-menu的 route属性设置为true，或者使用router-link去做跳转，不过那样显得要麻烦一些，所以还是推荐第一种</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"62\" src=\"https://img-blog.csdnimg.cn/2018112217051257.png\" width=\"1020\" /></p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\"> &lt;el-menu class=\"el-menu-vertical-demo\"\n                 background-color=\"#304156\"\n                 text-color=\"#bfcbd9\"\n                 active-text-color=\"#409eff\"\n                 :default-active=\"$route.path\"\n                 router &gt;\n    &lt;el-menu-item index=\"/developer/dashboard\"&gt;\n      &lt;i class=\"el-icon-ump-18\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;主页&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/charts\"&gt;\n      &lt;i class=\"el-icon-ump-shuju2\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;历史数据&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/devices\"&gt;\n      &lt;i class=\"el-icon-ump-shebei2\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;设备管理&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/streams\"&gt;\n      &lt;i class=\"el-icon-ump-shuju1\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;数据流管理&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/triggers\"&gt;\n      &lt;i class=\"el-icon-ump-chufaqi\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;触发器管理&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n    &lt;el-menu-item index=\"/developer/console\"&gt;\n      &lt;i class=\"el-icon-ump-kongzhitai1\"&gt;&lt;/i&gt;\n      &lt;span slot=\"title\"&gt;控制台&lt;/span&gt;\n    &lt;/el-menu-item&gt;\n&lt;/el-menu&gt;</code></pre>\n\n<p style=\"text-indent:50px;\">最后的效果：</p>\n\n<p style=\"text-indent:50px;\"><img alt=\"\" class=\"has\" height=\"403\" src=\"https://img-blog.csdnimg.cn/20181122170829897.png\" width=\"230\" /></p>\n\n<p style=\"text-indent:50px;\">下面开始内容主体，放个样图。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181122171312133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p style=\"text-indent:50px;\">样式部分就不说了看个人喜好，主要说一下如何获取后台的数据，数据的获取需要用到之前安装的axios插件，通过axios的get、post等方法访问后端的接口获取json数据例如get方法，then和catch是es6的语法，具体的我也解释明白。如果数据获取正常，后端返回的数据放在res.data里面，打印到控制台看看返回结果，post同理，只是参数不同</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">axios.get(url, &#123;\n　　params: &#123; 'key': 'value' &#125;\n&#125;).then((res)=&gt; &#123;\n　　console.log(res.data);\n&#125;).catch((error)=&gt; &#123;\n　　console.log(error);\n&#125;);</code></pre>\n\n<p style=\"text-indent:50px;\">一般来说获取数据可以放在created()或者mounted()里面，看自己需求吧，created要先于mounted，created那时候还没有生成dom，如果需要操作dom那么还是放到mounted里面吧。</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\">算了就写这么多吧，自己都不专业还是不误导别人了</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<p style=\"text-indent:50px;\"> </p>"},{"_content":"<p>关于触发器的通知，最开始有三种打算 微信公众号、 邮箱、 HTTP，最后发现微信公众号平台无法主动向用户推送消息，所以微信公众号暂时不做了，看看有没有其他的解决方案</p>\n\n<h3>搭建SMTP服务</h3>\n\n<p style=\"text-indent:0;\">发送邮件可以借助第三方平台如163、QQ等等，但是使用个人账户去做都是有最大发送数量限制的，为了稳妥起见还是决定搭建自己的STMP服务来发送邮件。</p>\n\n<p style=\"text-indent:0;\">以ubuntu 14.04为例：借助于postfix搭建SMTP服务</p>\n\n<ol><li>安装\n\t<pre class=\"has\">\n<code>apt-get install mailutils</code></pre>\n\n\t<p>在设置页面选择Internet site<br /><img alt=\"\" class=\"has\" height=\"269\" src=\"https://img-blog.csdnimg.cn/20181227134333835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"500\" /></p>\n\t</li>\n\t<li style=\"text-indent:0px;\"> 配置\n\t<pre class=\"has\">\n<code class=\"language-bash\">vim  /etc/postfix/main.cf\n\n\n# 修改以下内容\nmyhostname = mail.youraddress\nmydomain = youraddress\nmyorigin = admin@youraddress\n\nmydestination = $myhostname, localhost.$mydomain, $mydomain</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li style=\"text-indent:0px;\">重启服务\n\t<pre class=\"has\">\n<code>service postfix restart</code></pre>\n\t</li>\n\t<li style=\"text-indent:0px;\">测试\n\t<pre class=\"has\">\n<code>echo “This is the body of the email” | mail -s “This is the subject line” your_email_address\n\n</code></pre>\n\n\t<p>检查是否能够收到邮件，如果没有请检查服务器25端口是否开放，（腾讯云的默认是关闭的需要去申请解封）</p>\n\t</li>\n</ol><h3 style=\"text-indent:0px;\">邮箱服务</h3>\n\n<p style=\"text-indent:0px;\">python 自带两个模块可以实现发送邮件的功能，email和 smtplib，email负责构造邮件内容，smtplib用来发送邮件<br />\n下面是最简单的一个发送示例</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import smtplib\nfrom email.mime.text import MIMEText\nfrom email.header import Header\n\ndef send(receiver,payload):\n    sender = 'admin@iotforfml.cn'\n    # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码\n    message = MIMEText(payload, 'plain', 'utf-8')\n    # 邮件标题\n    subject = '触发器报警通知'\n    message['Subject'] = Header(subject, 'utf-8')\n    try:\n        smtp_obj = smtplib.SMTP('localhost')\n        smtp_obj.sendmail(sender, receiver, message.as_string())\n    except smtplib.SMTPException:\n        pass\n\nsend('1193589986@qq.com','aaaa')</code></pre>\n\n<p style=\"text-indent:0px;\">结果：<br /><img alt=\"\" class=\"has\" height=\"217\" src=\"https://img-blog.csdnimg.cn/20181227161551150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"599\" /></p>\n\n<p style=\"text-indent:0px;\">何时发送，怎么判断是否需要发送报警邮件，这个问题会放到持久化服务里面去判断，接受消息后就应该判断是否触发，具体的实现我想放到后面整合的时候在说，这里只是简单的实现一个发送邮件的接口</p>","source":"_posts/blogs-从零开始搭建物联网平台（8）：邮箱通知服务.md","raw":"<p>关于触发器的通知，最开始有三种打算 微信公众号、 邮箱、 HTTP，最后发现微信公众号平台无法主动向用户推送消息，所以微信公众号暂时不做了，看看有没有其他的解决方案</p>\n\n<h3>搭建SMTP服务</h3>\n\n<p style=\"text-indent:0;\">发送邮件可以借助第三方平台如163、QQ等等，但是使用个人账户去做都是有最大发送数量限制的，为了稳妥起见还是决定搭建自己的STMP服务来发送邮件。</p>\n\n<p style=\"text-indent:0;\">以ubuntu 14.04为例：借助于postfix搭建SMTP服务</p>\n\n<ol><li>安装\n\t<pre class=\"has\">\n<code>apt-get install mailutils</code></pre>\n\n\t<p>在设置页面选择Internet site<br /><img alt=\"\" class=\"has\" height=\"269\" src=\"https://img-blog.csdnimg.cn/20181227134333835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"500\" /></p>\n\t</li>\n\t<li style=\"text-indent:0px;\"> 配置\n\t<pre class=\"has\">\n<code class=\"language-bash\">vim  /etc/postfix/main.cf\n\n\n# 修改以下内容\nmyhostname = mail.youraddress\nmydomain = youraddress\nmyorigin = admin@youraddress\n\nmydestination = $myhostname, localhost.$mydomain, $mydomain</code></pre>\n\n\t<p> </p>\n\t</li>\n\t<li style=\"text-indent:0px;\">重启服务\n\t<pre class=\"has\">\n<code>service postfix restart</code></pre>\n\t</li>\n\t<li style=\"text-indent:0px;\">测试\n\t<pre class=\"has\">\n<code>echo “This is the body of the email” | mail -s “This is the subject line” your_email_address\n\n</code></pre>\n\n\t<p>检查是否能够收到邮件，如果没有请检查服务器25端口是否开放，（腾讯云的默认是关闭的需要去申请解封）</p>\n\t</li>\n</ol><h3 style=\"text-indent:0px;\">邮箱服务</h3>\n\n<p style=\"text-indent:0px;\">python 自带两个模块可以实现发送邮件的功能，email和 smtplib，email负责构造邮件内容，smtplib用来发送邮件<br />\n下面是最简单的一个发送示例</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import smtplib\nfrom email.mime.text import MIMEText\nfrom email.header import Header\n\ndef send(receiver,payload):\n    sender = 'admin@iotforfml.cn'\n    # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码\n    message = MIMEText(payload, 'plain', 'utf-8')\n    # 邮件标题\n    subject = '触发器报警通知'\n    message['Subject'] = Header(subject, 'utf-8')\n    try:\n        smtp_obj = smtplib.SMTP('localhost')\n        smtp_obj.sendmail(sender, receiver, message.as_string())\n    except smtplib.SMTPException:\n        pass\n\nsend('1193589986@qq.com','aaaa')</code></pre>\n\n<p style=\"text-indent:0px;\">结果：<br /><img alt=\"\" class=\"has\" height=\"217\" src=\"https://img-blog.csdnimg.cn/20181227161551150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"599\" /></p>\n\n<p style=\"text-indent:0px;\">何时发送，怎么判断是否需要发送报警邮件，这个问题会放到持久化服务里面去判断，接受消息后就应该判断是否触发，具体的实现我想放到后面整合的时候在说，这里只是简单的实现一个发送邮件的接口</p>","slug":"blogs-从零开始搭建物联网平台（8）：邮箱通知服务","published":1,"date":"2022-03-16T17:00:49.678Z","updated":"2022-03-16T17:05:39.004Z","_id":"cl0v6kepy0008yms4h0e76mmd","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>关于触发器的通知，最开始有三种打算 微信公众号、 邮箱、 HTTP，最后发现微信公众号平台无法主动向用户推送消息，所以微信公众号暂时不做了，看看有没有其他的解决方案</p>\n\n<h3>搭建SMTP服务</h3>\n\n<p style=\"text-indent:0;\">发送邮件可以借助第三方平台如163、QQ等等，但是使用个人账户去做都是有最大发送数量限制的，为了稳妥起见还是决定搭建自己的STMP服务来发送邮件。</p>\n\n<p style=\"text-indent:0;\">以ubuntu 14.04为例：借助于postfix搭建SMTP服务</p>\n\n<ol><li>安装\n    <pre class=\"has\">\n<code>apt-get install mailutils</code></pre>\n\n<pre><code>&lt;p&gt;在设置页面选择Internet site&lt;br /&gt;&lt;img alt=&quot;&quot; class=&quot;has&quot; height=&quot;269&quot; src=&quot;https://img-blog.csdnimg.cn/20181227134333835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li style=&quot;text-indent:0px;&quot;&gt; 配置\n&lt;pre class=&quot;has&quot;&gt;\n</code></pre>\n<p><code class=\"language-bash\">vim  /etc/postfix/main.cf</p>\n<h1 id=\"修改以下内容\"><a href=\"#修改以下内容\" class=\"headerlink\" title=\"修改以下内容\"></a>修改以下内容</h1><p>myhostname = mail.youraddress<br>mydomain = youraddress<br>myorigin = admin@youraddress</p>\n<p>mydestination = $myhostname, localhost.$mydomain, $mydomain</code></pre></p>\n<pre><code>&lt;p&gt; &lt;/p&gt;\n&lt;/li&gt;\n&lt;li style=&quot;text-indent:0px;&quot;&gt;重启服务\n&lt;pre class=&quot;has&quot;&gt;\n</code></pre>\n<p><code>service postfix restart</code></pre><br>    </li><br>    <li style=\"text-indent:0px;\">测试<br>    <pre class=\"has\"><br><code>echo “This is the body of the email” | mail -s “This is the subject line” your_email_address</p>\n<p></code></pre></p>\n<pre><code>&lt;p&gt;检查是否能够收到邮件，如果没有请检查服务器25端口是否开放，（腾讯云的默认是关闭的需要去申请解封）&lt;/p&gt;\n&lt;/li&gt;\n</code></pre>\n</ol><h3 style=\"text-indent:0px;\">邮箱服务</h3>\n\n<p style=\"text-indent:0px;\">python 自带两个模块可以实现发送邮件的功能，email和 smtplib，email负责构造邮件内容，smtplib用来发送邮件<br />\n下面是最简单的一个发送示例</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import smtplib\nfrom email.mime.text import MIMEText\nfrom email.header import Header\n\ndef send(receiver,payload):\n    sender = 'admin@iotforfml.cn'\n    # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码\n    message = MIMEText(payload, 'plain', 'utf-8')\n    # 邮件标题\n    subject = '触发器报警通知'\n    message['Subject'] = Header(subject, 'utf-8')\n    try:\n        smtp_obj = smtplib.SMTP('localhost')\n        smtp_obj.sendmail(sender, receiver, message.as_string())\n    except smtplib.SMTPException:\n        pass\n\nsend('1193589986@qq.com','aaaa')</code></pre>\n\n<p style=\"text-indent:0px;\">结果：<br /><img alt=\"\" class=\"has\" height=\"217\" src=\"https://img-blog.csdnimg.cn/20181227161551150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"599\" /></p>\n\n<p style=\"text-indent:0px;\">何时发送，怎么判断是否需要发送报警邮件，这个问题会放到持久化服务里面去判断，接受消息后就应该判断是否触发，具体的实现我想放到后面整合的时候在说，这里只是简单的实现一个发送邮件的接口</p>","site":{"data":{}},"excerpt":"","more":"<p>关于触发器的通知，最开始有三种打算 微信公众号、 邮箱、 HTTP，最后发现微信公众号平台无法主动向用户推送消息，所以微信公众号暂时不做了，看看有没有其他的解决方案</p>\n\n<h3>搭建SMTP服务</h3>\n\n<p style=\"text-indent:0;\">发送邮件可以借助第三方平台如163、QQ等等，但是使用个人账户去做都是有最大发送数量限制的，为了稳妥起见还是决定搭建自己的STMP服务来发送邮件。</p>\n\n<p style=\"text-indent:0;\">以ubuntu 14.04为例：借助于postfix搭建SMTP服务</p>\n\n<ol><li>安装\n    <pre class=\"has\">\n<code>apt-get install mailutils</code></pre>\n\n<pre><code>&lt;p&gt;在设置页面选择Internet site&lt;br /&gt;&lt;img alt=&quot;&quot; class=&quot;has&quot; height=&quot;269&quot; src=&quot;https://img-blog.csdnimg.cn/20181227134333835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70&quot; width=&quot;500&quot; /&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li style=&quot;text-indent:0px;&quot;&gt; 配置\n&lt;pre class=&quot;has&quot;&gt;\n</code></pre>\n<p><code class=\"language-bash\">vim  /etc/postfix/main.cf</p>\n<h1 id=\"修改以下内容\"><a href=\"#修改以下内容\" class=\"headerlink\" title=\"修改以下内容\"></a>修改以下内容</h1><p>myhostname = mail.youraddress<br>mydomain = youraddress<br>myorigin = admin@youraddress</p>\n<p>mydestination = $myhostname, localhost.$mydomain, $mydomain</code></pre></p>\n<pre><code>&lt;p&gt; &lt;/p&gt;\n&lt;/li&gt;\n&lt;li style=&quot;text-indent:0px;&quot;&gt;重启服务\n&lt;pre class=&quot;has&quot;&gt;\n</code></pre>\n<p><code>service postfix restart</code></pre><br>    </li><br>    <li style=\"text-indent:0px;\">测试<br>    <pre class=\"has\"><br><code>echo “This is the body of the email” | mail -s “This is the subject line” your_email_address</p>\n<p></code></pre></p>\n<pre><code>&lt;p&gt;检查是否能够收到邮件，如果没有请检查服务器25端口是否开放，（腾讯云的默认是关闭的需要去申请解封）&lt;/p&gt;\n&lt;/li&gt;\n</code></pre>\n</ol><h3 style=\"text-indent:0px;\">邮箱服务</h3>\n\n<p style=\"text-indent:0px;\">python 自带两个模块可以实现发送邮件的功能，email和 smtplib，email负责构造邮件内容，smtplib用来发送邮件<br />\n下面是最简单的一个发送示例</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import smtplib\nfrom email.mime.text import MIMEText\nfrom email.header import Header\n\ndef send(receiver,payload):\n    sender = 'admin@iotforfml.cn'\n    # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码\n    message = MIMEText(payload, 'plain', 'utf-8')\n    # 邮件标题\n    subject = '触发器报警通知'\n    message['Subject'] = Header(subject, 'utf-8')\n    try:\n        smtp_obj = smtplib.SMTP('localhost')\n        smtp_obj.sendmail(sender, receiver, message.as_string())\n    except smtplib.SMTPException:\n        pass\n\nsend('1193589986@qq.com','aaaa')</code></pre>\n\n<p style=\"text-indent:0px;\">结果：<br /><img alt=\"\" class=\"has\" height=\"217\" src=\"https://img-blog.csdnimg.cn/20181227161551150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"599\" /></p>\n\n<p style=\"text-indent:0px;\">何时发送，怎么判断是否需要发送报警邮件，这个问题会放到持久化服务里面去判断，接受消息后就应该判断是否触发，具体的实现我想放到后面整合的时候在说，这里只是简单的实现一个发送邮件的接口</p>"},{"_content":"<h3>冒泡排序思路：</h3>\n\n<p style=\"text-indent:50px;\">列表中的每两个相邻的数，如果前面比后面的大，则交换这两个数。直到列表变为有序的时候为止，例如下面这个列表<br />\n           [ 2,  1,  3,  0,  7,  6,  5,  4]</p>\n\n<p style=\"text-indent:50px;\">第一趟：<br />\n                  第一步：列表的第一位和第二位比较：如果第一位大于第二位，则交换两者位置。由于2大于1，所以此时列表 为：[1,  2,  3,  0,  7,  6,  5,  4]<br />\n                  第二步：再比较第二位和第三位，重复上面的操作，第一趟排序完成之后列表变为 [1,  2,  3,  0,   6,  5,  4 ,  7]，第一 趟完成之后最大数7跑到列表最后一位了。</p>\n\n<p style=\"text-indent:50px;\">第二趟： 还是从第一位开始比较，1小于2顺序不变，比较第二位和第三位2 小于3依然不变，比较第三位3大于0交换位 置， 此时列表变为[1,  2,  0,   3,   6,  5,  4 ,  7]，这一趟排序完成之后列表最终变为[1,  2,  0,   3,  5,  4,   6,  7]</p>\n\n<p style=\"text-indent:50px;\">冒泡排序的思想还是比较简单的，只是反复不断的比较相邻位置大小，并作交换，不再把每一步都交代明白了，只需重复上述的操作即可实现，最终裂变会变为[0,1,2,3,4,5,6,7],也就达到我们的排序目的了<br />\n    </p>\n\n<h3>代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def bubble_sort(nums):\n    for i in range(len(nums) - 1):  # i表示第几趟\n        for j in range(len(nums) - i - 1):  # j表示是第几个元素在比较\n            if nums[j] &gt; nums[j + 1]:  # 如果大于则交换位置\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n                print(nums)\n    return nums\n\n\nbubble_sort([2, 1, 3, 0, 7, 6, 5, 4])\n\n# [1, 2, 3, 0, 7, 6, 5, 4]\n# [1, 2, 0, 3, 7, 6, 5, 4]\n# [1, 2, 0, 3, 6, 7, 5, 4]\n# [1, 2, 0, 3, 6, 5, 7, 4]\n# [1, 2, 0, 3, 6, 5, 4, 7]\n# [1, 0, 2, 3, 6, 5, 4, 7]\n# [1, 0, 2, 3, 5, 6, 4, 7]\n# [1, 0, 2, 3, 5, 4, 6, 7]\n# [0, 1, 2, 3, 5, 4, 6, 7]\n# [0, 1, 2, 3, 4, 5, 6, 7]</code></pre>\n\n<h3>简单优化：   </h3>\n\n<p style=\"text-indent:50px;\">可以知道的是，如果列表是无序的，那么一趟排序的结果必然最少有一次交换，那么反过来想一下，如果一次完整的一趟没有交换任何位置，那么是不是就表明这个列表已经是有序的呢？按照这个思路我们来改进一下上面的代码。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def bubble_sort(nums):\n    for i in range(len(nums) - 1):  # i表示第几趟\n        flag = False  # 是否发生交换的标志位\n        for j in range(len(nums) - i - 1):  # j表示是第几个元素在比较\n            if nums[j] &gt; nums[j + 1]:  # 如果大于则交换位置\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n                flag = True\n        if not flag:  # 一趟排序完成没有发生交换直接返回\n            return nums     \n    return nums</code></pre>\n\n<p> </p>","source":"_posts/blogs-常用排序算法：冒泡排序.md","raw":"<h3>冒泡排序思路：</h3>\n\n<p style=\"text-indent:50px;\">列表中的每两个相邻的数，如果前面比后面的大，则交换这两个数。直到列表变为有序的时候为止，例如下面这个列表<br />\n           [ 2,  1,  3,  0,  7,  6,  5,  4]</p>\n\n<p style=\"text-indent:50px;\">第一趟：<br />\n                  第一步：列表的第一位和第二位比较：如果第一位大于第二位，则交换两者位置。由于2大于1，所以此时列表 为：[1,  2,  3,  0,  7,  6,  5,  4]<br />\n                  第二步：再比较第二位和第三位，重复上面的操作，第一趟排序完成之后列表变为 [1,  2,  3,  0,   6,  5,  4 ,  7]，第一 趟完成之后最大数7跑到列表最后一位了。</p>\n\n<p style=\"text-indent:50px;\">第二趟： 还是从第一位开始比较，1小于2顺序不变，比较第二位和第三位2 小于3依然不变，比较第三位3大于0交换位 置， 此时列表变为[1,  2,  0,   3,   6,  5,  4 ,  7]，这一趟排序完成之后列表最终变为[1,  2,  0,   3,  5,  4,   6,  7]</p>\n\n<p style=\"text-indent:50px;\">冒泡排序的思想还是比较简单的，只是反复不断的比较相邻位置大小，并作交换，不再把每一步都交代明白了，只需重复上述的操作即可实现，最终裂变会变为[0,1,2,3,4,5,6,7],也就达到我们的排序目的了<br />\n    </p>\n\n<h3>代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def bubble_sort(nums):\n    for i in range(len(nums) - 1):  # i表示第几趟\n        for j in range(len(nums) - i - 1):  # j表示是第几个元素在比较\n            if nums[j] &gt; nums[j + 1]:  # 如果大于则交换位置\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n                print(nums)\n    return nums\n\n\nbubble_sort([2, 1, 3, 0, 7, 6, 5, 4])\n\n# [1, 2, 3, 0, 7, 6, 5, 4]\n# [1, 2, 0, 3, 7, 6, 5, 4]\n# [1, 2, 0, 3, 6, 7, 5, 4]\n# [1, 2, 0, 3, 6, 5, 7, 4]\n# [1, 2, 0, 3, 6, 5, 4, 7]\n# [1, 0, 2, 3, 6, 5, 4, 7]\n# [1, 0, 2, 3, 5, 6, 4, 7]\n# [1, 0, 2, 3, 5, 4, 6, 7]\n# [0, 1, 2, 3, 5, 4, 6, 7]\n# [0, 1, 2, 3, 4, 5, 6, 7]</code></pre>\n\n<h3>简单优化：   </h3>\n\n<p style=\"text-indent:50px;\">可以知道的是，如果列表是无序的，那么一趟排序的结果必然最少有一次交换，那么反过来想一下，如果一次完整的一趟没有交换任何位置，那么是不是就表明这个列表已经是有序的呢？按照这个思路我们来改进一下上面的代码。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def bubble_sort(nums):\n    for i in range(len(nums) - 1):  # i表示第几趟\n        flag = False  # 是否发生交换的标志位\n        for j in range(len(nums) - i - 1):  # j表示是第几个元素在比较\n            if nums[j] &gt; nums[j + 1]:  # 如果大于则交换位置\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n                flag = True\n        if not flag:  # 一趟排序完成没有发生交换直接返回\n            return nums     \n    return nums</code></pre>\n\n<p> </p>","slug":"blogs-常用排序算法：冒泡排序","published":1,"date":"2022-03-16T17:01:18.339Z","updated":"2022-03-16T17:06:08.024Z","_id":"cl0v6kepz0009yms44k9b19vx","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>冒泡排序思路：</h3>\n\n<p style=\"text-indent:50px;\">列表中的每两个相邻的数，如果前面比后面的大，则交换这两个数。直到列表变为有序的时候为止，例如下面这个列表<br />\n           [ 2,  1,  3,  0,  7,  6,  5,  4]</p>\n\n<p style=\"text-indent:50px;\">第一趟：<br />\n                  第一步：列表的第一位和第二位比较：如果第一位大于第二位，则交换两者位置。由于2大于1，所以此时列表 为：[1,  2,  3,  0,  7,  6,  5,  4]<br />\n                  第二步：再比较第二位和第三位，重复上面的操作，第一趟排序完成之后列表变为 [1,  2,  3,  0,   6,  5,  4 ,  7]，第一 趟完成之后最大数7跑到列表最后一位了。</p>\n\n<p style=\"text-indent:50px;\">第二趟： 还是从第一位开始比较，1小于2顺序不变，比较第二位和第三位2 小于3依然不变，比较第三位3大于0交换位 置， 此时列表变为[1,  2,  0,   3,   6,  5,  4 ,  7]，这一趟排序完成之后列表最终变为[1,  2,  0,   3,  5,  4,   6,  7]</p>\n\n<p style=\"text-indent:50px;\">冒泡排序的思想还是比较简单的，只是反复不断的比较相邻位置大小，并作交换，不再把每一步都交代明白了，只需重复上述的操作即可实现，最终裂变会变为[0,1,2,3,4,5,6,7],也就达到我们的排序目的了<br />\n    </p>\n\n<h3>代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def bubble_sort(nums):\n    for i in range(len(nums) - 1):  # i表示第几趟\n        for j in range(len(nums) - i - 1):  # j表示是第几个元素在比较\n            if nums[j] &gt; nums[j + 1]:  # 如果大于则交换位置\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n                print(nums)\n    return nums\n\n\nbubble_sort([2, 1, 3, 0, 7, 6, 5, 4])\n\n# [1, 2, 3, 0, 7, 6, 5, 4]\n# [1, 2, 0, 3, 7, 6, 5, 4]\n# [1, 2, 0, 3, 6, 7, 5, 4]\n# [1, 2, 0, 3, 6, 5, 7, 4]\n# [1, 2, 0, 3, 6, 5, 4, 7]\n# [1, 0, 2, 3, 6, 5, 4, 7]\n# [1, 0, 2, 3, 5, 6, 4, 7]\n# [1, 0, 2, 3, 5, 4, 6, 7]\n# [0, 1, 2, 3, 5, 4, 6, 7]\n# [0, 1, 2, 3, 4, 5, 6, 7]</code></pre>\n\n<h3>简单优化：   </h3>\n\n<p style=\"text-indent:50px;\">可以知道的是，如果列表是无序的，那么一趟排序的结果必然最少有一次交换，那么反过来想一下，如果一次完整的一趟没有交换任何位置，那么是不是就表明这个列表已经是有序的呢？按照这个思路我们来改进一下上面的代码。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def bubble_sort(nums):\n    for i in range(len(nums) - 1):  # i表示第几趟\n        flag = False  # 是否发生交换的标志位\n        for j in range(len(nums) - i - 1):  # j表示是第几个元素在比较\n            if nums[j] &gt; nums[j + 1]:  # 如果大于则交换位置\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n                flag = True\n        if not flag:  # 一趟排序完成没有发生交换直接返回\n            return nums     \n    return nums</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<h3>冒泡排序思路：</h3>\n\n<p style=\"text-indent:50px;\">列表中的每两个相邻的数，如果前面比后面的大，则交换这两个数。直到列表变为有序的时候为止，例如下面这个列表<br />\n           [ 2,  1,  3,  0,  7,  6,  5,  4]</p>\n\n<p style=\"text-indent:50px;\">第一趟：<br />\n                  第一步：列表的第一位和第二位比较：如果第一位大于第二位，则交换两者位置。由于2大于1，所以此时列表 为：[1,  2,  3,  0,  7,  6,  5,  4]<br />\n                  第二步：再比较第二位和第三位，重复上面的操作，第一趟排序完成之后列表变为 [1,  2,  3,  0,   6,  5,  4 ,  7]，第一 趟完成之后最大数7跑到列表最后一位了。</p>\n\n<p style=\"text-indent:50px;\">第二趟： 还是从第一位开始比较，1小于2顺序不变，比较第二位和第三位2 小于3依然不变，比较第三位3大于0交换位 置， 此时列表变为[1,  2,  0,   3,   6,  5,  4 ,  7]，这一趟排序完成之后列表最终变为[1,  2,  0,   3,  5,  4,   6,  7]</p>\n\n<p style=\"text-indent:50px;\">冒泡排序的思想还是比较简单的，只是反复不断的比较相邻位置大小，并作交换，不再把每一步都交代明白了，只需重复上述的操作即可实现，最终裂变会变为[0,1,2,3,4,5,6,7],也就达到我们的排序目的了<br />\n    </p>\n\n<h3>代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def bubble_sort(nums):\n    for i in range(len(nums) - 1):  # i表示第几趟\n        for j in range(len(nums) - i - 1):  # j表示是第几个元素在比较\n            if nums[j] &gt; nums[j + 1]:  # 如果大于则交换位置\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n                print(nums)\n    return nums\n\n\nbubble_sort([2, 1, 3, 0, 7, 6, 5, 4])\n\n# [1, 2, 3, 0, 7, 6, 5, 4]\n# [1, 2, 0, 3, 7, 6, 5, 4]\n# [1, 2, 0, 3, 6, 7, 5, 4]\n# [1, 2, 0, 3, 6, 5, 7, 4]\n# [1, 2, 0, 3, 6, 5, 4, 7]\n# [1, 0, 2, 3, 6, 5, 4, 7]\n# [1, 0, 2, 3, 5, 6, 4, 7]\n# [1, 0, 2, 3, 5, 4, 6, 7]\n# [0, 1, 2, 3, 5, 4, 6, 7]\n# [0, 1, 2, 3, 4, 5, 6, 7]</code></pre>\n\n<h3>简单优化：   </h3>\n\n<p style=\"text-indent:50px;\">可以知道的是，如果列表是无序的，那么一趟排序的结果必然最少有一次交换，那么反过来想一下，如果一次完整的一趟没有交换任何位置，那么是不是就表明这个列表已经是有序的呢？按照这个思路我们来改进一下上面的代码。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def bubble_sort(nums):\n    for i in range(len(nums) - 1):  # i表示第几趟\n        flag = False  # 是否发生交换的标志位\n        for j in range(len(nums) - i - 1):  # j表示是第几个元素在比较\n            if nums[j] &gt; nums[j + 1]:  # 如果大于则交换位置\n                nums[j], nums[j + 1] = nums[j + 1], nums[j]\n                flag = True\n        if not flag:  # 一趟排序完成没有发生交换直接返回\n            return nums     \n    return nums</code></pre>\n\n<p> </p>"},{"_content":"<p style=\"text-indent:50px;\">回来更新了，先说明一下，这个项目没有烂尾，没有烂尾，没有烂尾，第一版其实已经做完几个月了，后来想实现小程序端的部分功能，最后结果就是导致小程序和web两个的接口不兼容，而且第一次设计的时候有很多地方没有设计好，所以又推翻重做了，在这一版本中，会对接入设备的订阅和发布做出严格的限制（无法订阅除系统topic之外的消息，无法发布没有注册的消息），但是为了实现部分设备之间的通信会设置一个自组网络，可将自己的设备添加到这个网络中，在这个网络中进行通信。废话不多说进入正题。</p>\n\n<h3 style=\"text-indent:50px;\">Models</h3>\n\n<p style=\"text-indent:50px;\">首先需要建立表来存储用户保存的指令内容，这里还是用django的models创建，和user、device表是一对多的关联，其中device_id 会作为消息的topic，所以设备想要接收消息需要订阅device_id的topic</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django.db import models\n\nclass CMD(models.Model):\n\n    name = models.CharField(max_length=32, null=False)  # 指令名称\n    cmd_id = models.IntegerField(unique=True, null=False, db_index=True)  # 指令ID\n    payload = models.CharField(max_length=32, null=False)  # 消息内容\n    qos = models.IntegerField(default=0,choices=[(0, 0), (1, 1), (2, 2),])  # 消息质量\n    ctime = models.DateTimeField(auto_now_add=True)  # 创建时间\n    token = models.CharField(max_length=64, null=False)  # 鉴权信息\n    introduce = models.TextField(null=True)  # 指令介绍\n    user = models.ForeignKey('user.UserInfo', to_field='uid', on_delete=models.CASCADE)  # 用户ID\n    device_id = models.ForeignKey('device.Device', to_field='did', on_delete=None)  # 指令接收的设备ID（指令的消息头topic）\n\n    class Meta:\n        db_table = 'quick_cmd'</code></pre>\n\n<h3 style=\"text-indent:50px;\">获取快捷指令</h3>\n\n<p style=\"text-indent:50px;\">使用了rest_framework做了全局的认证，request.user就是认证通过后返回的user_id，返回的数据格式为：{'code':0,'msg':'', 'data':[ {指令1}, {指令2}]}</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class CMDInfo(APIView):\n    \"\"\"\n    快捷指令信息\n    \"\"\"\n\n    @staticmethod\n    def get(request, *args):\n        \"\"\"\n        获取指令信息（全部）\n        :param request: \n        :param args: 指定cmd_id 获取单个信息\n        :return: json\n        \"\"\"\n        res = {'code': 0, 'msg': '', 'data': []}\n        try:\n            if not args:\n                cmd_obj = CMD.objects.filter(user_id= request.user).all()\n            else:\n                cmd_obj = CMD.objects.filter(cmd_id=args[0]).all()\n            for i in cmd_obj:\n                res['data'].append(model_to_dict(i))\n        except Exception as e:\n            res['code'] = 1\n            res['msg'] = e.__repr__()\n        return JsonResponse(res)</code></pre>\n\n<h3 style=\"text-indent:50px;\">展示指令标签</h3>\n\n<p style=\"text-indent:50px;\">以小程序端为例：在onLoad函数里请求后台接口，然后在wxml将数据渲染出来，这里使用了iview Weapp的组件</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">// .js文件\n\nonLoad: function(options) {\n    api.cmdInfo((res) =&gt; {\n      $Toast.hide()\n      if (res.data.code === 0) {\n        //生成随机的颜色\n        var tagsinfo = res.data.data\n        for (var i = 0; i &lt; tagsinfo.length; i++){\n          tagsinfo[i].color = this.data.color[Math.floor(Math.random() * 5)]\n        }  \n        this.setData({\n          quickCMD: tagsinfo\n        })\n      }\n    })\n  },\n\n\n// .wxml文件\n\n  &lt;view class='tags-pannel'&gt;\n    快捷指令\n    &lt;view class='edit'&gt;编辑&lt;/view&gt;\n    &lt;view wx:if='{{quickCMD.length&gt;0}}' style=\"padding-top:20px\"&gt;\n      &lt;i-tag class=\"tags\" color=\"{{item.color}}\" data-cmd=\"{{item}}\" bindtap=\"quickeSend\" wx:for=\"{{quickCMD}}\" wx:key='{{index}}'&gt;\n        {{item.name}}\n      &lt;/i-tag&gt;\n    &lt;/view&gt;\n    &lt;view wx:else&gt;\n      &lt;no-data title='未找到已经保存快捷指令！' /&gt;\n    &lt;/view&gt;\n  &lt;/view&gt;</code></pre>\n\n<h3 style=\"text-indent:50px;\">发送指令</h3>\n\n<p style=\"text-indent:50px;\">在wxml文件中绑定了点击事件：quickSend事件，通过target.dataset来传递参数，并将需要用到的数据转换为键值对类型，传给后台接口。</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">quickSend: function(e) {\n    let data = {\n      'topic': e.target.dataset.cmd.device_id,\n      'qos': e.target.dataset.cmd.qos,\n      'payload': e.target.dataset.cmd.payload\n    }\n    api.sendCmd(data,(res)=&gt;{\n      if (res.data.code === 0) {\n        $Toast({\n          content: '发送成功',\n          type: 'success',\n          duration: 1\n        });\n      } else{\n        $Toast({\n          content: '发送失败！',\n          type: 'error',\n          duration: 1\n        });\n      }\n    })\n  },</code></pre>\n\n<p style=\"text-indent:50px;\">后端接收发送过来的data还需要对数据格式进行验证，这里使用了django 的forms实现</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django import forms\nfrom django.core.validators import ValidationError\n\nclass QuickCMDForm(forms.Form):\n    topic = forms.CharField(\n        required=True,  # 是否为空\n        error_messages={\n            'required': 'topic不能为空',\n            'max_length': '用户名长度超过限制'\n        }\n    )\n    payload = forms.CharField(\n        required=True,\n        max_length=32,  # 最长长度\n        error_messages={\n            'required': '消息不能为空',\n            'max_length': '消息报文超过长度限制'\n        }\n    )\n    qos = forms.IntegerField(\n        required=True,\n        error_messages={\n            'required': 'QoS不能为空',\n        }\n    )\n\n    # 自定义校验\n    # 检查QoS值是否正确\n    def clean_qos(self):\n        qos = self.cleaned_data['qos']\n        is_exits = True if qos in [0,1,2] else False\n        if not is_exits:\n            raise ValidationError('QoS设置错误')\n        return qos</code></pre>\n\n<p style=\"text-indent:50px;\">对应的view当验证通过之后，还需要对数据进行处理，QoS要为int类型，topic和payload都是str类型的，以免EMQ接收请求失败，再通过HTTP请求EMQ的API实现指令的下发。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class SendCMD(APIView):\n    \"\"\"\n    发送指令\n    \"\"\"\n    parser_classes = [JSONParser, FormParser]\n    @staticmethod\n    def post(request):\n        print(request.data)\n        cmd_form = QuickCMDForm(request.data)\n        if cmd_form.is_valid():  # 检查消息格式是否正确\n            try:\n                data = {\n                    'topic': str(request.data.get('topic')),\n                    'payload': str(request.data.get('payload')),\n                    'qos': int(request.data.get('qos'))  # qos必须为整数\n                }\n                data = json.dumps(data)  # Dict转Json\n                print(data)\n                auth = HTTPBasicAuth(settings.MQTT_USER['username'], settings.MQTT_USER['password'])  # basicAuth认证\n                recv = requests.post(url=settings.BASE_EMQ_URL+\"/api/v2/mqtt/publish\" ,auth=auth, data=data)\n                if recv.status_code == 200:\n                    return JsonResponse(recv.json())\n                    # return json.loads(res.text)\n                else:\n                    return JsonResponse({'code': 1, 'result': []})\n            except Exception as e:\n                return JsonResponse({\"code\": 1, 'msg': e.__repr__(),'result': []})\n        else:\n            res = {'code': 1, 'msg': \"\"}\n            for i, error in cmd_form.errors.items():\n                res['msg'] = error[0]\n            return JsonResponse(res)</code></pre>\n\n<p style=\"text-indent:50px;\">EMQ提供了HTTP请求的方式来发布消息</p>\n\n<p style=\"text-indent:50px;\">API 定义:POST api/v2/mqtt/publish</p>\n\n<p style=\"text-indent:50px;\">请求参数:{ \"topic\" : \"/World\", \"payload\": \"hello\", \"qos\": 0, \"retain\" : false, \"client_id\": \"mqttjs_722b4d845f\" }</p>\n\n<p style=\"text-indent:50px;\">topic 参数必填，其他参数可选。payload 默认值空字符串，qos 默认为 0，retain 默认为 false，client_id 默认为 ‘http’。</p>\n\n<p style=\"text-indent:50px;\">请求成功：{ \"code\": 0, \"result\": [] }</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<h3 style=\"text-indent:50px;\">总结</h3>\n\n<p style=\"text-indent:50px;\">主要流程：获取用户的快捷指令信息---&gt; 页面展示 ---&gt;点击发送---&gt;后台验证消息可靠性---&gt;通过HTTP请求EMQ的API实现发布消息---&gt; 将结果返回给前端显示<br />\n </p>\n\n<p style=\"text-indent:50px;\">最后放几张小程序的截图：</p>\n\n<p style=\"text-indent:50px;\"><img alt=\"\" class=\"has\" height=\"400\" src=\"https://img-blog.csdnimg.cn/201903111501442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /><img alt=\"\" class=\"has\" height=\"400\" src=\"https://img-blog.csdnimg.cn/20190311150238562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /><img alt=\"\" class=\"has\" height=\"400\" src=\"https://img-blog.csdnimg.cn/20190311150301543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n","source":"_posts/blogs-从零开始搭建物联网平台（9）：快捷指令和指令发送.md","raw":"<p style=\"text-indent:50px;\">回来更新了，先说明一下，这个项目没有烂尾，没有烂尾，没有烂尾，第一版其实已经做完几个月了，后来想实现小程序端的部分功能，最后结果就是导致小程序和web两个的接口不兼容，而且第一次设计的时候有很多地方没有设计好，所以又推翻重做了，在这一版本中，会对接入设备的订阅和发布做出严格的限制（无法订阅除系统topic之外的消息，无法发布没有注册的消息），但是为了实现部分设备之间的通信会设置一个自组网络，可将自己的设备添加到这个网络中，在这个网络中进行通信。废话不多说进入正题。</p>\n\n<h3 style=\"text-indent:50px;\">Models</h3>\n\n<p style=\"text-indent:50px;\">首先需要建立表来存储用户保存的指令内容，这里还是用django的models创建，和user、device表是一对多的关联，其中device_id 会作为消息的topic，所以设备想要接收消息需要订阅device_id的topic</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django.db import models\n\nclass CMD(models.Model):\n\n    name = models.CharField(max_length=32, null=False)  # 指令名称\n    cmd_id = models.IntegerField(unique=True, null=False, db_index=True)  # 指令ID\n    payload = models.CharField(max_length=32, null=False)  # 消息内容\n    qos = models.IntegerField(default=0,choices=[(0, 0), (1, 1), (2, 2),])  # 消息质量\n    ctime = models.DateTimeField(auto_now_add=True)  # 创建时间\n    token = models.CharField(max_length=64, null=False)  # 鉴权信息\n    introduce = models.TextField(null=True)  # 指令介绍\n    user = models.ForeignKey('user.UserInfo', to_field='uid', on_delete=models.CASCADE)  # 用户ID\n    device_id = models.ForeignKey('device.Device', to_field='did', on_delete=None)  # 指令接收的设备ID（指令的消息头topic）\n\n    class Meta:\n        db_table = 'quick_cmd'</code></pre>\n\n<h3 style=\"text-indent:50px;\">获取快捷指令</h3>\n\n<p style=\"text-indent:50px;\">使用了rest_framework做了全局的认证，request.user就是认证通过后返回的user_id，返回的数据格式为：{'code':0,'msg':'', 'data':[ {指令1}, {指令2}]}</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class CMDInfo(APIView):\n    \"\"\"\n    快捷指令信息\n    \"\"\"\n\n    @staticmethod\n    def get(request, *args):\n        \"\"\"\n        获取指令信息（全部）\n        :param request: \n        :param args: 指定cmd_id 获取单个信息\n        :return: json\n        \"\"\"\n        res = {'code': 0, 'msg': '', 'data': []}\n        try:\n            if not args:\n                cmd_obj = CMD.objects.filter(user_id= request.user).all()\n            else:\n                cmd_obj = CMD.objects.filter(cmd_id=args[0]).all()\n            for i in cmd_obj:\n                res['data'].append(model_to_dict(i))\n        except Exception as e:\n            res['code'] = 1\n            res['msg'] = e.__repr__()\n        return JsonResponse(res)</code></pre>\n\n<h3 style=\"text-indent:50px;\">展示指令标签</h3>\n\n<p style=\"text-indent:50px;\">以小程序端为例：在onLoad函数里请求后台接口，然后在wxml将数据渲染出来，这里使用了iview Weapp的组件</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">// .js文件\n\nonLoad: function(options) {\n    api.cmdInfo((res) =&gt; {\n      $Toast.hide()\n      if (res.data.code === 0) {\n        //生成随机的颜色\n        var tagsinfo = res.data.data\n        for (var i = 0; i &lt; tagsinfo.length; i++){\n          tagsinfo[i].color = this.data.color[Math.floor(Math.random() * 5)]\n        }  \n        this.setData({\n          quickCMD: tagsinfo\n        })\n      }\n    })\n  },\n\n\n// .wxml文件\n\n  &lt;view class='tags-pannel'&gt;\n    快捷指令\n    &lt;view class='edit'&gt;编辑&lt;/view&gt;\n    &lt;view wx:if='{{quickCMD.length&gt;0}}' style=\"padding-top:20px\"&gt;\n      &lt;i-tag class=\"tags\" color=\"{{item.color}}\" data-cmd=\"{{item}}\" bindtap=\"quickeSend\" wx:for=\"{{quickCMD}}\" wx:key='{{index}}'&gt;\n        {{item.name}}\n      &lt;/i-tag&gt;\n    &lt;/view&gt;\n    &lt;view wx:else&gt;\n      &lt;no-data title='未找到已经保存快捷指令！' /&gt;\n    &lt;/view&gt;\n  &lt;/view&gt;</code></pre>\n\n<h3 style=\"text-indent:50px;\">发送指令</h3>\n\n<p style=\"text-indent:50px;\">在wxml文件中绑定了点击事件：quickSend事件，通过target.dataset来传递参数，并将需要用到的数据转换为键值对类型，传给后台接口。</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">quickSend: function(e) {\n    let data = {\n      'topic': e.target.dataset.cmd.device_id,\n      'qos': e.target.dataset.cmd.qos,\n      'payload': e.target.dataset.cmd.payload\n    }\n    api.sendCmd(data,(res)=&gt;{\n      if (res.data.code === 0) {\n        $Toast({\n          content: '发送成功',\n          type: 'success',\n          duration: 1\n        });\n      } else{\n        $Toast({\n          content: '发送失败！',\n          type: 'error',\n          duration: 1\n        });\n      }\n    })\n  },</code></pre>\n\n<p style=\"text-indent:50px;\">后端接收发送过来的data还需要对数据格式进行验证，这里使用了django 的forms实现</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django import forms\nfrom django.core.validators import ValidationError\n\nclass QuickCMDForm(forms.Form):\n    topic = forms.CharField(\n        required=True,  # 是否为空\n        error_messages={\n            'required': 'topic不能为空',\n            'max_length': '用户名长度超过限制'\n        }\n    )\n    payload = forms.CharField(\n        required=True,\n        max_length=32,  # 最长长度\n        error_messages={\n            'required': '消息不能为空',\n            'max_length': '消息报文超过长度限制'\n        }\n    )\n    qos = forms.IntegerField(\n        required=True,\n        error_messages={\n            'required': 'QoS不能为空',\n        }\n    )\n\n    # 自定义校验\n    # 检查QoS值是否正确\n    def clean_qos(self):\n        qos = self.cleaned_data['qos']\n        is_exits = True if qos in [0,1,2] else False\n        if not is_exits:\n            raise ValidationError('QoS设置错误')\n        return qos</code></pre>\n\n<p style=\"text-indent:50px;\">对应的view当验证通过之后，还需要对数据进行处理，QoS要为int类型，topic和payload都是str类型的，以免EMQ接收请求失败，再通过HTTP请求EMQ的API实现指令的下发。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class SendCMD(APIView):\n    \"\"\"\n    发送指令\n    \"\"\"\n    parser_classes = [JSONParser, FormParser]\n    @staticmethod\n    def post(request):\n        print(request.data)\n        cmd_form = QuickCMDForm(request.data)\n        if cmd_form.is_valid():  # 检查消息格式是否正确\n            try:\n                data = {\n                    'topic': str(request.data.get('topic')),\n                    'payload': str(request.data.get('payload')),\n                    'qos': int(request.data.get('qos'))  # qos必须为整数\n                }\n                data = json.dumps(data)  # Dict转Json\n                print(data)\n                auth = HTTPBasicAuth(settings.MQTT_USER['username'], settings.MQTT_USER['password'])  # basicAuth认证\n                recv = requests.post(url=settings.BASE_EMQ_URL+\"/api/v2/mqtt/publish\" ,auth=auth, data=data)\n                if recv.status_code == 200:\n                    return JsonResponse(recv.json())\n                    # return json.loads(res.text)\n                else:\n                    return JsonResponse({'code': 1, 'result': []})\n            except Exception as e:\n                return JsonResponse({\"code\": 1, 'msg': e.__repr__(),'result': []})\n        else:\n            res = {'code': 1, 'msg': \"\"}\n            for i, error in cmd_form.errors.items():\n                res['msg'] = error[0]\n            return JsonResponse(res)</code></pre>\n\n<p style=\"text-indent:50px;\">EMQ提供了HTTP请求的方式来发布消息</p>\n\n<p style=\"text-indent:50px;\">API 定义:POST api/v2/mqtt/publish</p>\n\n<p style=\"text-indent:50px;\">请求参数:{ \"topic\" : \"/World\", \"payload\": \"hello\", \"qos\": 0, \"retain\" : false, \"client_id\": \"mqttjs_722b4d845f\" }</p>\n\n<p style=\"text-indent:50px;\">topic 参数必填，其他参数可选。payload 默认值空字符串，qos 默认为 0，retain 默认为 false，client_id 默认为 ‘http’。</p>\n\n<p style=\"text-indent:50px;\">请求成功：{ \"code\": 0, \"result\": [] }</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<h3 style=\"text-indent:50px;\">总结</h3>\n\n<p style=\"text-indent:50px;\">主要流程：获取用户的快捷指令信息---&gt; 页面展示 ---&gt;点击发送---&gt;后台验证消息可靠性---&gt;通过HTTP请求EMQ的API实现发布消息---&gt; 将结果返回给前端显示<br />\n </p>\n\n<p style=\"text-indent:50px;\">最后放几张小程序的截图：</p>\n\n<p style=\"text-indent:50px;\"><img alt=\"\" class=\"has\" height=\"400\" src=\"https://img-blog.csdnimg.cn/201903111501442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /><img alt=\"\" class=\"has\" height=\"400\" src=\"https://img-blog.csdnimg.cn/20190311150238562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /><img alt=\"\" class=\"has\" height=\"400\" src=\"https://img-blog.csdnimg.cn/20190311150301543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n","slug":"blogs-从零开始搭建物联网平台（9）：快捷指令和指令发送","published":1,"date":"2022-03-16T17:00:42.329Z","updated":"2022-03-16T17:05:31.517Z","_id":"cl0v6keq0000ayms44pmrabs3","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p style=\"text-indent:50px;\">回来更新了，先说明一下，这个项目没有烂尾，没有烂尾，没有烂尾，第一版其实已经做完几个月了，后来想实现小程序端的部分功能，最后结果就是导致小程序和web两个的接口不兼容，而且第一次设计的时候有很多地方没有设计好，所以又推翻重做了，在这一版本中，会对接入设备的订阅和发布做出严格的限制（无法订阅除系统topic之外的消息，无法发布没有注册的消息），但是为了实现部分设备之间的通信会设置一个自组网络，可将自己的设备添加到这个网络中，在这个网络中进行通信。废话不多说进入正题。</p>\n\n<h3 style=\"text-indent:50px;\">Models</h3>\n\n<p style=\"text-indent:50px;\">首先需要建立表来存储用户保存的指令内容，这里还是用django的models创建，和user、device表是一对多的关联，其中device_id 会作为消息的topic，所以设备想要接收消息需要订阅device_id的topic</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django.db import models\n\nclass CMD(models.Model):\n\n    name = models.CharField(max_length=32, null=False)  # 指令名称\n    cmd_id = models.IntegerField(unique=True, null=False, db_index=True)  # 指令ID\n    payload = models.CharField(max_length=32, null=False)  # 消息内容\n    qos = models.IntegerField(default=0,choices=[(0, 0), (1, 1), (2, 2),])  # 消息质量\n    ctime = models.DateTimeField(auto_now_add=True)  # 创建时间\n    token = models.CharField(max_length=64, null=False)  # 鉴权信息\n    introduce = models.TextField(null=True)  # 指令介绍\n    user = models.ForeignKey('user.UserInfo', to_field='uid', on_delete=models.CASCADE)  # 用户ID\n    device_id = models.ForeignKey('device.Device', to_field='did', on_delete=None)  # 指令接收的设备ID（指令的消息头topic）\n\n    class Meta:\n        db_table = 'quick_cmd'</code></pre>\n\n<h3 style=\"text-indent:50px;\">获取快捷指令</h3>\n\n<p style=\"text-indent:50px;\">使用了rest_framework做了全局的认证，request.user就是认证通过后返回的user_id，返回的数据格式为：{'code':0,'msg':'', 'data':[ {指令1}, {指令2}]}</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class CMDInfo(APIView):\n    \"\"\"\n    快捷指令信息\n    \"\"\"\n\n    @staticmethod\n    def get(request, *args):\n        \"\"\"\n        获取指令信息（全部）\n        :param request: \n        :param args: 指定cmd_id 获取单个信息\n        :return: json\n        \"\"\"\n        res = &#123;'code': 0, 'msg': '', 'data': []&#125;\n        try:\n            if not args:\n                cmd_obj = CMD.objects.filter(user_id= request.user).all()\n            else:\n                cmd_obj = CMD.objects.filter(cmd_id=args[0]).all()\n            for i in cmd_obj:\n                res['data'].append(model_to_dict(i))\n        except Exception as e:\n            res['code'] = 1\n            res['msg'] = e.__repr__()\n        return JsonResponse(res)</code></pre>\n\n<h3 style=\"text-indent:50px;\">展示指令标签</h3>\n\n<p style=\"text-indent:50px;\">以小程序端为例：在onLoad函数里请求后台接口，然后在wxml将数据渲染出来，这里使用了iview Weapp的组件</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">// .js文件\n\nonLoad: function(options) &#123;\n    api.cmdInfo((res) =&gt; &#123;\n      $Toast.hide()\n      if (res.data.code === 0) &#123;\n        //生成随机的颜色\n        var tagsinfo = res.data.data\n        for (var i = 0; i &lt; tagsinfo.length; i++)&#123;\n          tagsinfo[i].color = this.data.color[Math.floor(Math.random() * 5)]\n        &#125;  \n        this.setData(&#123;\n          quickCMD: tagsinfo\n        &#125;)\n      &#125;\n    &#125;)\n  &#125;,\n\n\n// .wxml文件\n\n  &lt;view class='tags-pannel'&gt;\n    快捷指令\n    &lt;view class='edit'&gt;编辑&lt;/view&gt;\n    &lt;view wx:if='&#123;&#123;quickCMD.length&gt;0&#125;&#125;' style=\"padding-top:20px\"&gt;\n      &lt;i-tag class=\"tags\" color=\"&#123;&#123;item.color&#125;&#125;\" data-cmd=\"&#123;&#123;item&#125;&#125;\" bindtap=\"quickeSend\" wx:for=\"&#123;&#123;quickCMD&#125;&#125;\" wx:key='&#123;&#123;index&#125;&#125;'&gt;\n        &#123;&#123;item.name&#125;&#125;\n      &lt;/i-tag&gt;\n    &lt;/view&gt;\n    &lt;view wx:else&gt;\n      &lt;no-data title='未找到已经保存快捷指令！' /&gt;\n    &lt;/view&gt;\n  &lt;/view&gt;</code></pre>\n\n<h3 style=\"text-indent:50px;\">发送指令</h3>\n\n<p style=\"text-indent:50px;\">在wxml文件中绑定了点击事件：quickSend事件，通过target.dataset来传递参数，并将需要用到的数据转换为键值对类型，传给后台接口。</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">quickSend: function(e) &#123;\n    let data = &#123;\n      'topic': e.target.dataset.cmd.device_id,\n      'qos': e.target.dataset.cmd.qos,\n      'payload': e.target.dataset.cmd.payload\n    &#125;\n    api.sendCmd(data,(res)=&gt;&#123;\n      if (res.data.code === 0) &#123;\n        $Toast(&#123;\n          content: '发送成功',\n          type: 'success',\n          duration: 1\n        &#125;);\n      &#125; else&#123;\n        $Toast(&#123;\n          content: '发送失败！',\n          type: 'error',\n          duration: 1\n        &#125;);\n      &#125;\n    &#125;)\n  &#125;,</code></pre>\n\n<p style=\"text-indent:50px;\">后端接收发送过来的data还需要对数据格式进行验证，这里使用了django 的forms实现</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django import forms\nfrom django.core.validators import ValidationError\n\nclass QuickCMDForm(forms.Form):\n    topic = forms.CharField(\n        required=True,  # 是否为空\n        error_messages=&#123;\n            'required': 'topic不能为空',\n            'max_length': '用户名长度超过限制'\n        &#125;\n    )\n    payload = forms.CharField(\n        required=True,\n        max_length=32,  # 最长长度\n        error_messages=&#123;\n            'required': '消息不能为空',\n            'max_length': '消息报文超过长度限制'\n        &#125;\n    )\n    qos = forms.IntegerField(\n        required=True,\n        error_messages=&#123;\n            'required': 'QoS不能为空',\n        &#125;\n    )\n\n    # 自定义校验\n    # 检查QoS值是否正确\n    def clean_qos(self):\n        qos = self.cleaned_data['qos']\n        is_exits = True if qos in [0,1,2] else False\n        if not is_exits:\n            raise ValidationError('QoS设置错误')\n        return qos</code></pre>\n\n<p style=\"text-indent:50px;\">对应的view当验证通过之后，还需要对数据进行处理，QoS要为int类型，topic和payload都是str类型的，以免EMQ接收请求失败，再通过HTTP请求EMQ的API实现指令的下发。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class SendCMD(APIView):\n    \"\"\"\n    发送指令\n    \"\"\"\n    parser_classes = [JSONParser, FormParser]\n    @staticmethod\n    def post(request):\n        print(request.data)\n        cmd_form = QuickCMDForm(request.data)\n        if cmd_form.is_valid():  # 检查消息格式是否正确\n            try:\n                data = &#123;\n                    'topic': str(request.data.get('topic')),\n                    'payload': str(request.data.get('payload')),\n                    'qos': int(request.data.get('qos'))  # qos必须为整数\n                &#125;\n                data = json.dumps(data)  # Dict转Json\n                print(data)\n                auth = HTTPBasicAuth(settings.MQTT_USER['username'], settings.MQTT_USER['password'])  # basicAuth认证\n                recv = requests.post(url=settings.BASE_EMQ_URL+\"/api/v2/mqtt/publish\" ,auth=auth, data=data)\n                if recv.status_code == 200:\n                    return JsonResponse(recv.json())\n                    # return json.loads(res.text)\n                else:\n                    return JsonResponse(&#123;'code': 1, 'result': []&#125;)\n            except Exception as e:\n                return JsonResponse(&#123;\"code\": 1, 'msg': e.__repr__(),'result': []&#125;)\n        else:\n            res = &#123;'code': 1, 'msg': \"\"&#125;\n            for i, error in cmd_form.errors.items():\n                res['msg'] = error[0]\n            return JsonResponse(res)</code></pre>\n\n<p style=\"text-indent:50px;\">EMQ提供了HTTP请求的方式来发布消息</p>\n\n<p style=\"text-indent:50px;\">API 定义:POST api/v2/mqtt/publish</p>\n\n<p style=\"text-indent:50px;\">请求参数:{ \"topic\" : \"/World\", \"payload\": \"hello\", \"qos\": 0, \"retain\" : false, \"client_id\": \"mqttjs_722b4d845f\" }</p>\n\n<p style=\"text-indent:50px;\">topic 参数必填，其他参数可选。payload 默认值空字符串，qos 默认为 0，retain 默认为 false，client_id 默认为 ‘http’。</p>\n\n<p style=\"text-indent:50px;\">请求成功：{ \"code\": 0, \"result\": [] }</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<h3 style=\"text-indent:50px;\">总结</h3>\n\n<p style=\"text-indent:50px;\">主要流程：获取用户的快捷指令信息---&gt; 页面展示 ---&gt;点击发送---&gt;后台验证消息可靠性---&gt;通过HTTP请求EMQ的API实现发布消息---&gt; 将结果返回给前端显示<br />\n </p>\n\n<p style=\"text-indent:50px;\">最后放几张小程序的截图：</p>\n\n<p style=\"text-indent:50px;\"><img alt=\"\" class=\"has\" height=\"400\" src=\"https://img-blog.csdnimg.cn/201903111501442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /><img alt=\"\" class=\"has\" height=\"400\" src=\"https://img-blog.csdnimg.cn/20190311150238562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /><img alt=\"\" class=\"has\" height=\"400\" src=\"https://img-blog.csdnimg.cn/20190311150301543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n","site":{"data":{}},"excerpt":"","more":"<p style=\"text-indent:50px;\">回来更新了，先说明一下，这个项目没有烂尾，没有烂尾，没有烂尾，第一版其实已经做完几个月了，后来想实现小程序端的部分功能，最后结果就是导致小程序和web两个的接口不兼容，而且第一次设计的时候有很多地方没有设计好，所以又推翻重做了，在这一版本中，会对接入设备的订阅和发布做出严格的限制（无法订阅除系统topic之外的消息，无法发布没有注册的消息），但是为了实现部分设备之间的通信会设置一个自组网络，可将自己的设备添加到这个网络中，在这个网络中进行通信。废话不多说进入正题。</p>\n\n<h3 style=\"text-indent:50px;\">Models</h3>\n\n<p style=\"text-indent:50px;\">首先需要建立表来存储用户保存的指令内容，这里还是用django的models创建，和user、device表是一对多的关联，其中device_id 会作为消息的topic，所以设备想要接收消息需要订阅device_id的topic</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django.db import models\n\nclass CMD(models.Model):\n\n    name = models.CharField(max_length=32, null=False)  # 指令名称\n    cmd_id = models.IntegerField(unique=True, null=False, db_index=True)  # 指令ID\n    payload = models.CharField(max_length=32, null=False)  # 消息内容\n    qos = models.IntegerField(default=0,choices=[(0, 0), (1, 1), (2, 2),])  # 消息质量\n    ctime = models.DateTimeField(auto_now_add=True)  # 创建时间\n    token = models.CharField(max_length=64, null=False)  # 鉴权信息\n    introduce = models.TextField(null=True)  # 指令介绍\n    user = models.ForeignKey('user.UserInfo', to_field='uid', on_delete=models.CASCADE)  # 用户ID\n    device_id = models.ForeignKey('device.Device', to_field='did', on_delete=None)  # 指令接收的设备ID（指令的消息头topic）\n\n    class Meta:\n        db_table = 'quick_cmd'</code></pre>\n\n<h3 style=\"text-indent:50px;\">获取快捷指令</h3>\n\n<p style=\"text-indent:50px;\">使用了rest_framework做了全局的认证，request.user就是认证通过后返回的user_id，返回的数据格式为：{'code':0,'msg':'', 'data':[ {指令1}, {指令2}]}</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class CMDInfo(APIView):\n    \"\"\"\n    快捷指令信息\n    \"\"\"\n\n    @staticmethod\n    def get(request, *args):\n        \"\"\"\n        获取指令信息（全部）\n        :param request: \n        :param args: 指定cmd_id 获取单个信息\n        :return: json\n        \"\"\"\n        res = &#123;'code': 0, 'msg': '', 'data': []&#125;\n        try:\n            if not args:\n                cmd_obj = CMD.objects.filter(user_id= request.user).all()\n            else:\n                cmd_obj = CMD.objects.filter(cmd_id=args[0]).all()\n            for i in cmd_obj:\n                res['data'].append(model_to_dict(i))\n        except Exception as e:\n            res['code'] = 1\n            res['msg'] = e.__repr__()\n        return JsonResponse(res)</code></pre>\n\n<h3 style=\"text-indent:50px;\">展示指令标签</h3>\n\n<p style=\"text-indent:50px;\">以小程序端为例：在onLoad函数里请求后台接口，然后在wxml将数据渲染出来，这里使用了iview Weapp的组件</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">// .js文件\n\nonLoad: function(options) &#123;\n    api.cmdInfo((res) =&gt; &#123;\n      $Toast.hide()\n      if (res.data.code === 0) &#123;\n        //生成随机的颜色\n        var tagsinfo = res.data.data\n        for (var i = 0; i &lt; tagsinfo.length; i++)&#123;\n          tagsinfo[i].color = this.data.color[Math.floor(Math.random() * 5)]\n        &#125;  \n        this.setData(&#123;\n          quickCMD: tagsinfo\n        &#125;)\n      &#125;\n    &#125;)\n  &#125;,\n\n\n// .wxml文件\n\n  &lt;view class='tags-pannel'&gt;\n    快捷指令\n    &lt;view class='edit'&gt;编辑&lt;/view&gt;\n    &lt;view wx:if='&#123;&#123;quickCMD.length&gt;0&#125;&#125;' style=\"padding-top:20px\"&gt;\n      &lt;i-tag class=\"tags\" color=\"&#123;&#123;item.color&#125;&#125;\" data-cmd=\"&#123;&#123;item&#125;&#125;\" bindtap=\"quickeSend\" wx:for=\"&#123;&#123;quickCMD&#125;&#125;\" wx:key='&#123;&#123;index&#125;&#125;'&gt;\n        &#123;&#123;item.name&#125;&#125;\n      &lt;/i-tag&gt;\n    &lt;/view&gt;\n    &lt;view wx:else&gt;\n      &lt;no-data title='未找到已经保存快捷指令！' /&gt;\n    &lt;/view&gt;\n  &lt;/view&gt;</code></pre>\n\n<h3 style=\"text-indent:50px;\">发送指令</h3>\n\n<p style=\"text-indent:50px;\">在wxml文件中绑定了点击事件：quickSend事件，通过target.dataset来传递参数，并将需要用到的数据转换为键值对类型，传给后台接口。</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">quickSend: function(e) &#123;\n    let data = &#123;\n      'topic': e.target.dataset.cmd.device_id,\n      'qos': e.target.dataset.cmd.qos,\n      'payload': e.target.dataset.cmd.payload\n    &#125;\n    api.sendCmd(data,(res)=&gt;&#123;\n      if (res.data.code === 0) &#123;\n        $Toast(&#123;\n          content: '发送成功',\n          type: 'success',\n          duration: 1\n        &#125;);\n      &#125; else&#123;\n        $Toast(&#123;\n          content: '发送失败！',\n          type: 'error',\n          duration: 1\n        &#125;);\n      &#125;\n    &#125;)\n  &#125;,</code></pre>\n\n<p style=\"text-indent:50px;\">后端接收发送过来的data还需要对数据格式进行验证，这里使用了django 的forms实现</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django import forms\nfrom django.core.validators import ValidationError\n\nclass QuickCMDForm(forms.Form):\n    topic = forms.CharField(\n        required=True,  # 是否为空\n        error_messages=&#123;\n            'required': 'topic不能为空',\n            'max_length': '用户名长度超过限制'\n        &#125;\n    )\n    payload = forms.CharField(\n        required=True,\n        max_length=32,  # 最长长度\n        error_messages=&#123;\n            'required': '消息不能为空',\n            'max_length': '消息报文超过长度限制'\n        &#125;\n    )\n    qos = forms.IntegerField(\n        required=True,\n        error_messages=&#123;\n            'required': 'QoS不能为空',\n        &#125;\n    )\n\n    # 自定义校验\n    # 检查QoS值是否正确\n    def clean_qos(self):\n        qos = self.cleaned_data['qos']\n        is_exits = True if qos in [0,1,2] else False\n        if not is_exits:\n            raise ValidationError('QoS设置错误')\n        return qos</code></pre>\n\n<p style=\"text-indent:50px;\">对应的view当验证通过之后，还需要对数据进行处理，QoS要为int类型，topic和payload都是str类型的，以免EMQ接收请求失败，再通过HTTP请求EMQ的API实现指令的下发。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class SendCMD(APIView):\n    \"\"\"\n    发送指令\n    \"\"\"\n    parser_classes = [JSONParser, FormParser]\n    @staticmethod\n    def post(request):\n        print(request.data)\n        cmd_form = QuickCMDForm(request.data)\n        if cmd_form.is_valid():  # 检查消息格式是否正确\n            try:\n                data = &#123;\n                    'topic': str(request.data.get('topic')),\n                    'payload': str(request.data.get('payload')),\n                    'qos': int(request.data.get('qos'))  # qos必须为整数\n                &#125;\n                data = json.dumps(data)  # Dict转Json\n                print(data)\n                auth = HTTPBasicAuth(settings.MQTT_USER['username'], settings.MQTT_USER['password'])  # basicAuth认证\n                recv = requests.post(url=settings.BASE_EMQ_URL+\"/api/v2/mqtt/publish\" ,auth=auth, data=data)\n                if recv.status_code == 200:\n                    return JsonResponse(recv.json())\n                    # return json.loads(res.text)\n                else:\n                    return JsonResponse(&#123;'code': 1, 'result': []&#125;)\n            except Exception as e:\n                return JsonResponse(&#123;\"code\": 1, 'msg': e.__repr__(),'result': []&#125;)\n        else:\n            res = &#123;'code': 1, 'msg': \"\"&#125;\n            for i, error in cmd_form.errors.items():\n                res['msg'] = error[0]\n            return JsonResponse(res)</code></pre>\n\n<p style=\"text-indent:50px;\">EMQ提供了HTTP请求的方式来发布消息</p>\n\n<p style=\"text-indent:50px;\">API 定义:POST api/v2/mqtt/publish</p>\n\n<p style=\"text-indent:50px;\">请求参数:{ \"topic\" : \"/World\", \"payload\": \"hello\", \"qos\": 0, \"retain\" : false, \"client_id\": \"mqttjs_722b4d845f\" }</p>\n\n<p style=\"text-indent:50px;\">topic 参数必填，其他参数可选。payload 默认值空字符串，qos 默认为 0，retain 默认为 false，client_id 默认为 ‘http’。</p>\n\n<p style=\"text-indent:50px;\">请求成功：{ \"code\": 0, \"result\": [] }</p>\n\n<p style=\"text-indent:50px;\"> </p>\n\n<h3 style=\"text-indent:50px;\">总结</h3>\n\n<p style=\"text-indent:50px;\">主要流程：获取用户的快捷指令信息---&gt; 页面展示 ---&gt;点击发送---&gt;后台验证消息可靠性---&gt;通过HTTP请求EMQ的API实现发布消息---&gt; 将结果返回给前端显示<br />\n </p>\n\n<p style=\"text-indent:50px;\">最后放几张小程序的截图：</p>\n\n<p style=\"text-indent:50px;\"><img alt=\"\" class=\"has\" height=\"400\" src=\"https://img-blog.csdnimg.cn/201903111501442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /><img alt=\"\" class=\"has\" height=\"400\" src=\"https://img-blog.csdnimg.cn/20190311150238562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /><img alt=\"\" class=\"has\" height=\"400\" src=\"https://img-blog.csdnimg.cn/20190311150301543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n"},{"_content":"<h3>算法思路：</h3>\n\n<p>堆：分为大根堆和小根堆<br />\n       大根堆：一棵完全二叉树，满足任意一节点都比其孩子节点大。<br />\n       小根堆：一棵完全二叉树，满足任意一节点都比其孩子节点小。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"237\" src=\"https://img-blog.csdn.net/20181023151845413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"615\" /></p>\n\n<p>堆排序流程： </p>\n\n<ol><li>构造堆</li>\n\t<li>得到堆顶元素，为最大元素</li>\n\t<li>去掉堆顶，将堆的最后一个元素放到堆顶，然后调整重新使堆有序</li>\n\t<li>堆顶元素为第二大的元素</li>\n\t<li>重复第三步直到堆变空</li>\n</ol><p>例如以[4, 5, 3, 6, 1, 2 ]为例：<img alt=\"\" class=\"has\" height=\"519\" src=\"https://img-blog.csdn.net/20181023163153393?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"1062\" /></p>\n\n<p>准备知识：</p>\n\n<p>     在以顺序储存的完全二叉树中，父子节点的关系（下标）：</p>\n\n<ol><li>父节点和左孩子：左孩子下标 = 父节点下标 * 2 + 1</li>\n\t<li>父节点和右孩子：右孩子下标 = 父节点下标 * 2 + 2</li>\n\t<li>子节点和父节点： 父节点下标 = (子节点下标 - 1)  // 2</li>\n\t<li>最后一个非叶子节点：n // 2 -1</li>\n</ol><h3>代码实现：  </h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def sift(nums, low, high):\n    \"\"\"\n    调整堆，使堆有序\n    :param nums: list\n    :param low: 根节点\n    :param high: 尾节点（树的最后一个）\n    :return:\n    \"\"\"\n    temp = nums[low]\n    i = low\n    j = 2 * i + 1\n    while j &lt;= high:  # 当前i位置为叶子节点， j超过high了\n        # 找更大的子节点\n        if j + 1 &lt;= high and nums[j+1] &gt; nums[j]:  #\n            j = j + 1\n        if temp &lt; nums[j]:\n            nums[i] = nums[j]\n            i = j\n            j = 2 * i + 1\n        else:   # temp 大于两个子节点\n            break\n    nums[i] = temp\n\n\ndef heap_sort(nums):\n    # 建堆\n    l = len(nums)\n    for i in range(l//2-1, -1, -1):\n        # i是建堆时要调整的子树的根节点下标\n        sift(nums, i, l-1)\n    for i in range(l - 1, -1, -1):\n        # 当前的high值\n        nums[i], nums[0] = nums[0], nums[i]\n        sift(nums, 0, i-1)</code></pre>\n\n<h3>内置函数：</h3>\n\n<p style=\"text-indent:50px;\">Python内置模块heapq帮我们实现了堆排序，内置函数用的是小根堆，上面的代码是大根堆，差别不大，heapq模块主要包括三个函数:</p>\n\n<ol><li>\n\t<p style=\"text-indent:0;\">heapify(list) 建小根堆   把传入的list变成小根堆</p>\n\t</li>\n\t<li>\n\t<p style=\"text-indent:0;\">heappush(heap_list, item)向已经建好的堆中增加数据</p>\n\t</li>\n\t<li>\n\t<p style=\"text-indent:0;\">heappop(heap_list) 输出小根堆中最小值</p>\n\t</li>\n</ol><pre class=\"has\">\n<code class=\"language-python\">import heapq\n\nnums = [3, 2, 1, 0, 6]\n\nheapq.heapify(nums)\nprint(nums)\n# [0, 2, 1, 3, 6]\nheapq.heappush(nums, 4)\nprint(nums)\n# [0, 2, 1, 3, 6, 4]\nprint(heapq.heappop(nums))\n# 0\nprint(heapq.heappop(nums))\n# 1\nprint(heapq.heappop(nums))\n# 2</code></pre>\n\n<p> </p>","source":"_posts/blogs-常用排序算法：堆排序.md","raw":"<h3>算法思路：</h3>\n\n<p>堆：分为大根堆和小根堆<br />\n       大根堆：一棵完全二叉树，满足任意一节点都比其孩子节点大。<br />\n       小根堆：一棵完全二叉树，满足任意一节点都比其孩子节点小。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"237\" src=\"https://img-blog.csdn.net/20181023151845413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"615\" /></p>\n\n<p>堆排序流程： </p>\n\n<ol><li>构造堆</li>\n\t<li>得到堆顶元素，为最大元素</li>\n\t<li>去掉堆顶，将堆的最后一个元素放到堆顶，然后调整重新使堆有序</li>\n\t<li>堆顶元素为第二大的元素</li>\n\t<li>重复第三步直到堆变空</li>\n</ol><p>例如以[4, 5, 3, 6, 1, 2 ]为例：<img alt=\"\" class=\"has\" height=\"519\" src=\"https://img-blog.csdn.net/20181023163153393?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"1062\" /></p>\n\n<p>准备知识：</p>\n\n<p>     在以顺序储存的完全二叉树中，父子节点的关系（下标）：</p>\n\n<ol><li>父节点和左孩子：左孩子下标 = 父节点下标 * 2 + 1</li>\n\t<li>父节点和右孩子：右孩子下标 = 父节点下标 * 2 + 2</li>\n\t<li>子节点和父节点： 父节点下标 = (子节点下标 - 1)  // 2</li>\n\t<li>最后一个非叶子节点：n // 2 -1</li>\n</ol><h3>代码实现：  </h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def sift(nums, low, high):\n    \"\"\"\n    调整堆，使堆有序\n    :param nums: list\n    :param low: 根节点\n    :param high: 尾节点（树的最后一个）\n    :return:\n    \"\"\"\n    temp = nums[low]\n    i = low\n    j = 2 * i + 1\n    while j &lt;= high:  # 当前i位置为叶子节点， j超过high了\n        # 找更大的子节点\n        if j + 1 &lt;= high and nums[j+1] &gt; nums[j]:  #\n            j = j + 1\n        if temp &lt; nums[j]:\n            nums[i] = nums[j]\n            i = j\n            j = 2 * i + 1\n        else:   # temp 大于两个子节点\n            break\n    nums[i] = temp\n\n\ndef heap_sort(nums):\n    # 建堆\n    l = len(nums)\n    for i in range(l//2-1, -1, -1):\n        # i是建堆时要调整的子树的根节点下标\n        sift(nums, i, l-1)\n    for i in range(l - 1, -1, -1):\n        # 当前的high值\n        nums[i], nums[0] = nums[0], nums[i]\n        sift(nums, 0, i-1)</code></pre>\n\n<h3>内置函数：</h3>\n\n<p style=\"text-indent:50px;\">Python内置模块heapq帮我们实现了堆排序，内置函数用的是小根堆，上面的代码是大根堆，差别不大，heapq模块主要包括三个函数:</p>\n\n<ol><li>\n\t<p style=\"text-indent:0;\">heapify(list) 建小根堆   把传入的list变成小根堆</p>\n\t</li>\n\t<li>\n\t<p style=\"text-indent:0;\">heappush(heap_list, item)向已经建好的堆中增加数据</p>\n\t</li>\n\t<li>\n\t<p style=\"text-indent:0;\">heappop(heap_list) 输出小根堆中最小值</p>\n\t</li>\n</ol><pre class=\"has\">\n<code class=\"language-python\">import heapq\n\nnums = [3, 2, 1, 0, 6]\n\nheapq.heapify(nums)\nprint(nums)\n# [0, 2, 1, 3, 6]\nheapq.heappush(nums, 4)\nprint(nums)\n# [0, 2, 1, 3, 6, 4]\nprint(heapq.heappop(nums))\n# 0\nprint(heapq.heappop(nums))\n# 1\nprint(heapq.heappop(nums))\n# 2</code></pre>\n\n<p> </p>","slug":"blogs-常用排序算法：堆排序","published":1,"date":"2022-03-16T17:01:13.543Z","updated":"2022-03-16T17:06:03.298Z","_id":"cl0v6keq4000byms49mg97sa7","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>算法思路：</h3>\n\n<p>堆：分为大根堆和小根堆<br />\n       大根堆：一棵完全二叉树，满足任意一节点都比其孩子节点大。<br />\n       小根堆：一棵完全二叉树，满足任意一节点都比其孩子节点小。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"237\" src=\"https://img-blog.csdn.net/20181023151845413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"615\" /></p>\n\n<p>堆排序流程： </p>\n\n<ol><li>构造堆</li>\n    <li>得到堆顶元素，为最大元素</li>\n    <li>去掉堆顶，将堆的最后一个元素放到堆顶，然后调整重新使堆有序</li>\n    <li>堆顶元素为第二大的元素</li>\n    <li>重复第三步直到堆变空</li>\n</ol><p>例如以[4, 5, 3, 6, 1, 2 ]为例：<img alt=\"\" class=\"has\" height=\"519\" src=\"https://img-blog.csdn.net/20181023163153393?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"1062\" /></p>\n\n<p>准备知识：</p>\n\n<p>     在以顺序储存的完全二叉树中，父子节点的关系（下标）：</p>\n\n<ol><li>父节点和左孩子：左孩子下标 = 父节点下标 * 2 + 1</li>\n    <li>父节点和右孩子：右孩子下标 = 父节点下标 * 2 + 2</li>\n    <li>子节点和父节点： 父节点下标 = (子节点下标 - 1)  // 2</li>\n    <li>最后一个非叶子节点：n // 2 -1</li>\n</ol><h3>代码实现：  </h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def sift(nums, low, high):\n    \"\"\"\n    调整堆，使堆有序\n    :param nums: list\n    :param low: 根节点\n    :param high: 尾节点（树的最后一个）\n    :return:\n    \"\"\"\n    temp = nums[low]\n    i = low\n    j = 2 * i + 1\n    while j &lt;= high:  # 当前i位置为叶子节点， j超过high了\n        # 找更大的子节点\n        if j + 1 &lt;= high and nums[j+1] &gt; nums[j]:  #\n            j = j + 1\n        if temp &lt; nums[j]:\n            nums[i] = nums[j]\n            i = j\n            j = 2 * i + 1\n        else:   # temp 大于两个子节点\n            break\n    nums[i] = temp\n\n\ndef heap_sort(nums):\n    # 建堆\n    l = len(nums)\n    for i in range(l//2-1, -1, -1):\n        # i是建堆时要调整的子树的根节点下标\n        sift(nums, i, l-1)\n    for i in range(l - 1, -1, -1):\n        # 当前的high值\n        nums[i], nums[0] = nums[0], nums[i]\n        sift(nums, 0, i-1)</code></pre>\n\n<h3>内置函数：</h3>\n\n<p style=\"text-indent:50px;\">Python内置模块heapq帮我们实现了堆排序，内置函数用的是小根堆，上面的代码是大根堆，差别不大，heapq模块主要包括三个函数:</p>\n\n<ol><li>\n    <p style=\"text-indent:0;\">heapify(list) 建小根堆   把传入的list变成小根堆</p>\n    </li>\n    <li>\n    <p style=\"text-indent:0;\">heappush(heap_list, item)向已经建好的堆中增加数据</p>\n    </li>\n    <li>\n    <p style=\"text-indent:0;\">heappop(heap_list) 输出小根堆中最小值</p>\n    </li>\n</ol><pre class=\"has\">\n<code class=\"language-python\">import heapq\n\n<p>nums = [3, 2, 1, 0, 6]</p>\n<p>heapq.heapify(nums)<br>print(nums)</p>\n<h1 id=\"0-2-1-3-6\"><a href=\"#0-2-1-3-6\" class=\"headerlink\" title=\"[0, 2, 1, 3, 6]\"></a>[0, 2, 1, 3, 6]</h1><p>heapq.heappush(nums, 4)<br>print(nums)</p>\n<h1 id=\"0-2-1-3-6-4\"><a href=\"#0-2-1-3-6-4\" class=\"headerlink\" title=\"[0, 2, 1, 3, 6, 4]\"></a>[0, 2, 1, 3, 6, 4]</h1><p>print(heapq.heappop(nums))</p>\n<h1 id=\"0\"><a href=\"#0\" class=\"headerlink\" title=\"0\"></a>0</h1><p>print(heapq.heappop(nums))</p>\n<h1 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h1><p>print(heapq.heappop(nums))</p>\n<h1 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</code></pre></h1><p> </p>","site":{"data":{}},"excerpt":"","more":"<h3>算法思路：</h3>\n\n<p>堆：分为大根堆和小根堆<br />\n       大根堆：一棵完全二叉树，满足任意一节点都比其孩子节点大。<br />\n       小根堆：一棵完全二叉树，满足任意一节点都比其孩子节点小。</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"237\" src=\"https://img-blog.csdn.net/20181023151845413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"615\" /></p>\n\n<p>堆排序流程： </p>\n\n<ol><li>构造堆</li>\n    <li>得到堆顶元素，为最大元素</li>\n    <li>去掉堆顶，将堆的最后一个元素放到堆顶，然后调整重新使堆有序</li>\n    <li>堆顶元素为第二大的元素</li>\n    <li>重复第三步直到堆变空</li>\n</ol><p>例如以[4, 5, 3, 6, 1, 2 ]为例：<img alt=\"\" class=\"has\" height=\"519\" src=\"https://img-blog.csdn.net/20181023163153393?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"1062\" /></p>\n\n<p>准备知识：</p>\n\n<p>     在以顺序储存的完全二叉树中，父子节点的关系（下标）：</p>\n\n<ol><li>父节点和左孩子：左孩子下标 = 父节点下标 * 2 + 1</li>\n    <li>父节点和右孩子：右孩子下标 = 父节点下标 * 2 + 2</li>\n    <li>子节点和父节点： 父节点下标 = (子节点下标 - 1)  // 2</li>\n    <li>最后一个非叶子节点：n // 2 -1</li>\n</ol><h3>代码实现：  </h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def sift(nums, low, high):\n    \"\"\"\n    调整堆，使堆有序\n    :param nums: list\n    :param low: 根节点\n    :param high: 尾节点（树的最后一个）\n    :return:\n    \"\"\"\n    temp = nums[low]\n    i = low\n    j = 2 * i + 1\n    while j &lt;= high:  # 当前i位置为叶子节点， j超过high了\n        # 找更大的子节点\n        if j + 1 &lt;= high and nums[j+1] &gt; nums[j]:  #\n            j = j + 1\n        if temp &lt; nums[j]:\n            nums[i] = nums[j]\n            i = j\n            j = 2 * i + 1\n        else:   # temp 大于两个子节点\n            break\n    nums[i] = temp\n\n\ndef heap_sort(nums):\n    # 建堆\n    l = len(nums)\n    for i in range(l//2-1, -1, -1):\n        # i是建堆时要调整的子树的根节点下标\n        sift(nums, i, l-1)\n    for i in range(l - 1, -1, -1):\n        # 当前的high值\n        nums[i], nums[0] = nums[0], nums[i]\n        sift(nums, 0, i-1)</code></pre>\n\n<h3>内置函数：</h3>\n\n<p style=\"text-indent:50px;\">Python内置模块heapq帮我们实现了堆排序，内置函数用的是小根堆，上面的代码是大根堆，差别不大，heapq模块主要包括三个函数:</p>\n\n<ol><li>\n    <p style=\"text-indent:0;\">heapify(list) 建小根堆   把传入的list变成小根堆</p>\n    </li>\n    <li>\n    <p style=\"text-indent:0;\">heappush(heap_list, item)向已经建好的堆中增加数据</p>\n    </li>\n    <li>\n    <p style=\"text-indent:0;\">heappop(heap_list) 输出小根堆中最小值</p>\n    </li>\n</ol><pre class=\"has\">\n<code class=\"language-python\">import heapq\n\n<p>nums = [3, 2, 1, 0, 6]</p>\n<p>heapq.heapify(nums)<br>print(nums)</p>\n<h1 id=\"0-2-1-3-6\"><a href=\"#0-2-1-3-6\" class=\"headerlink\" title=\"[0, 2, 1, 3, 6]\"></a>[0, 2, 1, 3, 6]</h1><p>heapq.heappush(nums, 4)<br>print(nums)</p>\n<h1 id=\"0-2-1-3-6-4\"><a href=\"#0-2-1-3-6-4\" class=\"headerlink\" title=\"[0, 2, 1, 3, 6, 4]\"></a>[0, 2, 1, 3, 6, 4]</h1><p>print(heapq.heappop(nums))</p>\n<h1 id=\"0\"><a href=\"#0\" class=\"headerlink\" title=\"0\"></a>0</h1><p>print(heapq.heappop(nums))</p>\n<h1 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h1><p>print(heapq.heappop(nums))</p>\n<h1 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</code></pre></h1><p> </p>"},{"_content":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">希尔排序算是插入排序的一种，是改进版的直接插入排序，和直接插入排序不同的是它是按组进行插入排序的。步骤如下：</p>\n\n<ol><li style=\"text-indent:0px;\">取一个整数d1 = n / 2,将元素分成d1个组，每组相邻元素之间距离d1，然后在每组内部进行直接插入排序。</li>\n\t<li style=\"text-indent:0px;\">取第二个整数d2 = d1 / 2再将元素分成d2个组，然后再在每组内部进行插入排序。</li>\n\t<li style=\"text-indent:0px;\">\n\t<p style=\"text-indent:0;\">重复上面的步骤直到d = 1 的时候即所有元素在同一组进行插入排序。</p>\n\t</li>\n</ol><p style=\"text-indent:50px;\">例如数组 [4,3,5,1,6,0,7,2]排序过程如下图所示</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"417\" src=\"https://img-blog.csdn.net/20181024153628923?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"994\" /></p>\n\n<p style=\"text-indent:50px;\">希尔排序并每趟并不是使某些元素有序，而是使整体数据越来越有序，只会在最后一趟排序能使得所有元素都有序。</p>\n\n<h3 style=\"text-indent:0px;\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def shell_sort(nums):\n    d = len(nums) // 2\n    while d &gt; 0:   # 分组到一的时候停止\n        for i in range(d, len(nums)):  # 第i个分组\n            temp = nums[i]  #无序区第一位\n            j = i - d  # 有序区最后一位\n            while j &gt;= 0 and nums[j] &gt; temp:  # 如果有序区大于无序区\n                nums[j + d] = nums[j]\n                j -= d\n            nums[j+d] = temp\n        d //= 2</code></pre>\n\n<p style=\"text-indent:50px;\"> </p>","source":"_posts/blogs-常用排序算法：希尔排序.md","raw":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">希尔排序算是插入排序的一种，是改进版的直接插入排序，和直接插入排序不同的是它是按组进行插入排序的。步骤如下：</p>\n\n<ol><li style=\"text-indent:0px;\">取一个整数d1 = n / 2,将元素分成d1个组，每组相邻元素之间距离d1，然后在每组内部进行直接插入排序。</li>\n\t<li style=\"text-indent:0px;\">取第二个整数d2 = d1 / 2再将元素分成d2个组，然后再在每组内部进行插入排序。</li>\n\t<li style=\"text-indent:0px;\">\n\t<p style=\"text-indent:0;\">重复上面的步骤直到d = 1 的时候即所有元素在同一组进行插入排序。</p>\n\t</li>\n</ol><p style=\"text-indent:50px;\">例如数组 [4,3,5,1,6,0,7,2]排序过程如下图所示</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"417\" src=\"https://img-blog.csdn.net/20181024153628923?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"994\" /></p>\n\n<p style=\"text-indent:50px;\">希尔排序并每趟并不是使某些元素有序，而是使整体数据越来越有序，只会在最后一趟排序能使得所有元素都有序。</p>\n\n<h3 style=\"text-indent:0px;\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def shell_sort(nums):\n    d = len(nums) // 2\n    while d &gt; 0:   # 分组到一的时候停止\n        for i in range(d, len(nums)):  # 第i个分组\n            temp = nums[i]  #无序区第一位\n            j = i - d  # 有序区最后一位\n            while j &gt;= 0 and nums[j] &gt; temp:  # 如果有序区大于无序区\n                nums[j + d] = nums[j]\n                j -= d\n            nums[j+d] = temp\n        d //= 2</code></pre>\n\n<p style=\"text-indent:50px;\"> </p>","slug":"blogs-常用排序算法：希尔排序","published":1,"date":"2022-03-16T17:01:11.150Z","updated":"2022-03-16T17:06:00.870Z","_id":"cl0v6keq5000cyms4672jht7h","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">希尔排序算是插入排序的一种，是改进版的直接插入排序，和直接插入排序不同的是它是按组进行插入排序的。步骤如下：</p>\n\n<ol><li style=\"text-indent:0px;\">取一个整数d1 = n / 2,将元素分成d1个组，每组相邻元素之间距离d1，然后在每组内部进行直接插入排序。</li>\n    <li style=\"text-indent:0px;\">取第二个整数d2 = d1 / 2再将元素分成d2个组，然后再在每组内部进行插入排序。</li>\n    <li style=\"text-indent:0px;\">\n    <p style=\"text-indent:0;\">重复上面的步骤直到d = 1 的时候即所有元素在同一组进行插入排序。</p>\n    </li>\n</ol><p style=\"text-indent:50px;\">例如数组 [4,3,5,1,6,0,7,2]排序过程如下图所示</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"417\" src=\"https://img-blog.csdn.net/20181024153628923?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"994\" /></p>\n\n<p style=\"text-indent:50px;\">希尔排序并每趟并不是使某些元素有序，而是使整体数据越来越有序，只会在最后一趟排序能使得所有元素都有序。</p>\n\n<h3 style=\"text-indent:0px;\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def shell_sort(nums):\n    d = len(nums) // 2\n    while d &gt; 0:   # 分组到一的时候停止\n        for i in range(d, len(nums)):  # 第i个分组\n            temp = nums[i]  #无序区第一位\n            j = i - d  # 有序区最后一位\n            while j &gt;= 0 and nums[j] &gt; temp:  # 如果有序区大于无序区\n                nums[j + d] = nums[j]\n                j -= d\n            nums[j+d] = temp\n        d //= 2</code></pre>\n\n<p style=\"text-indent:50px;\"> </p>","site":{"data":{}},"excerpt":"","more":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">希尔排序算是插入排序的一种，是改进版的直接插入排序，和直接插入排序不同的是它是按组进行插入排序的。步骤如下：</p>\n\n<ol><li style=\"text-indent:0px;\">取一个整数d1 = n / 2,将元素分成d1个组，每组相邻元素之间距离d1，然后在每组内部进行直接插入排序。</li>\n    <li style=\"text-indent:0px;\">取第二个整数d2 = d1 / 2再将元素分成d2个组，然后再在每组内部进行插入排序。</li>\n    <li style=\"text-indent:0px;\">\n    <p style=\"text-indent:0;\">重复上面的步骤直到d = 1 的时候即所有元素在同一组进行插入排序。</p>\n    </li>\n</ol><p style=\"text-indent:50px;\">例如数组 [4,3,5,1,6,0,7,2]排序过程如下图所示</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"417\" src=\"https://img-blog.csdn.net/20181024153628923?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"994\" /></p>\n\n<p style=\"text-indent:50px;\">希尔排序并每趟并不是使某些元素有序，而是使整体数据越来越有序，只会在最后一趟排序能使得所有元素都有序。</p>\n\n<h3 style=\"text-indent:0px;\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def shell_sort(nums):\n    d = len(nums) // 2\n    while d &gt; 0:   # 分组到一的时候停止\n        for i in range(d, len(nums)):  # 第i个分组\n            temp = nums[i]  #无序区第一位\n            j = i - d  # 有序区最后一位\n            while j &gt;= 0 and nums[j] &gt; temp:  # 如果有序区大于无序区\n                nums[j + d] = nums[j]\n                j -= d\n            nums[j+d] = temp\n        d //= 2</code></pre>\n\n<p style=\"text-indent:50px;\"> </p>"},{"_content":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">简单来说归并排序就是将两个有序的序列合并成一个完整的有序序列。具体步骤如下：<br />\n           1. 选取序列1的第一个元素和序列2的第一个元素，较小的存放到新序列的第一位<br />\n           2. 选序列1的第二个元素再和序列2的第一个元素比较，选较小的存放到新序列的低二位<br />\n           3. 重复上述步骤直到序列1序列2没有下一个元素为止</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"209\" src=\"https://img-blog.csdn.net/20181023233332595?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"699\" /></p>\n\n<p style=\"text-indent:50px;\">那么问题来了，一个无序的序列又是如何分成两个有序序列然后执行上述的步骤呢，这个我们就需要先把原有的序列进行拆分，拆分到每个子序列长度都为1的时候所有子序列不就是有序的吗【手动滑稽】。那么一个完整的递归排序的过程就会分成两部分，第一拆分，第二合并，如下图所示</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"483\" src=\"https://img-blog.csdn.net/20181024013350783?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"851\" /></p>\n\n<h3 style=\"text-indent:0px;\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def merge(nums, low, mid, high):    # 合并\n    i = low\n    j = mid + 1\n    array = []\n    while i &lt;= mid and j &lt;= high:   # 循环从两边中取出较小的数放入新的空数组中\n        if nums[i] &lt;= nums[j]:\n            array.append(nums[i])\n            i += 1\n        else:\n            array.append(nums[j])\n            j += 1\n    while i &lt;= mid:            # 当某一边取完了之后，直接将剩下一边的数据直接存入\n        array.append(nums[i])\n        i += 1\n    while j &lt;= high:\n        array.append(nums[j])\n        j += 1\n    nums[low:high + 1] = array\n\n\ndef merge_sort(nums, left, right):  # 拆分\n    if left &lt; right:\n        mid = (left + right) // 2\n        merge_sort(nums, left, mid)\n        merge_sort(nums, mid + 1, right)\n        merge(nums, left, mid, right)</code></pre>\n\n<h3>补充</h3>\n\n<p style=\"text-indent:50px;\">之前面试遇到一个问题，给一个4G内存的计算机，硬盘大小为1T，设计一种算法将100G的数据从小到大排序，第一个想到的就是归并，但是呢这个归并不同上面说的那种，因为内存太小了，放不下那么多数据啊。所以呢需要做一下改进。4G和100G差别太多，以4G和12G为例，首先先从硬盘中取出3G数据放入内存中使用排序算法构造成有序数据在写回到硬盘中，再取出下一个3G数据排好序，直到所有的数据都取出来并排好序了，这样我们就得到了4个有序的子序列，下一步呢就是用我们刚刚说的归并排序将4个有序序列合并成一个完整的有序序列。</p>","source":"_posts/blogs-常用排序算法：归并排序.md","raw":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">简单来说归并排序就是将两个有序的序列合并成一个完整的有序序列。具体步骤如下：<br />\n           1. 选取序列1的第一个元素和序列2的第一个元素，较小的存放到新序列的第一位<br />\n           2. 选序列1的第二个元素再和序列2的第一个元素比较，选较小的存放到新序列的低二位<br />\n           3. 重复上述步骤直到序列1序列2没有下一个元素为止</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"209\" src=\"https://img-blog.csdn.net/20181023233332595?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"699\" /></p>\n\n<p style=\"text-indent:50px;\">那么问题来了，一个无序的序列又是如何分成两个有序序列然后执行上述的步骤呢，这个我们就需要先把原有的序列进行拆分，拆分到每个子序列长度都为1的时候所有子序列不就是有序的吗【手动滑稽】。那么一个完整的递归排序的过程就会分成两部分，第一拆分，第二合并，如下图所示</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"483\" src=\"https://img-blog.csdn.net/20181024013350783?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"851\" /></p>\n\n<h3 style=\"text-indent:0px;\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def merge(nums, low, mid, high):    # 合并\n    i = low\n    j = mid + 1\n    array = []\n    while i &lt;= mid and j &lt;= high:   # 循环从两边中取出较小的数放入新的空数组中\n        if nums[i] &lt;= nums[j]:\n            array.append(nums[i])\n            i += 1\n        else:\n            array.append(nums[j])\n            j += 1\n    while i &lt;= mid:            # 当某一边取完了之后，直接将剩下一边的数据直接存入\n        array.append(nums[i])\n        i += 1\n    while j &lt;= high:\n        array.append(nums[j])\n        j += 1\n    nums[low:high + 1] = array\n\n\ndef merge_sort(nums, left, right):  # 拆分\n    if left &lt; right:\n        mid = (left + right) // 2\n        merge_sort(nums, left, mid)\n        merge_sort(nums, mid + 1, right)\n        merge(nums, left, mid, right)</code></pre>\n\n<h3>补充</h3>\n\n<p style=\"text-indent:50px;\">之前面试遇到一个问题，给一个4G内存的计算机，硬盘大小为1T，设计一种算法将100G的数据从小到大排序，第一个想到的就是归并，但是呢这个归并不同上面说的那种，因为内存太小了，放不下那么多数据啊。所以呢需要做一下改进。4G和100G差别太多，以4G和12G为例，首先先从硬盘中取出3G数据放入内存中使用排序算法构造成有序数据在写回到硬盘中，再取出下一个3G数据排好序，直到所有的数据都取出来并排好序了，这样我们就得到了4个有序的子序列，下一步呢就是用我们刚刚说的归并排序将4个有序序列合并成一个完整的有序序列。</p>","slug":"blogs-常用排序算法：归并排序","published":1,"date":"2022-03-16T17:01:12.333Z","updated":"2022-03-16T17:06:02.058Z","_id":"cl0v6keq7000dyms4euef1vjh","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">简单来说归并排序就是将两个有序的序列合并成一个完整的有序序列。具体步骤如下：<br />\n           1. 选取序列1的第一个元素和序列2的第一个元素，较小的存放到新序列的第一位<br />\n           2. 选序列1的第二个元素再和序列2的第一个元素比较，选较小的存放到新序列的低二位<br />\n           3. 重复上述步骤直到序列1序列2没有下一个元素为止</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"209\" src=\"https://img-blog.csdn.net/20181023233332595?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"699\" /></p>\n\n<p style=\"text-indent:50px;\">那么问题来了，一个无序的序列又是如何分成两个有序序列然后执行上述的步骤呢，这个我们就需要先把原有的序列进行拆分，拆分到每个子序列长度都为1的时候所有子序列不就是有序的吗【手动滑稽】。那么一个完整的递归排序的过程就会分成两部分，第一拆分，第二合并，如下图所示</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"483\" src=\"https://img-blog.csdn.net/20181024013350783?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"851\" /></p>\n\n<h3 style=\"text-indent:0px;\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def merge(nums, low, mid, high):    # 合并\n    i = low\n    j = mid + 1\n    array = []\n    while i &lt;= mid and j &lt;= high:   # 循环从两边中取出较小的数放入新的空数组中\n        if nums[i] &lt;= nums[j]:\n            array.append(nums[i])\n            i += 1\n        else:\n            array.append(nums[j])\n            j += 1\n    while i &lt;= mid:            # 当某一边取完了之后，直接将剩下一边的数据直接存入\n        array.append(nums[i])\n        i += 1\n    while j &lt;= high:\n        array.append(nums[j])\n        j += 1\n    nums[low:high + 1] = array\n\n\ndef merge_sort(nums, left, right):  # 拆分\n    if left &lt; right:\n        mid = (left + right) // 2\n        merge_sort(nums, left, mid)\n        merge_sort(nums, mid + 1, right)\n        merge(nums, left, mid, right)</code></pre>\n\n<h3>补充</h3>\n\n<p style=\"text-indent:50px;\">之前面试遇到一个问题，给一个4G内存的计算机，硬盘大小为1T，设计一种算法将100G的数据从小到大排序，第一个想到的就是归并，但是呢这个归并不同上面说的那种，因为内存太小了，放不下那么多数据啊。所以呢需要做一下改进。4G和100G差别太多，以4G和12G为例，首先先从硬盘中取出3G数据放入内存中使用排序算法构造成有序数据在写回到硬盘中，再取出下一个3G数据排好序，直到所有的数据都取出来并排好序了，这样我们就得到了4个有序的子序列，下一步呢就是用我们刚刚说的归并排序将4个有序序列合并成一个完整的有序序列。</p>","site":{"data":{}},"excerpt":"","more":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">简单来说归并排序就是将两个有序的序列合并成一个完整的有序序列。具体步骤如下：<br />\n           1. 选取序列1的第一个元素和序列2的第一个元素，较小的存放到新序列的第一位<br />\n           2. 选序列1的第二个元素再和序列2的第一个元素比较，选较小的存放到新序列的低二位<br />\n           3. 重复上述步骤直到序列1序列2没有下一个元素为止</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"209\" src=\"https://img-blog.csdn.net/20181023233332595?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"699\" /></p>\n\n<p style=\"text-indent:50px;\">那么问题来了，一个无序的序列又是如何分成两个有序序列然后执行上述的步骤呢，这个我们就需要先把原有的序列进行拆分，拆分到每个子序列长度都为1的时候所有子序列不就是有序的吗【手动滑稽】。那么一个完整的递归排序的过程就会分成两部分，第一拆分，第二合并，如下图所示</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"483\" src=\"https://img-blog.csdn.net/20181024013350783?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"851\" /></p>\n\n<h3 style=\"text-indent:0px;\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def merge(nums, low, mid, high):    # 合并\n    i = low\n    j = mid + 1\n    array = []\n    while i &lt;= mid and j &lt;= high:   # 循环从两边中取出较小的数放入新的空数组中\n        if nums[i] &lt;= nums[j]:\n            array.append(nums[i])\n            i += 1\n        else:\n            array.append(nums[j])\n            j += 1\n    while i &lt;= mid:            # 当某一边取完了之后，直接将剩下一边的数据直接存入\n        array.append(nums[i])\n        i += 1\n    while j &lt;= high:\n        array.append(nums[j])\n        j += 1\n    nums[low:high + 1] = array\n\n\ndef merge_sort(nums, left, right):  # 拆分\n    if left &lt; right:\n        mid = (left + right) // 2\n        merge_sort(nums, left, mid)\n        merge_sort(nums, mid + 1, right)\n        merge(nums, left, mid, right)</code></pre>\n\n<h3>补充</h3>\n\n<p style=\"text-indent:50px;\">之前面试遇到一个问题，给一个4G内存的计算机，硬盘大小为1T，设计一种算法将100G的数据从小到大排序，第一个想到的就是归并，但是呢这个归并不同上面说的那种，因为内存太小了，放不下那么多数据啊。所以呢需要做一下改进。4G和100G差别太多，以4G和12G为例，首先先从硬盘中取出3G数据放入内存中使用排序算法构造成有序数据在写回到硬盘中，再取出下一个3G数据排好序，直到所有的数据都取出来并排好序了，这样我们就得到了4个有序的子序列，下一步呢就是用我们刚刚说的归并排序将4个有序序列合并成一个完整的有序序列。</p>"},{"_content":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">我们之前提到过计数排序，计数排序在某些情况下并不太适合，例如元素范围太大的情况，桶排序算是对于计数排序的一种改进，桶排序首先根据元素大小放置到不同的桶中，然后在对每一个桶内元素进行排序。</p>\n\n<p style=\"text-indent:50px;\">例如数组[29,25,3,49,9,37,21,43]，可以以10为区间来存放元素，具体操作如下图：</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"439\" src=\"https://img-blog.csdn.net/20181024224916708?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"696\" /></p>\n\n<p style=\"text-indent:50px;\">关于“桶”这个结构怎么实现，在python里面可以用二位数组来表示[ [  ], [   ], [  ] ....]，总得来说桶排序步骤：<br />\n            1 . 建桶<br />\n            2.  元素存放到桶里面<br />\n            3.  桶内元素进行排序（第二步和第三步可以合并到一起，因为初始的桶为空是有序的，每次只需执行一次插入即可保持有序<br />\n            4.  依次取出每个桶内元素</p>\n\n<p style=\"text-indent:50px;\">时间复杂度：平均O(n+k)， 最坏O(n^2 * k)都放到一个桶里面了</p>\n\n<p style=\"text-indent:50px;\">空间复杂度：O(nk)</p>\n\n<h3>代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def bucket_sort(nums, buckets):\n    \"\"\"\n    桶排序\n    :param nums: 无序数组\n    :param buckets: 桶个数\n    :return: 有序数组\n    \"\"\"\n    bucket = [[] for x in range(buckets)]  # 创建空桶\n    num = max(nums) - min(nums) + 1\n    l = num // buckets + 1 if num % buckets else num // buckets   # 计算每个桶大小\n    for i in nums:\n        bucket_num = i // l # 计算元素应该放入到哪一个桶里面\n        bucket[bucket_num].append(i)\n        # 维护桶内元素有序。\n        # 因为之前的桶内是有序的，插入一个新的元素可以使用插入排序继续保持桶内有序\n        tmp = i\n        j = len(bucket[bucket_num]) - 2\n        while j &gt;= 0 and bucket[bucket_num][j] &gt; tmp:  # 执行插入操作\n            bucket[bucket_num][j + 1] = bucket[bucket_num][j]\n            j -= 1\n        bucket[bucket_num][j+1] = tmp\n    res = []\n    # 依次取出桶内元素\n    for i in bucket:\n        res.extend(i)\n    return res</code></pre>\n\n<p> </p>","source":"_posts/blogs-常用排序算法：桶排序.md","raw":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">我们之前提到过计数排序，计数排序在某些情况下并不太适合，例如元素范围太大的情况，桶排序算是对于计数排序的一种改进，桶排序首先根据元素大小放置到不同的桶中，然后在对每一个桶内元素进行排序。</p>\n\n<p style=\"text-indent:50px;\">例如数组[29,25,3,49,9,37,21,43]，可以以10为区间来存放元素，具体操作如下图：</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"439\" src=\"https://img-blog.csdn.net/20181024224916708?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"696\" /></p>\n\n<p style=\"text-indent:50px;\">关于“桶”这个结构怎么实现，在python里面可以用二位数组来表示[ [  ], [   ], [  ] ....]，总得来说桶排序步骤：<br />\n            1 . 建桶<br />\n            2.  元素存放到桶里面<br />\n            3.  桶内元素进行排序（第二步和第三步可以合并到一起，因为初始的桶为空是有序的，每次只需执行一次插入即可保持有序<br />\n            4.  依次取出每个桶内元素</p>\n\n<p style=\"text-indent:50px;\">时间复杂度：平均O(n+k)， 最坏O(n^2 * k)都放到一个桶里面了</p>\n\n<p style=\"text-indent:50px;\">空间复杂度：O(nk)</p>\n\n<h3>代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def bucket_sort(nums, buckets):\n    \"\"\"\n    桶排序\n    :param nums: 无序数组\n    :param buckets: 桶个数\n    :return: 有序数组\n    \"\"\"\n    bucket = [[] for x in range(buckets)]  # 创建空桶\n    num = max(nums) - min(nums) + 1\n    l = num // buckets + 1 if num % buckets else num // buckets   # 计算每个桶大小\n    for i in nums:\n        bucket_num = i // l # 计算元素应该放入到哪一个桶里面\n        bucket[bucket_num].append(i)\n        # 维护桶内元素有序。\n        # 因为之前的桶内是有序的，插入一个新的元素可以使用插入排序继续保持桶内有序\n        tmp = i\n        j = len(bucket[bucket_num]) - 2\n        while j &gt;= 0 and bucket[bucket_num][j] &gt; tmp:  # 执行插入操作\n            bucket[bucket_num][j + 1] = bucket[bucket_num][j]\n            j -= 1\n        bucket[bucket_num][j+1] = tmp\n    res = []\n    # 依次取出桶内元素\n    for i in bucket:\n        res.extend(i)\n    return res</code></pre>\n\n<p> </p>","slug":"blogs-常用排序算法：桶排序","published":1,"date":"2022-03-16T17:01:08.793Z","updated":"2022-03-16T17:05:58.446Z","_id":"cl0v6keq8000eyms42x3rc3ow","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">我们之前提到过计数排序，计数排序在某些情况下并不太适合，例如元素范围太大的情况，桶排序算是对于计数排序的一种改进，桶排序首先根据元素大小放置到不同的桶中，然后在对每一个桶内元素进行排序。</p>\n\n<p style=\"text-indent:50px;\">例如数组[29,25,3,49,9,37,21,43]，可以以10为区间来存放元素，具体操作如下图：</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"439\" src=\"https://img-blog.csdn.net/20181024224916708?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"696\" /></p>\n\n<p style=\"text-indent:50px;\">关于“桶”这个结构怎么实现，在python里面可以用二位数组来表示[ [  ], [   ], [  ] ....]，总得来说桶排序步骤：<br />\n            1 . 建桶<br />\n            2.  元素存放到桶里面<br />\n            3.  桶内元素进行排序（第二步和第三步可以合并到一起，因为初始的桶为空是有序的，每次只需执行一次插入即可保持有序<br />\n            4.  依次取出每个桶内元素</p>\n\n<p style=\"text-indent:50px;\">时间复杂度：平均O(n+k)， 最坏O(n^2 * k)都放到一个桶里面了</p>\n\n<p style=\"text-indent:50px;\">空间复杂度：O(nk)</p>\n\n<h3>代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def bucket_sort(nums, buckets):\n    \"\"\"\n    桶排序\n    :param nums: 无序数组\n    :param buckets: 桶个数\n    :return: 有序数组\n    \"\"\"\n    bucket = [[] for x in range(buckets)]  # 创建空桶\n    num = max(nums) - min(nums) + 1\n    l = num // buckets + 1 if num % buckets else num // buckets   # 计算每个桶大小\n    for i in nums:\n        bucket_num = i // l # 计算元素应该放入到哪一个桶里面\n        bucket[bucket_num].append(i)\n        # 维护桶内元素有序。\n        # 因为之前的桶内是有序的，插入一个新的元素可以使用插入排序继续保持桶内有序\n        tmp = i\n        j = len(bucket[bucket_num]) - 2\n        while j &gt;= 0 and bucket[bucket_num][j] &gt; tmp:  # 执行插入操作\n            bucket[bucket_num][j + 1] = bucket[bucket_num][j]\n            j -= 1\n        bucket[bucket_num][j+1] = tmp\n    res = []\n    # 依次取出桶内元素\n    for i in bucket:\n        res.extend(i)\n    return res</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">我们之前提到过计数排序，计数排序在某些情况下并不太适合，例如元素范围太大的情况，桶排序算是对于计数排序的一种改进，桶排序首先根据元素大小放置到不同的桶中，然后在对每一个桶内元素进行排序。</p>\n\n<p style=\"text-indent:50px;\">例如数组[29,25,3,49,9,37,21,43]，可以以10为区间来存放元素，具体操作如下图：</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"439\" src=\"https://img-blog.csdn.net/20181024224916708?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"696\" /></p>\n\n<p style=\"text-indent:50px;\">关于“桶”这个结构怎么实现，在python里面可以用二位数组来表示[ [  ], [   ], [  ] ....]，总得来说桶排序步骤：<br />\n            1 . 建桶<br />\n            2.  元素存放到桶里面<br />\n            3.  桶内元素进行排序（第二步和第三步可以合并到一起，因为初始的桶为空是有序的，每次只需执行一次插入即可保持有序<br />\n            4.  依次取出每个桶内元素</p>\n\n<p style=\"text-indent:50px;\">时间复杂度：平均O(n+k)， 最坏O(n^2 * k)都放到一个桶里面了</p>\n\n<p style=\"text-indent:50px;\">空间复杂度：O(nk)</p>\n\n<h3>代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def bucket_sort(nums, buckets):\n    \"\"\"\n    桶排序\n    :param nums: 无序数组\n    :param buckets: 桶个数\n    :return: 有序数组\n    \"\"\"\n    bucket = [[] for x in range(buckets)]  # 创建空桶\n    num = max(nums) - min(nums) + 1\n    l = num // buckets + 1 if num % buckets else num // buckets   # 计算每个桶大小\n    for i in nums:\n        bucket_num = i // l # 计算元素应该放入到哪一个桶里面\n        bucket[bucket_num].append(i)\n        # 维护桶内元素有序。\n        # 因为之前的桶内是有序的，插入一个新的元素可以使用插入排序继续保持桶内有序\n        tmp = i\n        j = len(bucket[bucket_num]) - 2\n        while j &gt;= 0 and bucket[bucket_num][j] &gt; tmp:  # 执行插入操作\n            bucket[bucket_num][j + 1] = bucket[bucket_num][j]\n            j -= 1\n        bucket[bucket_num][j+1] = tmp\n    res = []\n    # 依次取出桶内元素\n    for i in bucket:\n        res.extend(i)\n    return res</code></pre>\n\n<p> </p>"},{"_content":"<h3>算法思路</h3>\n\n<p style=\"text-indent:50px;\">快速排序差不多是面试中问的最多的一种排序算法了，快排是比较容易理解的，核心思路就是，选取一个数作为基准，将原来的列表分为两个部分，一部分全部小于这个基准数，另外一部分全部大于这个基准数，然后呢再按照这个方法对划分出来的两部分继续做同样的操作，直到无法划分的时候排序也就完成了。</p>\n\n<p style=\"text-indent:50px;\">以数组[3,2,1,5,4,6]为例，其排序过程如下图所示。<img alt=\"\" class=\"has\" height=\"315\" src=\"https://img-blog.csdn.net/20181023002351996?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"837\" /></p>\n\n<p style=\"text-indent:50px;\">关于时间复杂度问题， 平均复杂度n log(n) 最坏情况 n^2，以长度为16的list为例：<img alt=\"\" class=\"has\" height=\"465\" src=\"https://img-blog.csdn.net/2018102315000133?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"706\" /></p>\n\n<h3>代码实现</h3>\n\n<p style=\"text-indent:0;\">方法一：</p>\n\n<p style=\"text-indent:50px;\">按照上述的思路可分为两个部分来写代码，一部分是使用递归，一部分是调整位置。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def partition(nums, left, right):\n    temp = nums[left]\n    while left &lt; right:\n        while left &lt; right and nums[right] &gt;= temp:   # 从右往左搜索比基准值小\n            right -= 1   # 没有则往右走一位\n        nums[left] = nums[right]  # 找到了比基准值小的则调整顺序\n        while left &lt; right and nums[left] &lt;= temp:  # 从左往右找比基准大的数\n            left += 1\n        nums[right] = nums[left]\n    nums[left] = temp   # 交换完成之后归位\n    return left  # 返回基准值的位置\n\n\ndef quick_sort(nums, left, right):\n    if left &lt; right:\n        mid = partition(nums, left, right)\n        quick_sort(nums, left, mid - 1)   # 比基准值小的一部分再次进行快排\n        quick_sort(nums, mid + 1, right)  # 比基准值大的一部分</code></pre>\n\n<p style=\"text-indent:0;\">方法二：</p>\n\n<p style=\"text-indent:50px;\">上面这种呢是在原有的list进行变换，如果不考虑原有变换还有一种更直观的方法来实现，使用列表生成式来实现，只不过在数据量很大的时候会占用更多的空间。不考虑交换操作，直接简单粗暴的把list分割成两部分。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def quick_sort(nums):\n    if len(nums) &lt;= 1:\n        return nums\n    pivot = nums[len(nums)//2]\n    left = [x for x in nums if x &lt; pivot]\n    middle = [x for x in nums if x == pivot]\n    right = [x for x in nums if x &gt; pivot]\n    return quick_sort(left) + middle + quick_sort(right)</code></pre>\n\n<p> </p>","source":"_posts/blogs-常用排序算法：快速排序.md","raw":"<h3>算法思路</h3>\n\n<p style=\"text-indent:50px;\">快速排序差不多是面试中问的最多的一种排序算法了，快排是比较容易理解的，核心思路就是，选取一个数作为基准，将原来的列表分为两个部分，一部分全部小于这个基准数，另外一部分全部大于这个基准数，然后呢再按照这个方法对划分出来的两部分继续做同样的操作，直到无法划分的时候排序也就完成了。</p>\n\n<p style=\"text-indent:50px;\">以数组[3,2,1,5,4,6]为例，其排序过程如下图所示。<img alt=\"\" class=\"has\" height=\"315\" src=\"https://img-blog.csdn.net/20181023002351996?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"837\" /></p>\n\n<p style=\"text-indent:50px;\">关于时间复杂度问题， 平均复杂度n log(n) 最坏情况 n^2，以长度为16的list为例：<img alt=\"\" class=\"has\" height=\"465\" src=\"https://img-blog.csdn.net/2018102315000133?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"706\" /></p>\n\n<h3>代码实现</h3>\n\n<p style=\"text-indent:0;\">方法一：</p>\n\n<p style=\"text-indent:50px;\">按照上述的思路可分为两个部分来写代码，一部分是使用递归，一部分是调整位置。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def partition(nums, left, right):\n    temp = nums[left]\n    while left &lt; right:\n        while left &lt; right and nums[right] &gt;= temp:   # 从右往左搜索比基准值小\n            right -= 1   # 没有则往右走一位\n        nums[left] = nums[right]  # 找到了比基准值小的则调整顺序\n        while left &lt; right and nums[left] &lt;= temp:  # 从左往右找比基准大的数\n            left += 1\n        nums[right] = nums[left]\n    nums[left] = temp   # 交换完成之后归位\n    return left  # 返回基准值的位置\n\n\ndef quick_sort(nums, left, right):\n    if left &lt; right:\n        mid = partition(nums, left, right)\n        quick_sort(nums, left, mid - 1)   # 比基准值小的一部分再次进行快排\n        quick_sort(nums, mid + 1, right)  # 比基准值大的一部分</code></pre>\n\n<p style=\"text-indent:0;\">方法二：</p>\n\n<p style=\"text-indent:50px;\">上面这种呢是在原有的list进行变换，如果不考虑原有变换还有一种更直观的方法来实现，使用列表生成式来实现，只不过在数据量很大的时候会占用更多的空间。不考虑交换操作，直接简单粗暴的把list分割成两部分。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def quick_sort(nums):\n    if len(nums) &lt;= 1:\n        return nums\n    pivot = nums[len(nums)//2]\n    left = [x for x in nums if x &lt; pivot]\n    middle = [x for x in nums if x == pivot]\n    right = [x for x in nums if x &gt; pivot]\n    return quick_sort(left) + middle + quick_sort(right)</code></pre>\n\n<p> </p>","slug":"blogs-常用排序算法：快速排序","published":1,"date":"2022-03-16T17:01:14.724Z","updated":"2022-03-16T17:06:04.468Z","_id":"cl0v6keqa000fyms466mwdxie","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>算法思路</h3>\n\n<p style=\"text-indent:50px;\">快速排序差不多是面试中问的最多的一种排序算法了，快排是比较容易理解的，核心思路就是，选取一个数作为基准，将原来的列表分为两个部分，一部分全部小于这个基准数，另外一部分全部大于这个基准数，然后呢再按照这个方法对划分出来的两部分继续做同样的操作，直到无法划分的时候排序也就完成了。</p>\n\n<p style=\"text-indent:50px;\">以数组[3,2,1,5,4,6]为例，其排序过程如下图所示。<img alt=\"\" class=\"has\" height=\"315\" src=\"https://img-blog.csdn.net/20181023002351996?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"837\" /></p>\n\n<p style=\"text-indent:50px;\">关于时间复杂度问题， 平均复杂度n log(n) 最坏情况 n^2，以长度为16的list为例：<img alt=\"\" class=\"has\" height=\"465\" src=\"https://img-blog.csdn.net/2018102315000133?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"706\" /></p>\n\n<h3>代码实现</h3>\n\n<p style=\"text-indent:0;\">方法一：</p>\n\n<p style=\"text-indent:50px;\">按照上述的思路可分为两个部分来写代码，一部分是使用递归，一部分是调整位置。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def partition(nums, left, right):\n    temp = nums[left]\n    while left &lt; right:\n        while left &lt; right and nums[right] &gt;= temp:   # 从右往左搜索比基准值小\n            right -= 1   # 没有则往右走一位\n        nums[left] = nums[right]  # 找到了比基准值小的则调整顺序\n        while left &lt; right and nums[left] &lt;= temp:  # 从左往右找比基准大的数\n            left += 1\n        nums[right] = nums[left]\n    nums[left] = temp   # 交换完成之后归位\n    return left  # 返回基准值的位置\n\n\ndef quick_sort(nums, left, right):\n    if left &lt; right:\n        mid = partition(nums, left, right)\n        quick_sort(nums, left, mid - 1)   # 比基准值小的一部分再次进行快排\n        quick_sort(nums, mid + 1, right)  # 比基准值大的一部分</code></pre>\n\n<p style=\"text-indent:0;\">方法二：</p>\n\n<p style=\"text-indent:50px;\">上面这种呢是在原有的list进行变换，如果不考虑原有变换还有一种更直观的方法来实现，使用列表生成式来实现，只不过在数据量很大的时候会占用更多的空间。不考虑交换操作，直接简单粗暴的把list分割成两部分。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def quick_sort(nums):\n    if len(nums) &lt;= 1:\n        return nums\n    pivot = nums[len(nums)//2]\n    left = [x for x in nums if x &lt; pivot]\n    middle = [x for x in nums if x == pivot]\n    right = [x for x in nums if x &gt; pivot]\n    return quick_sort(left) + middle + quick_sort(right)</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<h3>算法思路</h3>\n\n<p style=\"text-indent:50px;\">快速排序差不多是面试中问的最多的一种排序算法了，快排是比较容易理解的，核心思路就是，选取一个数作为基准，将原来的列表分为两个部分，一部分全部小于这个基准数，另外一部分全部大于这个基准数，然后呢再按照这个方法对划分出来的两部分继续做同样的操作，直到无法划分的时候排序也就完成了。</p>\n\n<p style=\"text-indent:50px;\">以数组[3,2,1,5,4,6]为例，其排序过程如下图所示。<img alt=\"\" class=\"has\" height=\"315\" src=\"https://img-blog.csdn.net/20181023002351996?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"837\" /></p>\n\n<p style=\"text-indent:50px;\">关于时间复杂度问题， 平均复杂度n log(n) 最坏情况 n^2，以长度为16的list为例：<img alt=\"\" class=\"has\" height=\"465\" src=\"https://img-blog.csdn.net/2018102315000133?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"706\" /></p>\n\n<h3>代码实现</h3>\n\n<p style=\"text-indent:0;\">方法一：</p>\n\n<p style=\"text-indent:50px;\">按照上述的思路可分为两个部分来写代码，一部分是使用递归，一部分是调整位置。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def partition(nums, left, right):\n    temp = nums[left]\n    while left &lt; right:\n        while left &lt; right and nums[right] &gt;= temp:   # 从右往左搜索比基准值小\n            right -= 1   # 没有则往右走一位\n        nums[left] = nums[right]  # 找到了比基准值小的则调整顺序\n        while left &lt; right and nums[left] &lt;= temp:  # 从左往右找比基准大的数\n            left += 1\n        nums[right] = nums[left]\n    nums[left] = temp   # 交换完成之后归位\n    return left  # 返回基准值的位置\n\n\ndef quick_sort(nums, left, right):\n    if left &lt; right:\n        mid = partition(nums, left, right)\n        quick_sort(nums, left, mid - 1)   # 比基准值小的一部分再次进行快排\n        quick_sort(nums, mid + 1, right)  # 比基准值大的一部分</code></pre>\n\n<p style=\"text-indent:0;\">方法二：</p>\n\n<p style=\"text-indent:50px;\">上面这种呢是在原有的list进行变换，如果不考虑原有变换还有一种更直观的方法来实现，使用列表生成式来实现，只不过在数据量很大的时候会占用更多的空间。不考虑交换操作，直接简单粗暴的把list分割成两部分。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def quick_sort(nums):\n    if len(nums) &lt;= 1:\n        return nums\n    pivot = nums[len(nums)//2]\n    left = [x for x in nums if x &lt; pivot]\n    middle = [x for x in nums if x == pivot]\n    right = [x for x in nums if x &gt; pivot]\n    return quick_sort(left) + middle + quick_sort(right)</code></pre>\n\n<p> </p>"},{"_content":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">顾名思义计数排序就是统计每个数出现的次数，例如给0-20范围内的数排序，首先建立一个长度为21的空数组，然后统计每个数出现的次数，再按照下标存入空数组中，例如1出现10次那么数组中的第二个元素为10 ，统计完所有的数之后呢在新建一个数组，在遍历之前存放次数的数组，按照个数往新数组中添加对应的数。</p>\n\n<p style=\"text-indent:50px;\">以一个例子来说明[1,2,3,1,0,4,1,3,4,2,0,1,2,3,4]排序过程如下图所示</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"301\" src=\"https://img-blog.csdn.net/20181024172139600?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"947\" /></p>\n\n<p style=\"text-indent:50px;\">计数排序虽然时间复杂度小O(n)，但是局限性很大，首先是需要知道最大数是多少，其次当无序列表分布很分散例如[1,3,1000000]，明明只有三个数但是却需要开辟一个长度为1000000的空列表，会造成空间浪费。所以计数排序只适合在特定的情况下使用。</p>\n\n<h3 style=\"text-indent:0px;\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def count_sort(nums, max_num):\n    \"\"\"\n    计数排序\n    :param nums: 无序数组\n    :param max_num: 最大数\n    \"\"\"\n    count = [0 for x in range(max_num+1)]  # 新建一个统计数组\n    for i in nums:  # 计数\n        count[i] += 1\n    nums.clear()  # 清空原有数组\n    for c, i in enumerate(count):  # 往空数组中添加元素\n        while i &gt; 0:\n            nums.append(c)\n            i -= 1</code></pre>\n\n<p> </p>","source":"_posts/blogs-常用排序算法：计数排序.md","raw":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">顾名思义计数排序就是统计每个数出现的次数，例如给0-20范围内的数排序，首先建立一个长度为21的空数组，然后统计每个数出现的次数，再按照下标存入空数组中，例如1出现10次那么数组中的第二个元素为10 ，统计完所有的数之后呢在新建一个数组，在遍历之前存放次数的数组，按照个数往新数组中添加对应的数。</p>\n\n<p style=\"text-indent:50px;\">以一个例子来说明[1,2,3,1,0,4,1,3,4,2,0,1,2,3,4]排序过程如下图所示</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"301\" src=\"https://img-blog.csdn.net/20181024172139600?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"947\" /></p>\n\n<p style=\"text-indent:50px;\">计数排序虽然时间复杂度小O(n)，但是局限性很大，首先是需要知道最大数是多少，其次当无序列表分布很分散例如[1,3,1000000]，明明只有三个数但是却需要开辟一个长度为1000000的空列表，会造成空间浪费。所以计数排序只适合在特定的情况下使用。</p>\n\n<h3 style=\"text-indent:0px;\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def count_sort(nums, max_num):\n    \"\"\"\n    计数排序\n    :param nums: 无序数组\n    :param max_num: 最大数\n    \"\"\"\n    count = [0 for x in range(max_num+1)]  # 新建一个统计数组\n    for i in nums:  # 计数\n        count[i] += 1\n    nums.clear()  # 清空原有数组\n    for c, i in enumerate(count):  # 往空数组中添加元素\n        while i &gt; 0:\n            nums.append(c)\n            i -= 1</code></pre>\n\n<p> </p>","slug":"blogs-常用排序算法：计数排序","published":1,"date":"2022-03-16T17:01:09.979Z","updated":"2022-03-16T17:05:59.640Z","_id":"cl0v6keqc000gyms4cpqu47f8","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">顾名思义计数排序就是统计每个数出现的次数，例如给0-20范围内的数排序，首先建立一个长度为21的空数组，然后统计每个数出现的次数，再按照下标存入空数组中，例如1出现10次那么数组中的第二个元素为10 ，统计完所有的数之后呢在新建一个数组，在遍历之前存放次数的数组，按照个数往新数组中添加对应的数。</p>\n\n<p style=\"text-indent:50px;\">以一个例子来说明[1,2,3,1,0,4,1,3,4,2,0,1,2,3,4]排序过程如下图所示</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"301\" src=\"https://img-blog.csdn.net/20181024172139600?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"947\" /></p>\n\n<p style=\"text-indent:50px;\">计数排序虽然时间复杂度小O(n)，但是局限性很大，首先是需要知道最大数是多少，其次当无序列表分布很分散例如[1,3,1000000]，明明只有三个数但是却需要开辟一个长度为1000000的空列表，会造成空间浪费。所以计数排序只适合在特定的情况下使用。</p>\n\n<h3 style=\"text-indent:0px;\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def count_sort(nums, max_num):\n    \"\"\"\n    计数排序\n    :param nums: 无序数组\n    :param max_num: 最大数\n    \"\"\"\n    count = [0 for x in range(max_num+1)]  # 新建一个统计数组\n    for i in nums:  # 计数\n        count[i] += 1\n    nums.clear()  # 清空原有数组\n    for c, i in enumerate(count):  # 往空数组中添加元素\n        while i &gt; 0:\n            nums.append(c)\n            i -= 1</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<h3>算法思路：</h3>\n\n<p style=\"text-indent:50px;\">顾名思义计数排序就是统计每个数出现的次数，例如给0-20范围内的数排序，首先建立一个长度为21的空数组，然后统计每个数出现的次数，再按照下标存入空数组中，例如1出现10次那么数组中的第二个元素为10 ，统计完所有的数之后呢在新建一个数组，在遍历之前存放次数的数组，按照个数往新数组中添加对应的数。</p>\n\n<p style=\"text-indent:50px;\">以一个例子来说明[1,2,3,1,0,4,1,3,4,2,0,1,2,3,4]排序过程如下图所示</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"301\" src=\"https://img-blog.csdn.net/20181024172139600?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"947\" /></p>\n\n<p style=\"text-indent:50px;\">计数排序虽然时间复杂度小O(n)，但是局限性很大，首先是需要知道最大数是多少，其次当无序列表分布很分散例如[1,3,1000000]，明明只有三个数但是却需要开辟一个长度为1000000的空列表，会造成空间浪费。所以计数排序只适合在特定的情况下使用。</p>\n\n<h3 style=\"text-indent:0px;\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def count_sort(nums, max_num):\n    \"\"\"\n    计数排序\n    :param nums: 无序数组\n    :param max_num: 最大数\n    \"\"\"\n    count = [0 for x in range(max_num+1)]  # 新建一个统计数组\n    for i in nums:  # 计数\n        count[i] += 1\n    nums.clear()  # 清空原有数组\n    for c, i in enumerate(count):  # 往空数组中添加元素\n        while i &gt; 0:\n            nums.append(c)\n            i -= 1</code></pre>\n\n<p> </p>"},{"_content":"<h3>算法思路</h3>\n\n<p style=\"text-indent:50px;\">插入排序就跟我们打扑克抽牌是一样的形式，每次新抽的牌插入到已有的有序牌中，是牌始终保持有序状态，例如[1,3, 2,4,0] 数组，先将1作为起始牌，下一张牌为3，第一趟完成后变成[1, 3]有序数组和[2,4,0]无序数组，接下来插入2，有序数组变成[1,2,3]，无序数组变成[4,0]，以此类推知道将所有的无序数组都插入完毕就能完成排序操作。</p>\n\n<p style=\"text-indent:50px;\">插入排序算法适用于少量数据的排序，时间复杂度为 O(n^2)。是一种稳定的排序方法。</p>\n\n<h3 style=\"text-indent:0px;\">代码实现</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def insert_sort(nums):\n    for i in range(1,len(nums)):  # 无序区[i:]\n        temp = nums[i]  # 无序区的第一个数\n        j = i - 1  # 有序区的最后一个\n        while j &gt;= 0 and nums[j] &gt; temp:  # 执行插入操作\n            nums[j+1] = nums[j] \n            j -= 1\n        nums[j+1] = temp\n        print(nums)\n\n\ninsert_sort([1,3, 2,4,0])\n\n# [1, 3, 2, 4, 0]\n# [1, 2, 3, 4, 0]\n# [1, 2, 3, 4, 0]\n# [0, 1, 2, 3, 4]</code></pre>\n\n<p> </p>","source":"_posts/blogs-常用排序算法：直接插入排序.md","raw":"<h3>算法思路</h3>\n\n<p style=\"text-indent:50px;\">插入排序就跟我们打扑克抽牌是一样的形式，每次新抽的牌插入到已有的有序牌中，是牌始终保持有序状态，例如[1,3, 2,4,0] 数组，先将1作为起始牌，下一张牌为3，第一趟完成后变成[1, 3]有序数组和[2,4,0]无序数组，接下来插入2，有序数组变成[1,2,3]，无序数组变成[4,0]，以此类推知道将所有的无序数组都插入完毕就能完成排序操作。</p>\n\n<p style=\"text-indent:50px;\">插入排序算法适用于少量数据的排序，时间复杂度为 O(n^2)。是一种稳定的排序方法。</p>\n\n<h3 style=\"text-indent:0px;\">代码实现</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def insert_sort(nums):\n    for i in range(1,len(nums)):  # 无序区[i:]\n        temp = nums[i]  # 无序区的第一个数\n        j = i - 1  # 有序区的最后一个\n        while j &gt;= 0 and nums[j] &gt; temp:  # 执行插入操作\n            nums[j+1] = nums[j] \n            j -= 1\n        nums[j+1] = temp\n        print(nums)\n\n\ninsert_sort([1,3, 2,4,0])\n\n# [1, 3, 2, 4, 0]\n# [1, 2, 3, 4, 0]\n# [1, 2, 3, 4, 0]\n# [0, 1, 2, 3, 4]</code></pre>\n\n<p> </p>","slug":"blogs-常用排序算法：直接插入排序","published":1,"date":"2022-03-16T17:01:15.927Z","updated":"2022-03-16T17:06:05.669Z","_id":"cl0v6keqd000hyms4cw724jd1","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>算法思路</h3>\n\n<p style=\"text-indent:50px;\">插入排序就跟我们打扑克抽牌是一样的形式，每次新抽的牌插入到已有的有序牌中，是牌始终保持有序状态，例如[1,3, 2,4,0] 数组，先将1作为起始牌，下一张牌为3，第一趟完成后变成[1, 3]有序数组和[2,4,0]无序数组，接下来插入2，有序数组变成[1,2,3]，无序数组变成[4,0]，以此类推知道将所有的无序数组都插入完毕就能完成排序操作。</p>\n\n<p style=\"text-indent:50px;\">插入排序算法适用于少量数据的排序，时间复杂度为 O(n^2)。是一种稳定的排序方法。</p>\n\n<h3 style=\"text-indent:0px;\">代码实现</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def insert_sort(nums):\n    for i in range(1,len(nums)):  # 无序区[i:]\n        temp = nums[i]  # 无序区的第一个数\n        j = i - 1  # 有序区的最后一个\n        while j &gt;= 0 and nums[j] &gt; temp:  # 执行插入操作\n            nums[j+1] = nums[j] \n            j -= 1\n        nums[j+1] = temp\n        print(nums)\n\n\ninsert_sort([1,3, 2,4,0])\n\n# [1, 3, 2, 4, 0]\n# [1, 2, 3, 4, 0]\n# [1, 2, 3, 4, 0]\n# [0, 1, 2, 3, 4]</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<h3>算法思路</h3>\n\n<p style=\"text-indent:50px;\">插入排序就跟我们打扑克抽牌是一样的形式，每次新抽的牌插入到已有的有序牌中，是牌始终保持有序状态，例如[1,3, 2,4,0] 数组，先将1作为起始牌，下一张牌为3，第一趟完成后变成[1, 3]有序数组和[2,4,0]无序数组，接下来插入2，有序数组变成[1,2,3]，无序数组变成[4,0]，以此类推知道将所有的无序数组都插入完毕就能完成排序操作。</p>\n\n<p style=\"text-indent:50px;\">插入排序算法适用于少量数据的排序，时间复杂度为 O(n^2)。是一种稳定的排序方法。</p>\n\n<h3 style=\"text-indent:0px;\">代码实现</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def insert_sort(nums):\n    for i in range(1,len(nums)):  # 无序区[i:]\n        temp = nums[i]  # 无序区的第一个数\n        j = i - 1  # 有序区的最后一个\n        while j &gt;= 0 and nums[j] &gt; temp:  # 执行插入操作\n            nums[j+1] = nums[j] \n            j -= 1\n        nums[j+1] = temp\n        print(nums)\n\n\ninsert_sort([1,3, 2,4,0])\n\n# [1, 3, 2, 4, 0]\n# [1, 2, 3, 4, 0]\n# [1, 2, 3, 4, 0]\n# [0, 1, 2, 3, 4]</code></pre>\n\n<p> </p>"},{"_content":"<h3 id=\"%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%EF%BC%9A\">算法思路：</h3>\n\n<p style=\"text-indent:50px;\">步骤：1. 创建10个队列(0-9)<br />\n                      2. 遍历每个数位，按照位数存入不同的桶中<br />\n                      3. 然后再将桶中的元素依次取出，放回到原有列表中<br />\n                      4. 继续执行上两步操作，直到列表中每个数的每一位都做完成排序<br />\n                      5. 最后取出桶内元素，排序完成</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"357\" src=\"https://img-blog.csdn.net/20181025144312786?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"800\" /></p>\n\n<p style=\"text-indent:50px;\">时间复杂度： O(kn)  k为最大数位数                   空间复杂度：O(k+n)</p>\n\n<h3 id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def radix_sort(nums):\n    max_num = max(nums)\n    bucket = [[] for _ in range(10)]  # 创建空桶\n    i = 0\n    while 10 ** i &lt; max_num:\n        # 按位数将数组存入桶中\n        for num in nums:\n            bucket[num // (10 ** i) % 10].append(num)\n        nums.clear()\n        for j in bucket:  # 取出桶中元素，顺便情况桶\n            nums.extend(j)\n            j.clear()\n        i += 1</code></pre>\n\n<p> </p>","source":"_posts/blogs-常用排序算法：基数排序.md","raw":"<h3 id=\"%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%EF%BC%9A\">算法思路：</h3>\n\n<p style=\"text-indent:50px;\">步骤：1. 创建10个队列(0-9)<br />\n                      2. 遍历每个数位，按照位数存入不同的桶中<br />\n                      3. 然后再将桶中的元素依次取出，放回到原有列表中<br />\n                      4. 继续执行上两步操作，直到列表中每个数的每一位都做完成排序<br />\n                      5. 最后取出桶内元素，排序完成</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"357\" src=\"https://img-blog.csdn.net/20181025144312786?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"800\" /></p>\n\n<p style=\"text-indent:50px;\">时间复杂度： O(kn)  k为最大数位数                   空间复杂度：O(k+n)</p>\n\n<h3 id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def radix_sort(nums):\n    max_num = max(nums)\n    bucket = [[] for _ in range(10)]  # 创建空桶\n    i = 0\n    while 10 ** i &lt; max_num:\n        # 按位数将数组存入桶中\n        for num in nums:\n            bucket[num // (10 ** i) % 10].append(num)\n        nums.clear()\n        for j in bucket:  # 取出桶中元素，顺便情况桶\n            nums.extend(j)\n            j.clear()\n        i += 1</code></pre>\n\n<p> </p>","slug":"blogs-常用排序算法：基数排序","published":1,"date":"2022-03-16T17:01:07.596Z","updated":"2022-03-16T17:05:57.273Z","_id":"cl0v6keqe000iyms4cgsd8hd2","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%EF%BC%9A\">算法思路：</h3>\n\n<p style=\"text-indent:50px;\">步骤：1. 创建10个队列(0-9)<br />\n                      2. 遍历每个数位，按照位数存入不同的桶中<br />\n                      3. 然后再将桶中的元素依次取出，放回到原有列表中<br />\n                      4. 继续执行上两步操作，直到列表中每个数的每一位都做完成排序<br />\n                      5. 最后取出桶内元素，排序完成</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"357\" src=\"https://img-blog.csdn.net/20181025144312786?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"800\" /></p>\n\n<p style=\"text-indent:50px;\">时间复杂度： O(kn)  k为最大数位数                   空间复杂度：O(k+n)</p>\n\n<h3 id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def radix_sort(nums):\n    max_num = max(nums)\n    bucket = [[] for _ in range(10)]  # 创建空桶\n    i = 0\n    while 10 ** i &lt; max_num:\n        # 按位数将数组存入桶中\n        for num in nums:\n            bucket[num // (10 ** i) % 10].append(num)\n        nums.clear()\n        for j in bucket:  # 取出桶中元素，顺便情况桶\n            nums.extend(j)\n            j.clear()\n        i += 1</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%EF%BC%9A\">算法思路：</h3>\n\n<p style=\"text-indent:50px;\">步骤：1. 创建10个队列(0-9)<br />\n                      2. 遍历每个数位，按照位数存入不同的桶中<br />\n                      3. 然后再将桶中的元素依次取出，放回到原有列表中<br />\n                      4. 继续执行上两步操作，直到列表中每个数的每一位都做完成排序<br />\n                      5. 最后取出桶内元素，排序完成</p>\n\n<p style=\"text-align:center;\"><img alt=\"\" class=\"has\" height=\"357\" src=\"https://img-blog.csdn.net/20181025144312786?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"800\" /></p>\n\n<p style=\"text-indent:50px;\">时间复杂度： O(kn)  k为最大数位数                   空间复杂度：O(k+n)</p>\n\n<h3 id=\"%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A\">代码实现：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">def radix_sort(nums):\n    max_num = max(nums)\n    bucket = [[] for _ in range(10)]  # 创建空桶\n    i = 0\n    while 10 ** i &lt; max_num:\n        # 按位数将数组存入桶中\n        for num in nums:\n            bucket[num // (10 ** i) % 10].append(num)\n        nums.clear()\n        for j in bucket:  # 取出桶中元素，顺便情况桶\n            nums.extend(j)\n            j.clear()\n        i += 1</code></pre>\n\n<p> </p>"},{"_content":"<h3>直接选择排序算法思路：</h3>\n\n<p style=\"text-indent:50px;\">第 1 趟，在待排序记录 r1 ~ r[n]中选出最小的记录，将它与 r1 交换；第 2 趟， 在待排序记录 r2 ~ r[n]中选出最小的记录，将它与 r2 交换；以此类推，第 i 趟在待排序 记录 r[i] ~ r[n]中选出最小的记录，将它与 r[i]交换，使有序序列不断增长直到全部排序 完毕。</p>\n\n<p style=\"text-indent:50px;\">例如[2, 4, 3, 1, 0]，第一趟找到最小值为0，将0和第一位交换，得到[0, 4, 3, 1, 2]，第二趟从[4, 3, 1, 2]中找到最小值1，再和第一位交换得到[0, 1, 3, 4, 2]，以此类推知道排序完成。</p>\n\n<h3>代码实现：</h3>\n\n<pre class=\"has\">\n<code>def select_sort(nums):\n    for i in range(len(nums)):  # 第i趟开始时 无序区为：[i:]\n        min_pos = i  # 最小值位置\n        for j in range(i + 1, len(nums)):  # 在无序区里面找最小值，并记录位置\n            if nums[j] &lt; nums[min_pos]:\n                min_pos = j\n        nums[min_pos], nums[i] = nums[i], nums[min_pos]  # 交换\n        print(nums)\n\n\nselect_sort([2, 4, 3, 1, 0])\n\n# [0, 4, 3, 1, 2]\n# [0, 1, 3, 4, 2]\n# [0, 1, 2, 4, 3]\n# [0, 1, 2, 3, 4]\n# [0, 1, 2, 3, 4]</code></pre>\n\n<p> </p>","source":"_posts/blogs-常用排序算法：直接选择排序.md","raw":"<h3>直接选择排序算法思路：</h3>\n\n<p style=\"text-indent:50px;\">第 1 趟，在待排序记录 r1 ~ r[n]中选出最小的记录，将它与 r1 交换；第 2 趟， 在待排序记录 r2 ~ r[n]中选出最小的记录，将它与 r2 交换；以此类推，第 i 趟在待排序 记录 r[i] ~ r[n]中选出最小的记录，将它与 r[i]交换，使有序序列不断增长直到全部排序 完毕。</p>\n\n<p style=\"text-indent:50px;\">例如[2, 4, 3, 1, 0]，第一趟找到最小值为0，将0和第一位交换，得到[0, 4, 3, 1, 2]，第二趟从[4, 3, 1, 2]中找到最小值1，再和第一位交换得到[0, 1, 3, 4, 2]，以此类推知道排序完成。</p>\n\n<h3>代码实现：</h3>\n\n<pre class=\"has\">\n<code>def select_sort(nums):\n    for i in range(len(nums)):  # 第i趟开始时 无序区为：[i:]\n        min_pos = i  # 最小值位置\n        for j in range(i + 1, len(nums)):  # 在无序区里面找最小值，并记录位置\n            if nums[j] &lt; nums[min_pos]:\n                min_pos = j\n        nums[min_pos], nums[i] = nums[i], nums[min_pos]  # 交换\n        print(nums)\n\n\nselect_sort([2, 4, 3, 1, 0])\n\n# [0, 4, 3, 1, 2]\n# [0, 1, 3, 4, 2]\n# [0, 1, 2, 4, 3]\n# [0, 1, 2, 3, 4]\n# [0, 1, 2, 3, 4]</code></pre>\n\n<p> </p>","slug":"blogs-常用排序算法：直接选择排序","published":1,"date":"2022-03-16T17:01:17.131Z","updated":"2022-03-16T17:06:06.831Z","_id":"cl0v6keqi000jyms413rec8rn","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>直接选择排序算法思路：</h3>\n\n<p style=\"text-indent:50px;\">第 1 趟，在待排序记录 r1 ~ r[n]中选出最小的记录，将它与 r1 交换；第 2 趟， 在待排序记录 r2 ~ r[n]中选出最小的记录，将它与 r2 交换；以此类推，第 i 趟在待排序 记录 r[i] ~ r[n]中选出最小的记录，将它与 r[i]交换，使有序序列不断增长直到全部排序 完毕。</p>\n\n<p style=\"text-indent:50px;\">例如[2, 4, 3, 1, 0]，第一趟找到最小值为0，将0和第一位交换，得到[0, 4, 3, 1, 2]，第二趟从[4, 3, 1, 2]中找到最小值1，再和第一位交换得到[0, 1, 3, 4, 2]，以此类推知道排序完成。</p>\n\n<h3>代码实现：</h3>\n\n<pre class=\"has\">\n<code>def select_sort(nums):\n    for i in range(len(nums)):  # 第i趟开始时 无序区为：[i:]\n        min_pos = i  # 最小值位置\n        for j in range(i + 1, len(nums)):  # 在无序区里面找最小值，并记录位置\n            if nums[j] &lt; nums[min_pos]:\n                min_pos = j\n        nums[min_pos], nums[i] = nums[i], nums[min_pos]  # 交换\n        print(nums)\n\n\nselect_sort([2, 4, 3, 1, 0])\n\n# [0, 4, 3, 1, 2]\n# [0, 1, 3, 4, 2]\n# [0, 1, 2, 4, 3]\n# [0, 1, 2, 3, 4]\n# [0, 1, 2, 3, 4]</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<h3>直接选择排序算法思路：</h3>\n\n<p style=\"text-indent:50px;\">第 1 趟，在待排序记录 r1 ~ r[n]中选出最小的记录，将它与 r1 交换；第 2 趟， 在待排序记录 r2 ~ r[n]中选出最小的记录，将它与 r2 交换；以此类推，第 i 趟在待排序 记录 r[i] ~ r[n]中选出最小的记录，将它与 r[i]交换，使有序序列不断增长直到全部排序 完毕。</p>\n\n<p style=\"text-indent:50px;\">例如[2, 4, 3, 1, 0]，第一趟找到最小值为0，将0和第一位交换，得到[0, 4, 3, 1, 2]，第二趟从[4, 3, 1, 2]中找到最小值1，再和第一位交换得到[0, 1, 3, 4, 2]，以此类推知道排序完成。</p>\n\n<h3>代码实现：</h3>\n\n<pre class=\"has\">\n<code>def select_sort(nums):\n    for i in range(len(nums)):  # 第i趟开始时 无序区为：[i:]\n        min_pos = i  # 最小值位置\n        for j in range(i + 1, len(nums)):  # 在无序区里面找最小值，并记录位置\n            if nums[j] &lt; nums[min_pos]:\n                min_pos = j\n        nums[min_pos], nums[i] = nums[i], nums[min_pos]  # 交换\n        print(nums)\n\n\nselect_sort([2, 4, 3, 1, 0])\n\n# [0, 4, 3, 1, 2]\n# [0, 1, 3, 4, 2]\n# [0, 1, 2, 4, 3]\n# [0, 1, 2, 3, 4]\n# [0, 1, 2, 3, 4]</code></pre>\n\n<p> </p>"},{"title":"Ajax","date":"2018-05-04T04:12:57.000Z","_content":"## Ajax\nAJAX即Asynchronous JavaScript and XML (异步的JavaScript和XML)，一种创建交互式网页应用的网页开发技术方案。之前我们在页面进行操作的时候往往会导致整个页面进行刷新，这样的体验往往不是很好，使用ajax发送请求的时候可以在后台处理请求和响应，例如在用户登录的时候提示用户当前输入的用户名是否正确，或者验证密码等等操作。\n### 原生Ajax\n原生的ajax是基于XmlHttpRequest对象进行操作的，因此要使用原生ajax先来看看XmlHttpRequest对象的主要方法和属性：\n- 方法：\n``` javascript\n   用于创建请求\n    \n   参数：\n       method： 请求方式（字符串类型），如：POST、GET、DELETE...\n       url：    要请求的地址（字符串类型）\n       async：  是否异步（布尔类型）\n \nb. void send(String body)\n    用于发送请求\n \n    参数：\n        body： 要发送的数据（字符串类型）\n \nc. void setRequestHeader(String header,String value)\n    用于设置请求头\n \n    参数：\n        header： 请求头的key（字符串类型）\n        vlaue：  请求头的value（字符串类型）\n \nd. String getAllResponseHeaders()\n    获取所有响应头\n \n    返回值：\n        响应头数据（字符串类型）\n \ne. String getResponseHeader(String header)\n    获取响应头中指定header的值\n \n    参数：\n        header： 响应头的key（字符串类型）\n \n    返回值：\n        响应头中指定的header对应的值\n \nf. void abort()\n \n    终止请求</pre>\n```\n- 属性：\n``` javascript\n   状态值（整数）\n \n   详细：\n      0-未初始化，尚未调用open()方法；\n      1-启动，调用了open()方法，未调用send()方法；\n      2-发送，已经调用了send()方法，未接收到响应；\n      3-接收，已经接收到部分响应数据；\n      4-完成，已经接收到全部响应数据；\n \nb. Function onreadystatechange\n   当readyState的值改变时自动触发执行其对应的函数（回调函数）\n \nc. String responseText\n   服务器返回的数据（字符串类型）\n \nd. XmlDocument responseXML\n   服务器返回的数据（Xml对象）\n \ne. Number states\n   状态码（整数），如：200、404...\n \nf. String statesText\n   状态文本（字符串），如：OK、NotFound...\n```\n\n有了上面的知识我们来实现一个最简单的原生ajax请求\n\najax_test.html:\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <input type=\"button\" value=\"test\" onclick=\"ajax_test();\">\n    <script>\n        function ajax_test() {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"POST\",'/ajax_receive/',true);\n            //设置请求头\n            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset-UTF-8');\n            xhr.send(\"name=root;password=123\");\n        }\n    </script>\n</body>\n</html>\n```\najax_receive处理函数：\n``` python\ndef ajax_receive(request):\n    if request.method == \"POST\":\n        print(request.POST)\n        return HttpResponse(\"l\")\n```\n点击按钮后台运行结果：\n```\n[04/May/2018 15:20:21] \"GET /ajax_receive/?t=1 HTTP/1.1\" 200 2\n<QueryDict: {'name': ['root'], 'password': ['123']}>\n```\n\n需要注意的是，使用原生ajax发送数据的时候必须要设置请求头，否则无法正常接收解析发送过来的数据\n\n### JQuery的ajax\njquery的ajax也是基于XmlHttpRequest或者ActiveXObject的\n- 常用参数及作用:\n```\nurl：请求地址\ntype：请求方式，GET、POST（1.9.0之后用method）\nheaders：请求头\ndata：要发送的数据\ncontentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\")\nasync：是否异步\ntimeout：设置请求超时时间（毫秒）\nbeforeSend：发送请求前执行的函数(全局)\ncomplete：完成之后执行的回调函数(全局)\nsuccess：成功之后执行的回调函数(全局)\nerror：失败之后执行的回调函数(全局)\n\n\naccepts：通过请求头发送给服务器，告诉服务器当前客户端课接受的数据类型\ndataType：将服务器端返回的数据转换成指定类型\n    \"xml\": 将服务器端返回的内容转换成xml&#26684;式\n    \"text\": 将服务器端返回的内容转换成普通文本&#26684;式\n    \"html\": 将服务器端返回的内容转换成普通文本&#26684;式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。\n    \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本&#26684;式\n    \"json\": 将服务器端返回的内容转换成相应的JavaScript对象\n    \"jsonp\": JSONP &#26684;式 使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数\n\nconverters： 转换器，将服务器端的内容根据指定的dataType转换类型，并传值给success回调函数\n```\n- 示例\n``` html\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n\n    <p>\n        <input type=\"button\" onclick=\"JqSendRequest();\" value='Ajax请求' />\n    </p>\n    <script type=\"text/javascript\" src=\"../static/js/jquery-1.11.0.min.js\"></script>\n    <script>\n\n        function JqSendRequest(){\n            $.ajax({\n                url: \"/ajax_receive/\",\n                type: 'GET',\n                dataType: 'text',\n                data:{\"name\":\"root\"},\n                success: function(data){\n                    alert(data)\n                }\n            })\n        }\n    </script>\n</body>\n</html>\n``` \n接收函数\n``` python\ndef ajax_receive(request):\n    if request.method == \"POST\":\n        print(request.POST)\n        return HttpResponse(\"POST\")\n    if request.method == 'GET':\n        print(request.GET)\n        return HttpResponse(\"GET\")\n```\n\n### 使用Ajax提交Form表单实现注册功能实例：\n\n首先需要对form表单做一下调整：\n``` html\n<form id=\"register_form\" onsubmit=\"return false\">\n    <h6>用户名</h6>\n    <input type=\"text\" placeholder=\"用户名\" name=\"username\" required=\"\">\n    <h6>邮箱</h6>\n    <input type=\"text\" class=\"email\" placeholder=\"邮箱\" name=\"Email\">\n    <h6>密码</h6>\n    <input type=\"password\" placeholder=\"密码\" name=\"password\">\n    <h6>确认密码</h6>\n    <input type=\"password\" placeholder=\"确认密码\" name=\"password\">\n    <div class=\"login-bottom\">\n        <input type=\"submit\" value=\"注 册\" onclick=\"login()\">\n        <div class=\"clear\"></div>\n    </div>\n</form>\n```\n为了防止点击submit按钮的时候发生跳转，需要在form中添加 onsubmit=\"return false\"参数，再去掉常用的action，method参数，最后再给submit按钮绑定点击事件，至此form表单完成\n接下来就是js部分：\n``` html\n<script src=\"../../static/js/jquery-1.11.0.min.js\"></script>\n    <script type=\"text/javascript\">\n        function login() {\n            $.ajax({\n                //几个参数需要注意一下\n                type: \"POST\",//方法类型\n                dataType: \"json\",//预期服务器返回的数据类型\n                url: \"/iot/register\",//url\n                data: $('#register_form').serialize(),\n                success: function (data) {\n                    if (data['error'] == \"OK\"){\n                        alert(\"注册成功\")\n                    }\n                    else {\n                        alert(data['error']);\n                    }\n                }\n\n            });\n        }\n    </script>\n```\ndata: 将form表单内容序列化一下，通过post方法发送请求，在回调函数里面显示提示信息。\n\nview函数：\n``` python\ndef register(request):\n    res = {'error':None}\n    if request.method == \"POST\":\n        name = request.POST.get(\"username\")\n        email= request.POST.get(\"Email\")\n        password =request.POST.getlist(\"password\")\n        print(password)\n        if password[0] != password[1]:\n            res['error'] = \"两次密码不同，请重新填写\"\n        else:\n            res['error'] = 'OK'\n        return HttpResponse(json.dumps(res),content_type=\"application/json\")\n```\n通过getlist方法获取列表多个值，判断两个密码是否相同，并把结果一json格式发送给前端。\n","source":"_posts/blogs-Ajax.md","raw":"---\ntitle: Ajax\ndate: 2018-05-04 12:12:57\ncategories: \n- 前端\ntags:\n- jQuery\n- 网络请求\n---\n## Ajax\nAJAX即Asynchronous JavaScript and XML (异步的JavaScript和XML)，一种创建交互式网页应用的网页开发技术方案。之前我们在页面进行操作的时候往往会导致整个页面进行刷新，这样的体验往往不是很好，使用ajax发送请求的时候可以在后台处理请求和响应，例如在用户登录的时候提示用户当前输入的用户名是否正确，或者验证密码等等操作。\n### 原生Ajax\n原生的ajax是基于XmlHttpRequest对象进行操作的，因此要使用原生ajax先来看看XmlHttpRequest对象的主要方法和属性：\n- 方法：\n``` javascript\n   用于创建请求\n    \n   参数：\n       method： 请求方式（字符串类型），如：POST、GET、DELETE...\n       url：    要请求的地址（字符串类型）\n       async：  是否异步（布尔类型）\n \nb. void send(String body)\n    用于发送请求\n \n    参数：\n        body： 要发送的数据（字符串类型）\n \nc. void setRequestHeader(String header,String value)\n    用于设置请求头\n \n    参数：\n        header： 请求头的key（字符串类型）\n        vlaue：  请求头的value（字符串类型）\n \nd. String getAllResponseHeaders()\n    获取所有响应头\n \n    返回值：\n        响应头数据（字符串类型）\n \ne. String getResponseHeader(String header)\n    获取响应头中指定header的值\n \n    参数：\n        header： 响应头的key（字符串类型）\n \n    返回值：\n        响应头中指定的header对应的值\n \nf. void abort()\n \n    终止请求</pre>\n```\n- 属性：\n``` javascript\n   状态值（整数）\n \n   详细：\n      0-未初始化，尚未调用open()方法；\n      1-启动，调用了open()方法，未调用send()方法；\n      2-发送，已经调用了send()方法，未接收到响应；\n      3-接收，已经接收到部分响应数据；\n      4-完成，已经接收到全部响应数据；\n \nb. Function onreadystatechange\n   当readyState的值改变时自动触发执行其对应的函数（回调函数）\n \nc. String responseText\n   服务器返回的数据（字符串类型）\n \nd. XmlDocument responseXML\n   服务器返回的数据（Xml对象）\n \ne. Number states\n   状态码（整数），如：200、404...\n \nf. String statesText\n   状态文本（字符串），如：OK、NotFound...\n```\n\n有了上面的知识我们来实现一个最简单的原生ajax请求\n\najax_test.html:\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    <input type=\"button\" value=\"test\" onclick=\"ajax_test();\">\n    <script>\n        function ajax_test() {\n            var xhr = new XMLHttpRequest();\n            xhr.open(\"POST\",'/ajax_receive/',true);\n            //设置请求头\n            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset-UTF-8');\n            xhr.send(\"name=root;password=123\");\n        }\n    </script>\n</body>\n</html>\n```\najax_receive处理函数：\n``` python\ndef ajax_receive(request):\n    if request.method == \"POST\":\n        print(request.POST)\n        return HttpResponse(\"l\")\n```\n点击按钮后台运行结果：\n```\n[04/May/2018 15:20:21] \"GET /ajax_receive/?t=1 HTTP/1.1\" 200 2\n<QueryDict: {'name': ['root'], 'password': ['123']}>\n```\n\n需要注意的是，使用原生ajax发送数据的时候必须要设置请求头，否则无法正常接收解析发送过来的数据\n\n### JQuery的ajax\njquery的ajax也是基于XmlHttpRequest或者ActiveXObject的\n- 常用参数及作用:\n```\nurl：请求地址\ntype：请求方式，GET、POST（1.9.0之后用method）\nheaders：请求头\ndata：要发送的数据\ncontentType：即将发送信息至服务器的内容编码类型(默认: \"application/x-www-form-urlencoded; charset=UTF-8\")\nasync：是否异步\ntimeout：设置请求超时时间（毫秒）\nbeforeSend：发送请求前执行的函数(全局)\ncomplete：完成之后执行的回调函数(全局)\nsuccess：成功之后执行的回调函数(全局)\nerror：失败之后执行的回调函数(全局)\n\n\naccepts：通过请求头发送给服务器，告诉服务器当前客户端课接受的数据类型\ndataType：将服务器端返回的数据转换成指定类型\n    \"xml\": 将服务器端返回的内容转换成xml&#26684;式\n    \"text\": 将服务器端返回的内容转换成普通文本&#26684;式\n    \"html\": 将服务器端返回的内容转换成普通文本&#26684;式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。\n    \"script\": 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本&#26684;式\n    \"json\": 将服务器端返回的内容转换成相应的JavaScript对象\n    \"jsonp\": JSONP &#26684;式 使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数\n\nconverters： 转换器，将服务器端的内容根据指定的dataType转换类型，并传值给success回调函数\n```\n- 示例\n``` html\n<head lang=\"en\">\n    <meta charset=\"UTF-8\">\n    <title></title>\n</head>\n<body>\n\n    <p>\n        <input type=\"button\" onclick=\"JqSendRequest();\" value='Ajax请求' />\n    </p>\n    <script type=\"text/javascript\" src=\"../static/js/jquery-1.11.0.min.js\"></script>\n    <script>\n\n        function JqSendRequest(){\n            $.ajax({\n                url: \"/ajax_receive/\",\n                type: 'GET',\n                dataType: 'text',\n                data:{\"name\":\"root\"},\n                success: function(data){\n                    alert(data)\n                }\n            })\n        }\n    </script>\n</body>\n</html>\n``` \n接收函数\n``` python\ndef ajax_receive(request):\n    if request.method == \"POST\":\n        print(request.POST)\n        return HttpResponse(\"POST\")\n    if request.method == 'GET':\n        print(request.GET)\n        return HttpResponse(\"GET\")\n```\n\n### 使用Ajax提交Form表单实现注册功能实例：\n\n首先需要对form表单做一下调整：\n``` html\n<form id=\"register_form\" onsubmit=\"return false\">\n    <h6>用户名</h6>\n    <input type=\"text\" placeholder=\"用户名\" name=\"username\" required=\"\">\n    <h6>邮箱</h6>\n    <input type=\"text\" class=\"email\" placeholder=\"邮箱\" name=\"Email\">\n    <h6>密码</h6>\n    <input type=\"password\" placeholder=\"密码\" name=\"password\">\n    <h6>确认密码</h6>\n    <input type=\"password\" placeholder=\"确认密码\" name=\"password\">\n    <div class=\"login-bottom\">\n        <input type=\"submit\" value=\"注 册\" onclick=\"login()\">\n        <div class=\"clear\"></div>\n    </div>\n</form>\n```\n为了防止点击submit按钮的时候发生跳转，需要在form中添加 onsubmit=\"return false\"参数，再去掉常用的action，method参数，最后再给submit按钮绑定点击事件，至此form表单完成\n接下来就是js部分：\n``` html\n<script src=\"../../static/js/jquery-1.11.0.min.js\"></script>\n    <script type=\"text/javascript\">\n        function login() {\n            $.ajax({\n                //几个参数需要注意一下\n                type: \"POST\",//方法类型\n                dataType: \"json\",//预期服务器返回的数据类型\n                url: \"/iot/register\",//url\n                data: $('#register_form').serialize(),\n                success: function (data) {\n                    if (data['error'] == \"OK\"){\n                        alert(\"注册成功\")\n                    }\n                    else {\n                        alert(data['error']);\n                    }\n                }\n\n            });\n        }\n    </script>\n```\ndata: 将form表单内容序列化一下，通过post方法发送请求，在回调函数里面显示提示信息。\n\nview函数：\n``` python\ndef register(request):\n    res = {'error':None}\n    if request.method == \"POST\":\n        name = request.POST.get(\"username\")\n        email= request.POST.get(\"Email\")\n        password =request.POST.getlist(\"password\")\n        print(password)\n        if password[0] != password[1]:\n            res['error'] = \"两次密码不同，请重新填写\"\n        else:\n            res['error'] = 'OK'\n        return HttpResponse(json.dumps(res),content_type=\"application/json\")\n```\n通过getlist方法获取列表多个值，判断两个密码是否相同，并把结果一json格式发送给前端。\n","slug":"blogs-Ajax","published":1,"updated":"2022-03-20T15:50:46.778Z","_id":"cl0v6kes6000kyms40l1w9til","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Ajax\"><a href=\"#Ajax\" class=\"headerlink\" title=\"Ajax\"></a>Ajax</h2><p>AJAX即Asynchronous JavaScript and XML (异步的JavaScript和XML)，一种创建交互式网页应用的网页开发技术方案。之前我们在页面进行操作的时候往往会导致整个页面进行刷新，这样的体验往往不是很好，使用ajax发送请求的时候可以在后台处理请求和响应，例如在用户登录的时候提示用户当前输入的用户名是否正确，或者验证密码等等操作。</p>\n<h3 id=\"原生Ajax\"><a href=\"#原生Ajax\" class=\"headerlink\" title=\"原生Ajax\"></a>原生Ajax</h3><p>原生的ajax是基于XmlHttpRequest对象进行操作的，因此要使用原生ajax先来看看XmlHttpRequest对象的主要方法和属性：</p>\n<ul>\n<li>方法：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   用于创建请求</span><br><span class=\"line\">    </span><br><span class=\"line\">   参数：</span><br><span class=\"line\">       method： 请求方式（字符串类型），如：<span class=\"variable constant_\">POST</span>、<span class=\"variable constant_\">GET</span>、<span class=\"variable constant_\">DELETE</span>...</span><br><span class=\"line\">       url：    要请求的地址（字符串类型）</span><br><span class=\"line\">       <span class=\"keyword\">async</span>：  是否异步（布尔类型）</span><br><span class=\"line\"> </span><br><span class=\"line\">b. <span class=\"keyword\">void</span> <span class=\"title function_\">send</span>(<span class=\"title class_\">String</span> body)</span><br><span class=\"line\">    用于发送请求</span><br><span class=\"line\"> </span><br><span class=\"line\">    参数：</span><br><span class=\"line\">        body： 要发送的数据（字符串类型）</span><br><span class=\"line\"> </span><br><span class=\"line\">c. <span class=\"keyword\">void</span> <span class=\"title function_\">setRequestHeader</span>(<span class=\"title class_\">String</span> header,<span class=\"title class_\">String</span> value)</span><br><span class=\"line\">    用于设置请求头</span><br><span class=\"line\"> </span><br><span class=\"line\">    参数：</span><br><span class=\"line\">        header： 请求头的key（字符串类型）</span><br><span class=\"line\">        vlaue：  请求头的value（字符串类型）</span><br><span class=\"line\"> </span><br><span class=\"line\">d. <span class=\"title class_\">String</span> <span class=\"title function_\">getAllResponseHeaders</span>()</span><br><span class=\"line\">    获取所有响应头</span><br><span class=\"line\"> </span><br><span class=\"line\">    返回值：</span><br><span class=\"line\">        响应头数据（字符串类型）</span><br><span class=\"line\"> </span><br><span class=\"line\">e. <span class=\"title class_\">String</span> <span class=\"title function_\">getResponseHeader</span>(<span class=\"title class_\">String</span> header)</span><br><span class=\"line\">    获取响应头中指定header的值</span><br><span class=\"line\"> </span><br><span class=\"line\">    参数：</span><br><span class=\"line\">        header： 响应头的key（字符串类型）</span><br><span class=\"line\"> </span><br><span class=\"line\">    返回值：</span><br><span class=\"line\">        响应头中指定的header对应的值</span><br><span class=\"line\"> </span><br><span class=\"line\">f. <span class=\"keyword\">void</span> <span class=\"title function_\">abort</span>()</span><br><span class=\"line\"> </span><br><span class=\"line\">    终止请求&lt;/pre&gt;</span><br></pre></td></tr></table></figure></li>\n<li>属性：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   状态值（整数）</span><br><span class=\"line\"> </span><br><span class=\"line\">   详细：</span><br><span class=\"line\">      <span class=\"number\">0</span>-未初始化，尚未调用<span class=\"title function_\">open</span>()方法；</span><br><span class=\"line\">      <span class=\"number\">1</span>-启动，调用了<span class=\"title function_\">open</span>()方法，未调用<span class=\"title function_\">send</span>()方法；</span><br><span class=\"line\">      <span class=\"number\">2</span>-发送，已经调用了<span class=\"title function_\">send</span>()方法，未接收到响应；</span><br><span class=\"line\">      <span class=\"number\">3</span>-接收，已经接收到部分响应数据；</span><br><span class=\"line\">      <span class=\"number\">4</span>-完成，已经接收到全部响应数据；</span><br><span class=\"line\"> </span><br><span class=\"line\">b. <span class=\"title class_\">Function</span> onreadystatechange</span><br><span class=\"line\">   当readyState的值改变时自动触发执行其对应的函数（回调函数）</span><br><span class=\"line\"> </span><br><span class=\"line\">c. <span class=\"title class_\">String</span> responseText</span><br><span class=\"line\">   服务器返回的数据（字符串类型）</span><br><span class=\"line\"> </span><br><span class=\"line\">d. <span class=\"title class_\">XmlDocument</span> responseXML</span><br><span class=\"line\">   服务器返回的数据（<span class=\"title class_\">Xml</span>对象）</span><br><span class=\"line\"> </span><br><span class=\"line\">e. <span class=\"title class_\">Number</span> states</span><br><span class=\"line\">   状态码（整数），如：<span class=\"number\">200</span>、<span class=\"number\">404.</span>..</span><br><span class=\"line\"> </span><br><span class=\"line\">f. <span class=\"title class_\">String</span> statesText</span><br><span class=\"line\">   状态文本（字符串），如：<span class=\"variable constant_\">OK</span>、<span class=\"title class_\">NotFound</span>...</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>有了上面的知识我们来实现一个最简单的原生ajax请求</p>\n<p>ajax_test.html:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Title<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;test&quot;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;ajax_test();&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">function</span> <span class=\"title function_\">ajax_test</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>();</span></span><br><span class=\"line\"><span class=\"language-javascript\">            xhr.<span class=\"title function_\">open</span>(<span class=\"string\">&quot;POST&quot;</span>,<span class=\"string\">&#x27;/ajax_receive/&#x27;</span>,<span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"comment\">//设置请求头</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">            xhr.<span class=\"title function_\">setRequestHeader</span>(<span class=\"string\">&#x27;Content-Type&#x27;</span>, <span class=\"string\">&#x27;application/x-www-form-urlencoded; charset-UTF-8&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">            xhr.<span class=\"title function_\">send</span>(<span class=\"string\">&quot;name=root;password=123&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>ajax_receive处理函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ajax_receive</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> request.method == <span class=\"string\">&quot;POST&quot;</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(request.POST)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponse(<span class=\"string\">&quot;l&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>点击按钮后台运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[04/May/2018 15:20:21] &quot;GET /ajax_receive/?t=1 HTTP/1.1&quot; 200 2</span><br><span class=\"line\">&lt;QueryDict: &#123;&#x27;name&#x27;: [&#x27;root&#x27;], &#x27;password&#x27;: [&#x27;123&#x27;]&#125;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，使用原生ajax发送数据的时候必须要设置请求头，否则无法正常接收解析发送过来的数据</p>\n<h3 id=\"JQuery的ajax\"><a href=\"#JQuery的ajax\" class=\"headerlink\" title=\"JQuery的ajax\"></a>JQuery的ajax</h3><p>jquery的ajax也是基于XmlHttpRequest或者ActiveXObject的</p>\n<ul>\n<li>常用参数及作用:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url：请求地址</span><br><span class=\"line\">type：请求方式，GET、POST（1.9.0之后用method）</span><br><span class=\"line\">headers：请求头</span><br><span class=\"line\">data：要发送的数据</span><br><span class=\"line\">contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;)</span><br><span class=\"line\">async：是否异步</span><br><span class=\"line\">timeout：设置请求超时时间（毫秒）</span><br><span class=\"line\">beforeSend：发送请求前执行的函数(全局)</span><br><span class=\"line\">complete：完成之后执行的回调函数(全局)</span><br><span class=\"line\">success：成功之后执行的回调函数(全局)</span><br><span class=\"line\">error：失败之后执行的回调函数(全局)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">accepts：通过请求头发送给服务器，告诉服务器当前客户端课接受的数据类型</span><br><span class=\"line\">dataType：将服务器端返回的数据转换成指定类型</span><br><span class=\"line\">    &quot;xml&quot;: 将服务器端返回的内容转换成xml&amp;#26684;式</span><br><span class=\"line\">    &quot;text&quot;: 将服务器端返回的内容转换成普通文本&amp;#26684;式</span><br><span class=\"line\">    &quot;html&quot;: 将服务器端返回的内容转换成普通文本&amp;#26684;式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。</span><br><span class=\"line\">    &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本&amp;#26684;式</span><br><span class=\"line\">    &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象</span><br><span class=\"line\">    &quot;jsonp&quot;: JSONP &amp;#26684;式 使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数</span><br><span class=\"line\"></span><br><span class=\"line\">converters： 转换器，将服务器端的内容根据指定的dataType转换类型，并传值给success回调函数</span><br></pre></td></tr></table></figure></li>\n<li>示例<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;JqSendRequest();&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&#x27;Ajax请求&#x27;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;../static/js/jquery-1.11.0.min.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">function</span> <span class=\"title function_\">JqSendRequest</span>(<span class=\"params\"></span>)&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            $.<span class=\"title function_\">ajax</span>(&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">url</span>: <span class=\"string\">&quot;/ajax_receive/&quot;</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">type</span>: <span class=\"string\">&#x27;GET&#x27;</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">dataType</span>: <span class=\"string\">&#x27;text&#x27;</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">data</span>:&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;root&quot;</span>&#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">success</span>: <span class=\"keyword\">function</span>(<span class=\"params\">data</span>)&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                    <span class=\"title function_\">alert</span>(data)</span></span><br><span class=\"line\"><span class=\"language-javascript\">                &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            &#125;)</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n接收函数<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ajax_receive</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> request.method == <span class=\"string\">&quot;POST&quot;</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(request.POST)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponse(<span class=\"string\">&quot;POST&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> request.method == <span class=\"string\">&#x27;GET&#x27;</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(request.GET)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponse(<span class=\"string\">&quot;GET&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"使用Ajax提交Form表单实现注册功能实例：\"><a href=\"#使用Ajax提交Form表单实现注册功能实例：\" class=\"headerlink\" title=\"使用Ajax提交Form表单实现注册功能实例：\"></a>使用Ajax提交Form表单实现注册功能实例：</h3><p>首先需要对form表单做一下调整：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;register_form&quot;</span> <span class=\"attr\">onsubmit</span>=<span class=\"string\">&quot;return false&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h6</span>&gt;</span>用户名<span class=\"tag\">&lt;/<span class=\"name\">h6</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;用户名&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">required</span>=<span class=\"string\">&quot;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h6</span>&gt;</span>邮箱<span class=\"tag\">&lt;/<span class=\"name\">h6</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;email&quot;</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;邮箱&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;Email&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h6</span>&gt;</span>密码<span class=\"tag\">&lt;/<span class=\"name\">h6</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;密码&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h6</span>&gt;</span>确认密码<span class=\"tag\">&lt;/<span class=\"name\">h6</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;确认密码&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;login-bottom&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;注 册&quot;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;login()&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;clear&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>为了防止点击submit按钮的时候发生跳转，需要在form中添加 onsubmit=”return false”参数，再去掉常用的action，method参数，最后再给submit按钮绑定点击事件，至此form表单完成<br>接下来就是js部分：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;../../static/js/jquery-1.11.0.min.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">function</span> <span class=\"title function_\">login</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            $.<span class=\"title function_\">ajax</span>(&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"comment\">//几个参数需要注意一下</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">type</span>: <span class=\"string\">&quot;POST&quot;</span>,<span class=\"comment\">//方法类型</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">dataType</span>: <span class=\"string\">&quot;json&quot;</span>,<span class=\"comment\">//预期服务器返回的数据类型</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">url</span>: <span class=\"string\">&quot;/iot/register&quot;</span>,<span class=\"comment\">//url</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">data</span>: $(<span class=\"string\">&#x27;#register_form&#x27;</span>).<span class=\"title function_\">serialize</span>(),</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                    <span class=\"keyword\">if</span> (data[<span class=\"string\">&#x27;error&#x27;</span>] == <span class=\"string\">&quot;OK&quot;</span>)&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                        <span class=\"title function_\">alert</span>(<span class=\"string\">&quot;注册成功&quot;</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">                    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                    <span class=\"keyword\">else</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                        <span class=\"title function_\">alert</span>(data[<span class=\"string\">&#x27;error&#x27;</span>]);</span></span><br><span class=\"line\"><span class=\"language-javascript\">                    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">            &#125;);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>data: 将form表单内容序列化一下，通过post方法发送请求，在回调函数里面显示提示信息。</p>\n<p>view函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">register</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\">    res = &#123;<span class=\"string\">&#x27;error&#x27;</span>:<span class=\"literal\">None</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> request.method == <span class=\"string\">&quot;POST&quot;</span>:</span><br><span class=\"line\">        name = request.POST.get(<span class=\"string\">&quot;username&quot;</span>)</span><br><span class=\"line\">        email= request.POST.get(<span class=\"string\">&quot;Email&quot;</span>)</span><br><span class=\"line\">        password =request.POST.getlist(<span class=\"string\">&quot;password&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(password)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> password[<span class=\"number\">0</span>] != password[<span class=\"number\">1</span>]:</span><br><span class=\"line\">            res[<span class=\"string\">&#x27;error&#x27;</span>] = <span class=\"string\">&quot;两次密码不同，请重新填写&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res[<span class=\"string\">&#x27;error&#x27;</span>] = <span class=\"string\">&#x27;OK&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponse(json.dumps(res),content_type=<span class=\"string\">&quot;application/json&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>通过getlist方法获取列表多个值，判断两个密码是否相同，并把结果一json格式发送给前端。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Ajax\"><a href=\"#Ajax\" class=\"headerlink\" title=\"Ajax\"></a>Ajax</h2><p>AJAX即Asynchronous JavaScript and XML (异步的JavaScript和XML)，一种创建交互式网页应用的网页开发技术方案。之前我们在页面进行操作的时候往往会导致整个页面进行刷新，这样的体验往往不是很好，使用ajax发送请求的时候可以在后台处理请求和响应，例如在用户登录的时候提示用户当前输入的用户名是否正确，或者验证密码等等操作。</p>\n<h3 id=\"原生Ajax\"><a href=\"#原生Ajax\" class=\"headerlink\" title=\"原生Ajax\"></a>原生Ajax</h3><p>原生的ajax是基于XmlHttpRequest对象进行操作的，因此要使用原生ajax先来看看XmlHttpRequest对象的主要方法和属性：</p>\n<ul>\n<li>方法：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   用于创建请求</span><br><span class=\"line\">    </span><br><span class=\"line\">   参数：</span><br><span class=\"line\">       method： 请求方式（字符串类型），如：<span class=\"variable constant_\">POST</span>、<span class=\"variable constant_\">GET</span>、<span class=\"variable constant_\">DELETE</span>...</span><br><span class=\"line\">       url：    要请求的地址（字符串类型）</span><br><span class=\"line\">       <span class=\"keyword\">async</span>：  是否异步（布尔类型）</span><br><span class=\"line\"> </span><br><span class=\"line\">b. <span class=\"keyword\">void</span> <span class=\"title function_\">send</span>(<span class=\"title class_\">String</span> body)</span><br><span class=\"line\">    用于发送请求</span><br><span class=\"line\"> </span><br><span class=\"line\">    参数：</span><br><span class=\"line\">        body： 要发送的数据（字符串类型）</span><br><span class=\"line\"> </span><br><span class=\"line\">c. <span class=\"keyword\">void</span> <span class=\"title function_\">setRequestHeader</span>(<span class=\"title class_\">String</span> header,<span class=\"title class_\">String</span> value)</span><br><span class=\"line\">    用于设置请求头</span><br><span class=\"line\"> </span><br><span class=\"line\">    参数：</span><br><span class=\"line\">        header： 请求头的key（字符串类型）</span><br><span class=\"line\">        vlaue：  请求头的value（字符串类型）</span><br><span class=\"line\"> </span><br><span class=\"line\">d. <span class=\"title class_\">String</span> <span class=\"title function_\">getAllResponseHeaders</span>()</span><br><span class=\"line\">    获取所有响应头</span><br><span class=\"line\"> </span><br><span class=\"line\">    返回值：</span><br><span class=\"line\">        响应头数据（字符串类型）</span><br><span class=\"line\"> </span><br><span class=\"line\">e. <span class=\"title class_\">String</span> <span class=\"title function_\">getResponseHeader</span>(<span class=\"title class_\">String</span> header)</span><br><span class=\"line\">    获取响应头中指定header的值</span><br><span class=\"line\"> </span><br><span class=\"line\">    参数：</span><br><span class=\"line\">        header： 响应头的key（字符串类型）</span><br><span class=\"line\"> </span><br><span class=\"line\">    返回值：</span><br><span class=\"line\">        响应头中指定的header对应的值</span><br><span class=\"line\"> </span><br><span class=\"line\">f. <span class=\"keyword\">void</span> <span class=\"title function_\">abort</span>()</span><br><span class=\"line\"> </span><br><span class=\"line\">    终止请求&lt;/pre&gt;</span><br></pre></td></tr></table></figure></li>\n<li>属性：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   状态值（整数）</span><br><span class=\"line\"> </span><br><span class=\"line\">   详细：</span><br><span class=\"line\">      <span class=\"number\">0</span>-未初始化，尚未调用<span class=\"title function_\">open</span>()方法；</span><br><span class=\"line\">      <span class=\"number\">1</span>-启动，调用了<span class=\"title function_\">open</span>()方法，未调用<span class=\"title function_\">send</span>()方法；</span><br><span class=\"line\">      <span class=\"number\">2</span>-发送，已经调用了<span class=\"title function_\">send</span>()方法，未接收到响应；</span><br><span class=\"line\">      <span class=\"number\">3</span>-接收，已经接收到部分响应数据；</span><br><span class=\"line\">      <span class=\"number\">4</span>-完成，已经接收到全部响应数据；</span><br><span class=\"line\"> </span><br><span class=\"line\">b. <span class=\"title class_\">Function</span> onreadystatechange</span><br><span class=\"line\">   当readyState的值改变时自动触发执行其对应的函数（回调函数）</span><br><span class=\"line\"> </span><br><span class=\"line\">c. <span class=\"title class_\">String</span> responseText</span><br><span class=\"line\">   服务器返回的数据（字符串类型）</span><br><span class=\"line\"> </span><br><span class=\"line\">d. <span class=\"title class_\">XmlDocument</span> responseXML</span><br><span class=\"line\">   服务器返回的数据（<span class=\"title class_\">Xml</span>对象）</span><br><span class=\"line\"> </span><br><span class=\"line\">e. <span class=\"title class_\">Number</span> states</span><br><span class=\"line\">   状态码（整数），如：<span class=\"number\">200</span>、<span class=\"number\">404.</span>..</span><br><span class=\"line\"> </span><br><span class=\"line\">f. <span class=\"title class_\">String</span> statesText</span><br><span class=\"line\">   状态文本（字符串），如：<span class=\"variable constant_\">OK</span>、<span class=\"title class_\">NotFound</span>...</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>有了上面的知识我们来实现一个最简单的原生ajax请求</p>\n<p>ajax_test.html:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Title<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;test&quot;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;ajax_test();&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">function</span> <span class=\"title function_\">ajax_test</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>();</span></span><br><span class=\"line\"><span class=\"language-javascript\">            xhr.<span class=\"title function_\">open</span>(<span class=\"string\">&quot;POST&quot;</span>,<span class=\"string\">&#x27;/ajax_receive/&#x27;</span>,<span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">            <span class=\"comment\">//设置请求头</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">            xhr.<span class=\"title function_\">setRequestHeader</span>(<span class=\"string\">&#x27;Content-Type&#x27;</span>, <span class=\"string\">&#x27;application/x-www-form-urlencoded; charset-UTF-8&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">            xhr.<span class=\"title function_\">send</span>(<span class=\"string\">&quot;name=root;password=123&quot;</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>ajax_receive处理函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ajax_receive</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> request.method == <span class=\"string\">&quot;POST&quot;</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(request.POST)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponse(<span class=\"string\">&quot;l&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>点击按钮后台运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[04/May/2018 15:20:21] &quot;GET /ajax_receive/?t=1 HTTP/1.1&quot; 200 2</span><br><span class=\"line\">&lt;QueryDict: &#123;&#x27;name&#x27;: [&#x27;root&#x27;], &#x27;password&#x27;: [&#x27;123&#x27;]&#125;&gt;</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，使用原生ajax发送数据的时候必须要设置请求头，否则无法正常接收解析发送过来的数据</p>\n<h3 id=\"JQuery的ajax\"><a href=\"#JQuery的ajax\" class=\"headerlink\" title=\"JQuery的ajax\"></a>JQuery的ajax</h3><p>jquery的ajax也是基于XmlHttpRequest或者ActiveXObject的</p>\n<ul>\n<li>常用参数及作用:<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url：请求地址</span><br><span class=\"line\">type：请求方式，GET、POST（1.9.0之后用method）</span><br><span class=\"line\">headers：请求头</span><br><span class=\"line\">data：要发送的数据</span><br><span class=\"line\">contentType：即将发送信息至服务器的内容编码类型(默认: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;)</span><br><span class=\"line\">async：是否异步</span><br><span class=\"line\">timeout：设置请求超时时间（毫秒）</span><br><span class=\"line\">beforeSend：发送请求前执行的函数(全局)</span><br><span class=\"line\">complete：完成之后执行的回调函数(全局)</span><br><span class=\"line\">success：成功之后执行的回调函数(全局)</span><br><span class=\"line\">error：失败之后执行的回调函数(全局)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">accepts：通过请求头发送给服务器，告诉服务器当前客户端课接受的数据类型</span><br><span class=\"line\">dataType：将服务器端返回的数据转换成指定类型</span><br><span class=\"line\">    &quot;xml&quot;: 将服务器端返回的内容转换成xml&amp;#26684;式</span><br><span class=\"line\">    &quot;text&quot;: 将服务器端返回的内容转换成普通文本&amp;#26684;式</span><br><span class=\"line\">    &quot;html&quot;: 将服务器端返回的内容转换成普通文本&amp;#26684;式，在插入DOM中时，如果包含JavaScript标签，则会尝试去执行。</span><br><span class=\"line\">    &quot;script&quot;: 尝试将返回值当作JavaScript去执行，然后再将服务器端返回的内容转换成普通文本&amp;#26684;式</span><br><span class=\"line\">    &quot;json&quot;: 将服务器端返回的内容转换成相应的JavaScript对象</span><br><span class=\"line\">    &quot;jsonp&quot;: JSONP &amp;#26684;式 使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数</span><br><span class=\"line\"></span><br><span class=\"line\">converters： 转换器，将服务器端的内容根据指定的dataType转换类型，并传值给success回调函数</span><br></pre></td></tr></table></figure></li>\n<li>示例<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;button&quot;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;JqSendRequest();&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&#x27;Ajax请求&#x27;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;../static/js/jquery-1.11.0.min.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">function</span> <span class=\"title function_\">JqSendRequest</span>(<span class=\"params\"></span>)&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            $.<span class=\"title function_\">ajax</span>(&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">url</span>: <span class=\"string\">&quot;/ajax_receive/&quot;</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">type</span>: <span class=\"string\">&#x27;GET&#x27;</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">dataType</span>: <span class=\"string\">&#x27;text&#x27;</span>,</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">data</span>:&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;root&quot;</span>&#125;,</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">success</span>: <span class=\"keyword\">function</span>(<span class=\"params\">data</span>)&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                    <span class=\"title function_\">alert</span>(data)</span></span><br><span class=\"line\"><span class=\"language-javascript\">                &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            &#125;)</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n接收函数<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ajax_receive</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> request.method == <span class=\"string\">&quot;POST&quot;</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(request.POST)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponse(<span class=\"string\">&quot;POST&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> request.method == <span class=\"string\">&#x27;GET&#x27;</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(request.GET)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponse(<span class=\"string\">&quot;GET&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"使用Ajax提交Form表单实现注册功能实例：\"><a href=\"#使用Ajax提交Form表单实现注册功能实例：\" class=\"headerlink\" title=\"使用Ajax提交Form表单实现注册功能实例：\"></a>使用Ajax提交Form表单实现注册功能实例：</h3><p>首先需要对form表单做一下调整：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;register_form&quot;</span> <span class=\"attr\">onsubmit</span>=<span class=\"string\">&quot;return false&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h6</span>&gt;</span>用户名<span class=\"tag\">&lt;/<span class=\"name\">h6</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;用户名&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">required</span>=<span class=\"string\">&quot;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h6</span>&gt;</span>邮箱<span class=\"tag\">&lt;/<span class=\"name\">h6</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;email&quot;</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;邮箱&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;Email&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h6</span>&gt;</span>密码<span class=\"tag\">&lt;/<span class=\"name\">h6</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;密码&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">h6</span>&gt;</span>确认密码<span class=\"tag\">&lt;/<span class=\"name\">h6</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;确认密码&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;login-bottom&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;submit&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;注 册&quot;</span> <span class=\"attr\">onclick</span>=<span class=\"string\">&quot;login()&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;clear&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>为了防止点击submit按钮的时候发生跳转，需要在form中添加 onsubmit=”return false”参数，再去掉常用的action，method参数，最后再给submit按钮绑定点击事件，至此form表单完成<br>接下来就是js部分：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;../../static/js/jquery-1.11.0.min.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">        <span class=\"keyword\">function</span> <span class=\"title function_\">login</span>(<span class=\"params\"></span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">            $.<span class=\"title function_\">ajax</span>(&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"comment\">//几个参数需要注意一下</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">type</span>: <span class=\"string\">&quot;POST&quot;</span>,<span class=\"comment\">//方法类型</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">dataType</span>: <span class=\"string\">&quot;json&quot;</span>,<span class=\"comment\">//预期服务器返回的数据类型</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">url</span>: <span class=\"string\">&quot;/iot/register&quot;</span>,<span class=\"comment\">//url</span></span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">data</span>: $(<span class=\"string\">&#x27;#register_form&#x27;</span>).<span class=\"title function_\">serialize</span>(),</span></span><br><span class=\"line\"><span class=\"language-javascript\">                <span class=\"attr\">success</span>: <span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                    <span class=\"keyword\">if</span> (data[<span class=\"string\">&#x27;error&#x27;</span>] == <span class=\"string\">&quot;OK&quot;</span>)&#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                        <span class=\"title function_\">alert</span>(<span class=\"string\">&quot;注册成功&quot;</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">                    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                    <span class=\"keyword\">else</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                        <span class=\"title function_\">alert</span>(data[<span class=\"string\">&#x27;error&#x27;</span>]);</span></span><br><span class=\"line\"><span class=\"language-javascript\">                    &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">                &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">            &#125;);</span></span><br><span class=\"line\"><span class=\"language-javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"language-javascript\">    </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>data: 将form表单内容序列化一下，通过post方法发送请求，在回调函数里面显示提示信息。</p>\n<p>view函数：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">register</span>(<span class=\"params\">request</span>):</span><br><span class=\"line\">    res = &#123;<span class=\"string\">&#x27;error&#x27;</span>:<span class=\"literal\">None</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> request.method == <span class=\"string\">&quot;POST&quot;</span>:</span><br><span class=\"line\">        name = request.POST.get(<span class=\"string\">&quot;username&quot;</span>)</span><br><span class=\"line\">        email= request.POST.get(<span class=\"string\">&quot;Email&quot;</span>)</span><br><span class=\"line\">        password =request.POST.getlist(<span class=\"string\">&quot;password&quot;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(password)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> password[<span class=\"number\">0</span>] != password[<span class=\"number\">1</span>]:</span><br><span class=\"line\">            res[<span class=\"string\">&#x27;error&#x27;</span>] = <span class=\"string\">&quot;两次密码不同，请重新填写&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            res[<span class=\"string\">&#x27;error&#x27;</span>] = <span class=\"string\">&#x27;OK&#x27;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> HttpResponse(json.dumps(res),content_type=<span class=\"string\">&quot;application/json&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>通过getlist方法获取列表多个值，判断两个密码是否相同，并把结果一json格式发送给前端。</p>\n"},{"_content":"\n首先说一下项目预期的目标，通过板载的WiFi模块联网获取天气信息，使用屏幕将信息显示出来，配合板载的语音模块播放当天天气状况。<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">总体的设计思路：天气获取的网站是心知天气网免费的API（需要注册），400次/小时的请求足够日常使用了，当然也可以使用付费接口那样能获取更多的信息。当开发板通过API接口发送请求时网站会返回json&#26684;式的信息，然后再通过json库将有用的信息解析出来，就能得到当天的天气信息了。然后将获取到的数据发送给屏幕进行处理，根据数据控制语音模块播放相应的语音文件。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">下面简单的介绍一下心知天气的API</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这个链接是获取实时天气状况</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\">https://api.seniverse.com/v3/weather/now.json?key=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">APIPASSWORD</span></span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\">&amp;location=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">地址</span></span></span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#457ffd; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"\">&amp;language=</span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\"><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\">返回的数据语言&#26684;式</span></span><span style=\"color:#457ffd; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"\">&amp;unit=</span></span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">温度单位</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">黑色加粗的部分是需要根据自己情况进行修改的。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">当发送正确的请求后将会收到服务器返回的json数据</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">{&quot;results&quot;:[{&quot;location&quot;:{&quot;id&quot;:&quot;WX4FBXXFKE4F&quot;,&quot;name&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;path&quot;:&quot;北京,北京,中国&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;timezone_offset&quot;:&quot;&#43;08:00&quot;},&quot;now&quot;:</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">{&quot;text&quot;:&quot;多云&quot;,&quot;code&quot;:&quot;4&quot;,&quot;temperature&quot;:&quot;25&quot;}</span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">,&quot;last_update&quot;:&quot;2017-04-14T12:20:00&#43;08:00&quot;}]}</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">黑色加粗就是我们需要解析的天气信息，本次需要用到的就这些了。更加详细的介绍请看</span><a target=\"_blank\" href=\"https://www.seniverse.com/api\" target=\"_blank\" style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(85,85,85); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">心知天气-天气数据API</a><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这次我们用到的库有</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">ArduinoJson、ArduinoHttpClient、WiFi</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">首先我们需要在setup中连接上WiFi</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span></p>\n<pre name=\"code\" class=\"cpp\">Serial.begin(9600);\n&nbsp;Serial.print(&quot;connect....&quot;);\n&nbsp;while (WiFi.begin(ssid, pass) != WL_CONNECTED)\n&nbsp;Serial.println(&quot;connected&quot;);</pre><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span>\n<p></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></span></p>\nWiFi连接后发送API请求，并解析数据\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span><pre name=\"code\" class=\"cpp\">int httpCode = 0;\n  String httpData;\n  //发送http请求\n  httpCode = http.get(&quot;/v3/weather/now.json?key=&quot; + APIPASSWORD + &quot;&amp;location=zhengzhou&amp;language=en&amp;unit=c&quot;);\n  //若是有返回就接收数据\n  if ( httpCode == 0)\n  {\n    Serial.println(&quot;startedRequest ok&quot;);\n    httpCode = http.responseStatusCode();\n    if (httpCode &gt;= 0)\n    {\n      int bodyLen = http.contentLength();\n      //将接收到的字符存入string中，直到数据接收完毕\n      while ( (http.connected() || http.available()) &amp;&amp; (!http.endOfBodyReached()))\n      {\n        if (http.available())\n        {\n          char c = http.read();\n          httpData += c;\n        }\n        else\n          delay(1000);\n      }\n      //提取出关于天气的那一段字符串\n      data = httpData.substring((httpData.indexOf(&quot;\\&quot;now\\&quot;:&quot;) + 6), httpData.indexOf(&quot;,\\&quot;last&quot;)); \n      //通过json库解析出相应的数据\n      DynamicJsonBuffer jsonBuffer;\n      JsonObject&amp; root = jsonBuffer.parseObject(data);\n      temperature = root[String(&quot;temperature&quot;)];\n      code = root[String(&quot;code&quot;)];\n    }\n  }\n  else\n    Serial.print(&quot;Connect failed&quot;);\n  http.stop();\n  //串口打印出温度\n  Serial.print(&quot;temperature is :&quot;):\n  Serial.println(temperature);\n  Serial.print(&quot;end&quot;);</pre><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></span></p>\n关于json库的使用我了解的不是很多，就不做详细的说明。我在做的时候发现若是将整个返回的数据进行解析并得不到正确的信息，我猜测是因为返回的数据包含有其他的信息并不是json库所能解析的&#26684;式，因此我将接收到的字符存入到一个String类型的字符串中，然后截取其中一段（也就是上面黑色加粗的那一段）进行解析。需要注意的是json解析String类型的方式和char类型是不同的，具体还请参考ArduinoJson的示例。<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">最后的结果</span>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214164623695?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></p>\n<br>\n<br>\n<br>\n","source":"_posts/blogs-Arduino语音天气预报（一）.md","raw":"\n首先说一下项目预期的目标，通过板载的WiFi模块联网获取天气信息，使用屏幕将信息显示出来，配合板载的语音模块播放当天天气状况。<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">总体的设计思路：天气获取的网站是心知天气网免费的API（需要注册），400次/小时的请求足够日常使用了，当然也可以使用付费接口那样能获取更多的信息。当开发板通过API接口发送请求时网站会返回json&#26684;式的信息，然后再通过json库将有用的信息解析出来，就能得到当天的天气信息了。然后将获取到的数据发送给屏幕进行处理，根据数据控制语音模块播放相应的语音文件。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">下面简单的介绍一下心知天气的API</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这个链接是获取实时天气状况</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\">https://api.seniverse.com/v3/weather/now.json?key=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">APIPASSWORD</span></span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\">&amp;location=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">地址</span></span></span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#457ffd; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"\">&amp;language=</span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\"><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\">返回的数据语言&#26684;式</span></span><span style=\"color:#457ffd; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"\">&amp;unit=</span></span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">温度单位</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">黑色加粗的部分是需要根据自己情况进行修改的。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">当发送正确的请求后将会收到服务器返回的json数据</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">{&quot;results&quot;:[{&quot;location&quot;:{&quot;id&quot;:&quot;WX4FBXXFKE4F&quot;,&quot;name&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;path&quot;:&quot;北京,北京,中国&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;timezone_offset&quot;:&quot;&#43;08:00&quot;},&quot;now&quot;:</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">{&quot;text&quot;:&quot;多云&quot;,&quot;code&quot;:&quot;4&quot;,&quot;temperature&quot;:&quot;25&quot;}</span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">,&quot;last_update&quot;:&quot;2017-04-14T12:20:00&#43;08:00&quot;}]}</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">黑色加粗就是我们需要解析的天气信息，本次需要用到的就这些了。更加详细的介绍请看</span><a target=\"_blank\" href=\"https://www.seniverse.com/api\" target=\"_blank\" style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(85,85,85); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">心知天气-天气数据API</a><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这次我们用到的库有</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">ArduinoJson、ArduinoHttpClient、WiFi</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">首先我们需要在setup中连接上WiFi</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span></p>\n<pre name=\"code\" class=\"cpp\">Serial.begin(9600);\n&nbsp;Serial.print(&quot;connect....&quot;);\n&nbsp;while (WiFi.begin(ssid, pass) != WL_CONNECTED)\n&nbsp;Serial.println(&quot;connected&quot;);</pre><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span>\n<p></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></span></p>\nWiFi连接后发送API请求，并解析数据\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span><pre name=\"code\" class=\"cpp\">int httpCode = 0;\n  String httpData;\n  //发送http请求\n  httpCode = http.get(&quot;/v3/weather/now.json?key=&quot; + APIPASSWORD + &quot;&amp;location=zhengzhou&amp;language=en&amp;unit=c&quot;);\n  //若是有返回就接收数据\n  if ( httpCode == 0)\n  {\n    Serial.println(&quot;startedRequest ok&quot;);\n    httpCode = http.responseStatusCode();\n    if (httpCode &gt;= 0)\n    {\n      int bodyLen = http.contentLength();\n      //将接收到的字符存入string中，直到数据接收完毕\n      while ( (http.connected() || http.available()) &amp;&amp; (!http.endOfBodyReached()))\n      {\n        if (http.available())\n        {\n          char c = http.read();\n          httpData += c;\n        }\n        else\n          delay(1000);\n      }\n      //提取出关于天气的那一段字符串\n      data = httpData.substring((httpData.indexOf(&quot;\\&quot;now\\&quot;:&quot;) + 6), httpData.indexOf(&quot;,\\&quot;last&quot;)); \n      //通过json库解析出相应的数据\n      DynamicJsonBuffer jsonBuffer;\n      JsonObject&amp; root = jsonBuffer.parseObject(data);\n      temperature = root[String(&quot;temperature&quot;)];\n      code = root[String(&quot;code&quot;)];\n    }\n  }\n  else\n    Serial.print(&quot;Connect failed&quot;);\n  http.stop();\n  //串口打印出温度\n  Serial.print(&quot;temperature is :&quot;):\n  Serial.println(temperature);\n  Serial.print(&quot;end&quot;);</pre><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></span></p>\n关于json库的使用我了解的不是很多，就不做详细的说明。我在做的时候发现若是将整个返回的数据进行解析并得不到正确的信息，我猜测是因为返回的数据包含有其他的信息并不是json库所能解析的&#26684;式，因此我将接收到的字符存入到一个String类型的字符串中，然后截取其中一段（也就是上面黑色加粗的那一段）进行解析。需要注意的是json解析String类型的方式和char类型是不同的，具体还请参考ArduinoJson的示例。<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">最后的结果</span>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214164623695?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></p>\n<br>\n<br>\n<br>\n","slug":"blogs-Arduino语音天气预报（一）","published":1,"date":"2022-03-16T17:09:44.058Z","updated":"2022-03-16T17:09:44.058Z","_id":"cl0v6kes6000lyms42da20mp3","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>首先说一下项目预期的目标，通过板载的WiFi模块联网获取天气信息，使用屏幕将信息显示出来，配合板载的语音模块播放当天天气状况。<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">总体的设计思路：天气获取的网站是心知天气网免费的API（需要注册），400次/小时的请求足够日常使用了，当然也可以使用付费接口那样能获取更多的信息。当开发板通过API接口发送请求时网站会返回json&#26684;式的信息，然后再通过json库将有用的信息解析出来，就能得到当天的天气信息了。然后将获取到的数据发送给屏幕进行处理，根据数据控制语音模块播放相应的语音文件。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">下面简单的介绍一下心知天气的API</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这个链接是获取实时天气状况</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\"><a href=\"https://api.seniverse.com/v3/weather/now.json?key=\">https://api.seniverse.com/v3/weather/now.json?key=</a></span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">APIPASSWORD</span></span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\">&amp;location=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">地址</span></span></span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#457ffd; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"\">&amp;language=</span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\"><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\">返回的数据语言&#26684;式</span></span><span style=\"color:#457ffd; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"\">&amp;unit=</span></span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">温度单位</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">黑色加粗的部分是需要根据自己情况进行修改的。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">当发送正确的请求后将会收到服务器返回的json数据</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">{&quot;results&quot;:[{&quot;location&quot;:{&quot;id&quot;:&quot;WX4FBXXFKE4F&quot;,&quot;name&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;path&quot;:&quot;北京,北京,中国&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;timezone_offset&quot;:&quot;&#43;08:00&quot;},&quot;now&quot;:</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">{&quot;text&quot;:&quot;多云&quot;,&quot;code&quot;:&quot;4&quot;,&quot;temperature&quot;:&quot;25&quot;}</span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">,&quot;last_update&quot;:&quot;2017-04-14T12:20:00&#43;08:00&quot;}]}</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">黑色加粗就是我们需要解析的天气信息，本次需要用到的就这些了。更加详细的介绍请看</span><a target=\"_blank\" href=\"https://www.seniverse.com/api\" target=\"_blank\" style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(85,85,85); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">心知天气-天气数据API</a><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这次我们用到的库有</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">ArduinoJson、ArduinoHttpClient、WiFi</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">首先我们需要在setup中连接上WiFi</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span></p>\n<pre name=\"code\" class=\"cpp\">Serial.begin(9600);\n&nbsp;Serial.print(&quot;connect....&quot;);\n&nbsp;while (WiFi.begin(ssid, pass) != WL_CONNECTED)\n&nbsp;Serial.println(&quot;connected&quot;);</pre><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span>\n<p></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></span></p>\nWiFi连接后发送API请求，并解析数据\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span><pre name=\"code\" class=\"cpp\">int httpCode = 0;\n  String httpData;\n  //发送http请求\n  httpCode = http.get(&quot;/v3/weather/now.json?key=&quot; + APIPASSWORD + &quot;&amp;location=zhengzhou&amp;language=en&amp;unit=c&quot;);\n  //若是有返回就接收数据\n  if ( httpCode == 0)\n  {\n    Serial.println(&quot;startedRequest ok&quot;);\n    httpCode = http.responseStatusCode();\n    if (httpCode &gt;= 0)\n    {\n      int bodyLen = http.contentLength();\n      //将接收到的字符存入string中，直到数据接收完毕\n      while ( (http.connected() || http.available()) &amp;&amp; (!http.endOfBodyReached()))\n      {\n        if (http.available())\n        {\n          char c = http.read();\n          httpData += c;\n        }\n        else\n          delay(1000);\n      }\n      //提取出关于天气的那一段字符串\n      data = httpData.substring((httpData.indexOf(&quot;\\&quot;now\\&quot;:&quot;) + 6), httpData.indexOf(&quot;,\\&quot;last&quot;)); \n      //通过json库解析出相应的数据\n      DynamicJsonBuffer jsonBuffer;\n      JsonObject&amp; root = jsonBuffer.parseObject(data);\n      temperature = root[String(&quot;temperature&quot;)];\n      code = root[String(&quot;code&quot;)];\n    }\n  }\n  else\n    Serial.print(&quot;Connect failed&quot;);\n  http.stop();\n  //串口打印出温度\n  Serial.print(&quot;temperature is :&quot;):\n  Serial.println(temperature);\n  Serial.print(&quot;end&quot;);</pre><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></span></p>\n关于json库的使用我了解的不是很多，就不做详细的说明。我在做的时候发现若是将整个返回的数据进行解析并得不到正确的信息，我猜测是因为返回的数据包含有其他的信息并不是json库所能解析的&#26684;式，因此我将接收到的字符存入到一个String类型的字符串中，然后截取其中一段（也就是上面黑色加粗的那一段）进行解析。需要注意的是json解析String类型的方式和char类型是不同的，具体还请参考ArduinoJson的示例。<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">最后的结果</span>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214164623695?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></p>\n<br>\n<br>\n<br>\n","site":{"data":{}},"excerpt":"","more":"<p>首先说一下项目预期的目标，通过板载的WiFi模块联网获取天气信息，使用屏幕将信息显示出来，配合板载的语音模块播放当天天气状况。<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">总体的设计思路：天气获取的网站是心知天气网免费的API（需要注册），400次/小时的请求足够日常使用了，当然也可以使用付费接口那样能获取更多的信息。当开发板通过API接口发送请求时网站会返回json&#26684;式的信息，然后再通过json库将有用的信息解析出来，就能得到当天的天气信息了。然后将获取到的数据发送给屏幕进行处理，根据数据控制语音模块播放相应的语音文件。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">下面简单的介绍一下心知天气的API</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这个链接是获取实时天气状况</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\"><a href=\"https://api.seniverse.com/v3/weather/now.json?key=\">https://api.seniverse.com/v3/weather/now.json?key=</a></span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">APIPASSWORD</span></span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\">&amp;location=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">地址</span></span></span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#457ffd; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"\">&amp;language=</span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\"><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\">返回的数据语言&#26684;式</span></span><span style=\"color:#457ffd; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"\">&amp;unit=</span></span></span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">温度单位</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">黑色加粗的部分是需要根据自己情况进行修改的。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">当发送正确的请求后将会收到服务器返回的json数据</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">{&quot;results&quot;:[{&quot;location&quot;:{&quot;id&quot;:&quot;WX4FBXXFKE4F&quot;,&quot;name&quot;:&quot;北京&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;path&quot;:&quot;北京,北京,中国&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;timezone_offset&quot;:&quot;&#43;08:00&quot;},&quot;now&quot;:</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">{&quot;text&quot;:&quot;多云&quot;,&quot;code&quot;:&quot;4&quot;,&quot;temperature&quot;:&quot;25&quot;}</span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">,&quot;last_update&quot;:&quot;2017-04-14T12:20:00&#43;08:00&quot;}]}</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">黑色加粗就是我们需要解析的天气信息，本次需要用到的就这些了。更加详细的介绍请看</span><a target=\"_blank\" href=\"https://www.seniverse.com/api\" target=\"_blank\" style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(85,85,85); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">心知天气-天气数据API</a><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这次我们用到的库有</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">ArduinoJson、ArduinoHttpClient、WiFi</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">首先我们需要在setup中连接上WiFi</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span></p>\n<pre name=\"code\" class=\"cpp\">Serial.begin(9600);\n&nbsp;Serial.print(&quot;connect....&quot;);\n&nbsp;while (WiFi.begin(ssid, pass) != WL_CONNECTED)\n&nbsp;Serial.println(&quot;connected&quot;);</pre><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span>\n<p></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></span></p>\nWiFi连接后发送API请求，并解析数据\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span><pre name=\"code\" class=\"cpp\">int httpCode = 0;\n  String httpData;\n  //发送http请求\n  httpCode = http.get(&quot;/v3/weather/now.json?key=&quot; + APIPASSWORD + &quot;&amp;location=zhengzhou&amp;language=en&amp;unit=c&quot;);\n  //若是有返回就接收数据\n  if ( httpCode == 0)\n  {\n    Serial.println(&quot;startedRequest ok&quot;);\n    httpCode = http.responseStatusCode();\n    if (httpCode &gt;= 0)\n    {\n      int bodyLen = http.contentLength();\n      //将接收到的字符存入string中，直到数据接收完毕\n      while ( (http.connected() || http.available()) &amp;&amp; (!http.endOfBodyReached()))\n      {\n        if (http.available())\n        {\n          char c = http.read();\n          httpData += c;\n        }\n        else\n          delay(1000);\n      }\n      //提取出关于天气的那一段字符串\n      data = httpData.substring((httpData.indexOf(&quot;\\&quot;now\\&quot;:&quot;) + 6), httpData.indexOf(&quot;,\\&quot;last&quot;)); \n      //通过json库解析出相应的数据\n      DynamicJsonBuffer jsonBuffer;\n      JsonObject&amp; root = jsonBuffer.parseObject(data);\n      temperature = root[String(&quot;temperature&quot;)];\n      code = root[String(&quot;code&quot;)];\n    }\n  }\n  else\n    Serial.print(&quot;Connect failed&quot;);\n  http.stop();\n  //串口打印出温度\n  Serial.print(&quot;temperature is :&quot;):\n  Serial.println(temperature);\n  Serial.print(&quot;end&quot;);</pre><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></span></p>\n关于json库的使用我了解的不是很多，就不做详细的说明。我在做的时候发现若是将整个返回的数据进行解析并得不到正确的信息，我猜测是因为返回的数据包含有其他的信息并不是json库所能解析的&#26684;式，因此我将接收到的字符存入到一个String类型的字符串中，然后截取其中一段（也就是上面黑色加粗的那一段）进行解析。需要注意的是json解析String类型的方式和char类型是不同的，具体还请参考ArduinoJson的示例。<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">最后的结果</span>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214164623695?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></p>\n<br>\n<br>\n<br>\n"},{"_content":"\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这篇我们会讲如何使用板载的语音模块播放</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这次用到的是串口语音模块，首先我们需要使用语音合成工具合成我们想要的语音存入内存卡中，然后呢当我们获取数据后发送相应的指令控制语音模块来播放对于的音频文件。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; color:#444444\"><span style=\"font-size:14px\">在这里不再说明如何合成音频文件了，直接切入正题。</span></span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; color:#444444\"><span style=\"font-size:14px\">这次我们主要用到的只有一条命令&nbsp; ———————&gt;&nbsp; &nbsp;<span style=\"font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:12px\">播放指定目录下的文件&nbsp;&nbsp;0x7E, 0x04, 0x44, 文件夹号, 文件号, 0xEF</span></span></span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">因此音频文件存放位置和命名需要有一定的&#26684;式：例如 01号文件夹中存放诸如描述天气情况的语音，02号文件夹存放温度语音等等。命名也是有技巧的，例如我们可以根据天气代码来描述天气的语音，例如“今天天气晴”可命名为001，正好我们获取到的天气代码也是1这样我们就不用来处理这部分对于关系了。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">还需要一点是在播放语音的过程中需要判断当前是否没有播放，这个可以通过模块上的一个引脚电平来判断，具体需要根据你自己的模块来设定，我的这个是当没有播放时电平为低，这样我们可以将引脚接入到Arduino的引脚上，通过读取引脚电压来判断。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">这部分代码就不拿出来单独说明了，因为太简单了，而且会和硬件有较大的关系难免有人在使用的时候出现问题。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">其实呢整个项目到这里已经完成了，但是我还想说一下有人可能直接烧代码会出现很多问题，那是因为我是用的并不是标准的Arduino开发板而是Fireduino使用Arduino平台开发而已，这块板子价&#26684;有点高只是做这个有点浪费而且我的也给弄坏了，理解了整个制作流程其实可以用更廉价的开发板来代替，例如NodeMCU、Arduino&#43;esp8266，而且所有的功能都能实现。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n<p><br>\n</p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; color:#444444\"><a target=\"_blank\" href=\"http://v.youku.com/v_show/id_XMjc1NTUzOTE5Mg==.html\" style=\"\"><span style=\"font-size:14px\"><strong>完整的项目演示</strong></span></a><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">参考代码</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><a target=\"_blank\" href=\"https://github.com/FanMLei/Weather_Station\">https://github.com/FanMLei/Weather_Station</a><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n","source":"_posts/blogs-Arduino语音天气预报（三）.md","raw":"\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这篇我们会讲如何使用板载的语音模块播放</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这次用到的是串口语音模块，首先我们需要使用语音合成工具合成我们想要的语音存入内存卡中，然后呢当我们获取数据后发送相应的指令控制语音模块来播放对于的音频文件。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; color:#444444\"><span style=\"font-size:14px\">在这里不再说明如何合成音频文件了，直接切入正题。</span></span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; color:#444444\"><span style=\"font-size:14px\">这次我们主要用到的只有一条命令&nbsp; ———————&gt;&nbsp; &nbsp;<span style=\"font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:12px\">播放指定目录下的文件&nbsp;&nbsp;0x7E, 0x04, 0x44, 文件夹号, 文件号, 0xEF</span></span></span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">因此音频文件存放位置和命名需要有一定的&#26684;式：例如 01号文件夹中存放诸如描述天气情况的语音，02号文件夹存放温度语音等等。命名也是有技巧的，例如我们可以根据天气代码来描述天气的语音，例如“今天天气晴”可命名为001，正好我们获取到的天气代码也是1这样我们就不用来处理这部分对于关系了。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">还需要一点是在播放语音的过程中需要判断当前是否没有播放，这个可以通过模块上的一个引脚电平来判断，具体需要根据你自己的模块来设定，我的这个是当没有播放时电平为低，这样我们可以将引脚接入到Arduino的引脚上，通过读取引脚电压来判断。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">这部分代码就不拿出来单独说明了，因为太简单了，而且会和硬件有较大的关系难免有人在使用的时候出现问题。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">其实呢整个项目到这里已经完成了，但是我还想说一下有人可能直接烧代码会出现很多问题，那是因为我是用的并不是标准的Arduino开发板而是Fireduino使用Arduino平台开发而已，这块板子价&#26684;有点高只是做这个有点浪费而且我的也给弄坏了，理解了整个制作流程其实可以用更廉价的开发板来代替，例如NodeMCU、Arduino&#43;esp8266，而且所有的功能都能实现。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n<p><br>\n</p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; color:#444444\"><a target=\"_blank\" href=\"http://v.youku.com/v_show/id_XMjc1NTUzOTE5Mg==.html\" style=\"\"><span style=\"font-size:14px\"><strong>完整的项目演示</strong></span></a><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">参考代码</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><a target=\"_blank\" href=\"https://github.com/FanMLei/Weather_Station\">https://github.com/FanMLei/Weather_Station</a><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n","slug":"blogs-Arduino语音天气预报（三）","published":1,"date":"2022-03-16T17:09:41.620Z","updated":"2022-03-16T17:09:41.620Z","_id":"cl0v6kes7000myms40hkj8l1h","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这篇我们会讲如何使用板载的语音模块播放</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这次用到的是串口语音模块，首先我们需要使用语音合成工具合成我们想要的语音存入内存卡中，然后呢当我们获取数据后发送相应的指令控制语音模块来播放对于的音频文件。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; color:#444444\"><span style=\"font-size:14px\">在这里不再说明如何合成音频文件了，直接切入正题。</span></span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; color:#444444\"><span style=\"font-size:14px\">这次我们主要用到的只有一条命令&nbsp; ———————&gt;&nbsp; &nbsp;<span style=\"font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:12px\">播放指定目录下的文件&nbsp;&nbsp;0x7E, 0x04, 0x44, 文件夹号, 文件号, 0xEF</span></span></span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">因此音频文件存放位置和命名需要有一定的&#26684;式：例如 01号文件夹中存放诸如描述天气情况的语音，02号文件夹存放温度语音等等。命名也是有技巧的，例如我们可以根据天气代码来描述天气的语音，例如“今天天气晴”可命名为001，正好我们获取到的天气代码也是1这样我们就不用来处理这部分对于关系了。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">还需要一点是在播放语音的过程中需要判断当前是否没有播放，这个可以通过模块上的一个引脚电平来判断，具体需要根据你自己的模块来设定，我的这个是当没有播放时电平为低，这样我们可以将引脚接入到Arduino的引脚上，通过读取引脚电压来判断。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">这部分代码就不拿出来单独说明了，因为太简单了，而且会和硬件有较大的关系难免有人在使用的时候出现问题。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">其实呢整个项目到这里已经完成了，但是我还想说一下有人可能直接烧代码会出现很多问题，那是因为我是用的并不是标准的Arduino开发板而是Fireduino使用Arduino平台开发而已，这块板子价&#26684;有点高只是做这个有点浪费而且我的也给弄坏了，理解了整个制作流程其实可以用更廉价的开发板来代替，例如NodeMCU、Arduino&#43;esp8266，而且所有的功能都能实现。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n<p><br>\n</p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; color:#444444\"><a target=\"_blank\" href=\"http://v.youku.com/v_show/id_XMjc1NTUzOTE5Mg==.html\" style=\"\"><span style=\"font-size:14px\"><strong>完整的项目演示</strong></span></a><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">参考代码</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><a target=\"_blank\" href=\"https://github.com/FanMLei/Weather_Station\">https://github.com/FanMLei/Weather_Station</a><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n","site":{"data":{}},"excerpt":"","more":"<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这篇我们会讲如何使用板载的语音模块播放</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">这次用到的是串口语音模块，首先我们需要使用语音合成工具合成我们想要的语音存入内存卡中，然后呢当我们获取数据后发送相应的指令控制语音模块来播放对于的音频文件。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; color:#444444\"><span style=\"font-size:14px\">在这里不再说明如何合成音频文件了，直接切入正题。</span></span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; color:#444444\"><span style=\"font-size:14px\">这次我们主要用到的只有一条命令&nbsp; ———————&gt;&nbsp; &nbsp;<span style=\"font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:12px\">播放指定目录下的文件&nbsp;&nbsp;0x7E, 0x04, 0x44, 文件夹号, 文件号, 0xEF</span></span></span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">因此音频文件存放位置和命名需要有一定的&#26684;式：例如 01号文件夹中存放诸如描述天气情况的语音，02号文件夹存放温度语音等等。命名也是有技巧的，例如我们可以根据天气代码来描述天气的语音，例如“今天天气晴”可命名为001，正好我们获取到的天气代码也是1这样我们就不用来处理这部分对于关系了。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">还需要一点是在播放语音的过程中需要判断当前是否没有播放，这个可以通过模块上的一个引脚电平来判断，具体需要根据你自己的模块来设定，我的这个是当没有播放时电平为低，这样我们可以将引脚接入到Arduino的引脚上，通过读取引脚电压来判断。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">这部分代码就不拿出来单独说明了，因为太简单了，而且会和硬件有较大的关系难免有人在使用的时候出现问题。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">其实呢整个项目到这里已经完成了，但是我还想说一下有人可能直接烧代码会出现很多问题，那是因为我是用的并不是标准的Arduino开发板而是Fireduino使用Arduino平台开发而已，这块板子价&#26684;有点高只是做这个有点浪费而且我的也给弄坏了，理解了整个制作流程其实可以用更廉价的开发板来代替，例如NodeMCU、Arduino&#43;esp8266，而且所有的功能都能实现。</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n<p><br>\n</p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; color:#444444\"><a target=\"_blank\" href=\"http://v.youku.com/v_show/id_XMjc1NTUzOTE5Mg==.html\" style=\"\"><span style=\"font-size:14px\"><strong>完整的项目演示</strong></span></a><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\">参考代码</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><a target=\"_blank\" href=\"https://github.com/FanMLei/Weather_Station\">https://github.com/FanMLei/Weather_Station</a><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n<p><span style=\"font-family:Microsoft Yahei,Simsun; font-size:12px; color:#444444\"><br>\n</span></p>\n"},{"_content":"<h3>基础知识</h3>\n\n<p>想要弄清楚rest framework的执行过程首先需要明白Django中CBV和FBV执行流程，http请求最最本质的就是一个socket，一个请求过来第一步就是做路由匹配，在FBV中因为视图本身就是一个函数，所以直接调用函数就可以了，但是CBV中视图是一个类而在这个类里面是我们编写的视图函数，所以比FBV多了一步如何找到那个函数并且执行它。</p>\n\n<p style=\"text-indent:0;\">CBV中是基于反射实现请求方式不同执行不同的方法，我们在使用CBV来实现的时候，通常都是在路由中使用as_view方法。<br /><img alt=\"\" class=\"has\" height=\"29\" src=\"https://img-blog.csdnimg.cn/20181127162910526.png\" width=\"608\" /></p>\n\n<p>这个方法存在于我们继承的父类View中，在as_view内部又会调用dispatch方法通过反射去找到对应的函数<br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181127163104969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /><br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181127164045587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p>所以总得来说，在CBV中一个请求过来的具体流程：url  → view → as_view → dispatch</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181127164908520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<h3>源码分析</h3>\n\n<p>有了上面的基础接下来就比较容易理解了</p>\n\n<p>首先在使用rest framework框架的时候 CBV不在是继承django的View了而是 rest framework的APIView，只是这个APIView也是继承django的View的，只不过是在原有的View中增加了很多功能而已，依然还是通过反射来实现的，所以跳过前面的内容直接到dispatch这部分</p>\n\n<p><img alt=\"\" class=\"has\" height=\"458\" src=\"https://img-blog.csdnimg.cn/20181127170329362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"984\" /></p>\n\n<p><img alt=\"\" class=\"has\" height=\"328\" src=\"https://img-blog.csdnimg.cn/20181127170932609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"774\" /></p>\n\n<p>正式进入正题，restframework主要包含认证、解析器、分页和序列化四个大的部分，就对应上图框框内的几个部分，这几个部分流程大致相同，所以就以认证为例来具体说说他的流程</p>\n\n<p>咱们接着上图继续往下一步一步走，首先会获取所有认证类的实例化对象。<br /><img alt=\"\" class=\"has\" height=\"142\" src=\"https://img-blog.csdnimg.cn/20181128000047237.png\" width=\"981\" /></p>\n\n<p>如果自己写的类里面没有认证类，就会到基类中继续寻找，默认使用rest framework的配置文件中的认证类<br /><img alt=\"\" class=\"has\" height=\"30\" src=\"https://img-blog.csdnimg.cn/20181128000109794.png\" width=\"821\" /><br />\n拿到了认证所需要的类的对象，就继续返回到dispatch中，这时候request已经是增加内容了的request</p>\n\n<p>返回dispatch之后回调用initial方法，在这个方法里面会执行所有之前我们添加的认证类、解析类<br /><img alt=\"\" class=\"has\" height=\"375\" src=\"https://img-blog.csdnimg.cn/20181128002438807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"793\" /></p>\n\n<p>initial方法里面跳转比较频繁，这里截图就重叠到一起方便看，经过一路的跳转最终是执行了request对象的_authenticate方法</p>\n\n<p><img alt=\"\" class=\"has\" height=\"426\" src=\"https://img-blog.csdnimg.cn/20181128002611464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"882\" /></p>\n\n<p>在_authenticate方法里面，会依次执行所有认证类的authenticate方法（由此我们也能知道如果我们想编写自己的认证类，那么认证部分需要放在authenticate方法里面），同时会将返回值赋值给request的user和auth属性<br /><img alt=\"\" class=\"has\" height=\"445\" src=\"https://img-blog.csdnimg.cn/20181128004850888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"849\" /></p>\n\n<p>所以rest framework的认证流程总得来说就是：<br /><img alt=\"\" class=\"has\" height=\"535\" src=\"https://img-blog.csdnimg.cn/20181128005730158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"1033\" /></p>","source":"_posts/blogs-Django rest framework  认证组件源码分析.md","raw":"<h3>基础知识</h3>\n\n<p>想要弄清楚rest framework的执行过程首先需要明白Django中CBV和FBV执行流程，http请求最最本质的就是一个socket，一个请求过来第一步就是做路由匹配，在FBV中因为视图本身就是一个函数，所以直接调用函数就可以了，但是CBV中视图是一个类而在这个类里面是我们编写的视图函数，所以比FBV多了一步如何找到那个函数并且执行它。</p>\n\n<p style=\"text-indent:0;\">CBV中是基于反射实现请求方式不同执行不同的方法，我们在使用CBV来实现的时候，通常都是在路由中使用as_view方法。<br /><img alt=\"\" class=\"has\" height=\"29\" src=\"https://img-blog.csdnimg.cn/20181127162910526.png\" width=\"608\" /></p>\n\n<p>这个方法存在于我们继承的父类View中，在as_view内部又会调用dispatch方法通过反射去找到对应的函数<br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181127163104969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /><br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181127164045587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p>所以总得来说，在CBV中一个请求过来的具体流程：url  → view → as_view → dispatch</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181127164908520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<h3>源码分析</h3>\n\n<p>有了上面的基础接下来就比较容易理解了</p>\n\n<p>首先在使用rest framework框架的时候 CBV不在是继承django的View了而是 rest framework的APIView，只是这个APIView也是继承django的View的，只不过是在原有的View中增加了很多功能而已，依然还是通过反射来实现的，所以跳过前面的内容直接到dispatch这部分</p>\n\n<p><img alt=\"\" class=\"has\" height=\"458\" src=\"https://img-blog.csdnimg.cn/20181127170329362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"984\" /></p>\n\n<p><img alt=\"\" class=\"has\" height=\"328\" src=\"https://img-blog.csdnimg.cn/20181127170932609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"774\" /></p>\n\n<p>正式进入正题，restframework主要包含认证、解析器、分页和序列化四个大的部分，就对应上图框框内的几个部分，这几个部分流程大致相同，所以就以认证为例来具体说说他的流程</p>\n\n<p>咱们接着上图继续往下一步一步走，首先会获取所有认证类的实例化对象。<br /><img alt=\"\" class=\"has\" height=\"142\" src=\"https://img-blog.csdnimg.cn/20181128000047237.png\" width=\"981\" /></p>\n\n<p>如果自己写的类里面没有认证类，就会到基类中继续寻找，默认使用rest framework的配置文件中的认证类<br /><img alt=\"\" class=\"has\" height=\"30\" src=\"https://img-blog.csdnimg.cn/20181128000109794.png\" width=\"821\" /><br />\n拿到了认证所需要的类的对象，就继续返回到dispatch中，这时候request已经是增加内容了的request</p>\n\n<p>返回dispatch之后回调用initial方法，在这个方法里面会执行所有之前我们添加的认证类、解析类<br /><img alt=\"\" class=\"has\" height=\"375\" src=\"https://img-blog.csdnimg.cn/20181128002438807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"793\" /></p>\n\n<p>initial方法里面跳转比较频繁，这里截图就重叠到一起方便看，经过一路的跳转最终是执行了request对象的_authenticate方法</p>\n\n<p><img alt=\"\" class=\"has\" height=\"426\" src=\"https://img-blog.csdnimg.cn/20181128002611464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"882\" /></p>\n\n<p>在_authenticate方法里面，会依次执行所有认证类的authenticate方法（由此我们也能知道如果我们想编写自己的认证类，那么认证部分需要放在authenticate方法里面），同时会将返回值赋值给request的user和auth属性<br /><img alt=\"\" class=\"has\" height=\"445\" src=\"https://img-blog.csdnimg.cn/20181128004850888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"849\" /></p>\n\n<p>所以rest framework的认证流程总得来说就是：<br /><img alt=\"\" class=\"has\" height=\"535\" src=\"https://img-blog.csdnimg.cn/20181128005730158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"1033\" /></p>","slug":"blogs-Django rest framework  认证组件源码分析","published":1,"date":"2022-03-16T17:00:55.649Z","updated":"2022-03-16T17:05:45.059Z","_id":"cl0v6kes7000nyms4dkdx6t10","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>基础知识</h3>\n\n<p>想要弄清楚rest framework的执行过程首先需要明白Django中CBV和FBV执行流程，http请求最最本质的就是一个socket，一个请求过来第一步就是做路由匹配，在FBV中因为视图本身就是一个函数，所以直接调用函数就可以了，但是CBV中视图是一个类而在这个类里面是我们编写的视图函数，所以比FBV多了一步如何找到那个函数并且执行它。</p>\n\n<p style=\"text-indent:0;\">CBV中是基于反射实现请求方式不同执行不同的方法，我们在使用CBV来实现的时候，通常都是在路由中使用as_view方法。<br /><img alt=\"\" class=\"has\" height=\"29\" src=\"https://img-blog.csdnimg.cn/20181127162910526.png\" width=\"608\" /></p>\n\n<p>这个方法存在于我们继承的父类View中，在as_view内部又会调用dispatch方法通过反射去找到对应的函数<br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181127163104969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /><br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181127164045587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p>所以总得来说，在CBV中一个请求过来的具体流程：url  → view → as_view → dispatch</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181127164908520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<h3>源码分析</h3>\n\n<p>有了上面的基础接下来就比较容易理解了</p>\n\n<p>首先在使用rest framework框架的时候 CBV不在是继承django的View了而是 rest framework的APIView，只是这个APIView也是继承django的View的，只不过是在原有的View中增加了很多功能而已，依然还是通过反射来实现的，所以跳过前面的内容直接到dispatch这部分</p>\n\n<p><img alt=\"\" class=\"has\" height=\"458\" src=\"https://img-blog.csdnimg.cn/20181127170329362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"984\" /></p>\n\n<p><img alt=\"\" class=\"has\" height=\"328\" src=\"https://img-blog.csdnimg.cn/20181127170932609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"774\" /></p>\n\n<p>正式进入正题，restframework主要包含认证、解析器、分页和序列化四个大的部分，就对应上图框框内的几个部分，这几个部分流程大致相同，所以就以认证为例来具体说说他的流程</p>\n\n<p>咱们接着上图继续往下一步一步走，首先会获取所有认证类的实例化对象。<br /><img alt=\"\" class=\"has\" height=\"142\" src=\"https://img-blog.csdnimg.cn/20181128000047237.png\" width=\"981\" /></p>\n\n<p>如果自己写的类里面没有认证类，就会到基类中继续寻找，默认使用rest framework的配置文件中的认证类<br /><img alt=\"\" class=\"has\" height=\"30\" src=\"https://img-blog.csdnimg.cn/20181128000109794.png\" width=\"821\" /><br />\n拿到了认证所需要的类的对象，就继续返回到dispatch中，这时候request已经是增加内容了的request</p>\n\n<p>返回dispatch之后回调用initial方法，在这个方法里面会执行所有之前我们添加的认证类、解析类<br /><img alt=\"\" class=\"has\" height=\"375\" src=\"https://img-blog.csdnimg.cn/20181128002438807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"793\" /></p>\n\n<p>initial方法里面跳转比较频繁，这里截图就重叠到一起方便看，经过一路的跳转最终是执行了request对象的_authenticate方法</p>\n\n<p><img alt=\"\" class=\"has\" height=\"426\" src=\"https://img-blog.csdnimg.cn/20181128002611464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"882\" /></p>\n\n<p>在_authenticate方法里面，会依次执行所有认证类的authenticate方法（由此我们也能知道如果我们想编写自己的认证类，那么认证部分需要放在authenticate方法里面），同时会将返回值赋值给request的user和auth属性<br /><img alt=\"\" class=\"has\" height=\"445\" src=\"https://img-blog.csdnimg.cn/20181128004850888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"849\" /></p>\n\n<p>所以rest framework的认证流程总得来说就是：<br /><img alt=\"\" class=\"has\" height=\"535\" src=\"https://img-blog.csdnimg.cn/20181128005730158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"1033\" /></p>","site":{"data":{}},"excerpt":"","more":"<h3>基础知识</h3>\n\n<p>想要弄清楚rest framework的执行过程首先需要明白Django中CBV和FBV执行流程，http请求最最本质的就是一个socket，一个请求过来第一步就是做路由匹配，在FBV中因为视图本身就是一个函数，所以直接调用函数就可以了，但是CBV中视图是一个类而在这个类里面是我们编写的视图函数，所以比FBV多了一步如何找到那个函数并且执行它。</p>\n\n<p style=\"text-indent:0;\">CBV中是基于反射实现请求方式不同执行不同的方法，我们在使用CBV来实现的时候，通常都是在路由中使用as_view方法。<br /><img alt=\"\" class=\"has\" height=\"29\" src=\"https://img-blog.csdnimg.cn/20181127162910526.png\" width=\"608\" /></p>\n\n<p>这个方法存在于我们继承的父类View中，在as_view内部又会调用dispatch方法通过反射去找到对应的函数<br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181127163104969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /><br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181127164045587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<p>所以总得来说，在CBV中一个请求过来的具体流程：url  → view → as_view → dispatch</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdnimg.cn/20181127164908520.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" /></p>\n\n<h3>源码分析</h3>\n\n<p>有了上面的基础接下来就比较容易理解了</p>\n\n<p>首先在使用rest framework框架的时候 CBV不在是继承django的View了而是 rest framework的APIView，只是这个APIView也是继承django的View的，只不过是在原有的View中增加了很多功能而已，依然还是通过反射来实现的，所以跳过前面的内容直接到dispatch这部分</p>\n\n<p><img alt=\"\" class=\"has\" height=\"458\" src=\"https://img-blog.csdnimg.cn/20181127170329362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"984\" /></p>\n\n<p><img alt=\"\" class=\"has\" height=\"328\" src=\"https://img-blog.csdnimg.cn/20181127170932609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"774\" /></p>\n\n<p>正式进入正题，restframework主要包含认证、解析器、分页和序列化四个大的部分，就对应上图框框内的几个部分，这几个部分流程大致相同，所以就以认证为例来具体说说他的流程</p>\n\n<p>咱们接着上图继续往下一步一步走，首先会获取所有认证类的实例化对象。<br /><img alt=\"\" class=\"has\" height=\"142\" src=\"https://img-blog.csdnimg.cn/20181128000047237.png\" width=\"981\" /></p>\n\n<p>如果自己写的类里面没有认证类，就会到基类中继续寻找，默认使用rest framework的配置文件中的认证类<br /><img alt=\"\" class=\"has\" height=\"30\" src=\"https://img-blog.csdnimg.cn/20181128000109794.png\" width=\"821\" /><br />\n拿到了认证所需要的类的对象，就继续返回到dispatch中，这时候request已经是增加内容了的request</p>\n\n<p>返回dispatch之后回调用initial方法，在这个方法里面会执行所有之前我们添加的认证类、解析类<br /><img alt=\"\" class=\"has\" height=\"375\" src=\"https://img-blog.csdnimg.cn/20181128002438807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"793\" /></p>\n\n<p>initial方法里面跳转比较频繁，这里截图就重叠到一起方便看，经过一路的跳转最终是执行了request对象的_authenticate方法</p>\n\n<p><img alt=\"\" class=\"has\" height=\"426\" src=\"https://img-blog.csdnimg.cn/20181128002611464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"882\" /></p>\n\n<p>在_authenticate方法里面，会依次执行所有认证类的authenticate方法（由此我们也能知道如果我们想编写自己的认证类，那么认证部分需要放在authenticate方法里面），同时会将返回值赋值给request的user和auth属性<br /><img alt=\"\" class=\"has\" height=\"445\" src=\"https://img-blog.csdnimg.cn/20181128004850888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"849\" /></p>\n\n<p>所以rest framework的认证流程总得来说就是：<br /><img alt=\"\" class=\"has\" height=\"535\" src=\"https://img-blog.csdnimg.cn/20181128005730158.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"1033\" /></p>"},{"_content":"\n<h2>一：前期准备</h2>\n<p>用到的硬件材料Arduino Mega2560 &#43; LCD4884 Joystick Shiled&nbsp;</p>\n<p>屏幕分辨率为48*84</p>\n<p>软件平台&nbsp;Arduino IDE， 需要用到的库&nbsp;U8glib &#43;MsTime2</p>\n<p><br>\n</p>\n<h2>二：设计思路</h2>\n<h3>1：游戏整体界面</h3>\n<div><span style=\"font-size:10px\">标准的俄罗斯方块为<span style=\"color:rgb(51,51,51); font-family:arial,'宋体',sans-serif; text-indent:28px\">行宽为10，列高为20，结合屏幕大小每个最小单位点设为2*2像素，共计七种方块，19种形状，使用[10][20]的二维数组存放方块位置信息，需要显示则将相应位置的数组&#20540;改为1，空白则为0。</span><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; text-indent:28px\">并在左侧显示下一个方块形状，右侧显示当前分数和等级</span></span></div>\n<div><br>\n</div>\n<div>游戏界面如图所示</div>\n<div><span style=\"color:rgb(51,51,51); font-family:arial,'宋体',sans-serif; text-indent:28px\"><span style=\"font-size:10px\"><img src=\"https://img-blog.csdn.net/20180211160807423?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</span></span></div>\n<div><br>\n</div>\n<h3>2：方块的产生、变换和移动</h3>\n<div>我没有采用使用整体存放方块图形信息的方法，因为不知道怎么使用U8glib库旋转单个图形，采用的是一种比较笨的方法。</div>\n<div>每一种方块选取一个中心点，围绕这个中心点来绘制方块，移动的时候也是直接移动中心点然后重新在中心点绘制方块，总共有16种方块图形这里选取其中一种来做例子说明</div>\n<div><br>\n</div>\n<h3>(1)&nbsp;方块的产生</h3>\n<div>例如Z形方块</div>\n<div><img src=\"https://img-blog.csdn.net/20180211161946252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div>选取B为中心点，只需要获取B的坐标信息，设为(x,y)那么其他几个方块的坐标也能相应求出来，然后将二维数组中的这几个对应&#20540;设为1，循环绘制的时候就能显示出方块图形了</div>\n<div><br>\n</div>\n<div><img src=\"https://img-blog.csdn.net/20180211162042026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<h3>(2)方块的变换和移动</h3>\n<div>我们想要控制方块旋转的时候就需要重新获取方块生成的方式</div>\n<div><img src=\"https://img-blog.csdn.net/20180211161946252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211163039154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211162938994?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div><br>\n</div>\n<div><img src=\"https://img-blog.csdn.net/20180211162042026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211163039154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211162947414?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div>在方块移动和变换的时候在这之前都需要先在二维数组中清空原有的方块信息，然后重新按照新的生成方式写入数组里面</div>\n<div><br>\n</div>\n<h3>(3):方块检测</h3>\n<div>每一次在移动和和变换的过程中还需要判断是否能够移动和变换，需要检测方块周围是否有足够的空间</div>\n<div>检测方法如下</div>\n<div><img src=\"https://img-blog.csdn.net/20180211163729222?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div>由于方块无法向上移动，所以上部不需要判断，我们只知道B的坐标，1-7号坐标可以根据B的坐标推断出来</div>\n<div>当我们需要右移动的时候就需要判断 2、4、6号位置是否已有方块阻挡或者到达边界，同理下移则需判断5、7号位置</div>\n<div><br>\n</div>\n<h2>三：详细设计</h2>\n<h3>1：按键检测</h3>\n<div>LCD4884 Joystick Shiled带有一个摇杆按键，并且和A0脚连接，所以读取A0引脚&#20540;即可。</div>\n<div>\n<pre class=\"cpp\">void Control()\n{\n  switchVoltage = analogRead(0);\n  if ( switchVoltage &gt; 600 &amp;&amp; switchVoltage &lt; 800 )            //上\n    dir = 1 ;\n  else if ( switchVoltage &gt; 180 &amp;&amp; switchVoltage &lt; 400 )       //下\n    dir = 3;\n  else if ( switchVoltage == 0 )                               //左\n    dir = 4;\n  else if ( switchVoltage &gt; 400 &amp;&amp; switchVoltage &lt; 600 )       //右\n    dir = 2;\n  else if ( switchVoltage &gt; 0 &amp;&amp; switchVoltage &lt; 180 )        //确认\n    dir = 5;\n}</pre>\n为了防止按键粘连，使用了MsTime2库定时扫描</div>\n<div>\n<pre class=\"cpp\">  MsTimer2::set(100, Control);                /*定时器中断按键的扫描*/\n  MsTimer2::start();</pre>\n<div><br>\n</div>\n<h3>2：初始化</h3>\n在游戏运行之前，初始化屏幕亮度、游戏等级、随机数种子(防止每一次方块出现次数都相同、清空数组&#20540;以及方块中心点位置，</div>\n<div>\n<pre class=\"cpp\">  randomSeed(analogRead(1));   <span style=\"white-space:pre\">\t\t</span>/*随机产生随机数序列以免方块的顺序为固定的*/\n  block_num = random(1, 20);<span style=\"white-space:pre\">\t\t</span>/*生成第一个方块信息\n  block_num_next = random(1, 20) ; <span style=\"white-space:pre\">\t</span>/*生成第二个方块\n  x = 5 , y = 2;\n  block_state_right = 0 ;\n  block_state_left = 0;\n  block_state_down = 0;\n  level_now = 300;\n  light_value = 50;    <span style=\"white-space:pre\">\t\t\t</span> /*设置背光亮度*/\n  pinMode(LCD_BACKLIGHT_PIN , OUTPUT);\n  analogWrite(LCD_BACKLIGHT_PIN, light_value);</pre>\n<br>\n<h3>3：绘制游戏界面背景</h3>\n<div>显示当前等级和分数，以及下一个方块形状，游戏的等级设置的是每次自动向下移动时延时的毫秒数，move_speed越小等级越高，方块向下移动也越来越快</div>\n<div>\n<pre class=\"cpp\">void interface()\n{\n  u8g.setFont(u8g_font_timR08);\n  u8g.drawStr(57, 10, &quot;Score&quot;);\n  u8g.drawStr(57, 30, &quot;Grade&quot;);\n  u8g.drawStr(0, 10, &quot;Next&quot;);\n  u8g.setPrintPos(70, 20);\n  /*显示分数*/\n  u8g.print(score);\n  /*显示等级*/\n  if ( move_speed &lt;= 300)\n    u8g.drawBox(60, 42, 3, 6);\n  if ( move_speed &lt;= 250)\n    u8g.drawBox(65, 39, 3, 9);\n  if ( move_speed &lt;= 200)\n    u8g.drawBox(70, 36, 3, 12);\n  if ( move_speed &lt;= 150)\n    u8g.drawBox(75, 33, 3, 15);\n  if (move_speed &lt;= 100)\n    u8g.drawBox(80, 30, 3, 18);\n  /*显示下一个方块*/\n  create_box_next(1);\n  for (int m = 0 ; m &lt; 5 ; m&#43;&#43;)\n    for (int n = 0 ; n &lt; 5 ; n&#43;&#43;)\n    {\n      if ( block_next[m][n] == 1)\n        u8g.drawBox(3 * m &#43; 5, 3 * n &#43; 15, 3, 3);\n    }\n  create_box_next(0);\n}</pre>\n</div>\n<div><br>\n</div>\n<h3>4：方块的生成</h3>\n<div>形状太多，代码复用率太高只截取部分，每次移动或者变换的时候都需要调用这个函数来清除上一个方块的位置信息</div>\n<div>\n<pre class=\"cpp\">void create_box(int a )  /*调整block数组中的&#20540;，参数为0的时候清除，参数为1时写入*/\n{\n  switch (block_num)\n  {\n    case 1:\n      block[x][y &#43; 1] = a;\n      block[x][y - 1] = a;\n      block[x - 1][y] = a;\n      block[x][y] = a;\n      break ;\n  }\n｝</pre>\n<br>\n<h3>5：方块的移动和变换</h3>\n</div>\n<div>每次移动和变换之前都得判断方块能否移动，能够移动还需要在移动之前清空原有的，不能移动的时候需要产生新的方块，这时候方块的中心点需要重置，并且当前形状的标号改为block_num_next的&#20540;，再重新随机生成一个数给block_num_next</div>\n<div>\n<pre class=\"cpp\">void block_go()             /*方块的移动和变形*/\n{\n  block_fixed();\n  if (block_state_down == 1 )    /*方块不能下降的时候生成新的方块*/\n  {\n    for (int m = 0; m &lt; 10; m&#43;&#43;)\n    {\n      if (block[m][3] == 1) /*判断游戏是否结束*/\n      {\n        game_over();\n        break;\n      }\n    }\n    x = 5 , y = 2;    /*设置初始中心点位置*/\n    block_num = block_num_next ;\n    block_num_next = random(1, 20) ;\n    block_state_right = 0 ;\n    block_state_left = 0;\n    block_state_down = 0;\n    create_box(0);\n  }}</pre>\n变换方块形状，需要注意的是方块标号是连续的，每次变换的时候实际只是更改了当前方块的标号，为了防止从一个类型调到另一个类型需要做一些判断来限制标号更改的范围</div>\n<div>\n<pre class=\"cpp\">switch (dir)\n  {\n    case 1:           /*变换方块形状*/\n      create_box(0);\n      if ( block_num &gt;= 1 &amp;&amp; block_num &lt;= 4)   /*防止变换的时候方块形状发生变换*/\n      {\n        block_num&#43;&#43;;\n        if (block_num &gt; 4)\n          block_num = 1;\n      }\n  }</pre>\n<br>\n<h3>6：判断方块能否移动</h3>\n每一种方块的判断方法都不同，需要根据当前方块标号做出不同的判断，判断结束会返回三个状态，block_state_left、block_state_down、block_state_right，这三个&#20540;为0的时候是可以向这个方向移动的</div>\n<div>\n<pre class=\"cpp\">void block_fixed()      /*判断方块是否能够移动*/\n{\n  switch (block_num)\n  {\n    case 1:\n      if (block[x - 2][y] == 1 || block[x - 1][y - 1] == 1 || block[x - 1][y &#43; 1] == 1 || x &lt;= 1)\n        block_state_left = 1;\n      else\n        block_state_left = 0;\n      if (block[x &#43; 1][y] == 1 || block[x &#43; 1][y - 1] == 1 || block[x &#43; 1][y &#43; 1] == 1 || x &gt;= 9)\n        block_state_right = 1;\n      else\n        block_state_right = 0;\n      if (block[x - 1][y &#43; 1] == 1 || block[x][y &#43; 2] == 1 || y &gt;= 18)\n        block_state_down = 1;\n      else\n        block_state_down = 0;\n      break;\n  }\n}</pre>\n<div><br>\n</div>\n<h3>7：绘制方块</h3>\n<div>遍历二维数组，当&#20540;为1的时候则显示最小像素点</div>\n<div>\n<pre class=\"cpp\">void draw_block()     /*绘制方块*/\n{\n  int block_x , block_y;\n  for (block_x = 0 ; block_x &lt; 10 ; block_x &#43;&#43;)\n    for (block_y = 0 ; block_y &lt; 20 ; block_y &#43;&#43;)\n    {\n      if (block[block_x][block_y] == 1)\n        u8g.drawBox(2 * block_x &#43; 28 , 2 * block_y &#43; 4 , 2 , 2);\n    }\n}</pre>\n<br>\n<br>\n</div>\n<h3>8：计算得分</h3>\n</div>\n<div>遍历整个二维数组，判断有多少行全为1，然后再将数组中每一行都往下挪多少行</div>\n<div>\n<pre class=\"cpp\">void remove_block()\n{\n  int sum = 0, m, n, i = 0 , h;       /*i：需要消除的行数，h:记录是哪一行需要消除*/\n  /*判断有多少行需要消除*/\n  for ( m = 19 ; m &gt; 4; m--)\n  {\n    for ( n = 0 ; n &lt; 10 ; n&#43;&#43;)\n      sum &#43;= block[n][m];\n    if (sum == 10)\n    {\n      i&#43;&#43;;\n      score &#43;= 10;\n      h = m;\n      block_state_down = 1 ;\n    }\n    else\n      sum = 0;\n  }\n  /*当存在消行的情况下数组每一行都向下移动i个单位*/\n  for (i; i &gt; 0; i--)\n    for ( m = h; m &gt;= 3; m--)\n      for ( n = 0; n &lt; 10; n&#43;&#43;)\n        block[n][m] = block[n][m - 1];\n}</pre>\n<br>\n<br>\n</div>\n<h2>四：结语</h2>\n<div>这个游戏是在一年前完成的，到今天很多细节忘得差不多了，只能凭借印象来大致的说明一下主要的流程和思路，代码中有很大一部分重用导致看起来很臃肿现在也懒得改了，有想折腾的可以尝试完善完善，另外其他的屏幕也是能适用的，只需要更改按键控制那个函数和u8glib那个头文件即可，但是分辨率就没办法了</div>\n<div>源码连接，喜欢的还请赏个Star</div>\n<div><strong><span style=\"color:#ff0000\">https://github.com/FanMLei/Arduino_Games</span></strong><br>\n</div>\n<div>试玩视频</div>\n<div><strong><span style=\"color:#ff0000\">http://v.youku.com/v_show/id_XMzM5NjA0NjY2OA==.html?spm=a2h3j.8428770.3416059.1</span></strong><br>\n</div>\n<div><br>\n</div>\n&nbsp;</div>\n<div><br>\n<br>\n</div>\n<div><br>\n</div>\n<p><br>\n</p>\n","source":"_posts/blogs-Arduino小游戏集合（俄罗斯方块）.md","raw":"\n<h2>一：前期准备</h2>\n<p>用到的硬件材料Arduino Mega2560 &#43; LCD4884 Joystick Shiled&nbsp;</p>\n<p>屏幕分辨率为48*84</p>\n<p>软件平台&nbsp;Arduino IDE， 需要用到的库&nbsp;U8glib &#43;MsTime2</p>\n<p><br>\n</p>\n<h2>二：设计思路</h2>\n<h3>1：游戏整体界面</h3>\n<div><span style=\"font-size:10px\">标准的俄罗斯方块为<span style=\"color:rgb(51,51,51); font-family:arial,'宋体',sans-serif; text-indent:28px\">行宽为10，列高为20，结合屏幕大小每个最小单位点设为2*2像素，共计七种方块，19种形状，使用[10][20]的二维数组存放方块位置信息，需要显示则将相应位置的数组&#20540;改为1，空白则为0。</span><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; text-indent:28px\">并在左侧显示下一个方块形状，右侧显示当前分数和等级</span></span></div>\n<div><br>\n</div>\n<div>游戏界面如图所示</div>\n<div><span style=\"color:rgb(51,51,51); font-family:arial,'宋体',sans-serif; text-indent:28px\"><span style=\"font-size:10px\"><img src=\"https://img-blog.csdn.net/20180211160807423?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</span></span></div>\n<div><br>\n</div>\n<h3>2：方块的产生、变换和移动</h3>\n<div>我没有采用使用整体存放方块图形信息的方法，因为不知道怎么使用U8glib库旋转单个图形，采用的是一种比较笨的方法。</div>\n<div>每一种方块选取一个中心点，围绕这个中心点来绘制方块，移动的时候也是直接移动中心点然后重新在中心点绘制方块，总共有16种方块图形这里选取其中一种来做例子说明</div>\n<div><br>\n</div>\n<h3>(1)&nbsp;方块的产生</h3>\n<div>例如Z形方块</div>\n<div><img src=\"https://img-blog.csdn.net/20180211161946252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div>选取B为中心点，只需要获取B的坐标信息，设为(x,y)那么其他几个方块的坐标也能相应求出来，然后将二维数组中的这几个对应&#20540;设为1，循环绘制的时候就能显示出方块图形了</div>\n<div><br>\n</div>\n<div><img src=\"https://img-blog.csdn.net/20180211162042026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<h3>(2)方块的变换和移动</h3>\n<div>我们想要控制方块旋转的时候就需要重新获取方块生成的方式</div>\n<div><img src=\"https://img-blog.csdn.net/20180211161946252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211163039154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211162938994?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div><br>\n</div>\n<div><img src=\"https://img-blog.csdn.net/20180211162042026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211163039154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211162947414?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div>在方块移动和变换的时候在这之前都需要先在二维数组中清空原有的方块信息，然后重新按照新的生成方式写入数组里面</div>\n<div><br>\n</div>\n<h3>(3):方块检测</h3>\n<div>每一次在移动和和变换的过程中还需要判断是否能够移动和变换，需要检测方块周围是否有足够的空间</div>\n<div>检测方法如下</div>\n<div><img src=\"https://img-blog.csdn.net/20180211163729222?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div>由于方块无法向上移动，所以上部不需要判断，我们只知道B的坐标，1-7号坐标可以根据B的坐标推断出来</div>\n<div>当我们需要右移动的时候就需要判断 2、4、6号位置是否已有方块阻挡或者到达边界，同理下移则需判断5、7号位置</div>\n<div><br>\n</div>\n<h2>三：详细设计</h2>\n<h3>1：按键检测</h3>\n<div>LCD4884 Joystick Shiled带有一个摇杆按键，并且和A0脚连接，所以读取A0引脚&#20540;即可。</div>\n<div>\n<pre class=\"cpp\">void Control()\n{\n  switchVoltage = analogRead(0);\n  if ( switchVoltage &gt; 600 &amp;&amp; switchVoltage &lt; 800 )            //上\n    dir = 1 ;\n  else if ( switchVoltage &gt; 180 &amp;&amp; switchVoltage &lt; 400 )       //下\n    dir = 3;\n  else if ( switchVoltage == 0 )                               //左\n    dir = 4;\n  else if ( switchVoltage &gt; 400 &amp;&amp; switchVoltage &lt; 600 )       //右\n    dir = 2;\n  else if ( switchVoltage &gt; 0 &amp;&amp; switchVoltage &lt; 180 )        //确认\n    dir = 5;\n}</pre>\n为了防止按键粘连，使用了MsTime2库定时扫描</div>\n<div>\n<pre class=\"cpp\">  MsTimer2::set(100, Control);                /*定时器中断按键的扫描*/\n  MsTimer2::start();</pre>\n<div><br>\n</div>\n<h3>2：初始化</h3>\n在游戏运行之前，初始化屏幕亮度、游戏等级、随机数种子(防止每一次方块出现次数都相同、清空数组&#20540;以及方块中心点位置，</div>\n<div>\n<pre class=\"cpp\">  randomSeed(analogRead(1));   <span style=\"white-space:pre\">\t\t</span>/*随机产生随机数序列以免方块的顺序为固定的*/\n  block_num = random(1, 20);<span style=\"white-space:pre\">\t\t</span>/*生成第一个方块信息\n  block_num_next = random(1, 20) ; <span style=\"white-space:pre\">\t</span>/*生成第二个方块\n  x = 5 , y = 2;\n  block_state_right = 0 ;\n  block_state_left = 0;\n  block_state_down = 0;\n  level_now = 300;\n  light_value = 50;    <span style=\"white-space:pre\">\t\t\t</span> /*设置背光亮度*/\n  pinMode(LCD_BACKLIGHT_PIN , OUTPUT);\n  analogWrite(LCD_BACKLIGHT_PIN, light_value);</pre>\n<br>\n<h3>3：绘制游戏界面背景</h3>\n<div>显示当前等级和分数，以及下一个方块形状，游戏的等级设置的是每次自动向下移动时延时的毫秒数，move_speed越小等级越高，方块向下移动也越来越快</div>\n<div>\n<pre class=\"cpp\">void interface()\n{\n  u8g.setFont(u8g_font_timR08);\n  u8g.drawStr(57, 10, &quot;Score&quot;);\n  u8g.drawStr(57, 30, &quot;Grade&quot;);\n  u8g.drawStr(0, 10, &quot;Next&quot;);\n  u8g.setPrintPos(70, 20);\n  /*显示分数*/\n  u8g.print(score);\n  /*显示等级*/\n  if ( move_speed &lt;= 300)\n    u8g.drawBox(60, 42, 3, 6);\n  if ( move_speed &lt;= 250)\n    u8g.drawBox(65, 39, 3, 9);\n  if ( move_speed &lt;= 200)\n    u8g.drawBox(70, 36, 3, 12);\n  if ( move_speed &lt;= 150)\n    u8g.drawBox(75, 33, 3, 15);\n  if (move_speed &lt;= 100)\n    u8g.drawBox(80, 30, 3, 18);\n  /*显示下一个方块*/\n  create_box_next(1);\n  for (int m = 0 ; m &lt; 5 ; m&#43;&#43;)\n    for (int n = 0 ; n &lt; 5 ; n&#43;&#43;)\n    {\n      if ( block_next[m][n] == 1)\n        u8g.drawBox(3 * m &#43; 5, 3 * n &#43; 15, 3, 3);\n    }\n  create_box_next(0);\n}</pre>\n</div>\n<div><br>\n</div>\n<h3>4：方块的生成</h3>\n<div>形状太多，代码复用率太高只截取部分，每次移动或者变换的时候都需要调用这个函数来清除上一个方块的位置信息</div>\n<div>\n<pre class=\"cpp\">void create_box(int a )  /*调整block数组中的&#20540;，参数为0的时候清除，参数为1时写入*/\n{\n  switch (block_num)\n  {\n    case 1:\n      block[x][y &#43; 1] = a;\n      block[x][y - 1] = a;\n      block[x - 1][y] = a;\n      block[x][y] = a;\n      break ;\n  }\n｝</pre>\n<br>\n<h3>5：方块的移动和变换</h3>\n</div>\n<div>每次移动和变换之前都得判断方块能否移动，能够移动还需要在移动之前清空原有的，不能移动的时候需要产生新的方块，这时候方块的中心点需要重置，并且当前形状的标号改为block_num_next的&#20540;，再重新随机生成一个数给block_num_next</div>\n<div>\n<pre class=\"cpp\">void block_go()             /*方块的移动和变形*/\n{\n  block_fixed();\n  if (block_state_down == 1 )    /*方块不能下降的时候生成新的方块*/\n  {\n    for (int m = 0; m &lt; 10; m&#43;&#43;)\n    {\n      if (block[m][3] == 1) /*判断游戏是否结束*/\n      {\n        game_over();\n        break;\n      }\n    }\n    x = 5 , y = 2;    /*设置初始中心点位置*/\n    block_num = block_num_next ;\n    block_num_next = random(1, 20) ;\n    block_state_right = 0 ;\n    block_state_left = 0;\n    block_state_down = 0;\n    create_box(0);\n  }}</pre>\n变换方块形状，需要注意的是方块标号是连续的，每次变换的时候实际只是更改了当前方块的标号，为了防止从一个类型调到另一个类型需要做一些判断来限制标号更改的范围</div>\n<div>\n<pre class=\"cpp\">switch (dir)\n  {\n    case 1:           /*变换方块形状*/\n      create_box(0);\n      if ( block_num &gt;= 1 &amp;&amp; block_num &lt;= 4)   /*防止变换的时候方块形状发生变换*/\n      {\n        block_num&#43;&#43;;\n        if (block_num &gt; 4)\n          block_num = 1;\n      }\n  }</pre>\n<br>\n<h3>6：判断方块能否移动</h3>\n每一种方块的判断方法都不同，需要根据当前方块标号做出不同的判断，判断结束会返回三个状态，block_state_left、block_state_down、block_state_right，这三个&#20540;为0的时候是可以向这个方向移动的</div>\n<div>\n<pre class=\"cpp\">void block_fixed()      /*判断方块是否能够移动*/\n{\n  switch (block_num)\n  {\n    case 1:\n      if (block[x - 2][y] == 1 || block[x - 1][y - 1] == 1 || block[x - 1][y &#43; 1] == 1 || x &lt;= 1)\n        block_state_left = 1;\n      else\n        block_state_left = 0;\n      if (block[x &#43; 1][y] == 1 || block[x &#43; 1][y - 1] == 1 || block[x &#43; 1][y &#43; 1] == 1 || x &gt;= 9)\n        block_state_right = 1;\n      else\n        block_state_right = 0;\n      if (block[x - 1][y &#43; 1] == 1 || block[x][y &#43; 2] == 1 || y &gt;= 18)\n        block_state_down = 1;\n      else\n        block_state_down = 0;\n      break;\n  }\n}</pre>\n<div><br>\n</div>\n<h3>7：绘制方块</h3>\n<div>遍历二维数组，当&#20540;为1的时候则显示最小像素点</div>\n<div>\n<pre class=\"cpp\">void draw_block()     /*绘制方块*/\n{\n  int block_x , block_y;\n  for (block_x = 0 ; block_x &lt; 10 ; block_x &#43;&#43;)\n    for (block_y = 0 ; block_y &lt; 20 ; block_y &#43;&#43;)\n    {\n      if (block[block_x][block_y] == 1)\n        u8g.drawBox(2 * block_x &#43; 28 , 2 * block_y &#43; 4 , 2 , 2);\n    }\n}</pre>\n<br>\n<br>\n</div>\n<h3>8：计算得分</h3>\n</div>\n<div>遍历整个二维数组，判断有多少行全为1，然后再将数组中每一行都往下挪多少行</div>\n<div>\n<pre class=\"cpp\">void remove_block()\n{\n  int sum = 0, m, n, i = 0 , h;       /*i：需要消除的行数，h:记录是哪一行需要消除*/\n  /*判断有多少行需要消除*/\n  for ( m = 19 ; m &gt; 4; m--)\n  {\n    for ( n = 0 ; n &lt; 10 ; n&#43;&#43;)\n      sum &#43;= block[n][m];\n    if (sum == 10)\n    {\n      i&#43;&#43;;\n      score &#43;= 10;\n      h = m;\n      block_state_down = 1 ;\n    }\n    else\n      sum = 0;\n  }\n  /*当存在消行的情况下数组每一行都向下移动i个单位*/\n  for (i; i &gt; 0; i--)\n    for ( m = h; m &gt;= 3; m--)\n      for ( n = 0; n &lt; 10; n&#43;&#43;)\n        block[n][m] = block[n][m - 1];\n}</pre>\n<br>\n<br>\n</div>\n<h2>四：结语</h2>\n<div>这个游戏是在一年前完成的，到今天很多细节忘得差不多了，只能凭借印象来大致的说明一下主要的流程和思路，代码中有很大一部分重用导致看起来很臃肿现在也懒得改了，有想折腾的可以尝试完善完善，另外其他的屏幕也是能适用的，只需要更改按键控制那个函数和u8glib那个头文件即可，但是分辨率就没办法了</div>\n<div>源码连接，喜欢的还请赏个Star</div>\n<div><strong><span style=\"color:#ff0000\">https://github.com/FanMLei/Arduino_Games</span></strong><br>\n</div>\n<div>试玩视频</div>\n<div><strong><span style=\"color:#ff0000\">http://v.youku.com/v_show/id_XMzM5NjA0NjY2OA==.html?spm=a2h3j.8428770.3416059.1</span></strong><br>\n</div>\n<div><br>\n</div>\n&nbsp;</div>\n<div><br>\n<br>\n</div>\n<div><br>\n</div>\n<p><br>\n</p>\n","slug":"blogs-Arduino小游戏集合（俄罗斯方块）","published":1,"date":"2022-03-16T17:09:45.294Z","updated":"2022-03-16T17:09:45.294Z","_id":"cl0v6kes8000oyms4gj7k86qw","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h2>一：前期准备</h2>\n<p>用到的硬件材料Arduino Mega2560 &#43; LCD4884 Joystick Shiled&nbsp;</p>\n<p>屏幕分辨率为48*84</p>\n<p>软件平台&nbsp;Arduino IDE， 需要用到的库&nbsp;U8glib &#43;MsTime2</p>\n<p><br>\n</p>\n<h2>二：设计思路</h2>\n<h3>1：游戏整体界面</h3>\n<div><span style=\"font-size:10px\">标准的俄罗斯方块为<span style=\"color:rgb(51,51,51); font-family:arial,'宋体',sans-serif; text-indent:28px\">行宽为10，列高为20，结合屏幕大小每个最小单位点设为2*2像素，共计七种方块，19种形状，使用[10][20]的二维数组存放方块位置信息，需要显示则将相应位置的数组&#20540;改为1，空白则为0。</span><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; text-indent:28px\">并在左侧显示下一个方块形状，右侧显示当前分数和等级</span></span></div>\n<div><br>\n</div>\n<div>游戏界面如图所示</div>\n<div><span style=\"color:rgb(51,51,51); font-family:arial,'宋体',sans-serif; text-indent:28px\"><span style=\"font-size:10px\"><img src=\"https://img-blog.csdn.net/20180211160807423?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</span></span></div>\n<div><br>\n</div>\n<h3>2：方块的产生、变换和移动</h3>\n<div>我没有采用使用整体存放方块图形信息的方法，因为不知道怎么使用U8glib库旋转单个图形，采用的是一种比较笨的方法。</div>\n<div>每一种方块选取一个中心点，围绕这个中心点来绘制方块，移动的时候也是直接移动中心点然后重新在中心点绘制方块，总共有16种方块图形这里选取其中一种来做例子说明</div>\n<div><br>\n</div>\n<h3>(1)&nbsp;方块的产生</h3>\n<div>例如Z形方块</div>\n<div><img src=\"https://img-blog.csdn.net/20180211161946252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div>选取B为中心点，只需要获取B的坐标信息，设为(x,y)那么其他几个方块的坐标也能相应求出来，然后将二维数组中的这几个对应&#20540;设为1，循环绘制的时候就能显示出方块图形了</div>\n<div><br>\n</div>\n<div><img src=\"https://img-blog.csdn.net/20180211162042026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<h3>(2)方块的变换和移动</h3>\n<div>我们想要控制方块旋转的时候就需要重新获取方块生成的方式</div>\n<div><img src=\"https://img-blog.csdn.net/20180211161946252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211163039154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211162938994?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div><br>\n</div>\n<div><img src=\"https://img-blog.csdn.net/20180211162042026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211163039154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211162947414?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div>在方块移动和变换的时候在这之前都需要先在二维数组中清空原有的方块信息，然后重新按照新的生成方式写入数组里面</div>\n<div><br>\n</div>\n<h3>(3):方块检测</h3>\n<div>每一次在移动和和变换的过程中还需要判断是否能够移动和变换，需要检测方块周围是否有足够的空间</div>\n<div>检测方法如下</div>\n<div><img src=\"https://img-blog.csdn.net/20180211163729222?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div>由于方块无法向上移动，所以上部不需要判断，我们只知道B的坐标，1-7号坐标可以根据B的坐标推断出来</div>\n<div>当我们需要右移动的时候就需要判断 2、4、6号位置是否已有方块阻挡或者到达边界，同理下移则需判断5、7号位置</div>\n<div><br>\n</div>\n<h2>三：详细设计</h2>\n<h3>1：按键检测</h3>\n<div>LCD4884 Joystick Shiled带有一个摇杆按键，并且和A0脚连接，所以读取A0引脚&#20540;即可。</div>\n<div>\n<pre class=\"cpp\">void Control()\n{\n  switchVoltage = analogRead(0);\n  if ( switchVoltage &gt; 600 &amp;&amp; switchVoltage &lt; 800 )            //上\n    dir = 1 ;\n  else if ( switchVoltage &gt; 180 &amp;&amp; switchVoltage &lt; 400 )       //下\n    dir = 3;\n  else if ( switchVoltage == 0 )                               //左\n    dir = 4;\n  else if ( switchVoltage &gt; 400 &amp;&amp; switchVoltage &lt; 600 )       //右\n    dir = 2;\n  else if ( switchVoltage &gt; 0 &amp;&amp; switchVoltage &lt; 180 )        //确认\n    dir = 5;\n}</pre>\n为了防止按键粘连，使用了MsTime2库定时扫描</div>\n<div>\n<pre class=\"cpp\">  MsTimer2::set(100, Control);                /*定时器中断按键的扫描*/\n  MsTimer2::start();</pre>\n<div><br>\n</div>\n<h3>2：初始化</h3>\n在游戏运行之前，初始化屏幕亮度、游戏等级、随机数种子(防止每一次方块出现次数都相同、清空数组&#20540;以及方块中心点位置，</div>\n<div>\n<pre class=\"cpp\">  randomSeed(analogRead(1));   <span style=\"white-space:pre\">        </span>/*随机产生随机数序列以免方块的顺序为固定的*/\n  block_num = random(1, 20);<span style=\"white-space:pre\">        </span>/*生成第一个方块信息\n  block_num_next = random(1, 20) ; <span style=\"white-space:pre\">    </span>/*生成第二个方块\n  x = 5 , y = 2;\n  block_state_right = 0 ;\n  block_state_left = 0;\n  block_state_down = 0;\n  level_now = 300;\n  light_value = 50;    <span style=\"white-space:pre\">            </span> /*设置背光亮度*/\n  pinMode(LCD_BACKLIGHT_PIN , OUTPUT);\n  analogWrite(LCD_BACKLIGHT_PIN, light_value);</pre>\n<br>\n<h3>3：绘制游戏界面背景</h3>\n<div>显示当前等级和分数，以及下一个方块形状，游戏的等级设置的是每次自动向下移动时延时的毫秒数，move_speed越小等级越高，方块向下移动也越来越快</div>\n<div>\n<pre class=\"cpp\">void interface()\n{\n  u8g.setFont(u8g_font_timR08);\n  u8g.drawStr(57, 10, &quot;Score&quot;);\n  u8g.drawStr(57, 30, &quot;Grade&quot;);\n  u8g.drawStr(0, 10, &quot;Next&quot;);\n  u8g.setPrintPos(70, 20);\n  /*显示分数*/\n  u8g.print(score);\n  /*显示等级*/\n  if ( move_speed &lt;= 300)\n    u8g.drawBox(60, 42, 3, 6);\n  if ( move_speed &lt;= 250)\n    u8g.drawBox(65, 39, 3, 9);\n  if ( move_speed &lt;= 200)\n    u8g.drawBox(70, 36, 3, 12);\n  if ( move_speed &lt;= 150)\n    u8g.drawBox(75, 33, 3, 15);\n  if (move_speed &lt;= 100)\n    u8g.drawBox(80, 30, 3, 18);\n  /*显示下一个方块*/\n  create_box_next(1);\n  for (int m = 0 ; m &lt; 5 ; m&#43;&#43;)\n    for (int n = 0 ; n &lt; 5 ; n&#43;&#43;)\n    {\n      if ( block_next[m][n] == 1)\n        u8g.drawBox(3 * m &#43; 5, 3 * n &#43; 15, 3, 3);\n    }\n  create_box_next(0);\n}</pre>\n</div>\n<div><br>\n</div>\n<h3>4：方块的生成</h3>\n<div>形状太多，代码复用率太高只截取部分，每次移动或者变换的时候都需要调用这个函数来清除上一个方块的位置信息</div>\n<div>\n<pre class=\"cpp\">void create_box(int a )  /*调整block数组中的&#20540;，参数为0的时候清除，参数为1时写入*/\n{\n  switch (block_num)\n  {\n    case 1:\n      block[x][y &#43; 1] = a;\n      block[x][y - 1] = a;\n      block[x - 1][y] = a;\n      block[x][y] = a;\n      break ;\n  }\n｝</pre>\n<br>\n<h3>5：方块的移动和变换</h3>\n</div>\n<div>每次移动和变换之前都得判断方块能否移动，能够移动还需要在移动之前清空原有的，不能移动的时候需要产生新的方块，这时候方块的中心点需要重置，并且当前形状的标号改为block_num_next的&#20540;，再重新随机生成一个数给block_num_next</div>\n<div>\n<pre class=\"cpp\">void block_go()             /*方块的移动和变形*/\n{\n  block_fixed();\n  if (block_state_down == 1 )    /*方块不能下降的时候生成新的方块*/\n  {\n    for (int m = 0; m &lt; 10; m&#43;&#43;)\n    {\n      if (block[m][3] == 1) /*判断游戏是否结束*/\n      {\n        game_over();\n        break;\n      }\n    }\n    x = 5 , y = 2;    /*设置初始中心点位置*/\n    block_num = block_num_next ;\n    block_num_next = random(1, 20) ;\n    block_state_right = 0 ;\n    block_state_left = 0;\n    block_state_down = 0;\n    create_box(0);\n  }}</pre>\n变换方块形状，需要注意的是方块标号是连续的，每次变换的时候实际只是更改了当前方块的标号，为了防止从一个类型调到另一个类型需要做一些判断来限制标号更改的范围</div>\n<div>\n<pre class=\"cpp\">switch (dir)\n  {\n    case 1:           /*变换方块形状*/\n      create_box(0);\n      if ( block_num &gt;= 1 &amp;&amp; block_num &lt;= 4)   /*防止变换的时候方块形状发生变换*/\n      {\n        block_num&#43;&#43;;\n        if (block_num &gt; 4)\n          block_num = 1;\n      }\n  }</pre>\n<br>\n<h3>6：判断方块能否移动</h3>\n每一种方块的判断方法都不同，需要根据当前方块标号做出不同的判断，判断结束会返回三个状态，block_state_left、block_state_down、block_state_right，这三个&#20540;为0的时候是可以向这个方向移动的</div>\n<div>\n<pre class=\"cpp\">void block_fixed()      /*判断方块是否能够移动*/\n{\n  switch (block_num)\n  {\n    case 1:\n      if (block[x - 2][y] == 1 || block[x - 1][y - 1] == 1 || block[x - 1][y &#43; 1] == 1 || x &lt;= 1)\n        block_state_left = 1;\n      else\n        block_state_left = 0;\n      if (block[x &#43; 1][y] == 1 || block[x &#43; 1][y - 1] == 1 || block[x &#43; 1][y &#43; 1] == 1 || x &gt;= 9)\n        block_state_right = 1;\n      else\n        block_state_right = 0;\n      if (block[x - 1][y &#43; 1] == 1 || block[x][y &#43; 2] == 1 || y &gt;= 18)\n        block_state_down = 1;\n      else\n        block_state_down = 0;\n      break;\n  }\n}</pre>\n<div><br>\n</div>\n<h3>7：绘制方块</h3>\n<div>遍历二维数组，当&#20540;为1的时候则显示最小像素点</div>\n<div>\n<pre class=\"cpp\">void draw_block()     /*绘制方块*/\n{\n  int block_x , block_y;\n  for (block_x = 0 ; block_x &lt; 10 ; block_x &#43;&#43;)\n    for (block_y = 0 ; block_y &lt; 20 ; block_y &#43;&#43;)\n    {\n      if (block[block_x][block_y] == 1)\n        u8g.drawBox(2 * block_x &#43; 28 , 2 * block_y &#43; 4 , 2 , 2);\n    }\n}</pre>\n<br>\n<br>\n</div>\n<h3>8：计算得分</h3>\n</div>\n<div>遍历整个二维数组，判断有多少行全为1，然后再将数组中每一行都往下挪多少行</div>\n<div>\n<pre class=\"cpp\">void remove_block()\n{\n  int sum = 0, m, n, i = 0 , h;       /*i：需要消除的行数，h:记录是哪一行需要消除*/\n  /*判断有多少行需要消除*/\n  for ( m = 19 ; m &gt; 4; m--)\n  {\n    for ( n = 0 ; n &lt; 10 ; n&#43;&#43;)\n      sum &#43;= block[n][m];\n    if (sum == 10)\n    {\n      i&#43;&#43;;\n      score &#43;= 10;\n      h = m;\n      block_state_down = 1 ;\n    }\n    else\n      sum = 0;\n  }\n  /*当存在消行的情况下数组每一行都向下移动i个单位*/\n  for (i; i &gt; 0; i--)\n    for ( m = h; m &gt;= 3; m--)\n      for ( n = 0; n &lt; 10; n&#43;&#43;)\n        block[n][m] = block[n][m - 1];\n}</pre>\n<br>\n<br>\n</div>\n<h2>四：结语</h2>\n<div>这个游戏是在一年前完成的，到今天很多细节忘得差不多了，只能凭借印象来大致的说明一下主要的流程和思路，代码中有很大一部分重用导致看起来很臃肿现在也懒得改了，有想折腾的可以尝试完善完善，另外其他的屏幕也是能适用的，只需要更改按键控制那个函数和u8glib那个头文件即可，但是分辨率就没办法了</div>\n<div>源码连接，喜欢的还请赏个Star</div>\n<div><strong><span style=\"color:#ff0000\">https://github.com/FanMLei/Arduino_Games</span></strong><br>\n</div>\n<div>试玩视频</div>\n<div><strong><span style=\"color:#ff0000\">http://v.youku.com/v_show/id_XMzM5NjA0NjY2OA==.html?spm=a2h3j.8428770.3416059.1</span></strong><br>\n</div>\n<div><br>\n</div>\n&nbsp;</div>\n<div><br>\n<br>\n</div>\n<div><br>\n</div>\n<p><br>\n</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>一：前期准备</h2>\n<p>用到的硬件材料Arduino Mega2560 &#43; LCD4884 Joystick Shiled&nbsp;</p>\n<p>屏幕分辨率为48*84</p>\n<p>软件平台&nbsp;Arduino IDE， 需要用到的库&nbsp;U8glib &#43;MsTime2</p>\n<p><br>\n</p>\n<h2>二：设计思路</h2>\n<h3>1：游戏整体界面</h3>\n<div><span style=\"font-size:10px\">标准的俄罗斯方块为<span style=\"color:rgb(51,51,51); font-family:arial,'宋体',sans-serif; text-indent:28px\">行宽为10，列高为20，结合屏幕大小每个最小单位点设为2*2像素，共计七种方块，19种形状，使用[10][20]的二维数组存放方块位置信息，需要显示则将相应位置的数组&#20540;改为1，空白则为0。</span><span style=\"color:rgb(51,51,51); font-family:arial,宋体,sans-serif; text-indent:28px\">并在左侧显示下一个方块形状，右侧显示当前分数和等级</span></span></div>\n<div><br>\n</div>\n<div>游戏界面如图所示</div>\n<div><span style=\"color:rgb(51,51,51); font-family:arial,'宋体',sans-serif; text-indent:28px\"><span style=\"font-size:10px\"><img src=\"https://img-blog.csdn.net/20180211160807423?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</span></span></div>\n<div><br>\n</div>\n<h3>2：方块的产生、变换和移动</h3>\n<div>我没有采用使用整体存放方块图形信息的方法，因为不知道怎么使用U8glib库旋转单个图形，采用的是一种比较笨的方法。</div>\n<div>每一种方块选取一个中心点，围绕这个中心点来绘制方块，移动的时候也是直接移动中心点然后重新在中心点绘制方块，总共有16种方块图形这里选取其中一种来做例子说明</div>\n<div><br>\n</div>\n<h3>(1)&nbsp;方块的产生</h3>\n<div>例如Z形方块</div>\n<div><img src=\"https://img-blog.csdn.net/20180211161946252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div>选取B为中心点，只需要获取B的坐标信息，设为(x,y)那么其他几个方块的坐标也能相应求出来，然后将二维数组中的这几个对应&#20540;设为1，循环绘制的时候就能显示出方块图形了</div>\n<div><br>\n</div>\n<div><img src=\"https://img-blog.csdn.net/20180211162042026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<h3>(2)方块的变换和移动</h3>\n<div>我们想要控制方块旋转的时候就需要重新获取方块生成的方式</div>\n<div><img src=\"https://img-blog.csdn.net/20180211161946252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211163039154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211162938994?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div><br>\n</div>\n<div><img src=\"https://img-blog.csdn.net/20180211162042026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211163039154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180211162947414?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div>在方块移动和变换的时候在这之前都需要先在二维数组中清空原有的方块信息，然后重新按照新的生成方式写入数组里面</div>\n<div><br>\n</div>\n<h3>(3):方块检测</h3>\n<div>每一次在移动和和变换的过程中还需要判断是否能够移动和变换，需要检测方块周围是否有足够的空间</div>\n<div>检测方法如下</div>\n<div><img src=\"https://img-blog.csdn.net/20180211163729222?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div>由于方块无法向上移动，所以上部不需要判断，我们只知道B的坐标，1-7号坐标可以根据B的坐标推断出来</div>\n<div>当我们需要右移动的时候就需要判断 2、4、6号位置是否已有方块阻挡或者到达边界，同理下移则需判断5、7号位置</div>\n<div><br>\n</div>\n<h2>三：详细设计</h2>\n<h3>1：按键检测</h3>\n<div>LCD4884 Joystick Shiled带有一个摇杆按键，并且和A0脚连接，所以读取A0引脚&#20540;即可。</div>\n<div>\n<pre class=\"cpp\">void Control()\n{\n  switchVoltage = analogRead(0);\n  if ( switchVoltage &gt; 600 &amp;&amp; switchVoltage &lt; 800 )            //上\n    dir = 1 ;\n  else if ( switchVoltage &gt; 180 &amp;&amp; switchVoltage &lt; 400 )       //下\n    dir = 3;\n  else if ( switchVoltage == 0 )                               //左\n    dir = 4;\n  else if ( switchVoltage &gt; 400 &amp;&amp; switchVoltage &lt; 600 )       //右\n    dir = 2;\n  else if ( switchVoltage &gt; 0 &amp;&amp; switchVoltage &lt; 180 )        //确认\n    dir = 5;\n}</pre>\n为了防止按键粘连，使用了MsTime2库定时扫描</div>\n<div>\n<pre class=\"cpp\">  MsTimer2::set(100, Control);                /*定时器中断按键的扫描*/\n  MsTimer2::start();</pre>\n<div><br>\n</div>\n<h3>2：初始化</h3>\n在游戏运行之前，初始化屏幕亮度、游戏等级、随机数种子(防止每一次方块出现次数都相同、清空数组&#20540;以及方块中心点位置，</div>\n<div>\n<pre class=\"cpp\">  randomSeed(analogRead(1));   <span style=\"white-space:pre\">        </span>/*随机产生随机数序列以免方块的顺序为固定的*/\n  block_num = random(1, 20);<span style=\"white-space:pre\">        </span>/*生成第一个方块信息\n  block_num_next = random(1, 20) ; <span style=\"white-space:pre\">    </span>/*生成第二个方块\n  x = 5 , y = 2;\n  block_state_right = 0 ;\n  block_state_left = 0;\n  block_state_down = 0;\n  level_now = 300;\n  light_value = 50;    <span style=\"white-space:pre\">            </span> /*设置背光亮度*/\n  pinMode(LCD_BACKLIGHT_PIN , OUTPUT);\n  analogWrite(LCD_BACKLIGHT_PIN, light_value);</pre>\n<br>\n<h3>3：绘制游戏界面背景</h3>\n<div>显示当前等级和分数，以及下一个方块形状，游戏的等级设置的是每次自动向下移动时延时的毫秒数，move_speed越小等级越高，方块向下移动也越来越快</div>\n<div>\n<pre class=\"cpp\">void interface()\n{\n  u8g.setFont(u8g_font_timR08);\n  u8g.drawStr(57, 10, &quot;Score&quot;);\n  u8g.drawStr(57, 30, &quot;Grade&quot;);\n  u8g.drawStr(0, 10, &quot;Next&quot;);\n  u8g.setPrintPos(70, 20);\n  /*显示分数*/\n  u8g.print(score);\n  /*显示等级*/\n  if ( move_speed &lt;= 300)\n    u8g.drawBox(60, 42, 3, 6);\n  if ( move_speed &lt;= 250)\n    u8g.drawBox(65, 39, 3, 9);\n  if ( move_speed &lt;= 200)\n    u8g.drawBox(70, 36, 3, 12);\n  if ( move_speed &lt;= 150)\n    u8g.drawBox(75, 33, 3, 15);\n  if (move_speed &lt;= 100)\n    u8g.drawBox(80, 30, 3, 18);\n  /*显示下一个方块*/\n  create_box_next(1);\n  for (int m = 0 ; m &lt; 5 ; m&#43;&#43;)\n    for (int n = 0 ; n &lt; 5 ; n&#43;&#43;)\n    {\n      if ( block_next[m][n] == 1)\n        u8g.drawBox(3 * m &#43; 5, 3 * n &#43; 15, 3, 3);\n    }\n  create_box_next(0);\n}</pre>\n</div>\n<div><br>\n</div>\n<h3>4：方块的生成</h3>\n<div>形状太多，代码复用率太高只截取部分，每次移动或者变换的时候都需要调用这个函数来清除上一个方块的位置信息</div>\n<div>\n<pre class=\"cpp\">void create_box(int a )  /*调整block数组中的&#20540;，参数为0的时候清除，参数为1时写入*/\n{\n  switch (block_num)\n  {\n    case 1:\n      block[x][y &#43; 1] = a;\n      block[x][y - 1] = a;\n      block[x - 1][y] = a;\n      block[x][y] = a;\n      break ;\n  }\n｝</pre>\n<br>\n<h3>5：方块的移动和变换</h3>\n</div>\n<div>每次移动和变换之前都得判断方块能否移动，能够移动还需要在移动之前清空原有的，不能移动的时候需要产生新的方块，这时候方块的中心点需要重置，并且当前形状的标号改为block_num_next的&#20540;，再重新随机生成一个数给block_num_next</div>\n<div>\n<pre class=\"cpp\">void block_go()             /*方块的移动和变形*/\n{\n  block_fixed();\n  if (block_state_down == 1 )    /*方块不能下降的时候生成新的方块*/\n  {\n    for (int m = 0; m &lt; 10; m&#43;&#43;)\n    {\n      if (block[m][3] == 1) /*判断游戏是否结束*/\n      {\n        game_over();\n        break;\n      }\n    }\n    x = 5 , y = 2;    /*设置初始中心点位置*/\n    block_num = block_num_next ;\n    block_num_next = random(1, 20) ;\n    block_state_right = 0 ;\n    block_state_left = 0;\n    block_state_down = 0;\n    create_box(0);\n  }}</pre>\n变换方块形状，需要注意的是方块标号是连续的，每次变换的时候实际只是更改了当前方块的标号，为了防止从一个类型调到另一个类型需要做一些判断来限制标号更改的范围</div>\n<div>\n<pre class=\"cpp\">switch (dir)\n  {\n    case 1:           /*变换方块形状*/\n      create_box(0);\n      if ( block_num &gt;= 1 &amp;&amp; block_num &lt;= 4)   /*防止变换的时候方块形状发生变换*/\n      {\n        block_num&#43;&#43;;\n        if (block_num &gt; 4)\n          block_num = 1;\n      }\n  }</pre>\n<br>\n<h3>6：判断方块能否移动</h3>\n每一种方块的判断方法都不同，需要根据当前方块标号做出不同的判断，判断结束会返回三个状态，block_state_left、block_state_down、block_state_right，这三个&#20540;为0的时候是可以向这个方向移动的</div>\n<div>\n<pre class=\"cpp\">void block_fixed()      /*判断方块是否能够移动*/\n{\n  switch (block_num)\n  {\n    case 1:\n      if (block[x - 2][y] == 1 || block[x - 1][y - 1] == 1 || block[x - 1][y &#43; 1] == 1 || x &lt;= 1)\n        block_state_left = 1;\n      else\n        block_state_left = 0;\n      if (block[x &#43; 1][y] == 1 || block[x &#43; 1][y - 1] == 1 || block[x &#43; 1][y &#43; 1] == 1 || x &gt;= 9)\n        block_state_right = 1;\n      else\n        block_state_right = 0;\n      if (block[x - 1][y &#43; 1] == 1 || block[x][y &#43; 2] == 1 || y &gt;= 18)\n        block_state_down = 1;\n      else\n        block_state_down = 0;\n      break;\n  }\n}</pre>\n<div><br>\n</div>\n<h3>7：绘制方块</h3>\n<div>遍历二维数组，当&#20540;为1的时候则显示最小像素点</div>\n<div>\n<pre class=\"cpp\">void draw_block()     /*绘制方块*/\n{\n  int block_x , block_y;\n  for (block_x = 0 ; block_x &lt; 10 ; block_x &#43;&#43;)\n    for (block_y = 0 ; block_y &lt; 20 ; block_y &#43;&#43;)\n    {\n      if (block[block_x][block_y] == 1)\n        u8g.drawBox(2 * block_x &#43; 28 , 2 * block_y &#43; 4 , 2 , 2);\n    }\n}</pre>\n<br>\n<br>\n</div>\n<h3>8：计算得分</h3>\n</div>\n<div>遍历整个二维数组，判断有多少行全为1，然后再将数组中每一行都往下挪多少行</div>\n<div>\n<pre class=\"cpp\">void remove_block()\n{\n  int sum = 0, m, n, i = 0 , h;       /*i：需要消除的行数，h:记录是哪一行需要消除*/\n  /*判断有多少行需要消除*/\n  for ( m = 19 ; m &gt; 4; m--)\n  {\n    for ( n = 0 ; n &lt; 10 ; n&#43;&#43;)\n      sum &#43;= block[n][m];\n    if (sum == 10)\n    {\n      i&#43;&#43;;\n      score &#43;= 10;\n      h = m;\n      block_state_down = 1 ;\n    }\n    else\n      sum = 0;\n  }\n  /*当存在消行的情况下数组每一行都向下移动i个单位*/\n  for (i; i &gt; 0; i--)\n    for ( m = h; m &gt;= 3; m--)\n      for ( n = 0; n &lt; 10; n&#43;&#43;)\n        block[n][m] = block[n][m - 1];\n}</pre>\n<br>\n<br>\n</div>\n<h2>四：结语</h2>\n<div>这个游戏是在一年前完成的，到今天很多细节忘得差不多了，只能凭借印象来大致的说明一下主要的流程和思路，代码中有很大一部分重用导致看起来很臃肿现在也懒得改了，有想折腾的可以尝试完善完善，另外其他的屏幕也是能适用的，只需要更改按键控制那个函数和u8glib那个头文件即可，但是分辨率就没办法了</div>\n<div>源码连接，喜欢的还请赏个Star</div>\n<div><strong><span style=\"color:#ff0000\">https://github.com/FanMLei/Arduino_Games</span></strong><br>\n</div>\n<div>试玩视频</div>\n<div><strong><span style=\"color:#ff0000\">http://v.youku.com/v_show/id_XMzM5NjA0NjY2OA==.html?spm=a2h3j.8428770.3416059.1</span></strong><br>\n</div>\n<div><br>\n</div>\n&nbsp;</div>\n<div><br>\n<br>\n</div>\n<div><br>\n</div>\n<p><br>\n</p>\n"},{"_content":"<p>前后端分离项目的部署主要使用Nginx和uwsgi来实现，把Nginx换成Apache也是可以的，看个人喜好。Nginx主要处理静态文件，uwsgi用来部署Django项目，处理其他请求</p>\n\n<p><strong>安装uwsgi:</strong></p>\n\n<pre class=\"has\">\n<code>pip3 install uwsgi</code></pre>\n\n<p><strong>测试uwsgi：</strong></p>\n\n<p>首先创建一个test.py文件</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def application(env, start_response):\n    start_response('200 OK', [('Content-Type','text/html')])\nreturn [b\"Hello World\"]</code></pre>\n\n<p>在文件目录下使用命令：</p>\n\n<pre class=\"has\">\n<code>uwsgi --http :80 --wsgi-file test.py</code></pre>\n\n<p>访问我们的网站，能够得到Hello World，则uwsgi安装成功<img alt=\"\" class=\"has\" height=\"88\" src=\"https://img-blog.csdnimg.cn/20181217150734770.png\" width=\"687\" /></p>\n\n<p><strong>部署django项目：</strong></p>\n\n<p>为了以后使用方便，可先创建一个目录存放uwsgi配置文件</p>\n\n<pre class=\"has\">\n<code>mkdir website_uwsgi\ncd website_uwsgi\nvim uwsgi.ini</code></pre>\n\n<p>配置文件内容如下</p>\n\n<pre class=\"has\">\n<code class=\"language-bash\">[uwsgi]\nchdir = /home/iot/IOTPlatform   #项目根目录\nmodule = IOTPlatform.wsgi:application  # wsgi\nhttp = :8000\nmaster = True\nProcesses = 4  #最大进程数\nharakiri = 60  # \nmax-requests = 5000\n\n# socket = 127.0.0.1:8000\n\nuid = 1000\ngid = 2000\n\npidfile = /home/iot/website_uwsgi/master.pid\ndaemonize = /home/iot/website_uwsgi/mysite.log\nvacuum = True</code></pre>\n\n<p>部分选项的含义：<br />\nchdir : 项目根目录路径<br />\nmodule： 入口文件<br />\nhttp：监听的IP和端口，socket也是，如果使用Nginx做反向代理就应该选择socket方式，因为nginx反向代理使用的是socket方式，在这个项目中没有使用方向代理所以选用了http的方式<br />\nmaster：是否启动主进程<br />\nprocesses:  设置进程数目<br />\nharakiri: 请求超时时间<br />\nmax-requests:每个工作进程设置请求数的上限<br />\npidfile:指定pid文件<br />\ndaemonize: 日志文件</p>\n\n<p>uwsgi配置文件写好了，使用命令启动： </p>\n\n<pre class=\"has\">\n<code>uwsgi --ini uwsgi.ini</code></pre>\n\n<p style=\"margin-left:0pt;\">启动完成之后，使用ps -aux | grep uwsgi 查看是否有4个进程来判断uwsgi是否启动成功，另外可以使用接口工具访问接口看是否有正常的数据</p>\n\n<p style=\"margin-left:0pt;\">其他的一些命令：<br />\nuwsgi --reload master.pid 重启服务<br />\nuwsgi --stop master.pid 停止服务</p>\n\n<p style=\"margin-left:0pt;\"><strong>部署静态文件：</strong></p>\n\n<p style=\"margin-left:0pt;\">静态文件有两种方式<br />\n1：通过django路由访问<br />\n2：通过nginx直接访问</p>\n\n<p style=\"margin-left:0pt;\"><strong>方式1：</strong></p>\n\n<p style=\"margin-left:0pt;\">需要在根目录的URL文件中增加 url(r'^$', TemplateView.as_view(template_name=\"index.html\")),作为入口，在setting中更改静态资源位置</p>\n\n<p>STATIC_URL = '/static/'</p>\n\n<p>STATICFILES_DIRS = (<br />\n    os.path.join(BASE_DIR, \"dist/static\"),  # 静态文件目录位置<br />\n)</p>\n\n<p><strong>方式2：</strong></p>\n\n<p style=\"margin-left:0pt;\">安装nginx:   apt-get install nginx<br />\n配置nginx:   cd /etc/nginx<br />\n首先在 nginx的可用配置目录下新建我们的配置文件</p>\n\n<pre class=\"has\">\n<code class=\"language-bash\">cd sites-available/\nvim mysite.conf</code></pre>\n\n<pre class=\"has\">\n<code class=\"language-bash\">server {\n    listen 80;\n    server_name iotplatform;\n    charset utf-8;\n    client_max_body_size 75M;   \n    location /static {\n        alias /home/iot/IOTPlatform/dist/static;\n    }    \n    location /media {\n        alias /home/iot/media;\n    }   \n    location / {\n        root /home/iot/IOTPlatform/dist;  \n\t    index index.html;\n        try_files $uri $uri/ /index.html;\n    }\n}\n</code></pre>\n\n<p>再使用命令测试我们的配置文件是否有问题</p>\n\n<pre class=\"has\">\n<code>ln -s /etc/nginx/sites-available/mysite.conf   /etc/nginx/sites-enabled/mysite.conf\nnginx -t</code></pre>\n\n<p>没有问题使用  service nginx restart重启nginx服务，这样就能访问到静态文件了</p>\n\n<p> </p>\n\n<p><strong>关于反向代理的问题</strong><br />\n反向代理的配置文件：</p>\n\n<pre class=\"has\">\n<code>server {\n    listen 80;\n    server_name iotplatform;\n    charset utf-8;\n    client_max_body_size 75M;\n    location /static {\n        alias /home/iot/IOTPlatform/dist/static\n    }\n    location /media {\n        alias /home/iot/media\n    }\n    location / {\n        uwsgi_pass 127.0.0.1:8000;\n        include /etc/nginx/uwsgi_params;\n    }\n}</code></pre>\n\n<p>使用nginx -t测试的时候出现</p>\n\n<p style=\"margin-left:0pt;\">nginx: [emerg] open() \"/etc/nginx/conf/uwsgi_params\" failed (2: No such file or directory) in /etc/nginx/nginx.conf:81</p>\n\n<p style=\"margin-left:0pt;\">nginx: configuration file /etc/nginx/nginx.conf test failed</p>\n\n<p style=\"margin-left:0pt;\">提示说没有找到uwsgi_params文件我的解决方法是：手动新建一个conf目录并将uwsgi_params文件复制过去</p>","source":"_posts/blogs-Django+Vue前后端分离项目的部署.md","raw":"<p>前后端分离项目的部署主要使用Nginx和uwsgi来实现，把Nginx换成Apache也是可以的，看个人喜好。Nginx主要处理静态文件，uwsgi用来部署Django项目，处理其他请求</p>\n\n<p><strong>安装uwsgi:</strong></p>\n\n<pre class=\"has\">\n<code>pip3 install uwsgi</code></pre>\n\n<p><strong>测试uwsgi：</strong></p>\n\n<p>首先创建一个test.py文件</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def application(env, start_response):\n    start_response('200 OK', [('Content-Type','text/html')])\nreturn [b\"Hello World\"]</code></pre>\n\n<p>在文件目录下使用命令：</p>\n\n<pre class=\"has\">\n<code>uwsgi --http :80 --wsgi-file test.py</code></pre>\n\n<p>访问我们的网站，能够得到Hello World，则uwsgi安装成功<img alt=\"\" class=\"has\" height=\"88\" src=\"https://img-blog.csdnimg.cn/20181217150734770.png\" width=\"687\" /></p>\n\n<p><strong>部署django项目：</strong></p>\n\n<p>为了以后使用方便，可先创建一个目录存放uwsgi配置文件</p>\n\n<pre class=\"has\">\n<code>mkdir website_uwsgi\ncd website_uwsgi\nvim uwsgi.ini</code></pre>\n\n<p>配置文件内容如下</p>\n\n<pre class=\"has\">\n<code class=\"language-bash\">[uwsgi]\nchdir = /home/iot/IOTPlatform   #项目根目录\nmodule = IOTPlatform.wsgi:application  # wsgi\nhttp = :8000\nmaster = True\nProcesses = 4  #最大进程数\nharakiri = 60  # \nmax-requests = 5000\n\n# socket = 127.0.0.1:8000\n\nuid = 1000\ngid = 2000\n\npidfile = /home/iot/website_uwsgi/master.pid\ndaemonize = /home/iot/website_uwsgi/mysite.log\nvacuum = True</code></pre>\n\n<p>部分选项的含义：<br />\nchdir : 项目根目录路径<br />\nmodule： 入口文件<br />\nhttp：监听的IP和端口，socket也是，如果使用Nginx做反向代理就应该选择socket方式，因为nginx反向代理使用的是socket方式，在这个项目中没有使用方向代理所以选用了http的方式<br />\nmaster：是否启动主进程<br />\nprocesses:  设置进程数目<br />\nharakiri: 请求超时时间<br />\nmax-requests:每个工作进程设置请求数的上限<br />\npidfile:指定pid文件<br />\ndaemonize: 日志文件</p>\n\n<p>uwsgi配置文件写好了，使用命令启动： </p>\n\n<pre class=\"has\">\n<code>uwsgi --ini uwsgi.ini</code></pre>\n\n<p style=\"margin-left:0pt;\">启动完成之后，使用ps -aux | grep uwsgi 查看是否有4个进程来判断uwsgi是否启动成功，另外可以使用接口工具访问接口看是否有正常的数据</p>\n\n<p style=\"margin-left:0pt;\">其他的一些命令：<br />\nuwsgi --reload master.pid 重启服务<br />\nuwsgi --stop master.pid 停止服务</p>\n\n<p style=\"margin-left:0pt;\"><strong>部署静态文件：</strong></p>\n\n<p style=\"margin-left:0pt;\">静态文件有两种方式<br />\n1：通过django路由访问<br />\n2：通过nginx直接访问</p>\n\n<p style=\"margin-left:0pt;\"><strong>方式1：</strong></p>\n\n<p style=\"margin-left:0pt;\">需要在根目录的URL文件中增加 url(r'^$', TemplateView.as_view(template_name=\"index.html\")),作为入口，在setting中更改静态资源位置</p>\n\n<p>STATIC_URL = '/static/'</p>\n\n<p>STATICFILES_DIRS = (<br />\n    os.path.join(BASE_DIR, \"dist/static\"),  # 静态文件目录位置<br />\n)</p>\n\n<p><strong>方式2：</strong></p>\n\n<p style=\"margin-left:0pt;\">安装nginx:   apt-get install nginx<br />\n配置nginx:   cd /etc/nginx<br />\n首先在 nginx的可用配置目录下新建我们的配置文件</p>\n\n<pre class=\"has\">\n<code class=\"language-bash\">cd sites-available/\nvim mysite.conf</code></pre>\n\n<pre class=\"has\">\n<code class=\"language-bash\">server {\n    listen 80;\n    server_name iotplatform;\n    charset utf-8;\n    client_max_body_size 75M;   \n    location /static {\n        alias /home/iot/IOTPlatform/dist/static;\n    }    \n    location /media {\n        alias /home/iot/media;\n    }   \n    location / {\n        root /home/iot/IOTPlatform/dist;  \n\t    index index.html;\n        try_files $uri $uri/ /index.html;\n    }\n}\n</code></pre>\n\n<p>再使用命令测试我们的配置文件是否有问题</p>\n\n<pre class=\"has\">\n<code>ln -s /etc/nginx/sites-available/mysite.conf   /etc/nginx/sites-enabled/mysite.conf\nnginx -t</code></pre>\n\n<p>没有问题使用  service nginx restart重启nginx服务，这样就能访问到静态文件了</p>\n\n<p> </p>\n\n<p><strong>关于反向代理的问题</strong><br />\n反向代理的配置文件：</p>\n\n<pre class=\"has\">\n<code>server {\n    listen 80;\n    server_name iotplatform;\n    charset utf-8;\n    client_max_body_size 75M;\n    location /static {\n        alias /home/iot/IOTPlatform/dist/static\n    }\n    location /media {\n        alias /home/iot/media\n    }\n    location / {\n        uwsgi_pass 127.0.0.1:8000;\n        include /etc/nginx/uwsgi_params;\n    }\n}</code></pre>\n\n<p>使用nginx -t测试的时候出现</p>\n\n<p style=\"margin-left:0pt;\">nginx: [emerg] open() \"/etc/nginx/conf/uwsgi_params\" failed (2: No such file or directory) in /etc/nginx/nginx.conf:81</p>\n\n<p style=\"margin-left:0pt;\">nginx: configuration file /etc/nginx/nginx.conf test failed</p>\n\n<p style=\"margin-left:0pt;\">提示说没有找到uwsgi_params文件我的解决方法是：手动新建一个conf目录并将uwsgi_params文件复制过去</p>","slug":"blogs-Django+Vue前后端分离项目的部署","published":1,"date":"2022-03-16T17:00:52.092Z","updated":"2022-03-16T17:05:41.451Z","_id":"cl0v6kes9000pyms431iecbrc","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前后端分离项目的部署主要使用Nginx和uwsgi来实现，把Nginx换成Apache也是可以的，看个人喜好。Nginx主要处理静态文件，uwsgi用来部署Django项目，处理其他请求</p>\n\n<p><strong>安装uwsgi:</strong></p>\n\n<pre class=\"has\">\n<code>pip3 install uwsgi</code></pre>\n\n<p><strong>测试uwsgi：</strong></p>\n\n<p>首先创建一个test.py文件</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def application(env, start_response):\n    start_response('200 OK', [('Content-Type','text/html')])\nreturn [b\"Hello World\"]</code></pre>\n\n<p>在文件目录下使用命令：</p>\n\n<pre class=\"has\">\n<code>uwsgi --http :80 --wsgi-file test.py</code></pre>\n\n<p>访问我们的网站，能够得到Hello World，则uwsgi安装成功<img alt=\"\" class=\"has\" height=\"88\" src=\"https://img-blog.csdnimg.cn/20181217150734770.png\" width=\"687\" /></p>\n\n<p><strong>部署django项目：</strong></p>\n\n<p>为了以后使用方便，可先创建一个目录存放uwsgi配置文件</p>\n\n<pre class=\"has\">\n<code>mkdir website_uwsgi\ncd website_uwsgi\nvim uwsgi.ini</code></pre>\n\n<p>配置文件内容如下</p>\n\n<pre class=\"has\">\n<code class=\"language-bash\">[uwsgi]\nchdir = /home/iot/IOTPlatform   #项目根目录\nmodule = IOTPlatform.wsgi:application  # wsgi\nhttp = :8000\nmaster = True\nProcesses = 4  #最大进程数\nharakiri = 60  # \nmax-requests = 5000\n\n# socket = 127.0.0.1:8000\n\nuid = 1000\ngid = 2000\n\npidfile = /home/iot/website_uwsgi/master.pid\ndaemonize = /home/iot/website_uwsgi/mysite.log\nvacuum = True</code></pre>\n\n<p>部分选项的含义：<br />\nchdir : 项目根目录路径<br />\nmodule： 入口文件<br />\nhttp：监听的IP和端口，socket也是，如果使用Nginx做反向代理就应该选择socket方式，因为nginx反向代理使用的是socket方式，在这个项目中没有使用方向代理所以选用了http的方式<br />\nmaster：是否启动主进程<br />\nprocesses:  设置进程数目<br />\nharakiri: 请求超时时间<br />\nmax-requests:每个工作进程设置请求数的上限<br />\npidfile:指定pid文件<br />\ndaemonize: 日志文件</p>\n\n<p>uwsgi配置文件写好了，使用命令启动： </p>\n\n<pre class=\"has\">\n<code>uwsgi --ini uwsgi.ini</code></pre>\n\n<p style=\"margin-left:0pt;\">启动完成之后，使用ps -aux | grep uwsgi 查看是否有4个进程来判断uwsgi是否启动成功，另外可以使用接口工具访问接口看是否有正常的数据</p>\n\n<p style=\"margin-left:0pt;\">其他的一些命令：<br />\nuwsgi --reload master.pid 重启服务<br />\nuwsgi --stop master.pid 停止服务</p>\n\n<p style=\"margin-left:0pt;\"><strong>部署静态文件：</strong></p>\n\n<p style=\"margin-left:0pt;\">静态文件有两种方式<br />\n1：通过django路由访问<br />\n2：通过nginx直接访问</p>\n\n<p style=\"margin-left:0pt;\"><strong>方式1：</strong></p>\n\n<p style=\"margin-left:0pt;\">需要在根目录的URL文件中增加 url(r'^$', TemplateView.as_view(template_name=\"index.html\")),作为入口，在setting中更改静态资源位置</p>\n\n<p>STATIC_URL = '/static/'</p>\n\n<p>STATICFILES_DIRS = (<br />\n    os.path.join(BASE_DIR, \"dist/static\"),  # 静态文件目录位置<br />\n)</p>\n\n<p><strong>方式2：</strong></p>\n\n<p style=\"margin-left:0pt;\">安装nginx:   apt-get install nginx<br />\n配置nginx:   cd /etc/nginx<br />\n首先在 nginx的可用配置目录下新建我们的配置文件</p>\n\n<pre class=\"has\">\n<code class=\"language-bash\">cd sites-available/\nvim mysite.conf</code></pre>\n\n<pre class=\"has\">\n<code class=\"language-bash\">server &#123;\n    listen 80;\n    server_name iotplatform;\n    charset utf-8;\n    client_max_body_size 75M;   \n    location /static &#123;\n        alias /home/iot/IOTPlatform/dist/static;\n    &#125;    \n    location /media &#123;\n        alias /home/iot/media;\n    &#125;   \n    location / &#123;\n        root /home/iot/IOTPlatform/dist;  \n        index index.html;\n        try_files $uri $uri/ /index.html;\n    &#125;\n&#125;\n</code></pre>\n\n<p>再使用命令测试我们的配置文件是否有问题</p>\n\n<pre class=\"has\">\n<code>ln -s /etc/nginx/sites-available/mysite.conf   /etc/nginx/sites-enabled/mysite.conf\nnginx -t</code></pre>\n\n<p>没有问题使用  service nginx restart重启nginx服务，这样就能访问到静态文件了</p>\n\n<p> </p>\n\n<p><strong>关于反向代理的问题</strong><br />\n反向代理的配置文件：</p>\n\n<pre class=\"has\">\n<code>server &#123;\n    listen 80;\n    server_name iotplatform;\n    charset utf-8;\n    client_max_body_size 75M;\n    location /static &#123;\n        alias /home/iot/IOTPlatform/dist/static\n    &#125;\n    location /media &#123;\n        alias /home/iot/media\n    &#125;\n    location / &#123;\n        uwsgi_pass 127.0.0.1:8000;\n        include /etc/nginx/uwsgi_params;\n    &#125;\n&#125;</code></pre>\n\n<p>使用nginx -t测试的时候出现</p>\n\n<p style=\"margin-left:0pt;\">nginx: [emerg] open() \"/etc/nginx/conf/uwsgi_params\" failed (2: No such file or directory) in /etc/nginx/nginx.conf:81</p>\n\n<p style=\"margin-left:0pt;\">nginx: configuration file /etc/nginx/nginx.conf test failed</p>\n\n<p style=\"margin-left:0pt;\">提示说没有找到uwsgi_params文件我的解决方法是：手动新建一个conf目录并将uwsgi_params文件复制过去</p>","site":{"data":{}},"excerpt":"","more":"<p>前后端分离项目的部署主要使用Nginx和uwsgi来实现，把Nginx换成Apache也是可以的，看个人喜好。Nginx主要处理静态文件，uwsgi用来部署Django项目，处理其他请求</p>\n\n<p><strong>安装uwsgi:</strong></p>\n\n<pre class=\"has\">\n<code>pip3 install uwsgi</code></pre>\n\n<p><strong>测试uwsgi：</strong></p>\n\n<p>首先创建一个test.py文件</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def application(env, start_response):\n    start_response('200 OK', [('Content-Type','text/html')])\nreturn [b\"Hello World\"]</code></pre>\n\n<p>在文件目录下使用命令：</p>\n\n<pre class=\"has\">\n<code>uwsgi --http :80 --wsgi-file test.py</code></pre>\n\n<p>访问我们的网站，能够得到Hello World，则uwsgi安装成功<img alt=\"\" class=\"has\" height=\"88\" src=\"https://img-blog.csdnimg.cn/20181217150734770.png\" width=\"687\" /></p>\n\n<p><strong>部署django项目：</strong></p>\n\n<p>为了以后使用方便，可先创建一个目录存放uwsgi配置文件</p>\n\n<pre class=\"has\">\n<code>mkdir website_uwsgi\ncd website_uwsgi\nvim uwsgi.ini</code></pre>\n\n<p>配置文件内容如下</p>\n\n<pre class=\"has\">\n<code class=\"language-bash\">[uwsgi]\nchdir = /home/iot/IOTPlatform   #项目根目录\nmodule = IOTPlatform.wsgi:application  # wsgi\nhttp = :8000\nmaster = True\nProcesses = 4  #最大进程数\nharakiri = 60  # \nmax-requests = 5000\n\n# socket = 127.0.0.1:8000\n\nuid = 1000\ngid = 2000\n\npidfile = /home/iot/website_uwsgi/master.pid\ndaemonize = /home/iot/website_uwsgi/mysite.log\nvacuum = True</code></pre>\n\n<p>部分选项的含义：<br />\nchdir : 项目根目录路径<br />\nmodule： 入口文件<br />\nhttp：监听的IP和端口，socket也是，如果使用Nginx做反向代理就应该选择socket方式，因为nginx反向代理使用的是socket方式，在这个项目中没有使用方向代理所以选用了http的方式<br />\nmaster：是否启动主进程<br />\nprocesses:  设置进程数目<br />\nharakiri: 请求超时时间<br />\nmax-requests:每个工作进程设置请求数的上限<br />\npidfile:指定pid文件<br />\ndaemonize: 日志文件</p>\n\n<p>uwsgi配置文件写好了，使用命令启动： </p>\n\n<pre class=\"has\">\n<code>uwsgi --ini uwsgi.ini</code></pre>\n\n<p style=\"margin-left:0pt;\">启动完成之后，使用ps -aux | grep uwsgi 查看是否有4个进程来判断uwsgi是否启动成功，另外可以使用接口工具访问接口看是否有正常的数据</p>\n\n<p style=\"margin-left:0pt;\">其他的一些命令：<br />\nuwsgi --reload master.pid 重启服务<br />\nuwsgi --stop master.pid 停止服务</p>\n\n<p style=\"margin-left:0pt;\"><strong>部署静态文件：</strong></p>\n\n<p style=\"margin-left:0pt;\">静态文件有两种方式<br />\n1：通过django路由访问<br />\n2：通过nginx直接访问</p>\n\n<p style=\"margin-left:0pt;\"><strong>方式1：</strong></p>\n\n<p style=\"margin-left:0pt;\">需要在根目录的URL文件中增加 url(r'^$', TemplateView.as_view(template_name=\"index.html\")),作为入口，在setting中更改静态资源位置</p>\n\n<p>STATIC_URL = '/static/'</p>\n\n<p>STATICFILES_DIRS = (<br />\n    os.path.join(BASE_DIR, \"dist/static\"),  # 静态文件目录位置<br />\n)</p>\n\n<p><strong>方式2：</strong></p>\n\n<p style=\"margin-left:0pt;\">安装nginx:   apt-get install nginx<br />\n配置nginx:   cd /etc/nginx<br />\n首先在 nginx的可用配置目录下新建我们的配置文件</p>\n\n<pre class=\"has\">\n<code class=\"language-bash\">cd sites-available/\nvim mysite.conf</code></pre>\n\n<pre class=\"has\">\n<code class=\"language-bash\">server &#123;\n    listen 80;\n    server_name iotplatform;\n    charset utf-8;\n    client_max_body_size 75M;   \n    location /static &#123;\n        alias /home/iot/IOTPlatform/dist/static;\n    &#125;    \n    location /media &#123;\n        alias /home/iot/media;\n    &#125;   \n    location / &#123;\n        root /home/iot/IOTPlatform/dist;  \n        index index.html;\n        try_files $uri $uri/ /index.html;\n    &#125;\n&#125;\n</code></pre>\n\n<p>再使用命令测试我们的配置文件是否有问题</p>\n\n<pre class=\"has\">\n<code>ln -s /etc/nginx/sites-available/mysite.conf   /etc/nginx/sites-enabled/mysite.conf\nnginx -t</code></pre>\n\n<p>没有问题使用  service nginx restart重启nginx服务，这样就能访问到静态文件了</p>\n\n<p> </p>\n\n<p><strong>关于反向代理的问题</strong><br />\n反向代理的配置文件：</p>\n\n<pre class=\"has\">\n<code>server &#123;\n    listen 80;\n    server_name iotplatform;\n    charset utf-8;\n    client_max_body_size 75M;\n    location /static &#123;\n        alias /home/iot/IOTPlatform/dist/static\n    &#125;\n    location /media &#123;\n        alias /home/iot/media\n    &#125;\n    location / &#123;\n        uwsgi_pass 127.0.0.1:8000;\n        include /etc/nginx/uwsgi_params;\n    &#125;\n&#125;</code></pre>\n\n<p>使用nginx -t测试的时候出现</p>\n\n<p style=\"margin-left:0pt;\">nginx: [emerg] open() \"/etc/nginx/conf/uwsgi_params\" failed (2: No such file or directory) in /etc/nginx/nginx.conf:81</p>\n\n<p style=\"margin-left:0pt;\">nginx: configuration file /etc/nginx/nginx.conf test failed</p>\n\n<p style=\"margin-left:0pt;\">提示说没有找到uwsgi_params文件我的解决方法是：手动新建一个conf目录并将uwsgi_params文件复制过去</p>"},{"_content":"\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">咱们接着上一篇来讲</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">作为天气预报的装置，若是只能在串口显示信息，那就没什么卵用了，还不如拿个手机看看省事，因此这篇将会讲一下如何使用外接屏幕显示信息。所用到的屏幕为串口彩屏，相较于普通的彩屏来说，串口屏的操作更为方便，也能更简单的制作画面较为复杂的界面，而且对于mcu没有任何要求只要能进行串口通信即可，因为串口屏内部本身是有主控的，串口屏可以根据指令自己绘图、操作控件。我们可以在页面上添加各种功能的控件，然后通过各种控件来显示信息达到我们想要的效果，如下图一样</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214165027152?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">举一个简单的例子：如果我们t5显示“1234”我们只需让mcu串口发送“t5.txt=&quot;1234&quot;”就可以了</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">当我们将所有的信息都发送后就能得到下面这样的效果图</span><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214165058970?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">看到这里我们应该能够知道上一篇从心知天气获取到的信息远远没有这么多，这一次我们还需要从另外的地址获取更多的信息。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\">https://api.seniverse.com/v3/weather/daily.json?key=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">APIPASSWORD</span></span></span><span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\">&amp;location=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">地址</span></span></span></span><span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#457ffd; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"\">&amp;language=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">返回的数据语言&#26684;式</span></span></span><span style=\"font-family:PingFangSC-Light,Helvetica Neue,Hiragino Sans GB,Microsoft YaHei,WenQuanYi Micro Hei,sans-serif; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-size:14px\"><span style=\"color:#034ef3; word-wrap:break-word; margin:0px; padding:0px\">&amp;unit=</span></span><span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">温度单位</span></span><span style=\"font-family:PingFangSC-Light,Helvetica Neue,Hiragino Sans GB,Microsoft YaHei,WenQuanYi Micro Hei,sans-serif; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-size:14px\"><span style=\"color:#034ef3; word-wrap:break-word; margin:0px; padding:0px\">&amp;start=</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\"><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\">起始时间（0：当天、1明天···）</span></span><span style=\"color:#034ef3; word-wrap:break-word; margin:0px; padding:0px\">&amp;days=</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\"><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\">获取多少天的信息（从起始时间开始，免费的最多只有三天）</span></span></span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">还是和上一篇一样黑色加粗的部分是需要根据自己情况进行修改的。这里由于Arduino处理中文很麻烦，因此语言我们最好选择英文，然后再同过其它代码转换成中文或其它。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">还需要提醒一下最好一天一天的获取信息，如start=0&amp;days=1，因为Arduinojson貌&#20284;是处理不了一个字符串包含多个json的数据&#26684;式。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">当连接成功后我们将会得到这样的数据：</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br style=\"word-wrap:break-word; margin:0px; padding:0px\">\n</span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">{&quot;results&quot;:[{&quot;location&quot;:{&quot;id&quot;:&quot;WX4FBXXFKE4F&quot;,&quot;name&quot;:&quot;Beijing&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;path&quot;:&quot;Beijing,Beijing,China&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;timezone_offset&quot;:&quot;&#43;08:00&quot;},&quot;daily&quot;:[{&quot;date&quot;:&quot;20170417&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">text_day</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;Cloudy&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">code_day</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;4&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">text_night</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;Cloudy&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">code_night</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;4&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">high</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;27&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">low</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;13&quot;,&quot;precip&quot;:&quot;&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_direction</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;SW&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_direction_degree</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;225&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_speed</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;15&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_scale</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;3&quot;}],&quot;last_update&quot;:&quot;2017-04-17T18:00:00&#43;08:00&quot;}]}</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">黑色加粗的就是我们需要获取的信息，包括白天天气、夜晚天气、最高气温、最低气温、风向、风速和风力等级，按照我们上一篇将的操作即可。这里我们只是获取了当天的全天天气，我们还要重复这样的操作获取第二天和第三的信息，好了到这里我们所有信息的获取就完成了，接下来就是如何将获取的信息传给屏幕并转化成中文。</span><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span></span></p>\n<pre name=\"code\" class=\"cpp\">data_day1 = httpData_day1.substring((httpData_day1.indexOf(&quot;\\&quot;daily\\&quot;&quot;) + 9), httpData.indexOf(&quot;],\\&quot;last&quot;));\n      DynamicJsonBuffer jsonBuffer;\n      JsonObject&amp; root = jsonBuffer.parseObject(data_day1);\n      date1 = root[(&quot;date&quot;)].as&lt;String&gt;();\n      temperature_low_day1 = root[String(&quot;low&quot;)];\n      temperature_high_day1 = root[String(&quot;high&quot;)];\n      code_day1 = root[String(&quot;code_day&quot;)];\n      code_night1 = root[String(&quot;code_night&quot;)];\n      wind_direction_day1 = root[(&quot;wind_direction&quot;)].as&lt;String&gt;();\n      wind_scale_day1 = root[String(&quot;wind_scale&quot;)];</pre>\n<p></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">数据的发送：</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">我们所用到的指令大概有切图、控件的赋&#20540;这三种指令，切图指令是让屏幕显示当前天气的图片信息，天气图片可以在心知天气上下载，由于目前串口屏的上位机并不支持矢量图，因此我们需要将天气图片和背景图P在一起然后按照顺序导入这些图片。切图指令为</span><span style=\"color:#ff0000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">picq\n x,y,w,h,pic_id</span></span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&nbsp;&nbsp;pic_id为我们导入的图片序号，由于是显示天气实况pic_id的&#20540;应该是上一篇我们解析出来的天气代码“code”</span><br>\n</span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214165426766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">天气图片的显示就完成了，下面就是发送其他的信息了。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">我们用到的大部分是文本控件使用到的指令为</span><span style=\"color:#ff0000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">控件ID.txt=&quot;\n &quot;</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">和</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#ff0000; word-wrap:break-word; margin:0px; padding:0px\">控件ID.txt=控件ID.txt&#43;&quot;\n &quot;</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">前一种会将以前的字符给覆盖掉，后一种则是在原有的基础上增加。</span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">由于Arduino解析中文、发送中文字符比较麻烦，所以我选择是发送数字和字符，然后通过让串口屏进行处理并组合成中文，</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">举个例子</span><br>\n</span></span></span></p>\n<p></p>\n<pre name=\"code\" class=\"cpp\">//假设白天为晴天，对应的天气代码为0，夜晚为多云，对应天气代码为4，那么整天的天气情况用中文表示应该是晴转多云\nif(code_day1==0)\n{\n        if(code_night1==4)\n                g0.txt=&quot;晴转多云&quot;;\n}</pre><br>\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">总共大概有30中天气情况，这样就会有几百种组合了，看&#20284;麻烦其实只需要写一遍然后Ctrl&#43;c 、Ctrl&#43;v再稍微调整一下就行了，风向风力同样是这样处理的。（如果嫌麻烦，直接下载链接的tft文件直接烧进屏幕即可），关于屏幕显示的东西就这么多了，其他的以后再补充吧！！！</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<br>\n<p></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">演示视频（</span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">增加了loading动画</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">）</span><br>\n</span></span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">http://v.youku.com/v_show/id_XMjcxNTk0MzIyOA==.html<br>\n</span></span></span></span></p>\n<a target=\"_blank\" target=\"_blank\" href=\"http://v.youku.com/v_show/id_XMjcxNTk0MzIyOA==.html\" style=\"font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px; font-weight:700\">点击打开链接</a><br>\n<br>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n","source":"_posts/blogs-Arduino语音天气预报（二）.md","raw":"\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">咱们接着上一篇来讲</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">作为天气预报的装置，若是只能在串口显示信息，那就没什么卵用了，还不如拿个手机看看省事，因此这篇将会讲一下如何使用外接屏幕显示信息。所用到的屏幕为串口彩屏，相较于普通的彩屏来说，串口屏的操作更为方便，也能更简单的制作画面较为复杂的界面，而且对于mcu没有任何要求只要能进行串口通信即可，因为串口屏内部本身是有主控的，串口屏可以根据指令自己绘图、操作控件。我们可以在页面上添加各种功能的控件，然后通过各种控件来显示信息达到我们想要的效果，如下图一样</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214165027152?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">举一个简单的例子：如果我们t5显示“1234”我们只需让mcu串口发送“t5.txt=&quot;1234&quot;”就可以了</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">当我们将所有的信息都发送后就能得到下面这样的效果图</span><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214165058970?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">看到这里我们应该能够知道上一篇从心知天气获取到的信息远远没有这么多，这一次我们还需要从另外的地址获取更多的信息。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\">https://api.seniverse.com/v3/weather/daily.json?key=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">APIPASSWORD</span></span></span><span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\">&amp;location=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">地址</span></span></span></span><span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#457ffd; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"\">&amp;language=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">返回的数据语言&#26684;式</span></span></span><span style=\"font-family:PingFangSC-Light,Helvetica Neue,Hiragino Sans GB,Microsoft YaHei,WenQuanYi Micro Hei,sans-serif; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-size:14px\"><span style=\"color:#034ef3; word-wrap:break-word; margin:0px; padding:0px\">&amp;unit=</span></span><span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">温度单位</span></span><span style=\"font-family:PingFangSC-Light,Helvetica Neue,Hiragino Sans GB,Microsoft YaHei,WenQuanYi Micro Hei,sans-serif; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-size:14px\"><span style=\"color:#034ef3; word-wrap:break-word; margin:0px; padding:0px\">&amp;start=</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\"><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\">起始时间（0：当天、1明天···）</span></span><span style=\"color:#034ef3; word-wrap:break-word; margin:0px; padding:0px\">&amp;days=</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\"><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\">获取多少天的信息（从起始时间开始，免费的最多只有三天）</span></span></span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">还是和上一篇一样黑色加粗的部分是需要根据自己情况进行修改的。这里由于Arduino处理中文很麻烦，因此语言我们最好选择英文，然后再同过其它代码转换成中文或其它。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">还需要提醒一下最好一天一天的获取信息，如start=0&amp;days=1，因为Arduinojson貌&#20284;是处理不了一个字符串包含多个json的数据&#26684;式。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">当连接成功后我们将会得到这样的数据：</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br style=\"word-wrap:break-word; margin:0px; padding:0px\">\n</span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">{&quot;results&quot;:[{&quot;location&quot;:{&quot;id&quot;:&quot;WX4FBXXFKE4F&quot;,&quot;name&quot;:&quot;Beijing&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;path&quot;:&quot;Beijing,Beijing,China&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;timezone_offset&quot;:&quot;&#43;08:00&quot;},&quot;daily&quot;:[{&quot;date&quot;:&quot;20170417&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">text_day</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;Cloudy&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">code_day</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;4&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">text_night</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;Cloudy&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">code_night</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;4&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">high</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;27&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">low</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;13&quot;,&quot;precip&quot;:&quot;&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_direction</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;SW&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_direction_degree</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;225&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_speed</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;15&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_scale</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;3&quot;}],&quot;last_update&quot;:&quot;2017-04-17T18:00:00&#43;08:00&quot;}]}</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">黑色加粗的就是我们需要获取的信息，包括白天天气、夜晚天气、最高气温、最低气温、风向、风速和风力等级，按照我们上一篇将的操作即可。这里我们只是获取了当天的全天天气，我们还要重复这样的操作获取第二天和第三的信息，好了到这里我们所有信息的获取就完成了，接下来就是如何将获取的信息传给屏幕并转化成中文。</span><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span></span></p>\n<pre name=\"code\" class=\"cpp\">data_day1 = httpData_day1.substring((httpData_day1.indexOf(&quot;\\&quot;daily\\&quot;&quot;) + 9), httpData.indexOf(&quot;],\\&quot;last&quot;));\n      DynamicJsonBuffer jsonBuffer;\n      JsonObject&amp; root = jsonBuffer.parseObject(data_day1);\n      date1 = root[(&quot;date&quot;)].as&lt;String&gt;();\n      temperature_low_day1 = root[String(&quot;low&quot;)];\n      temperature_high_day1 = root[String(&quot;high&quot;)];\n      code_day1 = root[String(&quot;code_day&quot;)];\n      code_night1 = root[String(&quot;code_night&quot;)];\n      wind_direction_day1 = root[(&quot;wind_direction&quot;)].as&lt;String&gt;();\n      wind_scale_day1 = root[String(&quot;wind_scale&quot;)];</pre>\n<p></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">数据的发送：</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">我们所用到的指令大概有切图、控件的赋&#20540;这三种指令，切图指令是让屏幕显示当前天气的图片信息，天气图片可以在心知天气上下载，由于目前串口屏的上位机并不支持矢量图，因此我们需要将天气图片和背景图P在一起然后按照顺序导入这些图片。切图指令为</span><span style=\"color:#ff0000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">picq\n x,y,w,h,pic_id</span></span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&nbsp;&nbsp;pic_id为我们导入的图片序号，由于是显示天气实况pic_id的&#20540;应该是上一篇我们解析出来的天气代码“code”</span><br>\n</span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214165426766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">天气图片的显示就完成了，下面就是发送其他的信息了。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">我们用到的大部分是文本控件使用到的指令为</span><span style=\"color:#ff0000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">控件ID.txt=&quot;\n &quot;</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">和</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#ff0000; word-wrap:break-word; margin:0px; padding:0px\">控件ID.txt=控件ID.txt&#43;&quot;\n &quot;</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">前一种会将以前的字符给覆盖掉，后一种则是在原有的基础上增加。</span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">由于Arduino解析中文、发送中文字符比较麻烦，所以我选择是发送数字和字符，然后通过让串口屏进行处理并组合成中文，</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">举个例子</span><br>\n</span></span></span></p>\n<p></p>\n<pre name=\"code\" class=\"cpp\">//假设白天为晴天，对应的天气代码为0，夜晚为多云，对应天气代码为4，那么整天的天气情况用中文表示应该是晴转多云\nif(code_day1==0)\n{\n        if(code_night1==4)\n                g0.txt=&quot;晴转多云&quot;;\n}</pre><br>\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">总共大概有30中天气情况，这样就会有几百种组合了，看&#20284;麻烦其实只需要写一遍然后Ctrl&#43;c 、Ctrl&#43;v再稍微调整一下就行了，风向风力同样是这样处理的。（如果嫌麻烦，直接下载链接的tft文件直接烧进屏幕即可），关于屏幕显示的东西就这么多了，其他的以后再补充吧！！！</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<br>\n<p></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">演示视频（</span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">增加了loading动画</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">）</span><br>\n</span></span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">http://v.youku.com/v_show/id_XMjcxNTk0MzIyOA==.html<br>\n</span></span></span></span></p>\n<a target=\"_blank\" target=\"_blank\" href=\"http://v.youku.com/v_show/id_XMjcxNTk0MzIyOA==.html\" style=\"font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px; font-weight:700\">点击打开链接</a><br>\n<br>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n","slug":"blogs-Arduino语音天气预报（二）","published":1,"date":"2022-03-16T17:09:42.837Z","updated":"2022-03-16T17:09:42.837Z","_id":"cl0v6kes9000qyms43r37a2vw","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">咱们接着上一篇来讲</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">作为天气预报的装置，若是只能在串口显示信息，那就没什么卵用了，还不如拿个手机看看省事，因此这篇将会讲一下如何使用外接屏幕显示信息。所用到的屏幕为串口彩屏，相较于普通的彩屏来说，串口屏的操作更为方便，也能更简单的制作画面较为复杂的界面，而且对于mcu没有任何要求只要能进行串口通信即可，因为串口屏内部本身是有主控的，串口屏可以根据指令自己绘图、操作控件。我们可以在页面上添加各种功能的控件，然后通过各种控件来显示信息达到我们想要的效果，如下图一样</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214165027152?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">举一个简单的例子：如果我们t5显示“1234”我们只需让mcu串口发送“t5.txt=&quot;1234&quot;”就可以了</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">当我们将所有的信息都发送后就能得到下面这样的效果图</span><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214165058970?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">看到这里我们应该能够知道上一篇从心知天气获取到的信息远远没有这么多，这一次我们还需要从另外的地址获取更多的信息。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\">https://api.seniverse.com/v3/weather/daily.json?key=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">APIPASSWORD</span></span></span><span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\">&amp;location=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">地址</span></span></span></span><span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#457ffd; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"\">&amp;language=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">返回的数据语言&#26684;式</span></span></span><span style=\"font-family:PingFangSC-Light,Helvetica Neue,Hiragino Sans GB,Microsoft YaHei,WenQuanYi Micro Hei,sans-serif; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-size:14px\"><span style=\"color:#034ef3; word-wrap:break-word; margin:0px; padding:0px\">&amp;unit=</span></span><span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">温度单位</span></span><span style=\"font-family:PingFangSC-Light,Helvetica Neue,Hiragino Sans GB,Microsoft YaHei,WenQuanYi Micro Hei,sans-serif; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-size:14px\"><span style=\"color:#034ef3; word-wrap:break-word; margin:0px; padding:0px\">&amp;start=</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\"><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\">起始时间（0：当天、1明天···）</span></span><span style=\"color:#034ef3; word-wrap:break-word; margin:0px; padding:0px\">&amp;days=</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\"><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\">获取多少天的信息（从起始时间开始，免费的最多只有三天）</span></span></span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">还是和上一篇一样黑色加粗的部分是需要根据自己情况进行修改的。这里由于Arduino处理中文很麻烦，因此语言我们最好选择英文，然后再同过其它代码转换成中文或其它。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">还需要提醒一下最好一天一天的获取信息，如start=0&amp;days=1，因为Arduinojson貌&#20284;是处理不了一个字符串包含多个json的数据&#26684;式。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">当连接成功后我们将会得到这样的数据：</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br style=\"word-wrap:break-word; margin:0px; padding:0px\">\n</span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">{&quot;results&quot;:[{&quot;location&quot;:{&quot;id&quot;:&quot;WX4FBXXFKE4F&quot;,&quot;name&quot;:&quot;Beijing&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;path&quot;:&quot;Beijing,Beijing,China&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;timezone_offset&quot;:&quot;&#43;08:00&quot;},&quot;daily&quot;:[{&quot;date&quot;:&quot;20170417&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">text_day</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;Cloudy&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">code_day</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;4&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">text_night</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;Cloudy&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">code_night</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;4&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">high</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;27&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">low</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;13&quot;,&quot;precip&quot;:&quot;&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_direction</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;SW&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_direction_degree</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;225&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_speed</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;15&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_scale</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;3&quot;}],&quot;last_update&quot;:&quot;2017-04-17T18:00:00&#43;08:00&quot;}]}</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">黑色加粗的就是我们需要获取的信息，包括白天天气、夜晚天气、最高气温、最低气温、风向、风速和风力等级，按照我们上一篇将的操作即可。这里我们只是获取了当天的全天天气，我们还要重复这样的操作获取第二天和第三的信息，好了到这里我们所有信息的获取就完成了，接下来就是如何将获取的信息传给屏幕并转化成中文。</span><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span></span></p>\n<pre name=\"code\" class=\"cpp\">data_day1 = httpData_day1.substring((httpData_day1.indexOf(&quot;\\&quot;daily\\&quot;&quot;) + 9), httpData.indexOf(&quot;],\\&quot;last&quot;));\n      DynamicJsonBuffer jsonBuffer;\n      JsonObject&amp; root = jsonBuffer.parseObject(data_day1);\n      date1 = root[(&quot;date&quot;)].as&lt;String&gt;();\n      temperature_low_day1 = root[String(&quot;low&quot;)];\n      temperature_high_day1 = root[String(&quot;high&quot;)];\n      code_day1 = root[String(&quot;code_day&quot;)];\n      code_night1 = root[String(&quot;code_night&quot;)];\n      wind_direction_day1 = root[(&quot;wind_direction&quot;)].as&lt;String&gt;();\n      wind_scale_day1 = root[String(&quot;wind_scale&quot;)];</pre>\n<p></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">数据的发送：</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">我们所用到的指令大概有切图、控件的赋&#20540;这三种指令，切图指令是让屏幕显示当前天气的图片信息，天气图片可以在心知天气上下载，由于目前串口屏的上位机并不支持矢量图，因此我们需要将天气图片和背景图P在一起然后按照顺序导入这些图片。切图指令为</span><span style=\"color:#ff0000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">picq\n x,y,w,h,pic_id</span></span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&nbsp;&nbsp;pic_id为我们导入的图片序号，由于是显示天气实况pic_id的&#20540;应该是上一篇我们解析出来的天气代码“code”</span><br>\n</span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214165426766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">天气图片的显示就完成了，下面就是发送其他的信息了。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">我们用到的大部分是文本控件使用到的指令为</span><span style=\"color:#ff0000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">控件ID.txt=&quot;\n &quot;</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">和</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#ff0000; word-wrap:break-word; margin:0px; padding:0px\">控件ID.txt=控件ID.txt&#43;&quot;\n &quot;</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">前一种会将以前的字符给覆盖掉，后一种则是在原有的基础上增加。</span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">由于Arduino解析中文、发送中文字符比较麻烦，所以我选择是发送数字和字符，然后通过让串口屏进行处理并组合成中文，</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">举个例子</span><br>\n</span></span></span></p>\n<p></p>\n<pre name=\"code\" class=\"cpp\">//假设白天为晴天，对应的天气代码为0，夜晚为多云，对应天气代码为4，那么整天的天气情况用中文表示应该是晴转多云\nif(code_day1==0)\n{\n        if(code_night1==4)\n                g0.txt=&quot;晴转多云&quot;;\n}</pre><br>\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">总共大概有30中天气情况，这样就会有几百种组合了，看&#20284;麻烦其实只需要写一遍然后Ctrl&#43;c 、Ctrl&#43;v再稍微调整一下就行了，风向风力同样是这样处理的。（如果嫌麻烦，直接下载链接的tft文件直接烧进屏幕即可），关于屏幕显示的东西就这么多了，其他的以后再补充吧！！！</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<br>\n<p></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">演示视频（</span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">增加了loading动画</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">）</span><br>\n</span></span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">http://v.youku.com/v_show/id_XMjcxNTk0MzIyOA==.html<br>\n</span></span></span></span></p>\n<a target=\"_blank\" target=\"_blank\" href=\"http://v.youku.com/v_show/id_XMjcxNTk0MzIyOA==.html\" style=\"font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px; font-weight:700\">点击打开链接</a><br>\n<br>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n","site":{"data":{}},"excerpt":"","more":"<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">咱们接着上一篇来讲</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">作为天气预报的装置，若是只能在串口显示信息，那就没什么卵用了，还不如拿个手机看看省事，因此这篇将会讲一下如何使用外接屏幕显示信息。所用到的屏幕为串口彩屏，相较于普通的彩屏来说，串口屏的操作更为方便，也能更简单的制作画面较为复杂的界面，而且对于mcu没有任何要求只要能进行串口通信即可，因为串口屏内部本身是有主控的，串口屏可以根据指令自己绘图、操作控件。我们可以在页面上添加各种功能的控件，然后通过各种控件来显示信息达到我们想要的效果，如下图一样</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214165027152?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">举一个简单的例子：如果我们t5显示“1234”我们只需让mcu串口发送“t5.txt=&quot;1234&quot;”就可以了</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">当我们将所有的信息都发送后就能得到下面这样的效果图</span><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214165058970?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">看到这里我们应该能够知道上一篇从心知天气获取到的信息远远没有这么多，这一次我们还需要从另外的地址获取更多的信息。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\">https://api.seniverse.com/v3/weather/daily.json?key=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">APIPASSWORD</span></span></span><span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#4169e1; word-wrap:break-word; margin:0px; padding:0px\">&amp;location=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"\"><span style=\"\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">地址</span></span></span></span><span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#457ffd; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"\">&amp;language=</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">返回的数据语言&#26684;式</span></span></span><span style=\"font-family:PingFangSC-Light,Helvetica Neue,Hiragino Sans GB,Microsoft YaHei,WenQuanYi Micro Hei,sans-serif; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-size:14px\"><span style=\"color:#034ef3; word-wrap:break-word; margin:0px; padding:0px\">&amp;unit=</span></span><span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">温度单位</span></span><span style=\"font-family:PingFangSC-Light,Helvetica Neue,Hiragino Sans GB,Microsoft YaHei,WenQuanYi Micro Hei,sans-serif; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-size:14px\"><span style=\"color:#034ef3; word-wrap:break-word; margin:0px; padding:0px\">&amp;start=</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\"><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\">起始时间（0：当天、1明天···）</span></span><span style=\"color:#034ef3; word-wrap:break-word; margin:0px; padding:0px\">&amp;days=</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\"><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px\">获取多少天的信息（从起始时间开始，免费的最多只有三天）</span></span></span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">还是和上一篇一样黑色加粗的部分是需要根据自己情况进行修改的。这里由于Arduino处理中文很麻烦，因此语言我们最好选择英文，然后再同过其它代码转换成中文或其它。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">还需要提醒一下最好一天一天的获取信息，如start=0&amp;days=1，因为Arduinojson貌&#20284;是处理不了一个字符串包含多个json的数据&#26684;式。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">当连接成功后我们将会得到这样的数据：</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#444444; word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br style=\"word-wrap:break-word; margin:0px; padding:0px\">\n</span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">{&quot;results&quot;:[{&quot;location&quot;:{&quot;id&quot;:&quot;WX4FBXXFKE4F&quot;,&quot;name&quot;:&quot;Beijing&quot;,&quot;country&quot;:&quot;CN&quot;,&quot;path&quot;:&quot;Beijing,Beijing,China&quot;,&quot;timezone&quot;:&quot;Asia/Shanghai&quot;,&quot;timezone_offset&quot;:&quot;&#43;08:00&quot;},&quot;daily&quot;:[{&quot;date&quot;:&quot;20170417&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">text_day</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;Cloudy&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">code_day</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;4&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">text_night</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;Cloudy&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">code_night</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;4&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">high</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;27&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">low</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;13&quot;,&quot;precip&quot;:&quot;&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_direction</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;SW&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_direction_degree</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;225&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_speed</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;15&quot;,&quot;</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">wind_scale</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&quot;:&quot;3&quot;}],&quot;last_update&quot;:&quot;2017-04-17T18:00:00&#43;08:00&quot;}]}</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">黑色加粗的就是我们需要获取的信息，包括白天天气、夜晚天气、最高气温、最低气温、风向、风速和风力等级，按照我们上一篇将的操作即可。这里我们只是获取了当天的全天天气，我们还要重复这样的操作获取第二天和第三的信息，好了到这里我们所有信息的获取就完成了，接下来就是如何将获取的信息传给屏幕并转化成中文。</span><br>\n</span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"></span></span></p>\n<pre name=\"code\" class=\"cpp\">data_day1 = httpData_day1.substring((httpData_day1.indexOf(&quot;\\&quot;daily\\&quot;&quot;) + 9), httpData.indexOf(&quot;],\\&quot;last&quot;));\n      DynamicJsonBuffer jsonBuffer;\n      JsonObject&amp; root = jsonBuffer.parseObject(data_day1);\n      date1 = root[(&quot;date&quot;)].as&lt;String&gt;();\n      temperature_low_day1 = root[String(&quot;low&quot;)];\n      temperature_high_day1 = root[String(&quot;high&quot;)];\n      code_day1 = root[String(&quot;code_day&quot;)];\n      code_night1 = root[String(&quot;code_night&quot;)];\n      wind_direction_day1 = root[(&quot;wind_direction&quot;)].as&lt;String&gt;();\n      wind_scale_day1 = root[String(&quot;wind_scale&quot;)];</pre>\n<p></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">数据的发送：</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">我们所用到的指令大概有切图、控件的赋&#20540;这三种指令，切图指令是让屏幕显示当前天气的图片信息，天气图片可以在心知天气上下载，由于目前串口屏的上位机并不支持矢量图，因此我们需要将天气图片和背景图P在一起然后按照顺序导入这些图片。切图指令为</span><span style=\"color:#ff0000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">picq\n x,y,w,h,pic_id</span></span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">&nbsp;&nbsp;pic_id为我们导入的图片序号，由于是显示天气实况pic_id的&#20540;应该是上一篇我们解析出来的天气代码“code”</span><br>\n</span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><img src=\"https://img-blog.csdn.net/20171214165426766?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">天气图片的显示就完成了，下面就是发送其他的信息了。</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">我们用到的大部分是文本控件使用到的指令为</span><span style=\"color:#ff0000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700\">控件ID.txt=&quot;\n &quot;</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">和</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:#ff0000; word-wrap:break-word; margin:0px; padding:0px\">控件ID.txt=控件ID.txt&#43;&quot;\n &quot;</span></span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">前一种会将以前的字符给覆盖掉，后一种则是在原有的基础上增加。</span><span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">由于Arduino解析中文、发送中文字符比较麻烦，所以我选择是发送数字和字符，然后通过让串口屏进行处理并组合成中文，</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<span style=\"color:#000000; word-wrap:break-word; margin:0px; padding:0px; font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">举个例子</span><br>\n</span></span></span></p>\n<p></p>\n<pre name=\"code\" class=\"cpp\">//假设白天为晴天，对应的天气代码为0，夜晚为多云，对应天气代码为4，那么整天的天气情况用中文表示应该是晴转多云\nif(code_day1==0)\n{\n        if(code_night1==4)\n                g0.txt=&quot;晴转多云&quot;;\n}</pre><br>\n<span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">总共大概有30中天气情况，这样就会有几百种组合了，看&#20284;麻烦其实只需要写一遍然后Ctrl&#43;c 、Ctrl&#43;v再稍微调整一下就行了，风向风力同样是这样处理的。（如果嫌麻烦，直接下载链接的tft文件直接烧进屏幕即可），关于屏幕显示的东西就这么多了，其他的以后再补充吧！！！</span><br style=\"word-wrap:break-word; margin:0px; padding:0px; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">\n<br>\n<p></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">演示视频（</span><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">增加了loading动画</span><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">）</span><br>\n</span></span></span></p>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><span style=\"word-wrap:break-word; margin:0px; padding:0px; font-weight:700; color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\">http://v.youku.com/v_show/id_XMjcxNTk0MzIyOA==.html<br>\n</span></span></span></span></p>\n<a target=\"_blank\" target=\"_blank\" href=\"http://v.youku.com/v_show/id_XMjcxNTk0MzIyOA==.html\" style=\"font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px; font-weight:700\">点击打开链接</a><br>\n<br>\n<p><span style=\"color:rgb(68,68,68); font-family:&quot;Microsoft Yahei&quot;,Simsun; font-size:14px\"><br>\n</span></p>\n"},{"_content":"<p>django实现websocket大致上有两种方式，一种channels，一种是dwebsocket。channels依赖于redis，twisted等，相比之下使用dwebsocket要更为方便一些。</p>\n\n<h3>安装： </h3>\n\n<pre class=\"has\">\n<code>pip install dwebsocket</code></pre>\n\n<h3>配置：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\"># setting.py\n\nINSTALLED_APPS = [\n    .....\n    .....\n    'dwebsocket',\n]\n\nMIDDLEWARE_CLASSES = [\n    ......\n    ......\n    'dwebsocket.middleware.WebSocketMiddleware'  # 为所有的URL提供websocket，如果只是单独的视图需要可以不选\n\n]\nWEBSOCKET_ACCEPT_ALL=True   # 可以允许每一个单独的视图实用websockets</code></pre>\n\n<h3>简单使用：</h3>\n\n<p>模拟文件下载的简单示例</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from dwebsocket.decorators import accept_websocket\n@accept_websocket\ndef test(request):\n    if not request.is_websocket():  # 判断是不是websocket连接\n        return render(request, 'websocket.html')\n    else:\n        download = Haproxy()\n        t = threading.Thread(target=download.run)\n        t.start()\n        sent = []\n        while download.status:\n            if len(download.res_dict) &gt; len(sent):\n                for i in download.res_dict.keys():\n                    if i not in sent:\n                        sent.append(i)\n                request.websocket.send(str(sent[-1]+str(download.res_dict[sent[-1]])).encode('utf-8'))  # 发送消息到客户端\n        if not download.status:\n            request.websocket.send('下载完成'.encode('utf-8'))</code></pre>\n\n<p>效果图：<br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180921152624468?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></p>\n\n<h3>详细：</h3>\n\n<p>dwebsocket有两种装饰器：require_websocket和accept_websocekt，使用require_websocket装饰器会导致视图函数无法接收导致正常的http请求，一般情况使用accept_websocket方式就可以了，</p>\n\n<p><strong>dwebsocket的一些内置方法：</strong></p>\n\n<p>request.is_websocket（）：判断请求是否是websocket方式，是返回true，否则返回false<br />\nrequest.websocket： 当请求为websocket的时候，会在request中增加一个websocket属性，<br />\nWebSocket.wait（） 返回客户端发送的一条消息，没有收到消息则会导致阻塞<br />\nWebSocket.read（） 和wait一样可以接受返回的消息，只是这种是非阻塞的，没有消息返回None<br />\nWebSocket.count_messages（）返回消息的数量<br />\nWebSocket.has_messages（）返回是否有新的消息过来<br />\nWebSocket.send（message）像客户端发送消息，message为byte类型</p>\n\n<p> </p>","source":"_posts/blogs-Django 实现Websocket.md","raw":"<p>django实现websocket大致上有两种方式，一种channels，一种是dwebsocket。channels依赖于redis，twisted等，相比之下使用dwebsocket要更为方便一些。</p>\n\n<h3>安装： </h3>\n\n<pre class=\"has\">\n<code>pip install dwebsocket</code></pre>\n\n<h3>配置：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\"># setting.py\n\nINSTALLED_APPS = [\n    .....\n    .....\n    'dwebsocket',\n]\n\nMIDDLEWARE_CLASSES = [\n    ......\n    ......\n    'dwebsocket.middleware.WebSocketMiddleware'  # 为所有的URL提供websocket，如果只是单独的视图需要可以不选\n\n]\nWEBSOCKET_ACCEPT_ALL=True   # 可以允许每一个单独的视图实用websockets</code></pre>\n\n<h3>简单使用：</h3>\n\n<p>模拟文件下载的简单示例</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from dwebsocket.decorators import accept_websocket\n@accept_websocket\ndef test(request):\n    if not request.is_websocket():  # 判断是不是websocket连接\n        return render(request, 'websocket.html')\n    else:\n        download = Haproxy()\n        t = threading.Thread(target=download.run)\n        t.start()\n        sent = []\n        while download.status:\n            if len(download.res_dict) &gt; len(sent):\n                for i in download.res_dict.keys():\n                    if i not in sent:\n                        sent.append(i)\n                request.websocket.send(str(sent[-1]+str(download.res_dict[sent[-1]])).encode('utf-8'))  # 发送消息到客户端\n        if not download.status:\n            request.websocket.send('下载完成'.encode('utf-8'))</code></pre>\n\n<p>效果图：<br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180921152624468?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></p>\n\n<h3>详细：</h3>\n\n<p>dwebsocket有两种装饰器：require_websocket和accept_websocekt，使用require_websocket装饰器会导致视图函数无法接收导致正常的http请求，一般情况使用accept_websocket方式就可以了，</p>\n\n<p><strong>dwebsocket的一些内置方法：</strong></p>\n\n<p>request.is_websocket（）：判断请求是否是websocket方式，是返回true，否则返回false<br />\nrequest.websocket： 当请求为websocket的时候，会在request中增加一个websocket属性，<br />\nWebSocket.wait（） 返回客户端发送的一条消息，没有收到消息则会导致阻塞<br />\nWebSocket.read（） 和wait一样可以接受返回的消息，只是这种是非阻塞的，没有消息返回None<br />\nWebSocket.count_messages（）返回消息的数量<br />\nWebSocket.has_messages（）返回是否有新的消息过来<br />\nWebSocket.send（message）像客户端发送消息，message为byte类型</p>\n\n<p> </p>","slug":"blogs-Django 实现Websocket","published":1,"date":"2022-03-16T17:09:02.783Z","updated":"2022-03-16T17:09:02.783Z","_id":"cl0v6kesa000ryms4d4akhiso","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>django实现websocket大致上有两种方式，一种channels，一种是dwebsocket。channels依赖于redis，twisted等，相比之下使用dwebsocket要更为方便一些。</p>\n\n<h3>安装： </h3>\n\n<pre class=\"has\">\n<code>pip install dwebsocket</code></pre>\n\n<h3>配置：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\"># setting.py\n\nINSTALLED_APPS = [\n    .....\n    .....\n    'dwebsocket',\n]\n\nMIDDLEWARE_CLASSES = [\n    ......\n    ......\n    'dwebsocket.middleware.WebSocketMiddleware'  # 为所有的URL提供websocket，如果只是单独的视图需要可以不选\n\n]\nWEBSOCKET_ACCEPT_ALL=True   # 可以允许每一个单独的视图实用websockets</code></pre>\n\n<h3>简单使用：</h3>\n\n<p>模拟文件下载的简单示例</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from dwebsocket.decorators import accept_websocket\n@accept_websocket\ndef test(request):\n    if not request.is_websocket():  # 判断是不是websocket连接\n        return render(request, 'websocket.html')\n    else:\n        download = Haproxy()\n        t = threading.Thread(target=download.run)\n        t.start()\n        sent = []\n        while download.status:\n            if len(download.res_dict) &gt; len(sent):\n                for i in download.res_dict.keys():\n                    if i not in sent:\n                        sent.append(i)\n                request.websocket.send(str(sent[-1]+str(download.res_dict[sent[-1]])).encode('utf-8'))  # 发送消息到客户端\n        if not download.status:\n            request.websocket.send('下载完成'.encode('utf-8'))</code></pre>\n\n<p>效果图：<br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180921152624468?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></p>\n\n<h3>详细：</h3>\n\n<p>dwebsocket有两种装饰器：require_websocket和accept_websocekt，使用require_websocket装饰器会导致视图函数无法接收导致正常的http请求，一般情况使用accept_websocket方式就可以了，</p>\n\n<p><strong>dwebsocket的一些内置方法：</strong></p>\n\n<p>request.is_websocket（）：判断请求是否是websocket方式，是返回true，否则返回false<br />\nrequest.websocket： 当请求为websocket的时候，会在request中增加一个websocket属性，<br />\nWebSocket.wait（） 返回客户端发送的一条消息，没有收到消息则会导致阻塞<br />\nWebSocket.read（） 和wait一样可以接受返回的消息，只是这种是非阻塞的，没有消息返回None<br />\nWebSocket.count_messages（）返回消息的数量<br />\nWebSocket.has_messages（）返回是否有新的消息过来<br />\nWebSocket.send（message）像客户端发送消息，message为byte类型</p>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<p>django实现websocket大致上有两种方式，一种channels，一种是dwebsocket。channels依赖于redis，twisted等，相比之下使用dwebsocket要更为方便一些。</p>\n\n<h3>安装： </h3>\n\n<pre class=\"has\">\n<code>pip install dwebsocket</code></pre>\n\n<h3>配置：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\"># setting.py\n\nINSTALLED_APPS = [\n    .....\n    .....\n    'dwebsocket',\n]\n\nMIDDLEWARE_CLASSES = [\n    ......\n    ......\n    'dwebsocket.middleware.WebSocketMiddleware'  # 为所有的URL提供websocket，如果只是单独的视图需要可以不选\n\n]\nWEBSOCKET_ACCEPT_ALL=True   # 可以允许每一个单独的视图实用websockets</code></pre>\n\n<h3>简单使用：</h3>\n\n<p>模拟文件下载的简单示例</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from dwebsocket.decorators import accept_websocket\n@accept_websocket\ndef test(request):\n    if not request.is_websocket():  # 判断是不是websocket连接\n        return render(request, 'websocket.html')\n    else:\n        download = Haproxy()\n        t = threading.Thread(target=download.run)\n        t.start()\n        sent = []\n        while download.status:\n            if len(download.res_dict) &gt; len(sent):\n                for i in download.res_dict.keys():\n                    if i not in sent:\n                        sent.append(i)\n                request.websocket.send(str(sent[-1]+str(download.res_dict[sent[-1]])).encode('utf-8'))  # 发送消息到客户端\n        if not download.status:\n            request.websocket.send('下载完成'.encode('utf-8'))</code></pre>\n\n<p>效果图：<br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180921152624468?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></p>\n\n<h3>详细：</h3>\n\n<p>dwebsocket有两种装饰器：require_websocket和accept_websocekt，使用require_websocket装饰器会导致视图函数无法接收导致正常的http请求，一般情况使用accept_websocket方式就可以了，</p>\n\n<p><strong>dwebsocket的一些内置方法：</strong></p>\n\n<p>request.is_websocket（）：判断请求是否是websocket方式，是返回true，否则返回false<br />\nrequest.websocket： 当请求为websocket的时候，会在request中增加一个websocket属性，<br />\nWebSocket.wait（） 返回客户端发送的一条消息，没有收到消息则会导致阻塞<br />\nWebSocket.read（） 和wait一样可以接受返回的消息，只是这种是非阻塞的，没有消息返回None<br />\nWebSocket.count_messages（）返回消息的数量<br />\nWebSocket.has_messages（）返回是否有新的消息过来<br />\nWebSocket.send（message）像客户端发送消息，message为byte类型</p>\n\n<p> </p>"},{"_content":"<p>先看一下出错的代码</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># 中间件\nclass AuthMiddleware(MiddlewareMixin):\n    \n    def process_request(self, request):\n        print(request.path)\n        print(request.session.get('is_log'))\n        if request.path != '/oa/login':\n            if request.session.get('is_log'):\n                return redirect('/oa/dashboard')\n            else:\n                return redirect('/oa/login')\n        else:\n            return</code></pre>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># view\nclass Login(View):\n    def get(self, request):\n        return render(request, 'website/signin.html')\n\n    def post(self, request):\n        res = {'status': 'succ'}\n        user_name = request.POST.get(\"name\", None)\n        password = request.POST.get(\"password\", None)\n        re_log = request.POST.get(\"remember\", None)\n        if user_name == 'root' and password == '123':\n            # 设置session\n            request.session['user'] = user_name\n            request.session['is_log'] = True\n            # 如果选择记住状态则保持一周的session信息\n            if re_log == 1:\n                request.session.set_expiry(1209600)\n            res['status'] = 'succ'\n        else:\n            res['status'] = '密码错误'\n        return HttpResponse(json.dumps(res), content_type=\"application/json\")\n\n\nclass Dashboard(View):\n    def get(self, request):\n        db = DataBase()\n        data = db.dashboard()\n        return render(request, 'website/dashboard.html', {'data': data})\n       </code></pre>\n\n<p>访问效果：<br /><img alt=\"\" class=\"has\" height=\"300\" src=\"https://img-blog.csdn.net/20180720102424649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"530\" /><br />\n登录成功之后一直出现重复的跳转问题。</p>\n\n<p>我们在来重新审视一下代码：<br />\n首先我们登录成功之后访问/oa/dashboard这个页面，然后在中间间的处理过程中由于第一个if判断和第二个if判断都满足导致再次跳转到oa/dashboard页面一直重复。而且在访问其他页面的时候依然是一直跳转dashboard这个页面的，逻辑有误。</p>\n\n<p>解决方法：在验证用户登录之后的session之后直接return掉而不是进行跳转。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class AuthMiddleware(MiddlewareMixin):\n\n    def process_request(self, request):\n        if request.path != '/oa/login':\n            if request.session.get('is_log'):\n                return\n            else:\n                return redirect('/oa/login')\n        else:\n            return</code></pre>\n\n<h2>之前逻辑没看清，现在突然发现这个问题好傻逼<br />\n </h2>","source":"_posts/blogs-Django使用中间件实现用户登录功能出现重复跳转的问题及解决方法.md","raw":"<p>先看一下出错的代码</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># 中间件\nclass AuthMiddleware(MiddlewareMixin):\n    \n    def process_request(self, request):\n        print(request.path)\n        print(request.session.get('is_log'))\n        if request.path != '/oa/login':\n            if request.session.get('is_log'):\n                return redirect('/oa/dashboard')\n            else:\n                return redirect('/oa/login')\n        else:\n            return</code></pre>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># view\nclass Login(View):\n    def get(self, request):\n        return render(request, 'website/signin.html')\n\n    def post(self, request):\n        res = {'status': 'succ'}\n        user_name = request.POST.get(\"name\", None)\n        password = request.POST.get(\"password\", None)\n        re_log = request.POST.get(\"remember\", None)\n        if user_name == 'root' and password == '123':\n            # 设置session\n            request.session['user'] = user_name\n            request.session['is_log'] = True\n            # 如果选择记住状态则保持一周的session信息\n            if re_log == 1:\n                request.session.set_expiry(1209600)\n            res['status'] = 'succ'\n        else:\n            res['status'] = '密码错误'\n        return HttpResponse(json.dumps(res), content_type=\"application/json\")\n\n\nclass Dashboard(View):\n    def get(self, request):\n        db = DataBase()\n        data = db.dashboard()\n        return render(request, 'website/dashboard.html', {'data': data})\n       </code></pre>\n\n<p>访问效果：<br /><img alt=\"\" class=\"has\" height=\"300\" src=\"https://img-blog.csdn.net/20180720102424649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"530\" /><br />\n登录成功之后一直出现重复的跳转问题。</p>\n\n<p>我们在来重新审视一下代码：<br />\n首先我们登录成功之后访问/oa/dashboard这个页面，然后在中间间的处理过程中由于第一个if判断和第二个if判断都满足导致再次跳转到oa/dashboard页面一直重复。而且在访问其他页面的时候依然是一直跳转dashboard这个页面的，逻辑有误。</p>\n\n<p>解决方法：在验证用户登录之后的session之后直接return掉而不是进行跳转。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class AuthMiddleware(MiddlewareMixin):\n\n    def process_request(self, request):\n        if request.path != '/oa/login':\n            if request.session.get('is_log'):\n                return\n            else:\n                return redirect('/oa/login')\n        else:\n            return</code></pre>\n\n<h2>之前逻辑没看清，现在突然发现这个问题好傻逼<br />\n </h2>","slug":"blogs-Django使用中间件实现用户登录功能出现重复跳转的问题及解决方法","published":1,"date":"2022-03-16T17:09:13.677Z","updated":"2022-03-16T17:09:13.677Z","_id":"cl0v6kesa000syms45zmmfiyg","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>先看一下出错的代码</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># 中间件\nclass AuthMiddleware(MiddlewareMixin):\n    \n    def process_request(self, request):\n        print(request.path)\n        print(request.session.get('is_log'))\n        if request.path != '/oa/login':\n            if request.session.get('is_log'):\n                return redirect('/oa/dashboard')\n            else:\n                return redirect('/oa/login')\n        else:\n            return</code></pre>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># view\nclass Login(View):\n    def get(self, request):\n        return render(request, 'website/signin.html')\n\n    def post(self, request):\n        res = &#123;'status': 'succ'&#125;\n        user_name = request.POST.get(\"name\", None)\n        password = request.POST.get(\"password\", None)\n        re_log = request.POST.get(\"remember\", None)\n        if user_name == 'root' and password == '123':\n            # 设置session\n            request.session['user'] = user_name\n            request.session['is_log'] = True\n            # 如果选择记住状态则保持一周的session信息\n            if re_log == 1:\n                request.session.set_expiry(1209600)\n            res['status'] = 'succ'\n        else:\n            res['status'] = '密码错误'\n        return HttpResponse(json.dumps(res), content_type=\"application/json\")\n\n\nclass Dashboard(View):\n    def get(self, request):\n        db = DataBase()\n        data = db.dashboard()\n        return render(request, 'website/dashboard.html', &#123;'data': data&#125;)\n       </code></pre>\n\n<p>访问效果：<br /><img alt=\"\" class=\"has\" height=\"300\" src=\"https://img-blog.csdn.net/20180720102424649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"530\" /><br />\n登录成功之后一直出现重复的跳转问题。</p>\n\n<p>我们在来重新审视一下代码：<br />\n首先我们登录成功之后访问/oa/dashboard这个页面，然后在中间间的处理过程中由于第一个if判断和第二个if判断都满足导致再次跳转到oa/dashboard页面一直重复。而且在访问其他页面的时候依然是一直跳转dashboard这个页面的，逻辑有误。</p>\n\n<p>解决方法：在验证用户登录之后的session之后直接return掉而不是进行跳转。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class AuthMiddleware(MiddlewareMixin):\n\n    def process_request(self, request):\n        if request.path != '/oa/login':\n            if request.session.get('is_log'):\n                return\n            else:\n                return redirect('/oa/login')\n        else:\n            return</code></pre>\n\n<h2>之前逻辑没看清，现在突然发现这个问题好傻逼<br />\n </h2>","site":{"data":{}},"excerpt":"","more":"<p>先看一下出错的代码</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># 中间件\nclass AuthMiddleware(MiddlewareMixin):\n    \n    def process_request(self, request):\n        print(request.path)\n        print(request.session.get('is_log'))\n        if request.path != '/oa/login':\n            if request.session.get('is_log'):\n                return redirect('/oa/dashboard')\n            else:\n                return redirect('/oa/login')\n        else:\n            return</code></pre>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># view\nclass Login(View):\n    def get(self, request):\n        return render(request, 'website/signin.html')\n\n    def post(self, request):\n        res = &#123;'status': 'succ'&#125;\n        user_name = request.POST.get(\"name\", None)\n        password = request.POST.get(\"password\", None)\n        re_log = request.POST.get(\"remember\", None)\n        if user_name == 'root' and password == '123':\n            # 设置session\n            request.session['user'] = user_name\n            request.session['is_log'] = True\n            # 如果选择记住状态则保持一周的session信息\n            if re_log == 1:\n                request.session.set_expiry(1209600)\n            res['status'] = 'succ'\n        else:\n            res['status'] = '密码错误'\n        return HttpResponse(json.dumps(res), content_type=\"application/json\")\n\n\nclass Dashboard(View):\n    def get(self, request):\n        db = DataBase()\n        data = db.dashboard()\n        return render(request, 'website/dashboard.html', &#123;'data': data&#125;)\n       </code></pre>\n\n<p>访问效果：<br /><img alt=\"\" class=\"has\" height=\"300\" src=\"https://img-blog.csdn.net/20180720102424649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"530\" /><br />\n登录成功之后一直出现重复的跳转问题。</p>\n\n<p>我们在来重新审视一下代码：<br />\n首先我们登录成功之后访问/oa/dashboard这个页面，然后在中间间的处理过程中由于第一个if判断和第二个if判断都满足导致再次跳转到oa/dashboard页面一直重复。而且在访问其他页面的时候依然是一直跳转dashboard这个页面的，逻辑有误。</p>\n\n<p>解决方法：在验证用户登录之后的session之后直接return掉而不是进行跳转。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class AuthMiddleware(MiddlewareMixin):\n\n    def process_request(self, request):\n        if request.path != '/oa/login':\n            if request.session.get('is_log'):\n                return\n            else:\n                return redirect('/oa/login')\n        else:\n            return</code></pre>\n\n<h2>之前逻辑没看清，现在突然发现这个问题好傻逼<br />\n </h2>"},{"_content":"<h3>中间件执行流程</h3>\n\n<p>django的中间件是一个轻量级的插件，可以改变django的输入和输出，中间件共有5种方法，分别为：</p>\n\n<ul><li>process_request(self,request)</li>\n\t<li>process_view(self, request, callback, callback_args, callback_kwargs)</li>\n\t<li>process_template_response(self,request,response)</li>\n\t<li>process_exception(self, request, exception)</li>\n\t<li>process_response(self, request, response)</li>\n</ul><p>前两个方法 都是自上而下的执行每个中间件，后面的三个都是反着来的<br /><img alt=\"\" class=\"has\" height=\"645\" src=\"https://img-blog.csdnimg.cn/20181128012607646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"1164\" /></p>\n\n<p> </p>\n\n<h3>CSRF验证</h3>\n\n<p>django的CSRF是基于中间件来实现的，而且是放在中间件中的view方法中，原因是：django的中间件是作用于全局的，但是某些情况某个函数可能不需要用到CSRF验证，所以在执行路由匹配的时候找到视图函数，看看他是否需要用到CSRF认证，如果不需要则会跳过CSRF。</p>\n\n<p>免除认证的方法：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># FBV\nfrom django.views.decorators.csrf import csrf_exempt\n@csrf_exempt\ndef test(request):\n    pass\n\n# 在CBV的方式中，单独给某个方法通过装饰器来免除是无效的，需要加到dispatch函数上面\n\n# 方法1\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.utils.decorators import method_decorator\nclass Test1(APIView):\n    @method_decorator(csrf_exempt)\n    def dispatch(self, request, *args, **kwargs):\n        ret = super(Test1,self).dispatch(request, *args, **kwargs)\n        return ret\n\n# 方法2\n@method_decorator(csrf_exempt,name='dispatch')\nclass Test2(APIView):\n    pass\n\n</code></pre>\n\n<p>单独想用CSRF的方法：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># 1.去掉setting中CSRF中间件\nfrom django.views.decorators.csrf import csrf_protect\n@csrf_protect\ndef test(request):\n    pass</code></pre>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>","source":"_posts/blogs-Django中间件执行流程和CSRF验证.md","raw":"<h3>中间件执行流程</h3>\n\n<p>django的中间件是一个轻量级的插件，可以改变django的输入和输出，中间件共有5种方法，分别为：</p>\n\n<ul><li>process_request(self,request)</li>\n\t<li>process_view(self, request, callback, callback_args, callback_kwargs)</li>\n\t<li>process_template_response(self,request,response)</li>\n\t<li>process_exception(self, request, exception)</li>\n\t<li>process_response(self, request, response)</li>\n</ul><p>前两个方法 都是自上而下的执行每个中间件，后面的三个都是反着来的<br /><img alt=\"\" class=\"has\" height=\"645\" src=\"https://img-blog.csdnimg.cn/20181128012607646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"1164\" /></p>\n\n<p> </p>\n\n<h3>CSRF验证</h3>\n\n<p>django的CSRF是基于中间件来实现的，而且是放在中间件中的view方法中，原因是：django的中间件是作用于全局的，但是某些情况某个函数可能不需要用到CSRF验证，所以在执行路由匹配的时候找到视图函数，看看他是否需要用到CSRF认证，如果不需要则会跳过CSRF。</p>\n\n<p>免除认证的方法：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># FBV\nfrom django.views.decorators.csrf import csrf_exempt\n@csrf_exempt\ndef test(request):\n    pass\n\n# 在CBV的方式中，单独给某个方法通过装饰器来免除是无效的，需要加到dispatch函数上面\n\n# 方法1\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.utils.decorators import method_decorator\nclass Test1(APIView):\n    @method_decorator(csrf_exempt)\n    def dispatch(self, request, *args, **kwargs):\n        ret = super(Test1,self).dispatch(request, *args, **kwargs)\n        return ret\n\n# 方法2\n@method_decorator(csrf_exempt,name='dispatch')\nclass Test2(APIView):\n    pass\n\n</code></pre>\n\n<p>单独想用CSRF的方法：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># 1.去掉setting中CSRF中间件\nfrom django.views.decorators.csrf import csrf_protect\n@csrf_protect\ndef test(request):\n    pass</code></pre>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>","slug":"blogs-Django中间件执行流程和CSRF验证","published":1,"date":"2022-03-16T17:00:54.444Z","updated":"2022-03-16T17:05:43.824Z","_id":"cl0v6kesb000tyms497ar3cm0","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>中间件执行流程</h3>\n\n<p>django的中间件是一个轻量级的插件，可以改变django的输入和输出，中间件共有5种方法，分别为：</p>\n\n<ul><li>process_request(self,request)</li>\n    <li>process_view(self, request, callback, callback_args, callback_kwargs)</li>\n    <li>process_template_response(self,request,response)</li>\n    <li>process_exception(self, request, exception)</li>\n    <li>process_response(self, request, response)</li>\n</ul><p>前两个方法 都是自上而下的执行每个中间件，后面的三个都是反着来的<br /><img alt=\"\" class=\"has\" height=\"645\" src=\"https://img-blog.csdnimg.cn/20181128012607646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"1164\" /></p>\n\n<p> </p>\n\n<h3>CSRF验证</h3>\n\n<p>django的CSRF是基于中间件来实现的，而且是放在中间件中的view方法中，原因是：django的中间件是作用于全局的，但是某些情况某个函数可能不需要用到CSRF验证，所以在执行路由匹配的时候找到视图函数，看看他是否需要用到CSRF认证，如果不需要则会跳过CSRF。</p>\n\n<p>免除认证的方法：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># FBV\nfrom django.views.decorators.csrf import csrf_exempt\n@csrf_exempt\ndef test(request):\n    pass\n\n# 在CBV的方式中，单独给某个方法通过装饰器来免除是无效的，需要加到dispatch函数上面\n\n# 方法1\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.utils.decorators import method_decorator\nclass Test1(APIView):\n    @method_decorator(csrf_exempt)\n    def dispatch(self, request, *args, **kwargs):\n        ret = super(Test1,self).dispatch(request, *args, **kwargs)\n        return ret\n\n# 方法2\n@method_decorator(csrf_exempt,name='dispatch')\nclass Test2(APIView):\n    pass\n\n</code></pre>\n\n<p>单独想用CSRF的方法：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># 1.去掉setting中CSRF中间件\nfrom django.views.decorators.csrf import csrf_protect\n@csrf_protect\ndef test(request):\n    pass</code></pre>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<h3>中间件执行流程</h3>\n\n<p>django的中间件是一个轻量级的插件，可以改变django的输入和输出，中间件共有5种方法，分别为：</p>\n\n<ul><li>process_request(self,request)</li>\n    <li>process_view(self, request, callback, callback_args, callback_kwargs)</li>\n    <li>process_template_response(self,request,response)</li>\n    <li>process_exception(self, request, exception)</li>\n    <li>process_response(self, request, response)</li>\n</ul><p>前两个方法 都是自上而下的执行每个中间件，后面的三个都是反着来的<br /><img alt=\"\" class=\"has\" height=\"645\" src=\"https://img-blog.csdnimg.cn/20181128012607646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"1164\" /></p>\n\n<p> </p>\n\n<h3>CSRF验证</h3>\n\n<p>django的CSRF是基于中间件来实现的，而且是放在中间件中的view方法中，原因是：django的中间件是作用于全局的，但是某些情况某个函数可能不需要用到CSRF验证，所以在执行路由匹配的时候找到视图函数，看看他是否需要用到CSRF认证，如果不需要则会跳过CSRF。</p>\n\n<p>免除认证的方法：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># FBV\nfrom django.views.decorators.csrf import csrf_exempt\n@csrf_exempt\ndef test(request):\n    pass\n\n# 在CBV的方式中，单独给某个方法通过装饰器来免除是无效的，需要加到dispatch函数上面\n\n# 方法1\nfrom django.views.decorators.csrf import csrf_exempt\nfrom django.utils.decorators import method_decorator\nclass Test1(APIView):\n    @method_decorator(csrf_exempt)\n    def dispatch(self, request, *args, **kwargs):\n        ret = super(Test1,self).dispatch(request, *args, **kwargs)\n        return ret\n\n# 方法2\n@method_decorator(csrf_exempt,name='dispatch')\nclass Test2(APIView):\n    pass\n\n</code></pre>\n\n<p>单独想用CSRF的方法：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># 1.去掉setting中CSRF中间件\nfrom django.views.decorators.csrf import csrf_protect\n@csrf_protect\ndef test(request):\n    pass</code></pre>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>"},{"_content":"<p>上一篇博客简单的说了说Django发送邮件的方法，这一篇仅仅谈一下如何通过邮件的方式进行验证，以重置密码功能为例。</p>\n\n<p>其实验证方法比较简单，只需要发送指定的链接给目标邮箱，用户点击链接即可通过验证，但是合成和验证这个指定的链接需要我们来处理，我用到的方法是，当用户申请邮箱验证的时候根据其邮箱地址和一个32位随机验证码去合成一个连接，当正常访问的使用后台可通过URL获取邮箱名以及验证码，再根据这两个值去数据库中匹配，看能否成功，若是成功则完成验证失败则提示用户链接无效，接下来是具体的实现方法：</p>\n\n<p>首先我们需要建立一张数据库表，其中内容包括：邮箱地址、32位随机验证码、创建时间。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class email_reset(models.Model):\n    email_address = models.EmailField(null=False,unique=True) #邮箱地址唯一的\n    vc_code = models.CharField(max_length=64,null=False) #随机验证码\n    send_time = models.DateTimeField(auto_now=True)  #邮箱发送时间</code></pre>\n\n<p>当用户需要用到邮箱验证的时候，则往数据库中新建一条数据之后在将邮箱地址和随机验证码合成为连接发送给目标</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def send_email(email_address):\n    vc_code = vc_code_generator()\n    msg = '&lt;h2&gt;重置密码&lt;/h1&gt;'\\\n          '&lt;h6&gt;如果不是你本人操作请忽略本消息,本条消息30分钟内有效,如果被禁止跳转请复制链接在浏览器中重新打开&lt;/h6&gt;'\\\n          '&lt;a href=\"http://localhost:8000/iot/resetpwd/?email=%s&amp;code=%s\"&gt;点击重置密码&lt;/a&gt;' % (email_address,vc_code)\n    u = models.email_reset.objects.filter(email_address=email_address).first()\n    if u :\n        models.email_reset.objects.filter(email_address=email_address).update(vc_code= vc_code)\n    else:\n        models.email_reset.objects.create(email_address=email_address,vc_code=vc_code)\n    send_mail('重置密码', '请前往这个网址：localhost:8000/forgetpwd重置密码', \"*****管理员&lt;****************@163.com&gt;\",\n              [email_address], fail_silently=False, html_message=msg)\n\n#生成随机验证码\ndef vc_code_generator(size=32, chars=string.ascii_uppercase + string.ascii_letters + string.digits):\n    return ''.join(random.choice(chars) for _ in range(size))</code></pre>\n\n<p>接下来则是处理URL了，根据之前发送的链接格式我们可以通过GET方式获取到其邮箱地址和验证码，再从数据库中查询是否有从 稍作简单的判断即可知道当前</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    if request.method == \"GET\":\n        email = request.GET.get(\"email\")\n        code = request.GET.get(\"code\")\n        if email and code:\n            if models.email_reset.objects.filter(email_address=email).filter(vc_code=code):\n                return render(request,'../templates/website/reset.html',{'email':email})\n            else:\n                return HttpResponse(\"&lt;h1&gt;抱歉你访问的网址有误&lt;/h1&gt;\")\n        else:\n            return HttpResponse(\"&lt;h1&gt;抱歉你访问的网址有误&lt;/h1&gt;\")</code></pre>\n\n<p> </p>","source":"_posts/blogs-Django使用邮箱进行验证操作的实现方法.md","raw":"<p>上一篇博客简单的说了说Django发送邮件的方法，这一篇仅仅谈一下如何通过邮件的方式进行验证，以重置密码功能为例。</p>\n\n<p>其实验证方法比较简单，只需要发送指定的链接给目标邮箱，用户点击链接即可通过验证，但是合成和验证这个指定的链接需要我们来处理，我用到的方法是，当用户申请邮箱验证的时候根据其邮箱地址和一个32位随机验证码去合成一个连接，当正常访问的使用后台可通过URL获取邮箱名以及验证码，再根据这两个值去数据库中匹配，看能否成功，若是成功则完成验证失败则提示用户链接无效，接下来是具体的实现方法：</p>\n\n<p>首先我们需要建立一张数据库表，其中内容包括：邮箱地址、32位随机验证码、创建时间。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class email_reset(models.Model):\n    email_address = models.EmailField(null=False,unique=True) #邮箱地址唯一的\n    vc_code = models.CharField(max_length=64,null=False) #随机验证码\n    send_time = models.DateTimeField(auto_now=True)  #邮箱发送时间</code></pre>\n\n<p>当用户需要用到邮箱验证的时候，则往数据库中新建一条数据之后在将邮箱地址和随机验证码合成为连接发送给目标</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def send_email(email_address):\n    vc_code = vc_code_generator()\n    msg = '&lt;h2&gt;重置密码&lt;/h1&gt;'\\\n          '&lt;h6&gt;如果不是你本人操作请忽略本消息,本条消息30分钟内有效,如果被禁止跳转请复制链接在浏览器中重新打开&lt;/h6&gt;'\\\n          '&lt;a href=\"http://localhost:8000/iot/resetpwd/?email=%s&amp;code=%s\"&gt;点击重置密码&lt;/a&gt;' % (email_address,vc_code)\n    u = models.email_reset.objects.filter(email_address=email_address).first()\n    if u :\n        models.email_reset.objects.filter(email_address=email_address).update(vc_code= vc_code)\n    else:\n        models.email_reset.objects.create(email_address=email_address,vc_code=vc_code)\n    send_mail('重置密码', '请前往这个网址：localhost:8000/forgetpwd重置密码', \"*****管理员&lt;****************@163.com&gt;\",\n              [email_address], fail_silently=False, html_message=msg)\n\n#生成随机验证码\ndef vc_code_generator(size=32, chars=string.ascii_uppercase + string.ascii_letters + string.digits):\n    return ''.join(random.choice(chars) for _ in range(size))</code></pre>\n\n<p>接下来则是处理URL了，根据之前发送的链接格式我们可以通过GET方式获取到其邮箱地址和验证码，再从数据库中查询是否有从 稍作简单的判断即可知道当前</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    if request.method == \"GET\":\n        email = request.GET.get(\"email\")\n        code = request.GET.get(\"code\")\n        if email and code:\n            if models.email_reset.objects.filter(email_address=email).filter(vc_code=code):\n                return render(request,'../templates/website/reset.html',{'email':email})\n            else:\n                return HttpResponse(\"&lt;h1&gt;抱歉你访问的网址有误&lt;/h1&gt;\")\n        else:\n            return HttpResponse(\"&lt;h1&gt;抱歉你访问的网址有误&lt;/h1&gt;\")</code></pre>\n\n<p> </p>","slug":"blogs-Django使用邮箱进行验证操作的实现方法","published":1,"date":"2022-03-16T17:09:14.866Z","updated":"2022-03-16T17:09:14.866Z","_id":"cl0v6kesc000uyms4bt6ufbug","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>上一篇博客简单的说了说Django发送邮件的方法，这一篇仅仅谈一下如何通过邮件的方式进行验证，以重置密码功能为例。</p>\n\n<p>其实验证方法比较简单，只需要发送指定的链接给目标邮箱，用户点击链接即可通过验证，但是合成和验证这个指定的链接需要我们来处理，我用到的方法是，当用户申请邮箱验证的时候根据其邮箱地址和一个32位随机验证码去合成一个连接，当正常访问的使用后台可通过URL获取邮箱名以及验证码，再根据这两个值去数据库中匹配，看能否成功，若是成功则完成验证失败则提示用户链接无效，接下来是具体的实现方法：</p>\n\n<p>首先我们需要建立一张数据库表，其中内容包括：邮箱地址、32位随机验证码、创建时间。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class email_reset(models.Model):\n    email_address = models.EmailField(null=False,unique=True) #邮箱地址唯一的\n    vc_code = models.CharField(max_length=64,null=False) #随机验证码\n    send_time = models.DateTimeField(auto_now=True)  #邮箱发送时间</code></pre>\n\n<p>当用户需要用到邮箱验证的时候，则往数据库中新建一条数据之后在将邮箱地址和随机验证码合成为连接发送给目标</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def send_email(email_address):\n    vc_code = vc_code_generator()\n    msg = '&lt;h2&gt;重置密码&lt;/h1&gt;'\\\n          '&lt;h6&gt;如果不是你本人操作请忽略本消息,本条消息30分钟内有效,如果被禁止跳转请复制链接在浏览器中重新打开&lt;/h6&gt;'\\\n          '&lt;a href=\"http://localhost:8000/iot/resetpwd/?email=%s&amp;code=%s\"&gt;点击重置密码&lt;/a&gt;' % (email_address,vc_code)\n    u = models.email_reset.objects.filter(email_address=email_address).first()\n    if u :\n        models.email_reset.objects.filter(email_address=email_address).update(vc_code= vc_code)\n    else:\n        models.email_reset.objects.create(email_address=email_address,vc_code=vc_code)\n    send_mail('重置密码', '请前往这个网址：localhost:8000/forgetpwd重置密码', \"*****管理员&lt;****************@163.com&gt;\",\n              [email_address], fail_silently=False, html_message=msg)\n\n#生成随机验证码\ndef vc_code_generator(size=32, chars=string.ascii_uppercase + string.ascii_letters + string.digits):\n    return ''.join(random.choice(chars) for _ in range(size))</code></pre>\n\n<p>接下来则是处理URL了，根据之前发送的链接格式我们可以通过GET方式获取到其邮箱地址和验证码，再从数据库中查询是否有从 稍作简单的判断即可知道当前</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    if request.method == \"GET\":\n        email = request.GET.get(\"email\")\n        code = request.GET.get(\"code\")\n        if email and code:\n            if models.email_reset.objects.filter(email_address=email).filter(vc_code=code):\n                return render(request,'../templates/website/reset.html',&#123;'email':email&#125;)\n            else:\n                return HttpResponse(\"&lt;h1&gt;抱歉你访问的网址有误&lt;/h1&gt;\")\n        else:\n            return HttpResponse(\"&lt;h1&gt;抱歉你访问的网址有误&lt;/h1&gt;\")</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<p>上一篇博客简单的说了说Django发送邮件的方法，这一篇仅仅谈一下如何通过邮件的方式进行验证，以重置密码功能为例。</p>\n\n<p>其实验证方法比较简单，只需要发送指定的链接给目标邮箱，用户点击链接即可通过验证，但是合成和验证这个指定的链接需要我们来处理，我用到的方法是，当用户申请邮箱验证的时候根据其邮箱地址和一个32位随机验证码去合成一个连接，当正常访问的使用后台可通过URL获取邮箱名以及验证码，再根据这两个值去数据库中匹配，看能否成功，若是成功则完成验证失败则提示用户链接无效，接下来是具体的实现方法：</p>\n\n<p>首先我们需要建立一张数据库表，其中内容包括：邮箱地址、32位随机验证码、创建时间。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class email_reset(models.Model):\n    email_address = models.EmailField(null=False,unique=True) #邮箱地址唯一的\n    vc_code = models.CharField(max_length=64,null=False) #随机验证码\n    send_time = models.DateTimeField(auto_now=True)  #邮箱发送时间</code></pre>\n\n<p>当用户需要用到邮箱验证的时候，则往数据库中新建一条数据之后在将邮箱地址和随机验证码合成为连接发送给目标</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def send_email(email_address):\n    vc_code = vc_code_generator()\n    msg = '&lt;h2&gt;重置密码&lt;/h1&gt;'\\\n          '&lt;h6&gt;如果不是你本人操作请忽略本消息,本条消息30分钟内有效,如果被禁止跳转请复制链接在浏览器中重新打开&lt;/h6&gt;'\\\n          '&lt;a href=\"http://localhost:8000/iot/resetpwd/?email=%s&amp;code=%s\"&gt;点击重置密码&lt;/a&gt;' % (email_address,vc_code)\n    u = models.email_reset.objects.filter(email_address=email_address).first()\n    if u :\n        models.email_reset.objects.filter(email_address=email_address).update(vc_code= vc_code)\n    else:\n        models.email_reset.objects.create(email_address=email_address,vc_code=vc_code)\n    send_mail('重置密码', '请前往这个网址：localhost:8000/forgetpwd重置密码', \"*****管理员&lt;****************@163.com&gt;\",\n              [email_address], fail_silently=False, html_message=msg)\n\n#生成随机验证码\ndef vc_code_generator(size=32, chars=string.ascii_uppercase + string.ascii_letters + string.digits):\n    return ''.join(random.choice(chars) for _ in range(size))</code></pre>\n\n<p>接下来则是处理URL了，根据之前发送的链接格式我们可以通过GET方式获取到其邮箱地址和验证码，再从数据库中查询是否有从 稍作简单的判断即可知道当前</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    if request.method == \"GET\":\n        email = request.GET.get(\"email\")\n        code = request.GET.get(\"code\")\n        if email and code:\n            if models.email_reset.objects.filter(email_address=email).filter(vc_code=code):\n                return render(request,'../templates/website/reset.html',&#123;'email':email&#125;)\n            else:\n                return HttpResponse(\"&lt;h1&gt;抱歉你访问的网址有误&lt;/h1&gt;\")\n        else:\n            return HttpResponse(\"&lt;h1&gt;抱歉你访问的网址有误&lt;/h1&gt;\")</code></pre>\n\n<p> </p>"},{"_content":"<p>Django提供了发送邮件的接口，仅需做简单的设置即可实现发送邮件的功能。<br />首先需要在setting做简单的配置，以163邮箱为例：</p><pre class=\"python\">EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'\nEMAIL_HOST = 'smtp.163.com' \nEMAIL_PORT = 25\nEMAIL_HOST_USER = '****' # 帐号\nEMAIL_HOST_PASSWORD = '****'  # 密码\nDEFAULT_FROM_EMAIL = \"*******\" #默认发送名</pre>下面是官网的一个示例：<pre class=\"python\">from django.core.mail import send_mail\n \nsend_mail('Subject here', 'Here is the message.', 'from@example.com',\n    ['to@example.com'], fail_silently=False)</pre>自定义一个测试的URL地址，传入相应的参数即可成功发送邮件<br /><p><img src=\"https://img-blog.csdn.net/20180511125242870?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /></p><p>如果是放在云服务器上运行的时候需要注意25号端口有没有被禁用，有些服务商会将25号端口默认禁用，需要解禁后才能使用</p>","source":"_posts/blogs-Django发送邮件.md","raw":"<p>Django提供了发送邮件的接口，仅需做简单的设置即可实现发送邮件的功能。<br />首先需要在setting做简单的配置，以163邮箱为例：</p><pre class=\"python\">EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'\nEMAIL_HOST = 'smtp.163.com' \nEMAIL_PORT = 25\nEMAIL_HOST_USER = '****' # 帐号\nEMAIL_HOST_PASSWORD = '****'  # 密码\nDEFAULT_FROM_EMAIL = \"*******\" #默认发送名</pre>下面是官网的一个示例：<pre class=\"python\">from django.core.mail import send_mail\n \nsend_mail('Subject here', 'Here is the message.', 'from@example.com',\n    ['to@example.com'], fail_silently=False)</pre>自定义一个测试的URL地址，传入相应的参数即可成功发送邮件<br /><p><img src=\"https://img-blog.csdn.net/20180511125242870?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /></p><p>如果是放在云服务器上运行的时候需要注意25号端口有没有被禁用，有些服务商会将25号端口默认禁用，需要解禁后才能使用</p>","slug":"blogs-Django发送邮件","published":1,"date":"2022-03-16T17:09:16.038Z","updated":"2022-03-16T17:09:16.038Z","_id":"cl0v6kesd000vyms40mg5hmle","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Django提供了发送邮件的接口，仅需做简单的设置即可实现发送邮件的功能。<br />首先需要在setting做简单的配置，以163邮箱为例：</p><pre class=\"python\">EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'\nEMAIL_HOST = 'smtp.163.com' \nEMAIL_PORT = 25\nEMAIL_HOST_USER = '****' # 帐号\nEMAIL_HOST_PASSWORD = '****'  # 密码\nDEFAULT_FROM_EMAIL = \"*******\" #默认发送名</pre>下面是官网的一个示例：<pre class=\"python\">from django.core.mail import send_mail\n \n<p>send_mail(‘Subject here’, ‘Here is the message.’, ‘<a href=\"mailto:&#102;&#114;&#x6f;&#x6d;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#109;\">&#102;&#114;&#x6f;&#x6d;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#109;</a>‘,<br>    [‘<a href=\"mailto:&#x74;&#111;&#64;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;\">&#x74;&#111;&#64;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;</a>‘], fail_silently=False)</pre>自定义一个测试的URL地址，传入相应的参数即可成功发送邮件<br /><p><img src=\"https://img-blog.csdn.net/20180511125242870?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /></p><p>如果是放在云服务器上运行的时候需要注意25号端口有没有被禁用，有些服务商会将25号端口默认禁用，需要解禁后才能使用</p></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Django提供了发送邮件的接口，仅需做简单的设置即可实现发送邮件的功能。<br />首先需要在setting做简单的配置，以163邮箱为例：</p><pre class=\"python\">EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'\nEMAIL_HOST = 'smtp.163.com' \nEMAIL_PORT = 25\nEMAIL_HOST_USER = '****' # 帐号\nEMAIL_HOST_PASSWORD = '****'  # 密码\nDEFAULT_FROM_EMAIL = \"*******\" #默认发送名</pre>下面是官网的一个示例：<pre class=\"python\">from django.core.mail import send_mail\n \n<p>send_mail(‘Subject here’, ‘Here is the message.’, ‘<a href=\"mailto:&#102;&#114;&#x6f;&#x6d;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#109;\">&#102;&#114;&#x6f;&#x6d;&#x40;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#x65;&#46;&#99;&#x6f;&#109;</a>‘,<br>    [‘<a href=\"mailto:&#x74;&#111;&#64;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;\">&#x74;&#111;&#64;&#x65;&#120;&#97;&#109;&#112;&#x6c;&#101;&#46;&#99;&#111;&#109;</a>‘], fail_silently=False)</pre>自定义一个测试的URL地址，传入相应的参数即可成功发送邮件<br /><p><img src=\"https://img-blog.csdn.net/20180511125242870?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /></p><p>如果是放在云服务器上运行的时候需要注意25号端口有没有被禁用，有些服务商会将25号端口默认禁用，需要解禁后才能使用</p></p>\n"},{"_content":"<p>接着上一篇的介绍，这部分将介绍如何读取上传的文件并调用转账接口实现转账功能。<br />\n具体步骤   ===》打开文件  ===》读取每一行的数据 ===》调用支付宝单笔转账接口</p>\n\n<p><strong>1.Excel文件的读取<br />\n     </strong>python读取excel文件需要用到xlrd这个库，这个库的具体用法这里就不说了，主要介绍一下读取excel文件的步骤：<br />\n     1.使用xlrd.open_workbook(path)打开文件<br />\n     2.遍历文件中所有的sheet，并且读取所有行数据</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">for sheet in ExcelFile.sheet_names():\n    data = ExcelFile.sheet_by_name(sheet)\n    i = 0\n    while i &lt; (data.nrows):\n        yield data.row_values(i)\n        i += 1</code></pre>\n\n<p>     为了防止文件过大占有太多内存，没有一次将所有数据都读取出来，而是使用生成器返回一个迭代对象，每次调用这个迭代对象来取出数据。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">f = read_excel('../files/2018.7.30(1).xls')\nfor i in f:\n    print(i)</code></pre>\n\n<p>运行结果：<br /><img alt=\"\" class=\"has\" height=\"87\" src=\"https://img-blog.csdn.net/20180809182420169?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"385\" /></p>\n\n<p><strong>2.调用转账接口：<br />\n     </strong>接口部分我们之前已经说过了，现在只需要将excel中的数据传递进去就能够实现转账功能了，<br />\n     为了不单单只是在后台打印交易信息，对之前的pay方法做一些调整</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">data = {'payee_account': None, 'amount': None, 'payee_real_name': None, 'remark': None, 'order_id': None,\n        'out_biz_no': None, 'pay_date': None, 'status': None}\nif result['code'] == '10000':\n    if result['msg'] == \"Success\":\n        print(payee_account + \"  转账成功\" + \"  交易单号：\" + result[\"out_biz_no\"])\n    data['payee_account'] = payee_account\n    data['amount'] = amount\n    data['payee_real_name'] = payee_real_name\n    data['order_id'] = result['order_id']\n    data['out_biz_no'] = result['out_biz_no']\n    data['pay_date'] = result['pay_date']\n    data['status'] = '转账成功'\n    return data\nelse:\n    print(payee_account, amount, result['sub_msg'], result[\"out_biz_no\"])\n    data['payee_account'] = payee_account\n    data['amount'] = amount\n    data['payee_real_name'] = payee_real_name\n    data['out_biz_no'] = result['out_biz_no']\n    data['status'] = result['sub_msg']\n    # error = [payee_account, amount, payee_real_name, result['sub_msg'], result['out_biz_no']]\n    return data</code></pre>\n\n<p>      方便起见将excel文件读取和转账接口封装到一个函数里面了，现在只需要传递文件路径就能直接转账了，数据库写入就不详细说了。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def run(path):\n    file = read_excel(path)\n    pay = Payment(*******)\n    data = []\n    error = []\n    for item in file:\n        res = pay.pay(item[1], item[0], item[3], item[2])\n        res['remark'] = item[4]\n        data.append(res)\n        if res['status'] != '转账成功':\n            error.append([res['payee_account'], res['amount'], res['payee_real_name'], res['remark'], res['status'],\n                          res['out_biz_no']])\n            # except Exception as e:\n            #     pass\n    write(data)  # 写入数据库\n    return error  # 网页返回错误信息\n</code></pre>\n\n<p><strong>3.网页显示失败信息：<br />\n     </strong>这一步没什么好说的了，我是直接使用django的render函数将错误信息渲染完成之后返回了一个新的页面。其实用Ajax接收数据然后js来渲染页面这种做法要好一些。</p>","source":"_posts/blogs-Django支付宝自动转账功能（二）.md","raw":"<p>接着上一篇的介绍，这部分将介绍如何读取上传的文件并调用转账接口实现转账功能。<br />\n具体步骤   ===》打开文件  ===》读取每一行的数据 ===》调用支付宝单笔转账接口</p>\n\n<p><strong>1.Excel文件的读取<br />\n     </strong>python读取excel文件需要用到xlrd这个库，这个库的具体用法这里就不说了，主要介绍一下读取excel文件的步骤：<br />\n     1.使用xlrd.open_workbook(path)打开文件<br />\n     2.遍历文件中所有的sheet，并且读取所有行数据</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">for sheet in ExcelFile.sheet_names():\n    data = ExcelFile.sheet_by_name(sheet)\n    i = 0\n    while i &lt; (data.nrows):\n        yield data.row_values(i)\n        i += 1</code></pre>\n\n<p>     为了防止文件过大占有太多内存，没有一次将所有数据都读取出来，而是使用生成器返回一个迭代对象，每次调用这个迭代对象来取出数据。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">f = read_excel('../files/2018.7.30(1).xls')\nfor i in f:\n    print(i)</code></pre>\n\n<p>运行结果：<br /><img alt=\"\" class=\"has\" height=\"87\" src=\"https://img-blog.csdn.net/20180809182420169?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"385\" /></p>\n\n<p><strong>2.调用转账接口：<br />\n     </strong>接口部分我们之前已经说过了，现在只需要将excel中的数据传递进去就能够实现转账功能了，<br />\n     为了不单单只是在后台打印交易信息，对之前的pay方法做一些调整</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">data = {'payee_account': None, 'amount': None, 'payee_real_name': None, 'remark': None, 'order_id': None,\n        'out_biz_no': None, 'pay_date': None, 'status': None}\nif result['code'] == '10000':\n    if result['msg'] == \"Success\":\n        print(payee_account + \"  转账成功\" + \"  交易单号：\" + result[\"out_biz_no\"])\n    data['payee_account'] = payee_account\n    data['amount'] = amount\n    data['payee_real_name'] = payee_real_name\n    data['order_id'] = result['order_id']\n    data['out_biz_no'] = result['out_biz_no']\n    data['pay_date'] = result['pay_date']\n    data['status'] = '转账成功'\n    return data\nelse:\n    print(payee_account, amount, result['sub_msg'], result[\"out_biz_no\"])\n    data['payee_account'] = payee_account\n    data['amount'] = amount\n    data['payee_real_name'] = payee_real_name\n    data['out_biz_no'] = result['out_biz_no']\n    data['status'] = result['sub_msg']\n    # error = [payee_account, amount, payee_real_name, result['sub_msg'], result['out_biz_no']]\n    return data</code></pre>\n\n<p>      方便起见将excel文件读取和转账接口封装到一个函数里面了，现在只需要传递文件路径就能直接转账了，数据库写入就不详细说了。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def run(path):\n    file = read_excel(path)\n    pay = Payment(*******)\n    data = []\n    error = []\n    for item in file:\n        res = pay.pay(item[1], item[0], item[3], item[2])\n        res['remark'] = item[4]\n        data.append(res)\n        if res['status'] != '转账成功':\n            error.append([res['payee_account'], res['amount'], res['payee_real_name'], res['remark'], res['status'],\n                          res['out_biz_no']])\n            # except Exception as e:\n            #     pass\n    write(data)  # 写入数据库\n    return error  # 网页返回错误信息\n</code></pre>\n\n<p><strong>3.网页显示失败信息：<br />\n     </strong>这一步没什么好说的了，我是直接使用django的render函数将错误信息渲染完成之后返回了一个新的页面。其实用Ajax接收数据然后js来渲染页面这种做法要好一些。</p>","slug":"blogs-Django支付宝自动转账功能（二）","published":1,"date":"2022-03-16T17:09:10.150Z","updated":"2022-03-16T17:09:10.150Z","_id":"cl0v6kesd000wyms4h2haa20c","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>接着上一篇的介绍，这部分将介绍如何读取上传的文件并调用转账接口实现转账功能。<br />\n具体步骤   ===》打开文件  ===》读取每一行的数据 ===》调用支付宝单笔转账接口</p>\n\n<p><strong>1.Excel文件的读取<br />\n     </strong>python读取excel文件需要用到xlrd这个库，这个库的具体用法这里就不说了，主要介绍一下读取excel文件的步骤：<br />\n     1.使用xlrd.open_workbook(path)打开文件<br />\n     2.遍历文件中所有的sheet，并且读取所有行数据</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">for sheet in ExcelFile.sheet_names():\n    data = ExcelFile.sheet_by_name(sheet)\n    i = 0\n    while i &lt; (data.nrows):\n        yield data.row_values(i)\n        i += 1</code></pre>\n\n<p>     为了防止文件过大占有太多内存，没有一次将所有数据都读取出来，而是使用生成器返回一个迭代对象，每次调用这个迭代对象来取出数据。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">f = read_excel('../files/2018.7.30(1).xls')\nfor i in f:\n    print(i)</code></pre>\n\n<p>运行结果：<br /><img alt=\"\" class=\"has\" height=\"87\" src=\"https://img-blog.csdn.net/20180809182420169?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"385\" /></p>\n\n<p><strong>2.调用转账接口：<br />\n     </strong>接口部分我们之前已经说过了，现在只需要将excel中的数据传递进去就能够实现转账功能了，<br />\n     为了不单单只是在后台打印交易信息，对之前的pay方法做一些调整</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">data = &#123;'payee_account': None, 'amount': None, 'payee_real_name': None, 'remark': None, 'order_id': None,\n        'out_biz_no': None, 'pay_date': None, 'status': None&#125;\nif result['code'] == '10000':\n    if result['msg'] == \"Success\":\n        print(payee_account + \"  转账成功\" + \"  交易单号：\" + result[\"out_biz_no\"])\n    data['payee_account'] = payee_account\n    data['amount'] = amount\n    data['payee_real_name'] = payee_real_name\n    data['order_id'] = result['order_id']\n    data['out_biz_no'] = result['out_biz_no']\n    data['pay_date'] = result['pay_date']\n    data['status'] = '转账成功'\n    return data\nelse:\n    print(payee_account, amount, result['sub_msg'], result[\"out_biz_no\"])\n    data['payee_account'] = payee_account\n    data['amount'] = amount\n    data['payee_real_name'] = payee_real_name\n    data['out_biz_no'] = result['out_biz_no']\n    data['status'] = result['sub_msg']\n    # error = [payee_account, amount, payee_real_name, result['sub_msg'], result['out_biz_no']]\n    return data</code></pre>\n\n<p>      方便起见将excel文件读取和转账接口封装到一个函数里面了，现在只需要传递文件路径就能直接转账了，数据库写入就不详细说了。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def run(path):\n    file = read_excel(path)\n    pay = Payment(*******)\n    data = []\n    error = []\n    for item in file:\n        res = pay.pay(item[1], item[0], item[3], item[2])\n        res['remark'] = item[4]\n        data.append(res)\n        if res['status'] != '转账成功':\n            error.append([res['payee_account'], res['amount'], res['payee_real_name'], res['remark'], res['status'],\n                          res['out_biz_no']])\n            # except Exception as e:\n            #     pass\n    write(data)  # 写入数据库\n    return error  # 网页返回错误信息\n</code></pre>\n\n<p><strong>3.网页显示失败信息：<br />\n     </strong>这一步没什么好说的了，我是直接使用django的render函数将错误信息渲染完成之后返回了一个新的页面。其实用Ajax接收数据然后js来渲染页面这种做法要好一些。</p>","site":{"data":{}},"excerpt":"","more":"<p>接着上一篇的介绍，这部分将介绍如何读取上传的文件并调用转账接口实现转账功能。<br />\n具体步骤   ===》打开文件  ===》读取每一行的数据 ===》调用支付宝单笔转账接口</p>\n\n<p><strong>1.Excel文件的读取<br />\n     </strong>python读取excel文件需要用到xlrd这个库，这个库的具体用法这里就不说了，主要介绍一下读取excel文件的步骤：<br />\n     1.使用xlrd.open_workbook(path)打开文件<br />\n     2.遍历文件中所有的sheet，并且读取所有行数据</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">for sheet in ExcelFile.sheet_names():\n    data = ExcelFile.sheet_by_name(sheet)\n    i = 0\n    while i &lt; (data.nrows):\n        yield data.row_values(i)\n        i += 1</code></pre>\n\n<p>     为了防止文件过大占有太多内存，没有一次将所有数据都读取出来，而是使用生成器返回一个迭代对象，每次调用这个迭代对象来取出数据。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">f = read_excel('../files/2018.7.30(1).xls')\nfor i in f:\n    print(i)</code></pre>\n\n<p>运行结果：<br /><img alt=\"\" class=\"has\" height=\"87\" src=\"https://img-blog.csdn.net/20180809182420169?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"385\" /></p>\n\n<p><strong>2.调用转账接口：<br />\n     </strong>接口部分我们之前已经说过了，现在只需要将excel中的数据传递进去就能够实现转账功能了，<br />\n     为了不单单只是在后台打印交易信息，对之前的pay方法做一些调整</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">data = &#123;'payee_account': None, 'amount': None, 'payee_real_name': None, 'remark': None, 'order_id': None,\n        'out_biz_no': None, 'pay_date': None, 'status': None&#125;\nif result['code'] == '10000':\n    if result['msg'] == \"Success\":\n        print(payee_account + \"  转账成功\" + \"  交易单号：\" + result[\"out_biz_no\"])\n    data['payee_account'] = payee_account\n    data['amount'] = amount\n    data['payee_real_name'] = payee_real_name\n    data['order_id'] = result['order_id']\n    data['out_biz_no'] = result['out_biz_no']\n    data['pay_date'] = result['pay_date']\n    data['status'] = '转账成功'\n    return data\nelse:\n    print(payee_account, amount, result['sub_msg'], result[\"out_biz_no\"])\n    data['payee_account'] = payee_account\n    data['amount'] = amount\n    data['payee_real_name'] = payee_real_name\n    data['out_biz_no'] = result['out_biz_no']\n    data['status'] = result['sub_msg']\n    # error = [payee_account, amount, payee_real_name, result['sub_msg'], result['out_biz_no']]\n    return data</code></pre>\n\n<p>      方便起见将excel文件读取和转账接口封装到一个函数里面了，现在只需要传递文件路径就能直接转账了，数据库写入就不详细说了。</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def run(path):\n    file = read_excel(path)\n    pay = Payment(*******)\n    data = []\n    error = []\n    for item in file:\n        res = pay.pay(item[1], item[0], item[3], item[2])\n        res['remark'] = item[4]\n        data.append(res)\n        if res['status'] != '转账成功':\n            error.append([res['payee_account'], res['amount'], res['payee_real_name'], res['remark'], res['status'],\n                          res['out_biz_no']])\n            # except Exception as e:\n            #     pass\n    write(data)  # 写入数据库\n    return error  # 网页返回错误信息\n</code></pre>\n\n<p><strong>3.网页显示失败信息：<br />\n     </strong>这一步没什么好说的了，我是直接使用django的render函数将错误信息渲染完成之后返回了一个新的页面。其实用Ajax接收数据然后js来渲染页面这种做法要好一些。</p>"},{"_content":"<p>首先说明一下最终实现的效果：===&gt;用户上传excel文件====&gt;网页端显示读取文件并显示预览效果====&gt;上传文件至服务器，服务器后台开始调用接口自动转账===&gt;所有转账信息存储到数据库中，失败信息返回到网页上。</p>\n\n<p>上一篇已经大致将支付接口实现了，这一篇将介绍如何和Django后台连接起来使用，在项目中使用的是excel文件储存转账信息的，所以我们首先需要了解如何读取Excel文件，然后才是进行转账操作，django则是提供网页服务，接收用户上传excel文件，保存交易信息等等。</p>\n\n<p><strong>1.网页端的预览：<br />\n    </strong> 选择上传文件后需要将文件内容读取并显示出来，方便确认信息是否有误后在上传，这里主要是通过JS读取文件内容，然后再把数据以表格的形式展现出来。这里用到了一个一个xlsx插件</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">//文件读取\n&lt;script src=\"http://oss.sheetjs.com/js-xlsx/xlsx.full.min.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n    /*\n    FileReader共有4种读取方法：\n    1.readAsArrayBuffer(file)：将文件读取为ArrayBuffer。\n    2.readAsBinaryString(file)：将文件读取为二进制字符串\n    3.readAsDataURL(file)：将文件读取为Data URL\n    4.readAsText(file, [encoding])：将文件读取为文本，encoding缺省值为'UTF-8'\n    */\n    var wb;//读取完成的数据\n    var rABS = false; //是否将文件读取为二进制字符串\n\n    function importf(obj) {//导入\n        if (!obj.files) {\n            return;\n        }\n        var f = obj.files[0];\n        var reader = new FileReader();\n        reader.onload = function (e) {\n            var data = e.target.result;\n            if (rABS) {\n                wb = XLSX.read(btoa(fixdata(data)), {//手动转化\n                    type: 'base64'\n                });\n            } else {\n                wb = XLSX.read(data, {\n                    type: 'binary'\n                });\n            }\n            //wb.SheetNames[0]是获取Sheets中第一个Sheet的名字\n            //wb.Sheets[Sheet名]获取第一个Sheet的数据\n            document.getElementById(\"preview\").innerHTML = XLSX.utils.sheet_to_html(wb.Sheets[wb.SheetNames[0]]);\n\n        };\n        if (rABS) {\n            reader.readAsArrayBuffer(f);\n        } else {\n            reader.readAsBinaryString(f);\n        }\n    }\n\n    function fixdata(data) { //文件流转BinaryString\n        var o = \"\",\n            l = 0,\n            w = 10240;\n        for (; l &lt; data.byteLength / w; ++l) o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w, l * w + w)));\n        o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w)));\n        return o;\n    }\n&lt;/script&gt;</code></pre>\n\n<p>HTML部分：</p>\n\n<pre class=\"has\">\n<code class=\"language-html\">&lt;form method=\"post\" action=\"\" id=\"upload_form\" enctype=\"multipart/form-data\"&gt;\n  &lt;div style=\"height: 40px;\"&gt;\n  &lt;input id=\"uploadFile\" type=\"file\" onchange=\"importf(this)\" style=\"display: inline-block;\"name=\"payment\"/&gt;\n   &lt;button id=\"upload\" style=\"height: 32px\"&gt;上传文件&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;div style=\"border: 1px solid #3b8fc5;border-radius: 5px;height: 500px;position: relative;overflow: auto;text-align:center;vertical-align: middle;\"id=\"preview\"&gt;\n     &lt;p style=\"color: #c1c1c1\"&gt;文件预览&lt;/p&gt;\n   &lt;/div&gt;\n&lt;/form&gt;</code></pre>\n\n<p>最终效果：<br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180809171519463?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></p>\n\n<p><strong>2.Excel文件上传和保存：<br />\n    </strong>通过Ajax提交form表单数据到后台，Ajax操作没什么可说的了，需要注意的是form 的enctype属性值，来看一下W3C上面的介绍<br /><img alt=\"\" class=\"has\" height=\"145\" src=\"https://img-blog.csdn.net/20180809173057807?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"824\" /><br /><img alt=\"\" class=\"has\" height=\"219\" src=\"https://img-blog.csdn.net/20180809173011988?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"831\" /><br />\n因此我们在上传文件的时候要用enctype=\"multipart/form-data\"<br /><br />\n前端发送文件了接下来就是后端接收文件了，文件数据会包含在request.FILES里面（注意，只有当request方法为POST并且form 的enctype属性值为multipart/form-data的时候request.FILES才会有数据）<br />\nrequest.FILES中包含下面几个属性：name(文件名)、size(文件大小)、content_type(文件类型)、read()读取整个文件、chunks()返回一个生成器对象</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">file = request.FILES.get('payment', None)\nf = open(file.name, 'wb')\nfor chunck in file.chunks():\n    f.write(chunck)\nf.close()</code></pre>\n\n<p><strong>    </strong>至此文件就保存下来了，文件名就是上传的文件名，路径默认为根路径</p>","source":"_posts/blogs-Django支付宝自动转账功能（一）.md","raw":"<p>首先说明一下最终实现的效果：===&gt;用户上传excel文件====&gt;网页端显示读取文件并显示预览效果====&gt;上传文件至服务器，服务器后台开始调用接口自动转账===&gt;所有转账信息存储到数据库中，失败信息返回到网页上。</p>\n\n<p>上一篇已经大致将支付接口实现了，这一篇将介绍如何和Django后台连接起来使用，在项目中使用的是excel文件储存转账信息的，所以我们首先需要了解如何读取Excel文件，然后才是进行转账操作，django则是提供网页服务，接收用户上传excel文件，保存交易信息等等。</p>\n\n<p><strong>1.网页端的预览：<br />\n    </strong> 选择上传文件后需要将文件内容读取并显示出来，方便确认信息是否有误后在上传，这里主要是通过JS读取文件内容，然后再把数据以表格的形式展现出来。这里用到了一个一个xlsx插件</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">//文件读取\n&lt;script src=\"http://oss.sheetjs.com/js-xlsx/xlsx.full.min.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n    /*\n    FileReader共有4种读取方法：\n    1.readAsArrayBuffer(file)：将文件读取为ArrayBuffer。\n    2.readAsBinaryString(file)：将文件读取为二进制字符串\n    3.readAsDataURL(file)：将文件读取为Data URL\n    4.readAsText(file, [encoding])：将文件读取为文本，encoding缺省值为'UTF-8'\n    */\n    var wb;//读取完成的数据\n    var rABS = false; //是否将文件读取为二进制字符串\n\n    function importf(obj) {//导入\n        if (!obj.files) {\n            return;\n        }\n        var f = obj.files[0];\n        var reader = new FileReader();\n        reader.onload = function (e) {\n            var data = e.target.result;\n            if (rABS) {\n                wb = XLSX.read(btoa(fixdata(data)), {//手动转化\n                    type: 'base64'\n                });\n            } else {\n                wb = XLSX.read(data, {\n                    type: 'binary'\n                });\n            }\n            //wb.SheetNames[0]是获取Sheets中第一个Sheet的名字\n            //wb.Sheets[Sheet名]获取第一个Sheet的数据\n            document.getElementById(\"preview\").innerHTML = XLSX.utils.sheet_to_html(wb.Sheets[wb.SheetNames[0]]);\n\n        };\n        if (rABS) {\n            reader.readAsArrayBuffer(f);\n        } else {\n            reader.readAsBinaryString(f);\n        }\n    }\n\n    function fixdata(data) { //文件流转BinaryString\n        var o = \"\",\n            l = 0,\n            w = 10240;\n        for (; l &lt; data.byteLength / w; ++l) o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w, l * w + w)));\n        o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w)));\n        return o;\n    }\n&lt;/script&gt;</code></pre>\n\n<p>HTML部分：</p>\n\n<pre class=\"has\">\n<code class=\"language-html\">&lt;form method=\"post\" action=\"\" id=\"upload_form\" enctype=\"multipart/form-data\"&gt;\n  &lt;div style=\"height: 40px;\"&gt;\n  &lt;input id=\"uploadFile\" type=\"file\" onchange=\"importf(this)\" style=\"display: inline-block;\"name=\"payment\"/&gt;\n   &lt;button id=\"upload\" style=\"height: 32px\"&gt;上传文件&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;div style=\"border: 1px solid #3b8fc5;border-radius: 5px;height: 500px;position: relative;overflow: auto;text-align:center;vertical-align: middle;\"id=\"preview\"&gt;\n     &lt;p style=\"color: #c1c1c1\"&gt;文件预览&lt;/p&gt;\n   &lt;/div&gt;\n&lt;/form&gt;</code></pre>\n\n<p>最终效果：<br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180809171519463?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></p>\n\n<p><strong>2.Excel文件上传和保存：<br />\n    </strong>通过Ajax提交form表单数据到后台，Ajax操作没什么可说的了，需要注意的是form 的enctype属性值，来看一下W3C上面的介绍<br /><img alt=\"\" class=\"has\" height=\"145\" src=\"https://img-blog.csdn.net/20180809173057807?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"824\" /><br /><img alt=\"\" class=\"has\" height=\"219\" src=\"https://img-blog.csdn.net/20180809173011988?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"831\" /><br />\n因此我们在上传文件的时候要用enctype=\"multipart/form-data\"<br /><br />\n前端发送文件了接下来就是后端接收文件了，文件数据会包含在request.FILES里面（注意，只有当request方法为POST并且form 的enctype属性值为multipart/form-data的时候request.FILES才会有数据）<br />\nrequest.FILES中包含下面几个属性：name(文件名)、size(文件大小)、content_type(文件类型)、read()读取整个文件、chunks()返回一个生成器对象</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">file = request.FILES.get('payment', None)\nf = open(file.name, 'wb')\nfor chunck in file.chunks():\n    f.write(chunck)\nf.close()</code></pre>\n\n<p><strong>    </strong>至此文件就保存下来了，文件名就是上传的文件名，路径默认为根路径</p>","slug":"blogs-Django支付宝自动转账功能（一）","published":1,"date":"2022-03-16T17:09:11.323Z","updated":"2022-03-16T17:09:11.323Z","_id":"cl0v6kese000xyms45ehsaxsm","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>首先说明一下最终实现的效果：===&gt;用户上传excel文件====&gt;网页端显示读取文件并显示预览效果====&gt;上传文件至服务器，服务器后台开始调用接口自动转账===&gt;所有转账信息存储到数据库中，失败信息返回到网页上。</p>\n\n<p>上一篇已经大致将支付接口实现了，这一篇将介绍如何和Django后台连接起来使用，在项目中使用的是excel文件储存转账信息的，所以我们首先需要了解如何读取Excel文件，然后才是进行转账操作，django则是提供网页服务，接收用户上传excel文件，保存交易信息等等。</p>\n\n<p><strong>1.网页端的预览：<br />\n    </strong> 选择上传文件后需要将文件内容读取并显示出来，方便确认信息是否有误后在上传，这里主要是通过JS读取文件内容，然后再把数据以表格的形式展现出来。这里用到了一个一个xlsx插件</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">//文件读取\n&lt;script src=\"http://oss.sheetjs.com/js-xlsx/xlsx.full.min.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n    /*\n    FileReader共有4种读取方法：\n    1.readAsArrayBuffer(file)：将文件读取为ArrayBuffer。\n    2.readAsBinaryString(file)：将文件读取为二进制字符串\n    3.readAsDataURL(file)：将文件读取为Data URL\n    4.readAsText(file, [encoding])：将文件读取为文本，encoding缺省值为'UTF-8'\n    */\n    var wb;//读取完成的数据\n    var rABS = false; //是否将文件读取为二进制字符串\n\n    function importf(obj) &#123;//导入\n        if (!obj.files) &#123;\n            return;\n        &#125;\n        var f = obj.files[0];\n        var reader = new FileReader();\n        reader.onload = function (e) &#123;\n            var data = e.target.result;\n            if (rABS) &#123;\n                wb = XLSX.read(btoa(fixdata(data)), &#123;//手动转化\n                    type: 'base64'\n                &#125;);\n            &#125; else &#123;\n                wb = XLSX.read(data, &#123;\n                    type: 'binary'\n                &#125;);\n            &#125;\n            //wb.SheetNames[0]是获取Sheets中第一个Sheet的名字\n            //wb.Sheets[Sheet名]获取第一个Sheet的数据\n            document.getElementById(\"preview\").innerHTML = XLSX.utils.sheet_to_html(wb.Sheets[wb.SheetNames[0]]);\n\n        &#125;;\n        if (rABS) &#123;\n            reader.readAsArrayBuffer(f);\n        &#125; else &#123;\n            reader.readAsBinaryString(f);\n        &#125;\n    &#125;\n\n    function fixdata(data) &#123; //文件流转BinaryString\n        var o = \"\",\n            l = 0,\n            w = 10240;\n        for (; l &lt; data.byteLength / w; ++l) o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w, l * w + w)));\n        o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w)));\n        return o;\n    &#125;\n&lt;/script&gt;</code></pre>\n\n<p>HTML部分：</p>\n\n<pre class=\"has\">\n<code class=\"language-html\">&lt;form method=\"post\" action=\"\" id=\"upload_form\" enctype=\"multipart/form-data\"&gt;\n  &lt;div style=\"height: 40px;\"&gt;\n  &lt;input id=\"uploadFile\" type=\"file\" onchange=\"importf(this)\" style=\"display: inline-block;\"name=\"payment\"/&gt;\n   &lt;button id=\"upload\" style=\"height: 32px\"&gt;上传文件&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;div style=\"border: 1px solid #3b8fc5;border-radius: 5px;height: 500px;position: relative;overflow: auto;text-align:center;vertical-align: middle;\"id=\"preview\"&gt;\n     &lt;p style=\"color: #c1c1c1\"&gt;文件预览&lt;/p&gt;\n   &lt;/div&gt;\n&lt;/form&gt;</code></pre>\n\n<p>最终效果：<br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180809171519463?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></p>\n\n<p><strong>2.Excel文件上传和保存：<br />\n    </strong>通过Ajax提交form表单数据到后台，Ajax操作没什么可说的了，需要注意的是form 的enctype属性值，来看一下W3C上面的介绍<br /><img alt=\"\" class=\"has\" height=\"145\" src=\"https://img-blog.csdn.net/20180809173057807?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"824\" /><br /><img alt=\"\" class=\"has\" height=\"219\" src=\"https://img-blog.csdn.net/20180809173011988?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"831\" /><br />\n因此我们在上传文件的时候要用enctype=\"multipart/form-data\"<br /><br />\n前端发送文件了接下来就是后端接收文件了，文件数据会包含在request.FILES里面（注意，只有当request方法为POST并且form 的enctype属性值为multipart/form-data的时候request.FILES才会有数据）<br />\nrequest.FILES中包含下面几个属性：name(文件名)、size(文件大小)、content_type(文件类型)、read()读取整个文件、chunks()返回一个生成器对象</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">file = request.FILES.get('payment', None)\nf = open(file.name, 'wb')\nfor chunck in file.chunks():\n    f.write(chunck)\nf.close()</code></pre>\n\n<p><strong>    </strong>至此文件就保存下来了，文件名就是上传的文件名，路径默认为根路径</p>","site":{"data":{}},"excerpt":"","more":"<p>首先说明一下最终实现的效果：===&gt;用户上传excel文件====&gt;网页端显示读取文件并显示预览效果====&gt;上传文件至服务器，服务器后台开始调用接口自动转账===&gt;所有转账信息存储到数据库中，失败信息返回到网页上。</p>\n\n<p>上一篇已经大致将支付接口实现了，这一篇将介绍如何和Django后台连接起来使用，在项目中使用的是excel文件储存转账信息的，所以我们首先需要了解如何读取Excel文件，然后才是进行转账操作，django则是提供网页服务，接收用户上传excel文件，保存交易信息等等。</p>\n\n<p><strong>1.网页端的预览：<br />\n    </strong> 选择上传文件后需要将文件内容读取并显示出来，方便确认信息是否有误后在上传，这里主要是通过JS读取文件内容，然后再把数据以表格的形式展现出来。这里用到了一个一个xlsx插件</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">//文件读取\n&lt;script src=\"http://oss.sheetjs.com/js-xlsx/xlsx.full.min.js\"&gt;&lt;/script&gt;\n&lt;script&gt;\n    /*\n    FileReader共有4种读取方法：\n    1.readAsArrayBuffer(file)：将文件读取为ArrayBuffer。\n    2.readAsBinaryString(file)：将文件读取为二进制字符串\n    3.readAsDataURL(file)：将文件读取为Data URL\n    4.readAsText(file, [encoding])：将文件读取为文本，encoding缺省值为'UTF-8'\n    */\n    var wb;//读取完成的数据\n    var rABS = false; //是否将文件读取为二进制字符串\n\n    function importf(obj) &#123;//导入\n        if (!obj.files) &#123;\n            return;\n        &#125;\n        var f = obj.files[0];\n        var reader = new FileReader();\n        reader.onload = function (e) &#123;\n            var data = e.target.result;\n            if (rABS) &#123;\n                wb = XLSX.read(btoa(fixdata(data)), &#123;//手动转化\n                    type: 'base64'\n                &#125;);\n            &#125; else &#123;\n                wb = XLSX.read(data, &#123;\n                    type: 'binary'\n                &#125;);\n            &#125;\n            //wb.SheetNames[0]是获取Sheets中第一个Sheet的名字\n            //wb.Sheets[Sheet名]获取第一个Sheet的数据\n            document.getElementById(\"preview\").innerHTML = XLSX.utils.sheet_to_html(wb.Sheets[wb.SheetNames[0]]);\n\n        &#125;;\n        if (rABS) &#123;\n            reader.readAsArrayBuffer(f);\n        &#125; else &#123;\n            reader.readAsBinaryString(f);\n        &#125;\n    &#125;\n\n    function fixdata(data) &#123; //文件流转BinaryString\n        var o = \"\",\n            l = 0,\n            w = 10240;\n        for (; l &lt; data.byteLength / w; ++l) o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w, l * w + w)));\n        o += String.fromCharCode.apply(null, new Uint8Array(data.slice(l * w)));\n        return o;\n    &#125;\n&lt;/script&gt;</code></pre>\n\n<p>HTML部分：</p>\n\n<pre class=\"has\">\n<code class=\"language-html\">&lt;form method=\"post\" action=\"\" id=\"upload_form\" enctype=\"multipart/form-data\"&gt;\n  &lt;div style=\"height: 40px;\"&gt;\n  &lt;input id=\"uploadFile\" type=\"file\" onchange=\"importf(this)\" style=\"display: inline-block;\"name=\"payment\"/&gt;\n   &lt;button id=\"upload\" style=\"height: 32px\"&gt;上传文件&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;div style=\"border: 1px solid #3b8fc5;border-radius: 5px;height: 500px;position: relative;overflow: auto;text-align:center;vertical-align: middle;\"id=\"preview\"&gt;\n     &lt;p style=\"color: #c1c1c1\"&gt;文件预览&lt;/p&gt;\n   &lt;/div&gt;\n&lt;/form&gt;</code></pre>\n\n<p>最终效果：<br /><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180809171519463?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></p>\n\n<p><strong>2.Excel文件上传和保存：<br />\n    </strong>通过Ajax提交form表单数据到后台，Ajax操作没什么可说的了，需要注意的是form 的enctype属性值，来看一下W3C上面的介绍<br /><img alt=\"\" class=\"has\" height=\"145\" src=\"https://img-blog.csdn.net/20180809173057807?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"824\" /><br /><img alt=\"\" class=\"has\" height=\"219\" src=\"https://img-blog.csdn.net/20180809173011988?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"831\" /><br />\n因此我们在上传文件的时候要用enctype=\"multipart/form-data\"<br /><br />\n前端发送文件了接下来就是后端接收文件了，文件数据会包含在request.FILES里面（注意，只有当request方法为POST并且form 的enctype属性值为multipart/form-data的时候request.FILES才会有数据）<br />\nrequest.FILES中包含下面几个属性：name(文件名)、size(文件大小)、content_type(文件类型)、read()读取整个文件、chunks()返回一个生成器对象</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">file = request.FILES.get('payment', None)\nf = open(file.name, 'wb')\nfor chunck in file.chunks():\n    f.write(chunck)\nf.close()</code></pre>\n\n<p><strong>    </strong>至此文件就保存下来了，文件名就是上传的文件名，路径默认为根路径</p>"},{"_content":"<p>首先需要在APP目录下创建一个templatetags目录</p>\n\n<p>然后在这个目录下新建一个任意名的.py文件 如 test.py</p>\n\n<p>创建一个template对象register</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django import template\nfrom django.utils.safestring import mark_safe\n\nregister =template.Library()</code></pre>\n\n<p>下面在这个文件中我们就可以写自定义函数了</p>\n\n<p>有两种方式</p>\n\n<p>一种是simple_tag,这种会限制参数的个数，但是不能作为IF的条件来使用</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">@register.simple_tag\ndef add(a,b):\n    return a+b</code></pre>\n\n<p>一种是filter，这个最多只能传递两个参数，可作为if条件使用</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">@register.filter\ndef subtract(a,b):\n    return a-b</code></pre>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p>这时候就可以在模板文件中使用这个函数了</p>\n\n<p>首先在开头位置导入test.py文件</p>\n\n<p>simple_tag直接使用%来调用函数，如果函数需要传参数，需要在函数后直接添加即可（用空格隔开）</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">{% load test %}\n\n{% add 2 3 %}\n\n{{ 1|subtract:2 }}</code></pre>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180329183633434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" /></p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p>要注意的是app目录下的templatetags名不能更改 register也不能更改</p>\n\n<p>还需要在settings里面注册这个app</p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>","source":"_posts/blogs-Django的template自定义函数的创建和使用.md","raw":"<p>首先需要在APP目录下创建一个templatetags目录</p>\n\n<p>然后在这个目录下新建一个任意名的.py文件 如 test.py</p>\n\n<p>创建一个template对象register</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django import template\nfrom django.utils.safestring import mark_safe\n\nregister =template.Library()</code></pre>\n\n<p>下面在这个文件中我们就可以写自定义函数了</p>\n\n<p>有两种方式</p>\n\n<p>一种是simple_tag,这种会限制参数的个数，但是不能作为IF的条件来使用</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">@register.simple_tag\ndef add(a,b):\n    return a+b</code></pre>\n\n<p>一种是filter，这个最多只能传递两个参数，可作为if条件使用</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">@register.filter\ndef subtract(a,b):\n    return a-b</code></pre>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p>这时候就可以在模板文件中使用这个函数了</p>\n\n<p>首先在开头位置导入test.py文件</p>\n\n<p>simple_tag直接使用%来调用函数，如果函数需要传参数，需要在函数后直接添加即可（用空格隔开）</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">{% load test %}\n\n{% add 2 3 %}\n\n{{ 1|subtract:2 }}</code></pre>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180329183633434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" /></p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p>要注意的是app目录下的templatetags名不能更改 register也不能更改</p>\n\n<p>还需要在settings里面注册这个app</p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>","slug":"blogs-Django的template自定义函数的创建和使用","published":1,"date":"2022-03-16T17:09:24.549Z","updated":"2022-03-16T17:09:24.549Z","_id":"cl0v6kese000yyms4153xabse","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>首先需要在APP目录下创建一个templatetags目录</p>\n\n<p>然后在这个目录下新建一个任意名的.py文件 如 test.py</p>\n\n<p>创建一个template对象register</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django import template\nfrom django.utils.safestring import mark_safe\n\nregister =template.Library()</code></pre>\n\n<p>下面在这个文件中我们就可以写自定义函数了</p>\n\n<p>有两种方式</p>\n\n<p>一种是simple_tag,这种会限制参数的个数，但是不能作为IF的条件来使用</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">@register.simple_tag\ndef add(a,b):\n    return a+b</code></pre>\n\n<p>一种是filter，这个最多只能传递两个参数，可作为if条件使用</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">@register.filter\ndef subtract(a,b):\n    return a-b</code></pre>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p>这时候就可以在模板文件中使用这个函数了</p>\n\n<p>首先在开头位置导入test.py文件</p>\n\n<p>simple_tag直接使用%来调用函数，如果函数需要传参数，需要在函数后直接添加即可（用空格隔开）</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">&#123;% load test %&#125;\n\n&#123;% add 2 3 %&#125;\n\n&#123;&#123; 1|subtract:2 &#125;&#125;</code></pre>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180329183633434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" /></p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p>要注意的是app目录下的templatetags名不能更改 register也不能更改</p>\n\n<p>还需要在settings里面注册这个app</p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<p>首先需要在APP目录下创建一个templatetags目录</p>\n\n<p>然后在这个目录下新建一个任意名的.py文件 如 test.py</p>\n\n<p>创建一个template对象register</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django import template\nfrom django.utils.safestring import mark_safe\n\nregister =template.Library()</code></pre>\n\n<p>下面在这个文件中我们就可以写自定义函数了</p>\n\n<p>有两种方式</p>\n\n<p>一种是simple_tag,这种会限制参数的个数，但是不能作为IF的条件来使用</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">@register.simple_tag\ndef add(a,b):\n    return a+b</code></pre>\n\n<p>一种是filter，这个最多只能传递两个参数，可作为if条件使用</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">@register.filter\ndef subtract(a,b):\n    return a-b</code></pre>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p>这时候就可以在模板文件中使用这个函数了</p>\n\n<p>首先在开头位置导入test.py文件</p>\n\n<p>simple_tag直接使用%来调用函数，如果函数需要传参数，需要在函数后直接添加即可（用空格隔开）</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">&#123;% load test %&#125;\n\n&#123;% add 2 3 %&#125;\n\n&#123;&#123; 1|subtract:2 &#125;&#125;</code></pre>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180329183633434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" /></p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p>要注意的是app目录下的templatetags名不能更改 register也不能更改</p>\n\n<p>还需要在settings里面注册这个app</p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>\n\n<p> </p>"},{"_content":"<h3>配置MySQL连接</h3>\n\n<p>setting.py中的数据库配置：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">DATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'oa',\n        'USER': 'root',\n        'PASSWORD': '123456',\n        'HOST': '127.0.0.1',\n        'PORT': '3306',\n    }\n}</code></pre>\n\n<p>然后需要在项目__init__.py中添加将，pymysql作为默认的驱动库</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import pymysql\npymysql.install_as_MySQLdb()</code></pre>\n\n<h3>从已有的数据库中导入结构：</h3>\n\n<p>命令行中输入python manage.py inspectdb &gt; appname/models.py</p>\n\n<h3>允许跨域请求：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">\n\nINSTALLED_APPS = [\n    \n    'corsheaders',\n    \n]\n\nMIDDLEWARE = [\n    \n    'corsheaders.middleware.CorsMiddleware',\n]\nCORS_ALLOW_CREDENTIALS = True\nCORS_ORIGIN_ALLOW_ALL = True\nCORS_ORIGIN_WHITELIST = (\n   \"*\"\n)\nCORS_ALLOW_METHODS = (\n    'DELETE',\n    'GET',\n    'OPTIONS',\n    'PATCH',\n    'POST',\n    'PUT',\n    'VIEW',\n)\n\nCORS_ALLOW_HEADERS = (\n    'XMLHttpRequest',\n    'X_FILENAME',\n    'accept-encoding',\n    'authorization',\n    'content-type',\n    'dnt',\n    'origin',\n    'user-agent',\n    'x-csrftoken',\n    'x-requested-with',\n    'Pragma',\n)\n</code></pre>\n\n<h3>设置中国时区：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">LANGUAGE_CODE = 'zh-Hans'\n\nTIME_ZONE = 'Asia/Shanghai'\n\nUSE_I18N = True\n\nUSE_L10N = True\n\nUSE_TZ = False</code></pre>\n\n<p> </p>","source":"_posts/blogs-Django常用配置.md","raw":"<h3>配置MySQL连接</h3>\n\n<p>setting.py中的数据库配置：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">DATABASES = {\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'oa',\n        'USER': 'root',\n        'PASSWORD': '123456',\n        'HOST': '127.0.0.1',\n        'PORT': '3306',\n    }\n}</code></pre>\n\n<p>然后需要在项目__init__.py中添加将，pymysql作为默认的驱动库</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import pymysql\npymysql.install_as_MySQLdb()</code></pre>\n\n<h3>从已有的数据库中导入结构：</h3>\n\n<p>命令行中输入python manage.py inspectdb &gt; appname/models.py</p>\n\n<h3>允许跨域请求：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">\n\nINSTALLED_APPS = [\n    \n    'corsheaders',\n    \n]\n\nMIDDLEWARE = [\n    \n    'corsheaders.middleware.CorsMiddleware',\n]\nCORS_ALLOW_CREDENTIALS = True\nCORS_ORIGIN_ALLOW_ALL = True\nCORS_ORIGIN_WHITELIST = (\n   \"*\"\n)\nCORS_ALLOW_METHODS = (\n    'DELETE',\n    'GET',\n    'OPTIONS',\n    'PATCH',\n    'POST',\n    'PUT',\n    'VIEW',\n)\n\nCORS_ALLOW_HEADERS = (\n    'XMLHttpRequest',\n    'X_FILENAME',\n    'accept-encoding',\n    'authorization',\n    'content-type',\n    'dnt',\n    'origin',\n    'user-agent',\n    'x-csrftoken',\n    'x-requested-with',\n    'Pragma',\n)\n</code></pre>\n\n<h3>设置中国时区：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">LANGUAGE_CODE = 'zh-Hans'\n\nTIME_ZONE = 'Asia/Shanghai'\n\nUSE_I18N = True\n\nUSE_L10N = True\n\nUSE_TZ = False</code></pre>\n\n<p> </p>","slug":"blogs-Django常用配置","published":1,"date":"2022-03-16T17:09:01.577Z","updated":"2022-03-16T17:09:01.577Z","_id":"cl0v6kesf000zyms470v9c9ev","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>配置MySQL连接</h3>\n\n<p>setting.py中的数据库配置：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">DATABASES = &#123;\n    'default': &#123;\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'oa',\n        'USER': 'root',\n        'PASSWORD': '123456',\n        'HOST': '127.0.0.1',\n        'PORT': '3306',\n    &#125;\n&#125;</code></pre>\n\n<p>然后需要在项目__init__.py中添加将，pymysql作为默认的驱动库</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import pymysql\npymysql.install_as_MySQLdb()</code></pre>\n\n<h3>从已有的数据库中导入结构：</h3>\n\n<p>命令行中输入python manage.py inspectdb &gt; appname/models.py</p>\n\n<h3>允许跨域请求：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">\n\nINSTALLED_APPS = [\n    \n    'corsheaders',\n    \n]\n\nMIDDLEWARE = [\n    \n    'corsheaders.middleware.CorsMiddleware',\n]\nCORS_ALLOW_CREDENTIALS = True\nCORS_ORIGIN_ALLOW_ALL = True\nCORS_ORIGIN_WHITELIST = (\n   \"*\"\n)\nCORS_ALLOW_METHODS = (\n    'DELETE',\n    'GET',\n    'OPTIONS',\n    'PATCH',\n    'POST',\n    'PUT',\n    'VIEW',\n)\n\nCORS_ALLOW_HEADERS = (\n    'XMLHttpRequest',\n    'X_FILENAME',\n    'accept-encoding',\n    'authorization',\n    'content-type',\n    'dnt',\n    'origin',\n    'user-agent',\n    'x-csrftoken',\n    'x-requested-with',\n    'Pragma',\n)\n</code></pre>\n\n<h3>设置中国时区：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">LANGUAGE_CODE = 'zh-Hans'\n\nTIME_ZONE = 'Asia/Shanghai'\n\nUSE_I18N = True\n\nUSE_L10N = True\n\nUSE_TZ = False</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<h3>配置MySQL连接</h3>\n\n<p>setting.py中的数据库配置：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">DATABASES = &#123;\n    'default': &#123;\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'oa',\n        'USER': 'root',\n        'PASSWORD': '123456',\n        'HOST': '127.0.0.1',\n        'PORT': '3306',\n    &#125;\n&#125;</code></pre>\n\n<p>然后需要在项目__init__.py中添加将，pymysql作为默认的驱动库</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import pymysql\npymysql.install_as_MySQLdb()</code></pre>\n\n<h3>从已有的数据库中导入结构：</h3>\n\n<p>命令行中输入python manage.py inspectdb &gt; appname/models.py</p>\n\n<h3>允许跨域请求：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">\n\nINSTALLED_APPS = [\n    \n    'corsheaders',\n    \n]\n\nMIDDLEWARE = [\n    \n    'corsheaders.middleware.CorsMiddleware',\n]\nCORS_ALLOW_CREDENTIALS = True\nCORS_ORIGIN_ALLOW_ALL = True\nCORS_ORIGIN_WHITELIST = (\n   \"*\"\n)\nCORS_ALLOW_METHODS = (\n    'DELETE',\n    'GET',\n    'OPTIONS',\n    'PATCH',\n    'POST',\n    'PUT',\n    'VIEW',\n)\n\nCORS_ALLOW_HEADERS = (\n    'XMLHttpRequest',\n    'X_FILENAME',\n    'accept-encoding',\n    'authorization',\n    'content-type',\n    'dnt',\n    'origin',\n    'user-agent',\n    'x-csrftoken',\n    'x-requested-with',\n    'Pragma',\n)\n</code></pre>\n\n<h3>设置中国时区：</h3>\n\n<pre class=\"has\">\n<code class=\"language-python\">LANGUAGE_CODE = 'zh-Hans'\n\nTIME_ZONE = 'Asia/Shanghai'\n\nUSE_I18N = True\n\nUSE_L10N = True\n\nUSE_TZ = False</code></pre>\n\n<p> </p>"},{"_content":"<p>简述：利用xlwt和django将table内的数据转换为excel文件下载到本地保存</p>\n\n<h3>生成Excel文件：</h3>\n\n<p>      使用了 xlwt 库，xlwt库可以将数据和格式信息写入到Excel文件中，具体步骤如下<br />\n      1：创建Excel文件首先需要实例化 Workbook 对象<br />\n          class   <code>xlwt.Workbook.</code><code>Workbook(</code>encoding ='ascii'，style_compression = 0 )<br />\n          有两个参数 encoding→文件编码格式    style_compression → 是否压缩 ，一般情况下使用默认参数即可。<br />\n      2：通过Workbook的add_sheet方法创建工作表<br />\n         add_sheet (sheetname, cell_overwrite_ok=False)<br />\n         sheetname→工作表名称   cell_overwrite_ok 重复写入同一个单元格是否覆盖原有内容，通过源码中发现当我们调用这个  方法的时候实际上得到的返回结果为一个Worksheet实例化对象</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    def add_sheet(self, sheetname, cell_overwrite_ok=False):\n        \"\"\"\n        This method is used to create Worksheets in a Workbook.\n\n        :param sheetname:\n\n          The name to use for this sheet, as it will appear in the\n          tabs at the bottom of the Excel application.\n\n        :param cell_overwrite_ok:\n\n          If ``True``, cells in the added worksheet will not raise an\n          exception if written to more than once.\n\n        :return:\n\n          The :class:`~xlwt.Worksheet.Worksheet` that was added.\n\n        \"\"\"\n        from . import Utils\n        from .Worksheet import Worksheet\n        if not isinstance(sheetname, unicode_type):\n            sheetname = sheetname.decode(self.encoding)\n        if not Utils.valid_sheet_name(sheetname):\n            raise Exception(\"invalid worksheet name %r\" % sheetname)\n        lower_name = sheetname.lower()\n        if lower_name in self.__worksheet_idx_from_name:\n            raise Exception(\"duplicate worksheet name %r\" % sheetname)\n        self.__worksheet_idx_from_name[lower_name] = len(self.__worksheets)\n        self.__worksheets.append(Worksheet(sheetname, self, cell_overwrite_ok))\n        return self.__worksheets[-1]</code></pre>\n\n<p>     3：往单元格里面写入数据<br />\n            通过Worksheet 的write方法写入数据<code>write</code><span style=\"color:#555555;\">（</span>r，c，label =''，style = &lt;xlwt.Style.XFStyle object&gt; <span style=\"color:#555555;\">）<br />\n            r 、c参数为单元格的行列数  label需要写入的数据  <br />\n            style指定单元格的内容格式 通过</span><code>xlwt.Style.easyxf()方法创建格式对象，包含字体、大小、颜色等<br />\n  4: 保存<br />\n    使用Workbook中的save方法保存，save方法提供两种保存方式：1.写入到本地磁盘  2.具有</code>write方法的流对象</p>\n\n<h3>Excel文件下载</h3>\n\n<p>Django提供有自带的文件下载功能，直接导入引用就可以了</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django.http import FileResponse\nfile = open(name, 'rb')\nresponse = FileResponse(file)\nresponse['Content-Type'] = 'application/octet-stream'\nresponse['Content-Disposition'] = 'attachment;filename=' + datetime.now().strftime(\"%Y-%m-%d\") + name\nreturn response</code></pre>\n\n<p>示例</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import xlwt\n\n\ndef write(data, name):\n    wbx = xlwt.Workbook()\n    sheet = wbx.add_sheet('Sheet1', cell_overwrite_ok=True)\n    for row, i in enumerate(data):\n        col = 0\n        for j in i:\n            sheet.write(row, col, i[j])\n            col += 1\n    wbx.save(name)</code></pre>\n\n<p> </p>","source":"_posts/blogs-Excel文件的创建和下载.md","raw":"<p>简述：利用xlwt和django将table内的数据转换为excel文件下载到本地保存</p>\n\n<h3>生成Excel文件：</h3>\n\n<p>      使用了 xlwt 库，xlwt库可以将数据和格式信息写入到Excel文件中，具体步骤如下<br />\n      1：创建Excel文件首先需要实例化 Workbook 对象<br />\n          class   <code>xlwt.Workbook.</code><code>Workbook(</code>encoding ='ascii'，style_compression = 0 )<br />\n          有两个参数 encoding→文件编码格式    style_compression → 是否压缩 ，一般情况下使用默认参数即可。<br />\n      2：通过Workbook的add_sheet方法创建工作表<br />\n         add_sheet (sheetname, cell_overwrite_ok=False)<br />\n         sheetname→工作表名称   cell_overwrite_ok 重复写入同一个单元格是否覆盖原有内容，通过源码中发现当我们调用这个  方法的时候实际上得到的返回结果为一个Worksheet实例化对象</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    def add_sheet(self, sheetname, cell_overwrite_ok=False):\n        \"\"\"\n        This method is used to create Worksheets in a Workbook.\n\n        :param sheetname:\n\n          The name to use for this sheet, as it will appear in the\n          tabs at the bottom of the Excel application.\n\n        :param cell_overwrite_ok:\n\n          If ``True``, cells in the added worksheet will not raise an\n          exception if written to more than once.\n\n        :return:\n\n          The :class:`~xlwt.Worksheet.Worksheet` that was added.\n\n        \"\"\"\n        from . import Utils\n        from .Worksheet import Worksheet\n        if not isinstance(sheetname, unicode_type):\n            sheetname = sheetname.decode(self.encoding)\n        if not Utils.valid_sheet_name(sheetname):\n            raise Exception(\"invalid worksheet name %r\" % sheetname)\n        lower_name = sheetname.lower()\n        if lower_name in self.__worksheet_idx_from_name:\n            raise Exception(\"duplicate worksheet name %r\" % sheetname)\n        self.__worksheet_idx_from_name[lower_name] = len(self.__worksheets)\n        self.__worksheets.append(Worksheet(sheetname, self, cell_overwrite_ok))\n        return self.__worksheets[-1]</code></pre>\n\n<p>     3：往单元格里面写入数据<br />\n            通过Worksheet 的write方法写入数据<code>write</code><span style=\"color:#555555;\">（</span>r，c，label =''，style = &lt;xlwt.Style.XFStyle object&gt; <span style=\"color:#555555;\">）<br />\n            r 、c参数为单元格的行列数  label需要写入的数据  <br />\n            style指定单元格的内容格式 通过</span><code>xlwt.Style.easyxf()方法创建格式对象，包含字体、大小、颜色等<br />\n  4: 保存<br />\n    使用Workbook中的save方法保存，save方法提供两种保存方式：1.写入到本地磁盘  2.具有</code>write方法的流对象</p>\n\n<h3>Excel文件下载</h3>\n\n<p>Django提供有自带的文件下载功能，直接导入引用就可以了</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django.http import FileResponse\nfile = open(name, 'rb')\nresponse = FileResponse(file)\nresponse['Content-Type'] = 'application/octet-stream'\nresponse['Content-Disposition'] = 'attachment;filename=' + datetime.now().strftime(\"%Y-%m-%d\") + name\nreturn response</code></pre>\n\n<p>示例</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import xlwt\n\n\ndef write(data, name):\n    wbx = xlwt.Workbook()\n    sheet = wbx.add_sheet('Sheet1', cell_overwrite_ok=True)\n    for row, i in enumerate(data):\n        col = 0\n        for j in i:\n            sheet.write(row, col, i[j])\n            col += 1\n    wbx.save(name)</code></pre>\n\n<p> </p>","slug":"blogs-Excel文件的创建和下载","published":1,"date":"2022-03-16T17:09:06.557Z","updated":"2022-03-16T17:09:06.557Z","_id":"cl0v6kesh0010yms4hlfmfmc5","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>简述：利用xlwt和django将table内的数据转换为excel文件下载到本地保存</p>\n\n<h3>生成Excel文件：</h3>\n\n<p>      使用了 xlwt 库，xlwt库可以将数据和格式信息写入到Excel文件中，具体步骤如下<br />\n      1：创建Excel文件首先需要实例化 Workbook 对象<br />\n          class   <code>xlwt.Workbook.</code><code>Workbook(</code>encoding ='ascii'，style_compression = 0 )<br />\n          有两个参数 encoding→文件编码格式    style_compression → 是否压缩 ，一般情况下使用默认参数即可。<br />\n      2：通过Workbook的add_sheet方法创建工作表<br />\n         add_sheet (sheetname, cell_overwrite_ok=False)<br />\n         sheetname→工作表名称   cell_overwrite_ok 重复写入同一个单元格是否覆盖原有内容，通过源码中发现当我们调用这个  方法的时候实际上得到的返回结果为一个Worksheet实例化对象</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    def add_sheet(self, sheetname, cell_overwrite_ok=False):\n        \"\"\"\n        This method is used to create Worksheets in a Workbook.\n\n        :param sheetname:\n\n          The name to use for this sheet, as it will appear in the\n          tabs at the bottom of the Excel application.\n\n        :param cell_overwrite_ok:\n\n          If ``True``, cells in the added worksheet will not raise an\n          exception if written to more than once.\n\n        :return:\n\n          The :class:`~xlwt.Worksheet.Worksheet` that was added.\n\n        \"\"\"\n        from . import Utils\n        from .Worksheet import Worksheet\n        if not isinstance(sheetname, unicode_type):\n            sheetname = sheetname.decode(self.encoding)\n        if not Utils.valid_sheet_name(sheetname):\n            raise Exception(\"invalid worksheet name %r\" % sheetname)\n        lower_name = sheetname.lower()\n        if lower_name in self.__worksheet_idx_from_name:\n            raise Exception(\"duplicate worksheet name %r\" % sheetname)\n        self.__worksheet_idx_from_name[lower_name] = len(self.__worksheets)\n        self.__worksheets.append(Worksheet(sheetname, self, cell_overwrite_ok))\n        return self.__worksheets[-1]</code></pre>\n\n<p>     3：往单元格里面写入数据<br />\n            通过Worksheet 的write方法写入数据<code>write</code><span style=\"color:#555555;\">（</span>r，c，label =''，style = &lt;xlwt.Style.XFStyle object&gt; <span style=\"color:#555555;\">）<br />\n            r 、c参数为单元格的行列数  label需要写入的数据  <br />\n            style指定单元格的内容格式 通过</span><code>xlwt.Style.easyxf()方法创建格式对象，包含字体、大小、颜色等<br />\n  4: 保存<br />\n    使用Workbook中的save方法保存，save方法提供两种保存方式：1.写入到本地磁盘  2.具有</code>write方法的流对象</p>\n\n<h3>Excel文件下载</h3>\n\n<p>Django提供有自带的文件下载功能，直接导入引用就可以了</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django.http import FileResponse\nfile = open(name, 'rb')\nresponse = FileResponse(file)\nresponse['Content-Type'] = 'application/octet-stream'\nresponse['Content-Disposition'] = 'attachment;filename=' + datetime.now().strftime(\"%Y-%m-%d\") + name\nreturn response</code></pre>\n\n<p>示例</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import xlwt\n\n\ndef write(data, name):\n    wbx = xlwt.Workbook()\n    sheet = wbx.add_sheet('Sheet1', cell_overwrite_ok=True)\n    for row, i in enumerate(data):\n        col = 0\n        for j in i:\n            sheet.write(row, col, i[j])\n            col += 1\n    wbx.save(name)</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<p>简述：利用xlwt和django将table内的数据转换为excel文件下载到本地保存</p>\n\n<h3>生成Excel文件：</h3>\n\n<p>      使用了 xlwt 库，xlwt库可以将数据和格式信息写入到Excel文件中，具体步骤如下<br />\n      1：创建Excel文件首先需要实例化 Workbook 对象<br />\n          class   <code>xlwt.Workbook.</code><code>Workbook(</code>encoding ='ascii'，style_compression = 0 )<br />\n          有两个参数 encoding→文件编码格式    style_compression → 是否压缩 ，一般情况下使用默认参数即可。<br />\n      2：通过Workbook的add_sheet方法创建工作表<br />\n         add_sheet (sheetname, cell_overwrite_ok=False)<br />\n         sheetname→工作表名称   cell_overwrite_ok 重复写入同一个单元格是否覆盖原有内容，通过源码中发现当我们调用这个  方法的时候实际上得到的返回结果为一个Worksheet实例化对象</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    def add_sheet(self, sheetname, cell_overwrite_ok=False):\n        \"\"\"\n        This method is used to create Worksheets in a Workbook.\n\n        :param sheetname:\n\n          The name to use for this sheet, as it will appear in the\n          tabs at the bottom of the Excel application.\n\n        :param cell_overwrite_ok:\n\n          If ``True``, cells in the added worksheet will not raise an\n          exception if written to more than once.\n\n        :return:\n\n          The :class:`~xlwt.Worksheet.Worksheet` that was added.\n\n        \"\"\"\n        from . import Utils\n        from .Worksheet import Worksheet\n        if not isinstance(sheetname, unicode_type):\n            sheetname = sheetname.decode(self.encoding)\n        if not Utils.valid_sheet_name(sheetname):\n            raise Exception(\"invalid worksheet name %r\" % sheetname)\n        lower_name = sheetname.lower()\n        if lower_name in self.__worksheet_idx_from_name:\n            raise Exception(\"duplicate worksheet name %r\" % sheetname)\n        self.__worksheet_idx_from_name[lower_name] = len(self.__worksheets)\n        self.__worksheets.append(Worksheet(sheetname, self, cell_overwrite_ok))\n        return self.__worksheets[-1]</code></pre>\n\n<p>     3：往单元格里面写入数据<br />\n            通过Worksheet 的write方法写入数据<code>write</code><span style=\"color:#555555;\">（</span>r，c，label =''，style = &lt;xlwt.Style.XFStyle object&gt; <span style=\"color:#555555;\">）<br />\n            r 、c参数为单元格的行列数  label需要写入的数据  <br />\n            style指定单元格的内容格式 通过</span><code>xlwt.Style.easyxf()方法创建格式对象，包含字体、大小、颜色等<br />\n  4: 保存<br />\n    使用Workbook中的save方法保存，save方法提供两种保存方式：1.写入到本地磁盘  2.具有</code>write方法的流对象</p>\n\n<h3>Excel文件下载</h3>\n\n<p>Django提供有自带的文件下载功能，直接导入引用就可以了</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from django.http import FileResponse\nfile = open(name, 'rb')\nresponse = FileResponse(file)\nresponse['Content-Type'] = 'application/octet-stream'\nresponse['Content-Disposition'] = 'attachment;filename=' + datetime.now().strftime(\"%Y-%m-%d\") + name\nreturn response</code></pre>\n\n<p>示例</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import xlwt\n\n\ndef write(data, name):\n    wbx = xlwt.Workbook()\n    sheet = wbx.add_sheet('Sheet1', cell_overwrite_ok=True)\n    for row, i in enumerate(data):\n        col = 0\n        for j in i:\n            sheet.write(row, col, i[j])\n            col += 1\n    wbx.save(name)</code></pre>\n\n<p> </p>"},{"_content":"<p>一脸懵逼，点击登录，如果错了会有提示，但是登录成功了后台会显示跳转到dashboard上，也能正常获取到cookie，但是就是页面不会变化，单独访问dashboard也是正常的。<br />\n问题代码如下：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># login   \n\n\nclass Login(View):\n    '''\n    用户登录\n    '''\n    def get(self, request):\n        return render(request, 'website/signin.html')\n\n    def post(self, request):\n        res = {'status': 'succ'}\n        user_name = request.POST.get(\"name\", None)\n        password = request.POST.get(\"password\", None)\n        u = models.WebsiteUserinfo.objects.filter(username=user_name).first()\n        if not u:\n            res['status'] = '用户名错误'\n        else:\n            if password == u.password:\n                # re = render(request,'website/dashboard.html')\n                re = redirect('/oa/dashboard')\n                re.set_cookie('is_log', True)  # 设置cookie\n                re.set_cookie('username', user_name)\n                return re\n            else:\n                res['status'] = '密码错误'\n        return HttpResponse(json.dumps(res), content_type=\"application/json\")\n\n\n#  dashboard\n\nclass Dashboard(View):\n    '''\n    主页\n    '''\n    def get(self, request):\n        print(request.COOKIES['username'])\n        return render(request, '../templates/website/dashboard.html', {'auth': '1234'})\n\n\n\n#  路由配置\n\nfrom django.conf.urls import url,include\nfrom django.contrib import admin\nfrom website import views\n\nurlpatterns = [\n    url(r'^admin/', admin.site.urls),\n    url(r'^$',views.init),\n    url(r'^oa/', include('website.urls')),\n]\n\n\nfrom django.conf.urls import url\nfrom website import views\nurlpatterns = [\n    url(r'^dashboard', views.Dashboard.as_view()),\n    url(r'^realtime_table', views.RealTimeTable.as_view()),\n    url(r'^everyday_table', views.EveryDayTable.as_view()),\n    url(r'^login', views.Login.as_view()),\n]</code></pre>\n\n<p>后台输出：<br /><img alt=\"\" class=\"has\" height=\"99\" src=\"https://img-blog.csdn.net/20180830100235311?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"685\" /></p>\n\n<p> </p>\n\n<h1><span style=\"color:#f33b45;\"><strong>解决问题：</strong></span></h1>\n\n<p><span style=\"color:#f33b45;\">注意力一直放在后台上了，之前是通过session保存用户状态的，现在需要改为cookie验证，如果要设置cookie返回类型必须为render，</span><span style=\"color:#f33b45;\">redirect，因此</span><span style=\"color:#f33b45;\">就将原来登录成功返回json改为了</span><span style=\"color:#f33b45;\">redirect，但是没有想到的是前端是通过Ajax发送消息的，无法识别返回类型，就导致了登录成功了却没有反应。总结来说是一个很、非常、超级低端的问题，只怪自己想当然的修改。</span></p>\n\n<p><span style=\"color:#f33b45;\">还是返回json格式，让js去设置cookie</span></p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">function login() {\n        $.ajax({\n            type: \"POST\",//方法类型\n            dataType: \"json\",//预期服务器返回的数据类型\n            url: \"/oa/login\",//url\n            data: $('#login_form').serialize(),\n            success: function (data) {\n                if (data['status'] != \"succ\"){\n                    alert(data['status']);\n                }\n                if (data['status'] == \"succ\"){\n                    var name = document.getElementById('u1').value;\n                    document.cookie=\"is_log=True;\";\n                    document.cookie=\"username=\"+name;\n                    window.location.href='/oa/dashboard';\n                }\n            }\n        });\n    }</code></pre>\n\n<p> </p>","source":"_posts/blogs-Django页面跳转但是不会显示出来？？？.md","raw":"<p>一脸懵逼，点击登录，如果错了会有提示，但是登录成功了后台会显示跳转到dashboard上，也能正常获取到cookie，但是就是页面不会变化，单独访问dashboard也是正常的。<br />\n问题代码如下：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># login   \n\n\nclass Login(View):\n    '''\n    用户登录\n    '''\n    def get(self, request):\n        return render(request, 'website/signin.html')\n\n    def post(self, request):\n        res = {'status': 'succ'}\n        user_name = request.POST.get(\"name\", None)\n        password = request.POST.get(\"password\", None)\n        u = models.WebsiteUserinfo.objects.filter(username=user_name).first()\n        if not u:\n            res['status'] = '用户名错误'\n        else:\n            if password == u.password:\n                # re = render(request,'website/dashboard.html')\n                re = redirect('/oa/dashboard')\n                re.set_cookie('is_log', True)  # 设置cookie\n                re.set_cookie('username', user_name)\n                return re\n            else:\n                res['status'] = '密码错误'\n        return HttpResponse(json.dumps(res), content_type=\"application/json\")\n\n\n#  dashboard\n\nclass Dashboard(View):\n    '''\n    主页\n    '''\n    def get(self, request):\n        print(request.COOKIES['username'])\n        return render(request, '../templates/website/dashboard.html', {'auth': '1234'})\n\n\n\n#  路由配置\n\nfrom django.conf.urls import url,include\nfrom django.contrib import admin\nfrom website import views\n\nurlpatterns = [\n    url(r'^admin/', admin.site.urls),\n    url(r'^$',views.init),\n    url(r'^oa/', include('website.urls')),\n]\n\n\nfrom django.conf.urls import url\nfrom website import views\nurlpatterns = [\n    url(r'^dashboard', views.Dashboard.as_view()),\n    url(r'^realtime_table', views.RealTimeTable.as_view()),\n    url(r'^everyday_table', views.EveryDayTable.as_view()),\n    url(r'^login', views.Login.as_view()),\n]</code></pre>\n\n<p>后台输出：<br /><img alt=\"\" class=\"has\" height=\"99\" src=\"https://img-blog.csdn.net/20180830100235311?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"685\" /></p>\n\n<p> </p>\n\n<h1><span style=\"color:#f33b45;\"><strong>解决问题：</strong></span></h1>\n\n<p><span style=\"color:#f33b45;\">注意力一直放在后台上了，之前是通过session保存用户状态的，现在需要改为cookie验证，如果要设置cookie返回类型必须为render，</span><span style=\"color:#f33b45;\">redirect，因此</span><span style=\"color:#f33b45;\">就将原来登录成功返回json改为了</span><span style=\"color:#f33b45;\">redirect，但是没有想到的是前端是通过Ajax发送消息的，无法识别返回类型，就导致了登录成功了却没有反应。总结来说是一个很、非常、超级低端的问题，只怪自己想当然的修改。</span></p>\n\n<p><span style=\"color:#f33b45;\">还是返回json格式，让js去设置cookie</span></p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">function login() {\n        $.ajax({\n            type: \"POST\",//方法类型\n            dataType: \"json\",//预期服务器返回的数据类型\n            url: \"/oa/login\",//url\n            data: $('#login_form').serialize(),\n            success: function (data) {\n                if (data['status'] != \"succ\"){\n                    alert(data['status']);\n                }\n                if (data['status'] == \"succ\"){\n                    var name = document.getElementById('u1').value;\n                    document.cookie=\"is_log=True;\";\n                    document.cookie=\"username=\"+name;\n                    window.location.href='/oa/dashboard';\n                }\n            }\n        });\n    }</code></pre>\n\n<p> </p>","slug":"blogs-Django页面跳转但是不会显示出来？？？","published":1,"date":"2022-03-16T17:09:05.379Z","updated":"2022-03-16T17:09:05.379Z","_id":"cl0v6kesh0011yms4e5xe366i","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>一脸懵逼，点击登录，如果错了会有提示，但是登录成功了后台会显示跳转到dashboard上，也能正常获取到cookie，但是就是页面不会变化，单独访问dashboard也是正常的。<br />\n问题代码如下：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># login   \n\n\nclass Login(View):\n    '''\n    用户登录\n    '''\n    def get(self, request):\n        return render(request, 'website/signin.html')\n\n    def post(self, request):\n        res = &#123;'status': 'succ'&#125;\n        user_name = request.POST.get(\"name\", None)\n        password = request.POST.get(\"password\", None)\n        u = models.WebsiteUserinfo.objects.filter(username=user_name).first()\n        if not u:\n            res['status'] = '用户名错误'\n        else:\n            if password == u.password:\n                # re = render(request,'website/dashboard.html')\n                re = redirect('/oa/dashboard')\n                re.set_cookie('is_log', True)  # 设置cookie\n                re.set_cookie('username', user_name)\n                return re\n            else:\n                res['status'] = '密码错误'\n        return HttpResponse(json.dumps(res), content_type=\"application/json\")\n\n\n#  dashboard\n\nclass Dashboard(View):\n    '''\n    主页\n    '''\n    def get(self, request):\n        print(request.COOKIES['username'])\n        return render(request, '../templates/website/dashboard.html', &#123;'auth': '1234'&#125;)\n\n\n\n#  路由配置\n\nfrom django.conf.urls import url,include\nfrom django.contrib import admin\nfrom website import views\n\nurlpatterns = [\n    url(r'^admin/', admin.site.urls),\n    url(r'^$',views.init),\n    url(r'^oa/', include('website.urls')),\n]\n\n\nfrom django.conf.urls import url\nfrom website import views\nurlpatterns = [\n    url(r'^dashboard', views.Dashboard.as_view()),\n    url(r'^realtime_table', views.RealTimeTable.as_view()),\n    url(r'^everyday_table', views.EveryDayTable.as_view()),\n    url(r'^login', views.Login.as_view()),\n]</code></pre>\n\n<p>后台输出：<br /><img alt=\"\" class=\"has\" height=\"99\" src=\"https://img-blog.csdn.net/20180830100235311?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"685\" /></p>\n\n<p> </p>\n\n<h1><span style=\"color:#f33b45;\"><strong>解决问题：</strong></span></h1>\n\n<p><span style=\"color:#f33b45;\">注意力一直放在后台上了，之前是通过session保存用户状态的，现在需要改为cookie验证，如果要设置cookie返回类型必须为render，</span><span style=\"color:#f33b45;\">redirect，因此</span><span style=\"color:#f33b45;\">就将原来登录成功返回json改为了</span><span style=\"color:#f33b45;\">redirect，但是没有想到的是前端是通过Ajax发送消息的，无法识别返回类型，就导致了登录成功了却没有反应。总结来说是一个很、非常、超级低端的问题，只怪自己想当然的修改。</span></p>\n\n<p><span style=\"color:#f33b45;\">还是返回json格式，让js去设置cookie</span></p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">function login() &#123;\n        $.ajax(&#123;\n            type: \"POST\",//方法类型\n            dataType: \"json\",//预期服务器返回的数据类型\n            url: \"/oa/login\",//url\n            data: $('#login_form').serialize(),\n            success: function (data) &#123;\n                if (data['status'] != \"succ\")&#123;\n                    alert(data['status']);\n                &#125;\n                if (data['status'] == \"succ\")&#123;\n                    var name = document.getElementById('u1').value;\n                    document.cookie=\"is_log=True;\";\n                    document.cookie=\"username=\"+name;\n                    window.location.href='/oa/dashboard';\n                &#125;\n            &#125;\n        &#125;);\n    &#125;</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<p>一脸懵逼，点击登录，如果错了会有提示，但是登录成功了后台会显示跳转到dashboard上，也能正常获取到cookie，但是就是页面不会变化，单独访问dashboard也是正常的。<br />\n问题代码如下：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># login   \n\n\nclass Login(View):\n    '''\n    用户登录\n    '''\n    def get(self, request):\n        return render(request, 'website/signin.html')\n\n    def post(self, request):\n        res = &#123;'status': 'succ'&#125;\n        user_name = request.POST.get(\"name\", None)\n        password = request.POST.get(\"password\", None)\n        u = models.WebsiteUserinfo.objects.filter(username=user_name).first()\n        if not u:\n            res['status'] = '用户名错误'\n        else:\n            if password == u.password:\n                # re = render(request,'website/dashboard.html')\n                re = redirect('/oa/dashboard')\n                re.set_cookie('is_log', True)  # 设置cookie\n                re.set_cookie('username', user_name)\n                return re\n            else:\n                res['status'] = '密码错误'\n        return HttpResponse(json.dumps(res), content_type=\"application/json\")\n\n\n#  dashboard\n\nclass Dashboard(View):\n    '''\n    主页\n    '''\n    def get(self, request):\n        print(request.COOKIES['username'])\n        return render(request, '../templates/website/dashboard.html', &#123;'auth': '1234'&#125;)\n\n\n\n#  路由配置\n\nfrom django.conf.urls import url,include\nfrom django.contrib import admin\nfrom website import views\n\nurlpatterns = [\n    url(r'^admin/', admin.site.urls),\n    url(r'^$',views.init),\n    url(r'^oa/', include('website.urls')),\n]\n\n\nfrom django.conf.urls import url\nfrom website import views\nurlpatterns = [\n    url(r'^dashboard', views.Dashboard.as_view()),\n    url(r'^realtime_table', views.RealTimeTable.as_view()),\n    url(r'^everyday_table', views.EveryDayTable.as_view()),\n    url(r'^login', views.Login.as_view()),\n]</code></pre>\n\n<p>后台输出：<br /><img alt=\"\" class=\"has\" height=\"99\" src=\"https://img-blog.csdn.net/20180830100235311?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"685\" /></p>\n\n<p> </p>\n\n<h1><span style=\"color:#f33b45;\"><strong>解决问题：</strong></span></h1>\n\n<p><span style=\"color:#f33b45;\">注意力一直放在后台上了，之前是通过session保存用户状态的，现在需要改为cookie验证，如果要设置cookie返回类型必须为render，</span><span style=\"color:#f33b45;\">redirect，因此</span><span style=\"color:#f33b45;\">就将原来登录成功返回json改为了</span><span style=\"color:#f33b45;\">redirect，但是没有想到的是前端是通过Ajax发送消息的，无法识别返回类型，就导致了登录成功了却没有反应。总结来说是一个很、非常、超级低端的问题，只怪自己想当然的修改。</span></p>\n\n<p><span style=\"color:#f33b45;\">还是返回json格式，让js去设置cookie</span></p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">function login() &#123;\n        $.ajax(&#123;\n            type: \"POST\",//方法类型\n            dataType: \"json\",//预期服务器返回的数据类型\n            url: \"/oa/login\",//url\n            data: $('#login_form').serialize(),\n            success: function (data) &#123;\n                if (data['status'] != \"succ\")&#123;\n                    alert(data['status']);\n                &#125;\n                if (data['status'] == \"succ\")&#123;\n                    var name = document.getElementById('u1').value;\n                    document.cookie=\"is_log=True;\";\n                    document.cookie=\"username=\"+name;\n                    window.location.href='/oa/dashboard';\n                &#125;\n            &#125;\n        &#125;);\n    &#125;</code></pre>\n\n<p> </p>"},{"_content":"<p>安装 apt-get install docker.io</p>\n\n<p>获取镜像：docker pull &lt;name&gt;</p>\n\n<p>运行一个容器： docker run &lt;参数&gt; &lt;image name&gt; <br />\n参数</p>\n\n<ul><li><code>-d, --detach=false</code>， 指定容器运行于前台还是后台，默认为false</li>\n\t<li><code>-i, --interactive=false</code>， 打开STDIN，用于控制台交互</li>\n\t<li><code>-t, --tty=false</code>， 分配tty设备，该可以支持终端登录，默认为false</li>\n\t<li><code>-u, --user=\"\"</code>， 指定容器的用户</li>\n\t<li><code>-a, --attach=[]</code>， 登录容器（必须是以docker run -d启动的容器）</li>\n\t<li><code>-w, --workdir=\"\"</code>， 指定容器的工作目录</li>\n\t<li><code>-c, --cpu-shares=0</code>， 设置容器CPU权重，在CPU共享场景使用</li>\n\t<li><code>-e, --env=[]</code>， 指定环境变量，容器中可以使用该环境变量</li>\n\t<li><code>-m, --memory=\"\"</code>， 指定容器的内存上限</li>\n\t<li><code>-P, --publish-all=false</code>， 指定容器暴露的端口</li>\n\t<li><code>-p, --publish=[]</code>， 指定容器暴露的端口</li>\n\t<li><code>-h, --hostname=\"\"</code>， 指定容器的主机名</li>\n\t<li><code>-v, --volume=[]</code>， 给容器挂载存储卷，挂载到容器的某个目录</li>\n</ul><p>将容器变为镜像 ： docker commit -a \"creator name\" -m \"information\"  containerID   imagename:tag</p>\n\n<p>删除单个容器：docker rm containerID </p>\n\n<p>删除所有容器：docker rm $(docker ps -a -q)</p>\n\n<p>删除镜像：docker rmi imageID  /  docker rmi imageName:Tag</p>","source":"_posts/blogs-Docker命令.md","raw":"<p>安装 apt-get install docker.io</p>\n\n<p>获取镜像：docker pull &lt;name&gt;</p>\n\n<p>运行一个容器： docker run &lt;参数&gt; &lt;image name&gt; <br />\n参数</p>\n\n<ul><li><code>-d, --detach=false</code>， 指定容器运行于前台还是后台，默认为false</li>\n\t<li><code>-i, --interactive=false</code>， 打开STDIN，用于控制台交互</li>\n\t<li><code>-t, --tty=false</code>， 分配tty设备，该可以支持终端登录，默认为false</li>\n\t<li><code>-u, --user=\"\"</code>， 指定容器的用户</li>\n\t<li><code>-a, --attach=[]</code>， 登录容器（必须是以docker run -d启动的容器）</li>\n\t<li><code>-w, --workdir=\"\"</code>， 指定容器的工作目录</li>\n\t<li><code>-c, --cpu-shares=0</code>， 设置容器CPU权重，在CPU共享场景使用</li>\n\t<li><code>-e, --env=[]</code>， 指定环境变量，容器中可以使用该环境变量</li>\n\t<li><code>-m, --memory=\"\"</code>， 指定容器的内存上限</li>\n\t<li><code>-P, --publish-all=false</code>， 指定容器暴露的端口</li>\n\t<li><code>-p, --publish=[]</code>， 指定容器暴露的端口</li>\n\t<li><code>-h, --hostname=\"\"</code>， 指定容器的主机名</li>\n\t<li><code>-v, --volume=[]</code>， 给容器挂载存储卷，挂载到容器的某个目录</li>\n</ul><p>将容器变为镜像 ： docker commit -a \"creator name\" -m \"information\"  containerID   imagename:tag</p>\n\n<p>删除单个容器：docker rm containerID </p>\n\n<p>删除所有容器：docker rm $(docker ps -a -q)</p>\n\n<p>删除镜像：docker rmi imageID  /  docker rmi imageName:Tag</p>","slug":"blogs-Docker命令","published":1,"date":"2022-03-16T17:00:53.277Z","updated":"2022-03-16T17:05:42.652Z","_id":"cl0v6kesi0012yms41qr59xi7","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>安装 apt-get install docker.io</p>\n\n<p>获取镜像：docker pull &lt;name&gt;</p>\n\n<p>运行一个容器： docker run &lt;参数&gt; &lt;image name&gt; <br />\n参数</p>\n\n<ul><li><code>-d, --detach=false</code>， 指定容器运行于前台还是后台，默认为false</li>\n    <li><code>-i, --interactive=false</code>， 打开STDIN，用于控制台交互</li>\n    <li><code>-t, --tty=false</code>， 分配tty设备，该可以支持终端登录，默认为false</li>\n    <li><code>-u, --user=\"\"</code>， 指定容器的用户</li>\n    <li><code>-a, --attach=[]</code>， 登录容器（必须是以docker run -d启动的容器）</li>\n    <li><code>-w, --workdir=\"\"</code>， 指定容器的工作目录</li>\n    <li><code>-c, --cpu-shares=0</code>， 设置容器CPU权重，在CPU共享场景使用</li>\n    <li><code>-e, --env=[]</code>， 指定环境变量，容器中可以使用该环境变量</li>\n    <li><code>-m, --memory=\"\"</code>， 指定容器的内存上限</li>\n    <li><code>-P, --publish-all=false</code>， 指定容器暴露的端口</li>\n    <li><code>-p, --publish=[]</code>， 指定容器暴露的端口</li>\n    <li><code>-h, --hostname=\"\"</code>， 指定容器的主机名</li>\n    <li><code>-v, --volume=[]</code>， 给容器挂载存储卷，挂载到容器的某个目录</li>\n</ul><p>将容器变为镜像 ： docker commit -a \"creator name\" -m \"information\"  containerID   imagename:tag</p>\n\n<p>删除单个容器：docker rm containerID </p>\n\n<p>删除所有容器：docker rm $(docker ps -a -q)</p>\n\n<p>删除镜像：docker rmi imageID  /  docker rmi imageName:Tag</p>","site":{"data":{}},"excerpt":"","more":"<p>安装 apt-get install docker.io</p>\n\n<p>获取镜像：docker pull &lt;name&gt;</p>\n\n<p>运行一个容器： docker run &lt;参数&gt; &lt;image name&gt; <br />\n参数</p>\n\n<ul><li><code>-d, --detach=false</code>， 指定容器运行于前台还是后台，默认为false</li>\n    <li><code>-i, --interactive=false</code>， 打开STDIN，用于控制台交互</li>\n    <li><code>-t, --tty=false</code>， 分配tty设备，该可以支持终端登录，默认为false</li>\n    <li><code>-u, --user=\"\"</code>， 指定容器的用户</li>\n    <li><code>-a, --attach=[]</code>， 登录容器（必须是以docker run -d启动的容器）</li>\n    <li><code>-w, --workdir=\"\"</code>， 指定容器的工作目录</li>\n    <li><code>-c, --cpu-shares=0</code>， 设置容器CPU权重，在CPU共享场景使用</li>\n    <li><code>-e, --env=[]</code>， 指定环境变量，容器中可以使用该环境变量</li>\n    <li><code>-m, --memory=\"\"</code>， 指定容器的内存上限</li>\n    <li><code>-P, --publish-all=false</code>， 指定容器暴露的端口</li>\n    <li><code>-p, --publish=[]</code>， 指定容器暴露的端口</li>\n    <li><code>-h, --hostname=\"\"</code>， 指定容器的主机名</li>\n    <li><code>-v, --volume=[]</code>， 给容器挂载存储卷，挂载到容器的某个目录</li>\n</ul><p>将容器变为镜像 ： docker commit -a \"creator name\" -m \"information\"  containerID   imagename:tag</p>\n\n<p>删除单个容器：docker rm containerID </p>\n\n<p>删除所有容器：docker rm $(docker ps -a -q)</p>\n\n<p>删除镜像：docker rmi imageID  /  docker rmi imageName:Tag</p>"},{"_content":"<p>1.   git init 初始化版本库<br />\n2.   git config --global user.name (your name)  配置<br />\n      git config --global user.email (your email)<br />\n3.   git add (file name)  将文件放置到缓存区<br />\n4.   git commit -m (describe) 将缓存区的文件提交到分支上<br />\n5.   git status 查看版本库状态<br />\n6.   git diff 查看具体修改内容<br />\n7.   git log 查看提交记录<br />\n8.   git reset  -- hard HEAD^ 退回上一次提交、  HEAD^^ 退回前两次、  HEAD~n 退回到前n次 、 commit id  退回到指定的位置<br />\n9.   git reflog 查看命令记录<br />\n10. git checkout -- (file name)  撤销修改<br />\n11. git rm (file name)  删除文件<br />\n12. git remote set-url origin [URL] 修改远程仓库地址<br />\n13. git config --global credential.helper store 永久记录Https用户名密码</p>\n","source":"_posts/blogs-Git命令.md","raw":"<p>1.   git init 初始化版本库<br />\n2.   git config --global user.name (your name)  配置<br />\n      git config --global user.email (your email)<br />\n3.   git add (file name)  将文件放置到缓存区<br />\n4.   git commit -m (describe) 将缓存区的文件提交到分支上<br />\n5.   git status 查看版本库状态<br />\n6.   git diff 查看具体修改内容<br />\n7.   git log 查看提交记录<br />\n8.   git reset  -- hard HEAD^ 退回上一次提交、  HEAD^^ 退回前两次、  HEAD~n 退回到前n次 、 commit id  退回到指定的位置<br />\n9.   git reflog 查看命令记录<br />\n10. git checkout -- (file name)  撤销修改<br />\n11. git rm (file name)  删除文件<br />\n12. git remote set-url origin [URL] 修改远程仓库地址<br />\n13. git config --global credential.helper store 永久记录Https用户名密码</p>\n","slug":"blogs-Git命令","published":1,"date":"2022-03-16T17:01:25.618Z","updated":"2022-03-16T17:06:15.312Z","_id":"cl0v6kesj0013yms453xf9vem","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>1.   git init 初始化版本库<br />\n2.   git config --global user.name (your name)  配置<br />\n      git config --global user.email (your email)<br />\n3.   git add (file name)  将文件放置到缓存区<br />\n4.   git commit -m (describe) 将缓存区的文件提交到分支上<br />\n5.   git status 查看版本库状态<br />\n6.   git diff 查看具体修改内容<br />\n7.   git log 查看提交记录<br />\n8.   git reset  -- hard HEAD^ 退回上一次提交、  HEAD^^ 退回前两次、  HEAD~n 退回到前n次 、 commit id  退回到指定的位置<br />\n9.   git reflog 查看命令记录<br />\n10. git checkout -- (file name)  撤销修改<br />\n11. git rm (file name)  删除文件<br />\n12. git remote set-url origin [URL] 修改远程仓库地址<br />\n13. git config --global credential.helper store 永久记录Https用户名密码</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.   git init 初始化版本库<br />\n2.   git config --global user.name (your name)  配置<br />\n      git config --global user.email (your email)<br />\n3.   git add (file name)  将文件放置到缓存区<br />\n4.   git commit -m (describe) 将缓存区的文件提交到分支上<br />\n5.   git status 查看版本库状态<br />\n6.   git diff 查看具体修改内容<br />\n7.   git log 查看提交记录<br />\n8.   git reset  -- hard HEAD^ 退回上一次提交、  HEAD^^ 退回前两次、  HEAD~n 退回到前n次 、 commit id  退回到指定的位置<br />\n9.   git reflog 查看命令记录<br />\n10. git checkout -- (file name)  撤销修改<br />\n11. git rm (file name)  删除文件<br />\n12. git remote set-url origin [URL] 修改远程仓库地址<br />\n13. git config --global credential.helper store 永久记录Https用户名密码</p>\n"},{"_content":"<p>configparser是python中自带的一个配置文件读写的库，python2中为ConfigParser在python3中更名为configparser，首先我们建立一个test.ini的配置文件，内容如下：</p><pre class=\"python\">[device]\nport=COM9\nbaud_rate=9600</pre><h5>读操作：</h5><p>实例：</p><pre class=\"python\">import configparser\ncf=configparser.ConfigParser()\ncf.read(\"test.ini\")\nprint(cf.sections())\nprint(cf.options(\"device\"))\nprint(cf.items(\"device\"))\nprint(cf.get(\"device\",\"port\"))</pre><p>首先导入configparser模块，再使用read方法读取配置文件内容。<br /></p><p>sections()方法返回文件中所有section<br /></p><p>options(section_name)方法返回该section_name下所有的option<br /></p><p>items(section_name)方法以元祖的格式返回该section_name下的所有option的key和value<br /></p><p>get(section_name, option_name)方法只返回key<br />运行结果<br /></p><p></p><p><img src=\"https://img-blog.csdn.net/20180501224730635?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /></p><h5>写操作：<br /></h5><p>实例：</p><pre class=\"python\">cf.add_section(\"section1\")\ncf.set('section1','key1','value1')\ncf.write(open(\"test.ini\",'w'))\n\nprint(cf.sections())\nprint(cf.items(\"section1\"))</pre><p>add_section(new_section_name)：新建一个section，如果已存在会报错。<br /></p><p>set(section_name, option_name, value): 如果option_name存在则更新value，如果不存在则新建一个option和value，但是如果section不存在会报错。<br />write(）方法将内容重新写入到文件中，需要注意的是如果在写之前没有读去过这个文件那么这次写入将会导致之前的文件内容被覆盖掉。<br />运行结果<br /></p><p></p><p><img src=\"https://img-blog.csdn.net/20180501233400538?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /></p><h5>删除：</h5><p>实例：</p><pre class=\"python\">cf.remove_option(\"section1\",\"key1\")\nprint(cf.sections())\nprint(cf.items(\"section1\"))\n\ncf.remove_section(\"section1\")\nprint(cf.sections())</pre><p>remove_option(section_name,option_name)：删除指定的option，section不存在会报错。<br /></p><p>remove_section(section_name)：删除指定的section。<br />需要注意这里的删除仅仅只是在内存中进行的，还要进行write()操作写入到文件中，否则配置文件实际上是没有被更改的。<br /></p><p>运行结果：<br /><img src=\"https://img-blog.csdn.net/20180501235039847?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /><br /><br /></p>                                                                             <p></p><p></p><p></p><p></p>","source":"_posts/blogs-configparser模块的简单使用.md","raw":"<p>configparser是python中自带的一个配置文件读写的库，python2中为ConfigParser在python3中更名为configparser，首先我们建立一个test.ini的配置文件，内容如下：</p><pre class=\"python\">[device]\nport=COM9\nbaud_rate=9600</pre><h5>读操作：</h5><p>实例：</p><pre class=\"python\">import configparser\ncf=configparser.ConfigParser()\ncf.read(\"test.ini\")\nprint(cf.sections())\nprint(cf.options(\"device\"))\nprint(cf.items(\"device\"))\nprint(cf.get(\"device\",\"port\"))</pre><p>首先导入configparser模块，再使用read方法读取配置文件内容。<br /></p><p>sections()方法返回文件中所有section<br /></p><p>options(section_name)方法返回该section_name下所有的option<br /></p><p>items(section_name)方法以元祖的格式返回该section_name下的所有option的key和value<br /></p><p>get(section_name, option_name)方法只返回key<br />运行结果<br /></p><p></p><p><img src=\"https://img-blog.csdn.net/20180501224730635?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /></p><h5>写操作：<br /></h5><p>实例：</p><pre class=\"python\">cf.add_section(\"section1\")\ncf.set('section1','key1','value1')\ncf.write(open(\"test.ini\",'w'))\n\nprint(cf.sections())\nprint(cf.items(\"section1\"))</pre><p>add_section(new_section_name)：新建一个section，如果已存在会报错。<br /></p><p>set(section_name, option_name, value): 如果option_name存在则更新value，如果不存在则新建一个option和value，但是如果section不存在会报错。<br />write(）方法将内容重新写入到文件中，需要注意的是如果在写之前没有读去过这个文件那么这次写入将会导致之前的文件内容被覆盖掉。<br />运行结果<br /></p><p></p><p><img src=\"https://img-blog.csdn.net/20180501233400538?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /></p><h5>删除：</h5><p>实例：</p><pre class=\"python\">cf.remove_option(\"section1\",\"key1\")\nprint(cf.sections())\nprint(cf.items(\"section1\"))\n\ncf.remove_section(\"section1\")\nprint(cf.sections())</pre><p>remove_option(section_name,option_name)：删除指定的option，section不存在会报错。<br /></p><p>remove_section(section_name)：删除指定的section。<br />需要注意这里的删除仅仅只是在内存中进行的，还要进行write()操作写入到文件中，否则配置文件实际上是没有被更改的。<br /></p><p>运行结果：<br /><img src=\"https://img-blog.csdn.net/20180501235039847?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /><br /><br /></p>                                                                             <p></p><p></p><p></p><p></p>","slug":"blogs-configparser模块的简单使用","published":1,"date":"2022-03-16T17:09:19.653Z","updated":"2022-03-16T17:09:19.654Z","_id":"cl0v6kesj0014yms4a917eeow","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>configparser是python中自带的一个配置文件读写的库，python2中为ConfigParser在python3中更名为configparser，首先我们建立一个test.ini的配置文件，内容如下：</p><pre class=\"python\">[device]\nport=COM9\nbaud_rate=9600</pre><h5>读操作：</h5><p>实例：</p><pre class=\"python\">import configparser\ncf=configparser.ConfigParser()\ncf.read(\"test.ini\")\nprint(cf.sections())\nprint(cf.options(\"device\"))\nprint(cf.items(\"device\"))\nprint(cf.get(\"device\",\"port\"))</pre><p>首先导入configparser模块，再使用read方法读取配置文件内容。<br /></p><p>sections()方法返回文件中所有section<br /></p><p>options(section_name)方法返回该section_name下所有的option<br /></p><p>items(section_name)方法以元祖的格式返回该section_name下的所有option的key和value<br /></p><p>get(section_name, option_name)方法只返回key<br />运行结果<br /></p><p></p><p><img src=\"https://img-blog.csdn.net/20180501224730635?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /></p><h5>写操作：<br /></h5><p>实例：</p><pre class=\"python\">cf.add_section(\"section1\")\ncf.set('section1','key1','value1')\ncf.write(open(\"test.ini\",'w'))\n\n<p>print(cf.sections())<br>print(cf.items(“section1”))</pre><p>add_section(new_section_name)：新建一个section，如果已存在会报错。<br /></p><p>set(section_name, option_name, value): 如果option_name存在则更新value，如果不存在则新建一个option和value，但是如果section不存在会报错。<br />write(）方法将内容重新写入到文件中，需要注意的是如果在写之前没有读去过这个文件那么这次写入将会导致之前的文件内容被覆盖掉。<br />运行结果<br /></p><p></p><p><img src=\"https://img-blog.csdn.net/20180501233400538?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /></p><h5>删除：</h5><p>实例：</p><pre class=\"python\">cf.remove_option(\"section1\",\"key1\")<br>print(cf.sections())<br>print(cf.items(\"section1\"))</p>\n<p>cf.remove_section(“section1”)<br>print(cf.sections())</pre><p>remove_option(section_name,option_name)：删除指定的option，section不存在会报错。<br /></p><p>remove_section(section_name)：删除指定的section。<br />需要注意这里的删除仅仅只是在内存中进行的，还要进行write()操作写入到文件中，否则配置文件实际上是没有被更改的。<br /></p><p>运行结果：<br /><img src=\"https://img-blog.csdn.net/20180501235039847?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /><br /><br /></p>                                                                             <p></p><p></p><p></p><p></p></p>\n","site":{"data":{}},"excerpt":"","more":"<p>configparser是python中自带的一个配置文件读写的库，python2中为ConfigParser在python3中更名为configparser，首先我们建立一个test.ini的配置文件，内容如下：</p><pre class=\"python\">[device]\nport=COM9\nbaud_rate=9600</pre><h5>读操作：</h5><p>实例：</p><pre class=\"python\">import configparser\ncf=configparser.ConfigParser()\ncf.read(\"test.ini\")\nprint(cf.sections())\nprint(cf.options(\"device\"))\nprint(cf.items(\"device\"))\nprint(cf.get(\"device\",\"port\"))</pre><p>首先导入configparser模块，再使用read方法读取配置文件内容。<br /></p><p>sections()方法返回文件中所有section<br /></p><p>options(section_name)方法返回该section_name下所有的option<br /></p><p>items(section_name)方法以元祖的格式返回该section_name下的所有option的key和value<br /></p><p>get(section_name, option_name)方法只返回key<br />运行结果<br /></p><p></p><p><img src=\"https://img-blog.csdn.net/20180501224730635?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /></p><h5>写操作：<br /></h5><p>实例：</p><pre class=\"python\">cf.add_section(\"section1\")\ncf.set('section1','key1','value1')\ncf.write(open(\"test.ini\",'w'))\n\n<p>print(cf.sections())<br>print(cf.items(“section1”))</pre><p>add_section(new_section_name)：新建一个section，如果已存在会报错。<br /></p><p>set(section_name, option_name, value): 如果option_name存在则更新value，如果不存在则新建一个option和value，但是如果section不存在会报错。<br />write(）方法将内容重新写入到文件中，需要注意的是如果在写之前没有读去过这个文件那么这次写入将会导致之前的文件内容被覆盖掉。<br />运行结果<br /></p><p></p><p><img src=\"https://img-blog.csdn.net/20180501233400538?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /></p><h5>删除：</h5><p>实例：</p><pre class=\"python\">cf.remove_option(\"section1\",\"key1\")<br>print(cf.sections())<br>print(cf.items(\"section1\"))</p>\n<p>cf.remove_section(“section1”)<br>print(cf.sections())</pre><p>remove_option(section_name,option_name)：删除指定的option，section不存在会报错。<br /></p><p>remove_section(section_name)：删除指定的section。<br />需要注意这里的删除仅仅只是在内存中进行的，还要进行write()操作写入到文件中，否则配置文件实际上是没有被更改的。<br /></p><p>运行结果：<br /><img src=\"https://img-blog.csdn.net/20180501235039847?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\" /><br /><br /></p>                                                                             <p></p><p></p><p></p><p></p></p>\n"},{"_content":"\n<h2>cookie</h2>\n<p>cookie:客户端浏览器上的一个文件（键&#20540;对方式存储，类&#20284;于python中的字典），一般用于记录用户状态、和用户信息的，绝大多数的网站自动登录功能都是基于cookie实现的，下面使用Django实现一个用户登陆作为例子展示。<br>\n</p>\n<p>首先是最简单的登录页面&nbsp;login：</p>\n<pre class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action=&quot;/login/&quot; method=&quot;post&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt;\n    &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\nlogin请求处理函数\n<pre class=\"python\">user_infp ={\n    &quot;fml&quot;:{&quot;password&quot;:&quot;123&quot;}\n}\n\ndef login(request):\n    if request.method == &quot;GET&quot;:\n        return  render(request,&quot;login.html&quot;)\n    if request.method == &quot;POST&quot;:\n        u = request.POST.get(&quot;username&quot;)\n        p = request.POST.get(&quot;password&quot;)\n        dic = user_infp.get(u)\n        if not dic:\n            return render(request,&quot;login.html&quot;)\n        if dic[&quot;password&quot;] == p:\n            res = redirect('/index')\n            res.set_cookie(&quot;username&quot;,u)\n            return res\n        else:\n            return render(request,&quot;login.html&quot;)</pre>\n当请求为get方式的时候返回登录页面，为post方式的时候验证表单，这里只使用字典来简化从数据库验证的操作。当验证通过的时候跳转到index页面，并且设置一个cookie，内容为｛&quot;username&quot;:username},否则任然返回当前页面。\n<p>index页面：仅仅用来显示登录的用户名</p>\n<pre class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;欢迎{{ user }}&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\n<p>index处理函数：</p>\n<pre class=\"html\">def index(request):\n    user = request.COOKIES.get(&quot;username&quot;)\n    if not user:\n        return redirect('/login')\n    else:\n        return render(request,'index.html',{&quot;user&quot;:user})</pre>\n如果上面我们如果登录成功浏览器会存储一个cookie，当我们再次请求index页面的时候，同时发送过去的还有本地的cookie，所以可以从request中的cookie中获取我们已经存储的用户名，如果不存在则跳转到login页面，如果有登录信息则显示登录页面<img src=\"\" alt=\"\"><br>\n<img src=\"\" alt=\"\"><br>\n<p>以上是最简单的cookie使用，其实cookie还有很多其他的用法</p>\n<p></p>\n<pre class=\"python\">rep = HttpResponse(...) 或 rep ＝ render(request, ...)\n \nrep.set_cookie(key,value,...)\nrep.set_signed_cookie(key,value,salt='加密盐',...)\n    参数：\n        key,              键\n        value='',         &#20540;\n        max_age=None,     超时时间\n        expires=None,     超时时间(IE requires expires, so set it if hasn't been already.)\n        path='/',         Cookie生效的路径，/ 表示根路径，特殊的：跟路径的cookie可以被任何url的页面访问\n        domain=None,      Cookie生效的域名\n        secure=False,     https传输\n        httponly=False    只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖）</pre>\n<p><img src=\"\" alt=\"\"><br>\n<img src=\"\" alt=\"\"><br>\n下面再来详细说一说各个参数的作用。<br>\n首先是获取cookie，salt：这个参数的具体作用目前我还是不太清除，猜测是cookie加密操作，等我弄懂了再回来修改。<br>\n<br>\n接下来是设置cookie，key和value不用再说了，<br>\n<strong>max_age:</strong>设置超时时间以秒为单位，很多网站上登录页面都有多长时间免登录的功能一般都是通过这个来设置的，当超过了一段时间这个cookie就会失效<br>\n<span style=\"white-space:pre\"></span><strong>expires</strong>:&nbsp;同样是设置超时时间的，但是和上面的不太一样，这里的单位不是秒，而是datetime,所以就有两种超时时间的设置方法</p>\n<pre class=\"python\">#max_age方法\nres.set_cookie(&quot;username&quot;,u,max_age=10)\n#expires方法\nimport datetime\ncurrent_time = datetime.datetime.utcnow()\nend_time = current_time &#43; datetime.timedelta(seconds=10)\nres.set_cookie(&quot;username&quot;,u,expires=end_time)</pre>\n<span style=\"white-space:pre\"></span><strong>path</strong>:是指定cookie生效的路径，参数默认为 ' / '&nbsp;可被当前网站任意URL页面访问，下面我们重新写一个页面index1，内容和index相同\n<pre class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;这里是index1欢迎{{ user }}&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\nindex1&nbsp;的处理函数\n<pre class=\"python\">def index1(request):\n    user = request.COOKIES.get(&quot;username&quot;)\n    if not user:\n        return HttpResponse(&quot;没有获取到cookie&quot;)\n    else:\n        return render(request,&quot;index1.html&quot;,{&quot;user&quot;:user})</pre>\n<p><br>\n</p>\n这里我们将login函数里面的cookie设置为\n<pre style=\"background-color:#272822; color:#f8f8f2; font-family:Consolas; font-size:9pt\">res.set_cookie(<span style=\"color:#e6db74\">&quot;username&quot;</span><span style=\"color:#cc7832\">,</span>u<span style=\"color:#cc7832\">,</span><span style=\"color:#aa4926\">path</span><span style=\"color:#f92672\">=</span><span style=\"color:#e6db74\">'/index'</span>)</pre>\n然后重新运行登录<img src=\"\" alt=\"\">，这里就能看出在index可以正常获取到cookie，而index1获取不到，path设置成功。\n<p><strong>domain:</strong>设置生效域名，这里只能设置当前域名的子域名，无法给其他域名设置<br>\n<br>\n</p>\n<h2>session</h2>\n<div>和cookie不同的是session是保存在服务器端的键&#20540;对，session基于cookie来使用的，一般情况下本地的cookie会存储session中的key名，然后通过cookie中的key去获取服务器上存储的信息。</div>\n下面依然以用户登录作为最简单的示例：<br>\n模板还是上面的那两个，这里只重写对应的处理函数<pre name=\"code\" class=\"python\">user_infp ={\n    &quot;fml&quot;:{&quot;password&quot;:&quot;123&quot;}\n}\n\ndef login(request):\n    if request.method == &quot;GET&quot;:\n        return  render(request,&quot;login.html&quot;)\n    if request.method == &quot;POST&quot;:\n        u = request.POST.get(&quot;username&quot;)\n        p = request.POST.get(&quot;password&quot;)\n        dic = user_infp.get(u)\n        if not dic:\n            return render(request,&quot;login.html&quot;)\n        if dic[&quot;password&quot;] == p:\n            res = redirect('/index')\n            request.session['username'] = u\n            request.session[&quot;is_login&quot;] = True\n            return res\n        else:\n            return render(request,&quot;login.html&quot;)\n\ndef index(request):\n    print(request.session[&quot;is_login&quot;])\n    if request.session[&quot;is_login&quot;]:\n        return render(request, 'index.html', {&quot;user&quot;: request.session[&quot;username&quot;]})\n    else:\n        return redirect('/login')</pre>乍一看和cookie的操作类&#20284;，其实这是因为django为我们在后台做了很多工作，例如\n<pre style=\"background-color:#272822; color:#f8f8f2; font-family:'Consolas'; font-size:9.0pt\"><span style=\"color:#fd971f\"><em>request</em></span>.session[<span style=\"color:#e6db74\">'username'</span>] <span style=\"color:#f92672\">= </span>u\n<span style=\"color:#fd971f\"><em>request</em></span>.session[<span style=\"color:#e6db74\">&quot;is_login&quot;</span>] <span style=\"color:#f92672\">= </span><span style=\"color:#66d9ef\"><em>True</em></span></pre>\n这两句就很简单的完成了session的创建，实际上django首先生成了一串随机字符串用来作为key并将这个随机字符串保存到本地的cookie中，然后在将后面的两个内容以字典的形式存到服务器端，django中默认session存储在数据库中。\n<p></p>\n<p></p>\n<pre style=\"background-color:#272822; color:#f8f8f2; font-family:'Consolas'; font-size:9.0pt\"><span style=\"color:#fd971f\"><em>request</em></span>.session[<span style=\"color:#e6db74\">&quot;is_login&quot;</span>]<span style=\"color:#f92672\">:</span></pre>\n这一步首先从cookie中回去对应的key，然后再从数据库中获取对应的value进行判断<br>\n同样的session和cookie一样也有一些高级功能，例如设置超时时间<br>\n<pre name=\"code\" class=\"python\">request.session.set_expiry(value)\n            * 如果value是个整数，session会在些秒数后失效。\n            * 如果value是个datatime或timedelta，session就会在这个时间后失效。\n            * 如果value是0,用户关闭浏览器session就会失效。\n            * 如果value是None,session会依赖全局session失效策略。</pre>\n<p></p>\n<p>除了超时时间设置还有一下功能：</p>\n<p><pre name=\"code\" class=\"python\">        # 获取、设置、删除Session中数据\n        request.session['k1']\n        request.session.get('k1',None)\n        request.session['k1'] = 123\n        request.session.setdefault('k1',123) # 存在则不设置\n        del request.session['k1']\n \n        # 所有 键、值、键值对\n        request.session.keys()\n        request.session.values()\n        request.session.items()\n        request.session.iterkeys()\n        request.session.itervalues()\n        request.session.iteritems()\n \n \n        # 用户session的随机字符串\n        request.session.session_key\n \n        # 将所有Session失效日期小于当前日期的数据删除\n        request.session.clear_expired()\n \n        # 检查 用户session的随机字符串 在数据库中是否\n        request.session.exists(&quot;session_key&quot;)\n \n        # 删除当前用户的所有Session数据\n        request.session.delete(&quot;session_key&quot;)</pre><br>\n</p>\n在django中session共有5种方式来存储：数据库、缓存、文件、缓存加数据库、加密cookie，但是都需要我们在settings里面设置，下面就是每种的配置方式\n<p><pre name=\"code\" class=\"python\">#数据库配置\n\nSESSION_ENGINE = 'django.contrib.sessions.backends.db'  # 引擎（默认）\n\nSESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）\nSESSION_COOKIE_PATH ＝ &quot;/&quot;  # Session的cookie保存的路径（默认）\nSESSION_COOKIE_DOMAIN = None  # Session的cookie保存的域名（默认）\nSESSION_COOKIE_SECURE = False  # 是否Https传输cookie（默认）\nSESSION_COOKIE_HTTPONLY = True  # 是否Session的cookie只支持http传输（默认）\nSESSION_COOKIE_AGE = 1209600  # Session的cookie失效日期（2周）（默认）\nSESSION_EXPIRE_AT_BROWSER_CLOSE = False  # 是否关闭浏览器使得Session过期（默认）\nSESSION_SAVE_EVERY_REQUEST = False  # 是否每次请求都保存Session，默认修改之后才保存（默认）\n\n#缓存配置\nSESSION_ENGINE = 'django.contrib.sessions.backends.cache'  # 引擎\nSESSION_CACHE_ALIAS = 'default'  # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置\n\nSESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串\nSESSION_COOKIE_PATH ＝ &quot;/&quot;  # Session的cookie保存的路径\nSESSION_COOKIE_DOMAIN = None  # Session的cookie保存的域名\nSESSION_COOKIE_SECURE = False  # 是否Https传输cookie\nSESSION_COOKIE_HTTPONLY = True  # 是否Session的cookie只支持http传输\nSESSION_COOKIE_AGE = 1209600  # Session的cookie失效日期（2周）\nSESSION_EXPIRE_AT_BROWSER_CLOSE = False  # 是否关闭浏览器使得Session过期\nSESSION_SAVE_EVERY_REQUEST = False  # 是否每次请求都保存Session，默认修改之后才保存\n\n#文件配置\nSESSION_ENGINE = 'django.contrib.sessions.backends.file'  # 引擎\nSESSION_FILE_PATH = None  # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir()                                                            # 如：/var/folders/d3/j9tj0gz93dg06bmwxmhh6_xm0000gn/T\n\nSESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串\nSESSION_COOKIE_PATH ＝ &quot;/&quot;  # Session的cookie保存的路径\nSESSION_COOKIE_DOMAIN = None  # Session的cookie保存的域名\nSESSION_COOKIE_SECURE = False  # 是否Https传输cookie\nSESSION_COOKIE_HTTPONLY = True  # 是否Session的cookie只支持http传输\nSESSION_COOKIE_AGE = 1209600  # Session的cookie失效日期（2周）\nSESSION_EXPIRE_AT_BROWSER_CLOSE = False  # 是否关闭浏览器使得Session过期\nSESSION_SAVE_EVERY_REQUEST = False  # 是否每次请求都保存Session，默认修改之后才保存\n\n#缓存加数据库（数据库实现持久化，缓存提高效率）\nSESSION_ENGINE = 'django.contrib.sessions.backends.cached_db'        # 引擎\n\n#加密Cookie\nSESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies'   # 引擎</pre><br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n</p>\n<p><br>\n</p>\n","source":"_posts/blogs-cookie和session.md","raw":"\n<h2>cookie</h2>\n<p>cookie:客户端浏览器上的一个文件（键&#20540;对方式存储，类&#20284;于python中的字典），一般用于记录用户状态、和用户信息的，绝大多数的网站自动登录功能都是基于cookie实现的，下面使用Django实现一个用户登陆作为例子展示。<br>\n</p>\n<p>首先是最简单的登录页面&nbsp;login：</p>\n<pre class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action=&quot;/login/&quot; method=&quot;post&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt;\n    &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\nlogin请求处理函数\n<pre class=\"python\">user_infp ={\n    &quot;fml&quot;:{&quot;password&quot;:&quot;123&quot;}\n}\n\ndef login(request):\n    if request.method == &quot;GET&quot;:\n        return  render(request,&quot;login.html&quot;)\n    if request.method == &quot;POST&quot;:\n        u = request.POST.get(&quot;username&quot;)\n        p = request.POST.get(&quot;password&quot;)\n        dic = user_infp.get(u)\n        if not dic:\n            return render(request,&quot;login.html&quot;)\n        if dic[&quot;password&quot;] == p:\n            res = redirect('/index')\n            res.set_cookie(&quot;username&quot;,u)\n            return res\n        else:\n            return render(request,&quot;login.html&quot;)</pre>\n当请求为get方式的时候返回登录页面，为post方式的时候验证表单，这里只使用字典来简化从数据库验证的操作。当验证通过的时候跳转到index页面，并且设置一个cookie，内容为｛&quot;username&quot;:username},否则任然返回当前页面。\n<p>index页面：仅仅用来显示登录的用户名</p>\n<pre class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;欢迎{{ user }}&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\n<p>index处理函数：</p>\n<pre class=\"html\">def index(request):\n    user = request.COOKIES.get(&quot;username&quot;)\n    if not user:\n        return redirect('/login')\n    else:\n        return render(request,'index.html',{&quot;user&quot;:user})</pre>\n如果上面我们如果登录成功浏览器会存储一个cookie，当我们再次请求index页面的时候，同时发送过去的还有本地的cookie，所以可以从request中的cookie中获取我们已经存储的用户名，如果不存在则跳转到login页面，如果有登录信息则显示登录页面<img src=\"\" alt=\"\"><br>\n<img src=\"\" alt=\"\"><br>\n<p>以上是最简单的cookie使用，其实cookie还有很多其他的用法</p>\n<p></p>\n<pre class=\"python\">rep = HttpResponse(...) 或 rep ＝ render(request, ...)\n \nrep.set_cookie(key,value,...)\nrep.set_signed_cookie(key,value,salt='加密盐',...)\n    参数：\n        key,              键\n        value='',         &#20540;\n        max_age=None,     超时时间\n        expires=None,     超时时间(IE requires expires, so set it if hasn't been already.)\n        path='/',         Cookie生效的路径，/ 表示根路径，特殊的：跟路径的cookie可以被任何url的页面访问\n        domain=None,      Cookie生效的域名\n        secure=False,     https传输\n        httponly=False    只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖）</pre>\n<p><img src=\"\" alt=\"\"><br>\n<img src=\"\" alt=\"\"><br>\n下面再来详细说一说各个参数的作用。<br>\n首先是获取cookie，salt：这个参数的具体作用目前我还是不太清除，猜测是cookie加密操作，等我弄懂了再回来修改。<br>\n<br>\n接下来是设置cookie，key和value不用再说了，<br>\n<strong>max_age:</strong>设置超时时间以秒为单位，很多网站上登录页面都有多长时间免登录的功能一般都是通过这个来设置的，当超过了一段时间这个cookie就会失效<br>\n<span style=\"white-space:pre\"></span><strong>expires</strong>:&nbsp;同样是设置超时时间的，但是和上面的不太一样，这里的单位不是秒，而是datetime,所以就有两种超时时间的设置方法</p>\n<pre class=\"python\">#max_age方法\nres.set_cookie(&quot;username&quot;,u,max_age=10)\n#expires方法\nimport datetime\ncurrent_time = datetime.datetime.utcnow()\nend_time = current_time &#43; datetime.timedelta(seconds=10)\nres.set_cookie(&quot;username&quot;,u,expires=end_time)</pre>\n<span style=\"white-space:pre\"></span><strong>path</strong>:是指定cookie生效的路径，参数默认为 ' / '&nbsp;可被当前网站任意URL页面访问，下面我们重新写一个页面index1，内容和index相同\n<pre class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;这里是index1欢迎{{ user }}&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\nindex1&nbsp;的处理函数\n<pre class=\"python\">def index1(request):\n    user = request.COOKIES.get(&quot;username&quot;)\n    if not user:\n        return HttpResponse(&quot;没有获取到cookie&quot;)\n    else:\n        return render(request,&quot;index1.html&quot;,{&quot;user&quot;:user})</pre>\n<p><br>\n</p>\n这里我们将login函数里面的cookie设置为\n<pre style=\"background-color:#272822; color:#f8f8f2; font-family:Consolas; font-size:9pt\">res.set_cookie(<span style=\"color:#e6db74\">&quot;username&quot;</span><span style=\"color:#cc7832\">,</span>u<span style=\"color:#cc7832\">,</span><span style=\"color:#aa4926\">path</span><span style=\"color:#f92672\">=</span><span style=\"color:#e6db74\">'/index'</span>)</pre>\n然后重新运行登录<img src=\"\" alt=\"\">，这里就能看出在index可以正常获取到cookie，而index1获取不到，path设置成功。\n<p><strong>domain:</strong>设置生效域名，这里只能设置当前域名的子域名，无法给其他域名设置<br>\n<br>\n</p>\n<h2>session</h2>\n<div>和cookie不同的是session是保存在服务器端的键&#20540;对，session基于cookie来使用的，一般情况下本地的cookie会存储session中的key名，然后通过cookie中的key去获取服务器上存储的信息。</div>\n下面依然以用户登录作为最简单的示例：<br>\n模板还是上面的那两个，这里只重写对应的处理函数<pre name=\"code\" class=\"python\">user_infp ={\n    &quot;fml&quot;:{&quot;password&quot;:&quot;123&quot;}\n}\n\ndef login(request):\n    if request.method == &quot;GET&quot;:\n        return  render(request,&quot;login.html&quot;)\n    if request.method == &quot;POST&quot;:\n        u = request.POST.get(&quot;username&quot;)\n        p = request.POST.get(&quot;password&quot;)\n        dic = user_infp.get(u)\n        if not dic:\n            return render(request,&quot;login.html&quot;)\n        if dic[&quot;password&quot;] == p:\n            res = redirect('/index')\n            request.session['username'] = u\n            request.session[&quot;is_login&quot;] = True\n            return res\n        else:\n            return render(request,&quot;login.html&quot;)\n\ndef index(request):\n    print(request.session[&quot;is_login&quot;])\n    if request.session[&quot;is_login&quot;]:\n        return render(request, 'index.html', {&quot;user&quot;: request.session[&quot;username&quot;]})\n    else:\n        return redirect('/login')</pre>乍一看和cookie的操作类&#20284;，其实这是因为django为我们在后台做了很多工作，例如\n<pre style=\"background-color:#272822; color:#f8f8f2; font-family:'Consolas'; font-size:9.0pt\"><span style=\"color:#fd971f\"><em>request</em></span>.session[<span style=\"color:#e6db74\">'username'</span>] <span style=\"color:#f92672\">= </span>u\n<span style=\"color:#fd971f\"><em>request</em></span>.session[<span style=\"color:#e6db74\">&quot;is_login&quot;</span>] <span style=\"color:#f92672\">= </span><span style=\"color:#66d9ef\"><em>True</em></span></pre>\n这两句就很简单的完成了session的创建，实际上django首先生成了一串随机字符串用来作为key并将这个随机字符串保存到本地的cookie中，然后在将后面的两个内容以字典的形式存到服务器端，django中默认session存储在数据库中。\n<p></p>\n<p></p>\n<pre style=\"background-color:#272822; color:#f8f8f2; font-family:'Consolas'; font-size:9.0pt\"><span style=\"color:#fd971f\"><em>request</em></span>.session[<span style=\"color:#e6db74\">&quot;is_login&quot;</span>]<span style=\"color:#f92672\">:</span></pre>\n这一步首先从cookie中回去对应的key，然后再从数据库中获取对应的value进行判断<br>\n同样的session和cookie一样也有一些高级功能，例如设置超时时间<br>\n<pre name=\"code\" class=\"python\">request.session.set_expiry(value)\n            * 如果value是个整数，session会在些秒数后失效。\n            * 如果value是个datatime或timedelta，session就会在这个时间后失效。\n            * 如果value是0,用户关闭浏览器session就会失效。\n            * 如果value是None,session会依赖全局session失效策略。</pre>\n<p></p>\n<p>除了超时时间设置还有一下功能：</p>\n<p><pre name=\"code\" class=\"python\">        # 获取、设置、删除Session中数据\n        request.session['k1']\n        request.session.get('k1',None)\n        request.session['k1'] = 123\n        request.session.setdefault('k1',123) # 存在则不设置\n        del request.session['k1']\n \n        # 所有 键、值、键值对\n        request.session.keys()\n        request.session.values()\n        request.session.items()\n        request.session.iterkeys()\n        request.session.itervalues()\n        request.session.iteritems()\n \n \n        # 用户session的随机字符串\n        request.session.session_key\n \n        # 将所有Session失效日期小于当前日期的数据删除\n        request.session.clear_expired()\n \n        # 检查 用户session的随机字符串 在数据库中是否\n        request.session.exists(&quot;session_key&quot;)\n \n        # 删除当前用户的所有Session数据\n        request.session.delete(&quot;session_key&quot;)</pre><br>\n</p>\n在django中session共有5种方式来存储：数据库、缓存、文件、缓存加数据库、加密cookie，但是都需要我们在settings里面设置，下面就是每种的配置方式\n<p><pre name=\"code\" class=\"python\">#数据库配置\n\nSESSION_ENGINE = 'django.contrib.sessions.backends.db'  # 引擎（默认）\n\nSESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）\nSESSION_COOKIE_PATH ＝ &quot;/&quot;  # Session的cookie保存的路径（默认）\nSESSION_COOKIE_DOMAIN = None  # Session的cookie保存的域名（默认）\nSESSION_COOKIE_SECURE = False  # 是否Https传输cookie（默认）\nSESSION_COOKIE_HTTPONLY = True  # 是否Session的cookie只支持http传输（默认）\nSESSION_COOKIE_AGE = 1209600  # Session的cookie失效日期（2周）（默认）\nSESSION_EXPIRE_AT_BROWSER_CLOSE = False  # 是否关闭浏览器使得Session过期（默认）\nSESSION_SAVE_EVERY_REQUEST = False  # 是否每次请求都保存Session，默认修改之后才保存（默认）\n\n#缓存配置\nSESSION_ENGINE = 'django.contrib.sessions.backends.cache'  # 引擎\nSESSION_CACHE_ALIAS = 'default'  # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置\n\nSESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串\nSESSION_COOKIE_PATH ＝ &quot;/&quot;  # Session的cookie保存的路径\nSESSION_COOKIE_DOMAIN = None  # Session的cookie保存的域名\nSESSION_COOKIE_SECURE = False  # 是否Https传输cookie\nSESSION_COOKIE_HTTPONLY = True  # 是否Session的cookie只支持http传输\nSESSION_COOKIE_AGE = 1209600  # Session的cookie失效日期（2周）\nSESSION_EXPIRE_AT_BROWSER_CLOSE = False  # 是否关闭浏览器使得Session过期\nSESSION_SAVE_EVERY_REQUEST = False  # 是否每次请求都保存Session，默认修改之后才保存\n\n#文件配置\nSESSION_ENGINE = 'django.contrib.sessions.backends.file'  # 引擎\nSESSION_FILE_PATH = None  # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir()                                                            # 如：/var/folders/d3/j9tj0gz93dg06bmwxmhh6_xm0000gn/T\n\nSESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串\nSESSION_COOKIE_PATH ＝ &quot;/&quot;  # Session的cookie保存的路径\nSESSION_COOKIE_DOMAIN = None  # Session的cookie保存的域名\nSESSION_COOKIE_SECURE = False  # 是否Https传输cookie\nSESSION_COOKIE_HTTPONLY = True  # 是否Session的cookie只支持http传输\nSESSION_COOKIE_AGE = 1209600  # Session的cookie失效日期（2周）\nSESSION_EXPIRE_AT_BROWSER_CLOSE = False  # 是否关闭浏览器使得Session过期\nSESSION_SAVE_EVERY_REQUEST = False  # 是否每次请求都保存Session，默认修改之后才保存\n\n#缓存加数据库（数据库实现持久化，缓存提高效率）\nSESSION_ENGINE = 'django.contrib.sessions.backends.cached_db'        # 引擎\n\n#加密Cookie\nSESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies'   # 引擎</pre><br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n</p>\n<p><br>\n</p>\n","slug":"blogs-cookie和session","published":1,"date":"2022-03-16T17:09:18.485Z","updated":"2022-03-16T17:09:18.485Z","_id":"cl0v6kesk0015yms48bo8919y","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h2>cookie</h2>\n<p>cookie:客户端浏览器上的一个文件（键&#20540;对方式存储，类&#20284;于python中的字典），一般用于记录用户状态、和用户信息的，绝大多数的网站自动登录功能都是基于cookie实现的，下面使用Django实现一个用户登陆作为例子展示。<br>\n</p>\n<p>首先是最简单的登录页面&nbsp;login：</p>\n<pre class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action=&quot;/login/&quot; method=&quot;post&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt;\n    &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\nlogin请求处理函数\n<pre class=\"python\">user_infp ={\n    &quot;fml&quot;:{&quot;password&quot;:&quot;123&quot;}\n}\n\n<p>def login(request):<br>    if request.method == &quot;GET&quot;:<br>        return  render(request,&quot;login.html&quot;)<br>    if request.method == &quot;POST&quot;:<br>        u = request.POST.get(&quot;username&quot;)<br>        p = request.POST.get(&quot;password&quot;)<br>        dic = user_infp.get(u)<br>        if not dic:<br>            return render(request,&quot;login.html&quot;)<br>        if dic[&quot;password&quot;] == p:<br>            res = redirect(‘/index’)<br>            res.set_cookie(&quot;username&quot;,u)<br>            return res<br>        else:<br>            return render(request,&quot;login.html&quot;)</pre><br>当请求为get方式的时候返回登录页面，为post方式的时候验证表单，这里只使用字典来简化从数据库验证的操作。当验证通过的时候跳转到index页面，并且设置一个cookie，内容为｛&quot;username&quot;:username},否则任然返回当前页面。</p>\n<p>index页面：仅仅用来显示登录的用户名</p>\n<pre class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;欢迎&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\n<p>index处理函数：</p>\n<pre class=\"html\">def index(request):\n    user = request.COOKIES.get(&quot;username&quot;)\n    if not user:\n        return redirect('/login')\n    else:\n        return render(request,'index.html',{&quot;user&quot;:user})</pre>\n如果上面我们如果登录成功浏览器会存储一个cookie，当我们再次请求index页面的时候，同时发送过去的还有本地的cookie，所以可以从request中的cookie中获取我们已经存储的用户名，如果不存在则跳转到login页面，如果有登录信息则显示登录页面<img src=\"\" alt=\"\"><br>\n<img src=\"\" alt=\"\"><br>\n<p>以上是最简单的cookie使用，其实cookie还有很多其他的用法</p>\n<p></p>\n<pre class=\"python\">rep = HttpResponse(...) 或 rep ＝ render(request, ...)\n \n<p>rep.set_cookie(key,value,…)<br>rep.set_signed_cookie(key,value,salt=’加密盐’,…)<br>    参数：<br>        key,              键<br>        value=’’,         &#20540;<br>        max_age=None,     超时时间<br>        expires=None,     超时时间(IE requires expires, so set it if hasn’t been already.)<br>        path=’/‘,         Cookie生效的路径，/ 表示根路径，特殊的：跟路径的cookie可以被任何url的页面访问<br>        domain=None,      Cookie生效的域名<br>        secure=False,     https传输<br>        httponly=False    只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖）</pre></p>\n<p><img src=\"\" alt=\"\"><br>\n<img src=\"\" alt=\"\"><br>\n下面再来详细说一说各个参数的作用。<br>\n首先是获取cookie，salt：这个参数的具体作用目前我还是不太清除，猜测是cookie加密操作，等我弄懂了再回来修改。<br>\n<br>\n接下来是设置cookie，key和value不用再说了，<br>\n<strong>max_age:</strong>设置超时时间以秒为单位，很多网站上登录页面都有多长时间免登录的功能一般都是通过这个来设置的，当超过了一段时间这个cookie就会失效<br>\n<span style=\"white-space:pre\"></span><strong>expires</strong>:&nbsp;同样是设置超时时间的，但是和上面的不太一样，这里的单位不是秒，而是datetime,所以就有两种超时时间的设置方法</p>\n<pre class=\"python\">#max_age方法\nres.set_cookie(&quot;username&quot;,u,max_age=10)\n#expires方法\nimport datetime\ncurrent_time = datetime.datetime.utcnow()\nend_time = current_time &#43; datetime.timedelta(seconds=10)\nres.set_cookie(&quot;username&quot;,u,expires=end_time)</pre>\n<span style=\"white-space:pre\"></span><strong>path</strong>:是指定cookie生效的路径，参数默认为 ' / '&nbsp;可被当前网站任意URL页面访问，下面我们重新写一个页面index1，内容和index相同\n<pre class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;这里是index1欢迎&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\nindex1&nbsp;的处理函数\n<pre class=\"python\">def index1(request):\n    user = request.COOKIES.get(&quot;username&quot;)\n    if not user:\n        return HttpResponse(&quot;没有获取到cookie&quot;)\n    else:\n        return render(request,&quot;index1.html&quot;,{&quot;user&quot;:user})</pre>\n<p><br>\n</p>\n这里我们将login函数里面的cookie设置为\n<pre style=\"background-color:#272822; color:#f8f8f2; font-family:Consolas; font-size:9pt\">res.set_cookie(<span style=\"color:#e6db74\">&quot;username&quot;</span><span style=\"color:#cc7832\">,</span>u<span style=\"color:#cc7832\">,</span><span style=\"color:#aa4926\">path</span><span style=\"color:#f92672\">=</span><span style=\"color:#e6db74\">'/index'</span>)</pre>\n然后重新运行登录<img src=\"\" alt=\"\">，这里就能看出在index可以正常获取到cookie，而index1获取不到，path设置成功。\n<p><strong>domain:</strong>设置生效域名，这里只能设置当前域名的子域名，无法给其他域名设置<br>\n<br>\n</p>\n<h2>session</h2>\n<div>和cookie不同的是session是保存在服务器端的键&#20540;对，session基于cookie来使用的，一般情况下本地的cookie会存储session中的key名，然后通过cookie中的key去获取服务器上存储的信息。</div>\n下面依然以用户登录作为最简单的示例：<br>\n模板还是上面的那两个，这里只重写对应的处理函数<pre name=\"code\" class=\"python\">user_infp ={\n    &quot;fml&quot;:{&quot;password&quot;:&quot;123&quot;}\n}\n\n<p>def login(request):<br>    if request.method == &quot;GET&quot;:<br>        return  render(request,&quot;login.html&quot;)<br>    if request.method == &quot;POST&quot;:<br>        u = request.POST.get(&quot;username&quot;)<br>        p = request.POST.get(&quot;password&quot;)<br>        dic = user_infp.get(u)<br>        if not dic:<br>            return render(request,&quot;login.html&quot;)<br>        if dic[&quot;password&quot;] == p:<br>            res = redirect(‘/index’)<br>            request.session[‘username’] = u<br>            request.session[&quot;is_login&quot;] = True<br>            return res<br>        else:<br>            return render(request,&quot;login.html&quot;)</p>\n<p>def index(request):<br>    print(request.session[&quot;is_login&quot;])<br>    if request.session[&quot;is_login&quot;]:<br>        return render(request, ‘index.html’, {&quot;user&quot;: request.session[&quot;username&quot;]})<br>    else:<br>        return redirect(‘/login’)</pre>乍一看和cookie的操作类&#20284;，其实这是因为django为我们在后台做了很多工作，例如</p>\n<pre style=\"background-color:#272822; color:#f8f8f2; font-family:'Consolas'; font-size:9.0pt\"><span style=\"color:#fd971f\"><em>request</em></span>.session[<span style=\"color:#e6db74\">'username'</span>] <span style=\"color:#f92672\">= </span>u\n<span style=\"color:#fd971f\"><em>request</em></span>.session[<span style=\"color:#e6db74\">&quot;is_login&quot;</span>] <span style=\"color:#f92672\">= </span><span style=\"color:#66d9ef\"><em>True</em></span></pre>\n<p>这两句就很简单的完成了session的创建，实际上django首先生成了一串随机字符串用来作为key并将这个随机字符串保存到本地的cookie中，然后在将后面的两个内容以字典的形式存到服务器端，django中默认session存储在数据库中。</p>\n<p></p>\n<p></p>\n<pre style=\"background-color:#272822; color:#f8f8f2; font-family:'Consolas'; font-size:9.0pt\"><span style=\"color:#fd971f\"><em>request</em></span>.session[<span style=\"color:#e6db74\">&quot;is_login&quot;</span>]<span style=\"color:#f92672\">:</span></pre>\n这一步首先从cookie中回去对应的key，然后再从数据库中获取对应的value进行判断<br>\n同样的session和cookie一样也有一些高级功能，例如设置超时时间<br>\n<pre name=\"code\" class=\"python\">request.session.set_expiry(value)\n            * 如果value是个整数，session会在些秒数后失效。\n            * 如果value是个datatime或timedelta，session就会在这个时间后失效。\n            * 如果value是0,用户关闭浏览器session就会失效。\n            * 如果value是None,session会依赖全局session失效策略。</pre>\n<p></p>\n<p>除了超时时间设置还有一下功能：</p>\n<p><pre name=\"code\" class=\"python\">        # 获取、设置、删除Session中数据\n        request.session['k1']\n        request.session.get('k1',None)\n        request.session['k1'] = 123\n        request.session.setdefault('k1',123) # 存在则不设置\n        del request.session['k1']\n \n<pre><code>    # 所有 键、值、键值对\n    request.session.keys()\n    request.session.values()\n    request.session.items()\n    request.session.iterkeys()\n    request.session.itervalues()\n    request.session.iteritems()\n\n\n    # 用户session的随机字符串\n    request.session.session_key\n\n    # 将所有Session失效日期小于当前日期的数据删除\n    request.session.clear_expired()\n\n    # 检查 用户session的随机字符串 在数据库中是否\n    request.session.exists(&amp;quot;session_key&amp;quot;)\n\n    # 删除当前用户的所有Session数据\n    request.session.delete(&amp;quot;session_key&amp;quot;)&lt;/pre&gt;&lt;br&gt;\n</code></pre>\n</p>\n在django中session共有5种方式来存储：数据库、缓存、文件、缓存加数据库、加密cookie，但是都需要我们在settings里面设置，下面就是每种的配置方式\n<p><pre name=\"code\" class=\"python\">#数据库配置\n\n<p>SESSION_ENGINE = ‘django.contrib.sessions.backends.db’  # 引擎（默认）</p>\n<p>SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）<br>SESSION_COOKIE_PATH ＝ &quot;/&quot;  # Session的cookie保存的路径（默认）<br>SESSION_COOKIE_DOMAIN = None  # Session的cookie保存的域名（默认）<br>SESSION_COOKIE_SECURE = False  # 是否Https传输cookie（默认）<br>SESSION_COOKIE_HTTPONLY = True  # 是否Session的cookie只支持http传输（默认）<br>SESSION_COOKIE_AGE = 1209600  # Session的cookie失效日期（2周）（默认）<br>SESSION_EXPIRE_AT_BROWSER_CLOSE = False  # 是否关闭浏览器使得Session过期（默认）<br>SESSION_SAVE_EVERY_REQUEST = False  # 是否每次请求都保存Session，默认修改之后才保存（默认）</p>\n<p>#缓存配置<br>SESSION_ENGINE = ‘django.contrib.sessions.backends.cache’  # 引擎<br>SESSION_CACHE_ALIAS = ‘default’  # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置</p>\n<p>SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串<br>SESSION_COOKIE_PATH ＝ &quot;/&quot;  # Session的cookie保存的路径<br>SESSION_COOKIE_DOMAIN = None  # Session的cookie保存的域名<br>SESSION_COOKIE_SECURE = False  # 是否Https传输cookie<br>SESSION_COOKIE_HTTPONLY = True  # 是否Session的cookie只支持http传输<br>SESSION_COOKIE_AGE = 1209600  # Session的cookie失效日期（2周）<br>SESSION_EXPIRE_AT_BROWSER_CLOSE = False  # 是否关闭浏览器使得Session过期<br>SESSION_SAVE_EVERY_REQUEST = False  # 是否每次请求都保存Session，默认修改之后才保存</p>\n<p>#文件配置<br>SESSION_ENGINE = ‘django.contrib.sessions.backends.file’  # 引擎<br>SESSION_FILE_PATH = None  # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir()                                                            # 如：/var/folders/d3/j9tj0gz93dg06bmwxmhh6_xm0000gn/T</p>\n<p>SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串<br>SESSION_COOKIE_PATH ＝ &quot;/&quot;  # Session的cookie保存的路径<br>SESSION_COOKIE_DOMAIN = None  # Session的cookie保存的域名<br>SESSION_COOKIE_SECURE = False  # 是否Https传输cookie<br>SESSION_COOKIE_HTTPONLY = True  # 是否Session的cookie只支持http传输<br>SESSION_COOKIE_AGE = 1209600  # Session的cookie失效日期（2周）<br>SESSION_EXPIRE_AT_BROWSER_CLOSE = False  # 是否关闭浏览器使得Session过期<br>SESSION_SAVE_EVERY_REQUEST = False  # 是否每次请求都保存Session，默认修改之后才保存</p>\n<p>#缓存加数据库（数据库实现持久化，缓存提高效率）<br>SESSION_ENGINE = ‘django.contrib.sessions.backends.cached_db’        # 引擎</p>\n<p>#加密Cookie<br>SESSION_ENGINE = ‘django.contrib.sessions.backends.signed_cookies’   # 引擎</pre><br><br><br><br><br><br><br><br><br><br><br><br><br></p>\n</p>\n<p><br>\n</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>cookie</h2>\n<p>cookie:客户端浏览器上的一个文件（键&#20540;对方式存储，类&#20284;于python中的字典），一般用于记录用户状态、和用户信息的，绝大多数的网站自动登录功能都是基于cookie实现的，下面使用Django实现一个用户登陆作为例子展示。<br>\n</p>\n<p>首先是最简单的登录页面&nbsp;login：</p>\n<pre class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;form action=&quot;/login/&quot; method=&quot;post&quot;&gt;\n    &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt;\n    &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt;\n    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\nlogin请求处理函数\n<pre class=\"python\">user_infp ={\n    &quot;fml&quot;:{&quot;password&quot;:&quot;123&quot;}\n}\n\n<p>def login(request):<br>    if request.method == &quot;GET&quot;:<br>        return  render(request,&quot;login.html&quot;)<br>    if request.method == &quot;POST&quot;:<br>        u = request.POST.get(&quot;username&quot;)<br>        p = request.POST.get(&quot;password&quot;)<br>        dic = user_infp.get(u)<br>        if not dic:<br>            return render(request,&quot;login.html&quot;)<br>        if dic[&quot;password&quot;] == p:<br>            res = redirect(‘/index’)<br>            res.set_cookie(&quot;username&quot;,u)<br>            return res<br>        else:<br>            return render(request,&quot;login.html&quot;)</pre><br>当请求为get方式的时候返回登录页面，为post方式的时候验证表单，这里只使用字典来简化从数据库验证的操作。当验证通过的时候跳转到index页面，并且设置一个cookie，内容为｛&quot;username&quot;:username},否则任然返回当前页面。</p>\n<p>index页面：仅仅用来显示登录的用户名</p>\n<pre class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;欢迎&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\n<p>index处理函数：</p>\n<pre class=\"html\">def index(request):\n    user = request.COOKIES.get(&quot;username&quot;)\n    if not user:\n        return redirect('/login')\n    else:\n        return render(request,'index.html',{&quot;user&quot;:user})</pre>\n如果上面我们如果登录成功浏览器会存储一个cookie，当我们再次请求index页面的时候，同时发送过去的还有本地的cookie，所以可以从request中的cookie中获取我们已经存储的用户名，如果不存在则跳转到login页面，如果有登录信息则显示登录页面<img src=\"\" alt=\"\"><br>\n<img src=\"\" alt=\"\"><br>\n<p>以上是最简单的cookie使用，其实cookie还有很多其他的用法</p>\n<p></p>\n<pre class=\"python\">rep = HttpResponse(...) 或 rep ＝ render(request, ...)\n \n<p>rep.set_cookie(key,value,…)<br>rep.set_signed_cookie(key,value,salt=’加密盐’,…)<br>    参数：<br>        key,              键<br>        value=’’,         &#20540;<br>        max_age=None,     超时时间<br>        expires=None,     超时时间(IE requires expires, so set it if hasn’t been already.)<br>        path=’/‘,         Cookie生效的路径，/ 表示根路径，特殊的：跟路径的cookie可以被任何url的页面访问<br>        domain=None,      Cookie生效的域名<br>        secure=False,     https传输<br>        httponly=False    只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖）</pre></p>\n<p><img src=\"\" alt=\"\"><br>\n<img src=\"\" alt=\"\"><br>\n下面再来详细说一说各个参数的作用。<br>\n首先是获取cookie，salt：这个参数的具体作用目前我还是不太清除，猜测是cookie加密操作，等我弄懂了再回来修改。<br>\n<br>\n接下来是设置cookie，key和value不用再说了，<br>\n<strong>max_age:</strong>设置超时时间以秒为单位，很多网站上登录页面都有多长时间免登录的功能一般都是通过这个来设置的，当超过了一段时间这个cookie就会失效<br>\n<span style=\"white-space:pre\"></span><strong>expires</strong>:&nbsp;同样是设置超时时间的，但是和上面的不太一样，这里的单位不是秒，而是datetime,所以就有两种超时时间的设置方法</p>\n<pre class=\"python\">#max_age方法\nres.set_cookie(&quot;username&quot;,u,max_age=10)\n#expires方法\nimport datetime\ncurrent_time = datetime.datetime.utcnow()\nend_time = current_time &#43; datetime.timedelta(seconds=10)\nres.set_cookie(&quot;username&quot;,u,expires=end_time)</pre>\n<span style=\"white-space:pre\"></span><strong>path</strong>:是指定cookie生效的路径，参数默认为 ' / '&nbsp;可被当前网站任意URL页面访问，下面我们重新写一个页面index1，内容和index相同\n<pre class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;这里是index1欢迎&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</pre>\nindex1&nbsp;的处理函数\n<pre class=\"python\">def index1(request):\n    user = request.COOKIES.get(&quot;username&quot;)\n    if not user:\n        return HttpResponse(&quot;没有获取到cookie&quot;)\n    else:\n        return render(request,&quot;index1.html&quot;,{&quot;user&quot;:user})</pre>\n<p><br>\n</p>\n这里我们将login函数里面的cookie设置为\n<pre style=\"background-color:#272822; color:#f8f8f2; font-family:Consolas; font-size:9pt\">res.set_cookie(<span style=\"color:#e6db74\">&quot;username&quot;</span><span style=\"color:#cc7832\">,</span>u<span style=\"color:#cc7832\">,</span><span style=\"color:#aa4926\">path</span><span style=\"color:#f92672\">=</span><span style=\"color:#e6db74\">'/index'</span>)</pre>\n然后重新运行登录<img src=\"\" alt=\"\">，这里就能看出在index可以正常获取到cookie，而index1获取不到，path设置成功。\n<p><strong>domain:</strong>设置生效域名，这里只能设置当前域名的子域名，无法给其他域名设置<br>\n<br>\n</p>\n<h2>session</h2>\n<div>和cookie不同的是session是保存在服务器端的键&#20540;对，session基于cookie来使用的，一般情况下本地的cookie会存储session中的key名，然后通过cookie中的key去获取服务器上存储的信息。</div>\n下面依然以用户登录作为最简单的示例：<br>\n模板还是上面的那两个，这里只重写对应的处理函数<pre name=\"code\" class=\"python\">user_infp ={\n    &quot;fml&quot;:{&quot;password&quot;:&quot;123&quot;}\n}\n\n<p>def login(request):<br>    if request.method == &quot;GET&quot;:<br>        return  render(request,&quot;login.html&quot;)<br>    if request.method == &quot;POST&quot;:<br>        u = request.POST.get(&quot;username&quot;)<br>        p = request.POST.get(&quot;password&quot;)<br>        dic = user_infp.get(u)<br>        if not dic:<br>            return render(request,&quot;login.html&quot;)<br>        if dic[&quot;password&quot;] == p:<br>            res = redirect(‘/index’)<br>            request.session[‘username’] = u<br>            request.session[&quot;is_login&quot;] = True<br>            return res<br>        else:<br>            return render(request,&quot;login.html&quot;)</p>\n<p>def index(request):<br>    print(request.session[&quot;is_login&quot;])<br>    if request.session[&quot;is_login&quot;]:<br>        return render(request, ‘index.html’, {&quot;user&quot;: request.session[&quot;username&quot;]})<br>    else:<br>        return redirect(‘/login’)</pre>乍一看和cookie的操作类&#20284;，其实这是因为django为我们在后台做了很多工作，例如</p>\n<pre style=\"background-color:#272822; color:#f8f8f2; font-family:'Consolas'; font-size:9.0pt\"><span style=\"color:#fd971f\"><em>request</em></span>.session[<span style=\"color:#e6db74\">'username'</span>] <span style=\"color:#f92672\">= </span>u\n<span style=\"color:#fd971f\"><em>request</em></span>.session[<span style=\"color:#e6db74\">&quot;is_login&quot;</span>] <span style=\"color:#f92672\">= </span><span style=\"color:#66d9ef\"><em>True</em></span></pre>\n<p>这两句就很简单的完成了session的创建，实际上django首先生成了一串随机字符串用来作为key并将这个随机字符串保存到本地的cookie中，然后在将后面的两个内容以字典的形式存到服务器端，django中默认session存储在数据库中。</p>\n<p></p>\n<p></p>\n<pre style=\"background-color:#272822; color:#f8f8f2; font-family:'Consolas'; font-size:9.0pt\"><span style=\"color:#fd971f\"><em>request</em></span>.session[<span style=\"color:#e6db74\">&quot;is_login&quot;</span>]<span style=\"color:#f92672\">:</span></pre>\n这一步首先从cookie中回去对应的key，然后再从数据库中获取对应的value进行判断<br>\n同样的session和cookie一样也有一些高级功能，例如设置超时时间<br>\n<pre name=\"code\" class=\"python\">request.session.set_expiry(value)\n            * 如果value是个整数，session会在些秒数后失效。\n            * 如果value是个datatime或timedelta，session就会在这个时间后失效。\n            * 如果value是0,用户关闭浏览器session就会失效。\n            * 如果value是None,session会依赖全局session失效策略。</pre>\n<p></p>\n<p>除了超时时间设置还有一下功能：</p>\n<p><pre name=\"code\" class=\"python\">        # 获取、设置、删除Session中数据\n        request.session['k1']\n        request.session.get('k1',None)\n        request.session['k1'] = 123\n        request.session.setdefault('k1',123) # 存在则不设置\n        del request.session['k1']\n \n<pre><code>    # 所有 键、值、键值对\n    request.session.keys()\n    request.session.values()\n    request.session.items()\n    request.session.iterkeys()\n    request.session.itervalues()\n    request.session.iteritems()\n\n\n    # 用户session的随机字符串\n    request.session.session_key\n\n    # 将所有Session失效日期小于当前日期的数据删除\n    request.session.clear_expired()\n\n    # 检查 用户session的随机字符串 在数据库中是否\n    request.session.exists(&amp;quot;session_key&amp;quot;)\n\n    # 删除当前用户的所有Session数据\n    request.session.delete(&amp;quot;session_key&amp;quot;)&lt;/pre&gt;&lt;br&gt;\n</code></pre>\n</p>\n在django中session共有5种方式来存储：数据库、缓存、文件、缓存加数据库、加密cookie，但是都需要我们在settings里面设置，下面就是每种的配置方式\n<p><pre name=\"code\" class=\"python\">#数据库配置\n\n<p>SESSION_ENGINE = ‘django.contrib.sessions.backends.db’  # 引擎（默认）</p>\n<p>SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）<br>SESSION_COOKIE_PATH ＝ &quot;/&quot;  # Session的cookie保存的路径（默认）<br>SESSION_COOKIE_DOMAIN = None  # Session的cookie保存的域名（默认）<br>SESSION_COOKIE_SECURE = False  # 是否Https传输cookie（默认）<br>SESSION_COOKIE_HTTPONLY = True  # 是否Session的cookie只支持http传输（默认）<br>SESSION_COOKIE_AGE = 1209600  # Session的cookie失效日期（2周）（默认）<br>SESSION_EXPIRE_AT_BROWSER_CLOSE = False  # 是否关闭浏览器使得Session过期（默认）<br>SESSION_SAVE_EVERY_REQUEST = False  # 是否每次请求都保存Session，默认修改之后才保存（默认）</p>\n<p>#缓存配置<br>SESSION_ENGINE = ‘django.contrib.sessions.backends.cache’  # 引擎<br>SESSION_CACHE_ALIAS = ‘default’  # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置</p>\n<p>SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串<br>SESSION_COOKIE_PATH ＝ &quot;/&quot;  # Session的cookie保存的路径<br>SESSION_COOKIE_DOMAIN = None  # Session的cookie保存的域名<br>SESSION_COOKIE_SECURE = False  # 是否Https传输cookie<br>SESSION_COOKIE_HTTPONLY = True  # 是否Session的cookie只支持http传输<br>SESSION_COOKIE_AGE = 1209600  # Session的cookie失效日期（2周）<br>SESSION_EXPIRE_AT_BROWSER_CLOSE = False  # 是否关闭浏览器使得Session过期<br>SESSION_SAVE_EVERY_REQUEST = False  # 是否每次请求都保存Session，默认修改之后才保存</p>\n<p>#文件配置<br>SESSION_ENGINE = ‘django.contrib.sessions.backends.file’  # 引擎<br>SESSION_FILE_PATH = None  # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir()                                                            # 如：/var/folders/d3/j9tj0gz93dg06bmwxmhh6_xm0000gn/T</p>\n<p>SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串<br>SESSION_COOKIE_PATH ＝ &quot;/&quot;  # Session的cookie保存的路径<br>SESSION_COOKIE_DOMAIN = None  # Session的cookie保存的域名<br>SESSION_COOKIE_SECURE = False  # 是否Https传输cookie<br>SESSION_COOKIE_HTTPONLY = True  # 是否Session的cookie只支持http传输<br>SESSION_COOKIE_AGE = 1209600  # Session的cookie失效日期（2周）<br>SESSION_EXPIRE_AT_BROWSER_CLOSE = False  # 是否关闭浏览器使得Session过期<br>SESSION_SAVE_EVERY_REQUEST = False  # 是否每次请求都保存Session，默认修改之后才保存</p>\n<p>#缓存加数据库（数据库实现持久化，缓存提高效率）<br>SESSION_ENGINE = ‘django.contrib.sessions.backends.cached_db’        # 引擎</p>\n<p>#加密Cookie<br>SESSION_ENGINE = ‘django.contrib.sessions.backends.signed_cookies’   # 引擎</pre><br><br><br><br><br><br><br><br><br><br><br><br><br></p>\n</p>\n<p><br>\n</p>\n"},{"_content":"<p>之前使用vue构建的前端页面每次加载都需要十几秒的时间，最初的时候因为浏览器有缓存一直没有发现这个问题，后来换用设备访问的时候才发现。不想花费太多的时间去优化vue的代码，感觉作用不大，毕竟服务器带宽只有1M，再怎么压缩文件大小都需要很长时间传输，所以使用CDN去加速静态资源</p>\n\n<p>先看一下之前的加载速度，简直惨不忍睹<img alt=\"\" class=\"has\" height=\"69\" src=\"https://img-blog.csdnimg.cn/20181217200021726.png\" width=\"850\" /></p>\n\n<p>首先需要在云服务商那购买CDN服务，我的服务器是腾讯云的正好腾讯云也有免费的CDN可以试用，购买环节跳过。</p>\n\n<p>要使用CDN服务首先需要在域名管理处添加域名：</p>\n\n<p><img alt=\"\" class=\"has\" height=\"103\" src=\"https://img-blog.csdnimg.cn/20181217200522978.png\" width=\"800\" /></p>\n\n<p>域名配置需要按照自己的服务器填写，加速服务的配置看自己的需求了，一般来说选择css、js、和图片资源就够了<img alt=\"\" class=\"has\" height=\"407\" src=\"https://img-blog.csdnimg.cn/20181217200806211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"700\" /></p>\n\n<p>提交配置等待几分钟后在域名管理处查看CNAME<img alt=\"\" class=\"has\" height=\"61\" src=\"https://img-blog.csdnimg.cn/20181217201433716.png\" width=\"850\" /></p>\n\n<p>接下来需要配置DNS解析服务<br />\n在开启的时候如果出现冲突，按照提示关闭另外的一个即可<br /><img alt=\"\" class=\"has\" height=\"56\" src=\"https://img-blog.csdnimg.cn/20181217201655175.png\" width=\"850\" /></p>\n\n<p>至此CDN的配置完成了，如果访问还是很慢先去CDN刷新缓存检查一下</p>\n\n<p>最后的成果：1.16秒</p>\n\n<p><img alt=\"\" class=\"has\" height=\"106\" src=\"https://img-blog.csdnimg.cn/20181217202537753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"850\" /></p>\n\n<p> </p>","source":"_posts/blogs-使用CDN优化首页加载速度.md","raw":"<p>之前使用vue构建的前端页面每次加载都需要十几秒的时间，最初的时候因为浏览器有缓存一直没有发现这个问题，后来换用设备访问的时候才发现。不想花费太多的时间去优化vue的代码，感觉作用不大，毕竟服务器带宽只有1M，再怎么压缩文件大小都需要很长时间传输，所以使用CDN去加速静态资源</p>\n\n<p>先看一下之前的加载速度，简直惨不忍睹<img alt=\"\" class=\"has\" height=\"69\" src=\"https://img-blog.csdnimg.cn/20181217200021726.png\" width=\"850\" /></p>\n\n<p>首先需要在云服务商那购买CDN服务，我的服务器是腾讯云的正好腾讯云也有免费的CDN可以试用，购买环节跳过。</p>\n\n<p>要使用CDN服务首先需要在域名管理处添加域名：</p>\n\n<p><img alt=\"\" class=\"has\" height=\"103\" src=\"https://img-blog.csdnimg.cn/20181217200522978.png\" width=\"800\" /></p>\n\n<p>域名配置需要按照自己的服务器填写，加速服务的配置看自己的需求了，一般来说选择css、js、和图片资源就够了<img alt=\"\" class=\"has\" height=\"407\" src=\"https://img-blog.csdnimg.cn/20181217200806211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"700\" /></p>\n\n<p>提交配置等待几分钟后在域名管理处查看CNAME<img alt=\"\" class=\"has\" height=\"61\" src=\"https://img-blog.csdnimg.cn/20181217201433716.png\" width=\"850\" /></p>\n\n<p>接下来需要配置DNS解析服务<br />\n在开启的时候如果出现冲突，按照提示关闭另外的一个即可<br /><img alt=\"\" class=\"has\" height=\"56\" src=\"https://img-blog.csdnimg.cn/20181217201655175.png\" width=\"850\" /></p>\n\n<p>至此CDN的配置完成了，如果访问还是很慢先去CDN刷新缓存检查一下</p>\n\n<p>最后的成果：1.16秒</p>\n\n<p><img alt=\"\" class=\"has\" height=\"106\" src=\"https://img-blog.csdnimg.cn/20181217202537753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"850\" /></p>\n\n<p> </p>","slug":"blogs-使用CDN优化首页加载速度","published":1,"date":"2022-03-16T17:00:50.878Z","updated":"2022-03-16T17:05:40.196Z","_id":"cl0v6kesl0016yms44xmt4jer","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>之前使用vue构建的前端页面每次加载都需要十几秒的时间，最初的时候因为浏览器有缓存一直没有发现这个问题，后来换用设备访问的时候才发现。不想花费太多的时间去优化vue的代码，感觉作用不大，毕竟服务器带宽只有1M，再怎么压缩文件大小都需要很长时间传输，所以使用CDN去加速静态资源</p>\n\n<p>先看一下之前的加载速度，简直惨不忍睹<img alt=\"\" class=\"has\" height=\"69\" src=\"https://img-blog.csdnimg.cn/20181217200021726.png\" width=\"850\" /></p>\n\n<p>首先需要在云服务商那购买CDN服务，我的服务器是腾讯云的正好腾讯云也有免费的CDN可以试用，购买环节跳过。</p>\n\n<p>要使用CDN服务首先需要在域名管理处添加域名：</p>\n\n<p><img alt=\"\" class=\"has\" height=\"103\" src=\"https://img-blog.csdnimg.cn/20181217200522978.png\" width=\"800\" /></p>\n\n<p>域名配置需要按照自己的服务器填写，加速服务的配置看自己的需求了，一般来说选择css、js、和图片资源就够了<img alt=\"\" class=\"has\" height=\"407\" src=\"https://img-blog.csdnimg.cn/20181217200806211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"700\" /></p>\n\n<p>提交配置等待几分钟后在域名管理处查看CNAME<img alt=\"\" class=\"has\" height=\"61\" src=\"https://img-blog.csdnimg.cn/20181217201433716.png\" width=\"850\" /></p>\n\n<p>接下来需要配置DNS解析服务<br />\n在开启的时候如果出现冲突，按照提示关闭另外的一个即可<br /><img alt=\"\" class=\"has\" height=\"56\" src=\"https://img-blog.csdnimg.cn/20181217201655175.png\" width=\"850\" /></p>\n\n<p>至此CDN的配置完成了，如果访问还是很慢先去CDN刷新缓存检查一下</p>\n\n<p>最后的成果：1.16秒</p>\n\n<p><img alt=\"\" class=\"has\" height=\"106\" src=\"https://img-blog.csdnimg.cn/20181217202537753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"850\" /></p>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<p>之前使用vue构建的前端页面每次加载都需要十几秒的时间，最初的时候因为浏览器有缓存一直没有发现这个问题，后来换用设备访问的时候才发现。不想花费太多的时间去优化vue的代码，感觉作用不大，毕竟服务器带宽只有1M，再怎么压缩文件大小都需要很长时间传输，所以使用CDN去加速静态资源</p>\n\n<p>先看一下之前的加载速度，简直惨不忍睹<img alt=\"\" class=\"has\" height=\"69\" src=\"https://img-blog.csdnimg.cn/20181217200021726.png\" width=\"850\" /></p>\n\n<p>首先需要在云服务商那购买CDN服务，我的服务器是腾讯云的正好腾讯云也有免费的CDN可以试用，购买环节跳过。</p>\n\n<p>要使用CDN服务首先需要在域名管理处添加域名：</p>\n\n<p><img alt=\"\" class=\"has\" height=\"103\" src=\"https://img-blog.csdnimg.cn/20181217200522978.png\" width=\"800\" /></p>\n\n<p>域名配置需要按照自己的服务器填写，加速服务的配置看自己的需求了，一般来说选择css、js、和图片资源就够了<img alt=\"\" class=\"has\" height=\"407\" src=\"https://img-blog.csdnimg.cn/20181217200806211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"700\" /></p>\n\n<p>提交配置等待几分钟后在域名管理处查看CNAME<img alt=\"\" class=\"has\" height=\"61\" src=\"https://img-blog.csdnimg.cn/20181217201433716.png\" width=\"850\" /></p>\n\n<p>接下来需要配置DNS解析服务<br />\n在开启的时候如果出现冲突，按照提示关闭另外的一个即可<br /><img alt=\"\" class=\"has\" height=\"56\" src=\"https://img-blog.csdnimg.cn/20181217201655175.png\" width=\"850\" /></p>\n\n<p>至此CDN的配置完成了，如果访问还是很慢先去CDN刷新缓存检查一下</p>\n\n<p>最后的成果：1.16秒</p>\n\n<p><img alt=\"\" class=\"has\" height=\"106\" src=\"https://img-blog.csdnimg.cn/20181217202537753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"850\" /></p>\n\n<p> </p>"},{"_content":"\n<p>列表是python中常用的一种数据结构，能够存放任意的其他数据类型，int、str、list 、tuple等，但是最近发现了一个问题，代码如下</p>\n<pre class=\"python\">data = []\nbuff = dict()\nfor i in range(5):\n    buff['d'] = i\n    data.append(buff)\nprint(data)</pre>\n<p>原本以为打印的结果会是</p>\n<p>[{'d':0},{'d':1},{'d':2},{'d':3},{'d':4}]</p>\n<p>但是最终的结果为<img src=\"\" alt=\"\"><img src=\"\" alt=\"\"></p>\n<p>[{'d':4},{'d':4},{'d':4},{'d':4},{'d':4}]<br>\n</p>\n<p><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"></p>\n<p>最后发现其实当我们使用列表存储数据的时候，只是把数据的内存地址给存入列表中了而不是数据本身，所以上面的代码就不难理解我们只是在data列表中存了5个buff的内存地址，而且这5个内存地址是指向同一个数据的，当运行到最后一个循环的时候buff里面的数据就变为{'d':4},所以data最后的结果就是5个相同的内容。</p>\n<p>弄清楚了上面的问题，我们可以做以下更改来实现我们的目的</p>\n<pre class=\"html\">data = []\nbuff = dict()\nfor i in range(5):\n    buff['d'] = i\n    data.append(buff)\n    buff = dict()\nprint(data)</pre>\n<p>最终的结果如下<img src=\"\" alt=\"\"><img src=\"\" alt=\"\"></p>\n<p>[{'d':0},{'d':1},{'d':2},{'d':3},{'d':4}],</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>因为我们在append之后相当于新建了一个空字典，buff不再指向之前的内存地址了，在下次循环的时候会将数据存档在新的内存空间里面，而列表中其实是存了5个不同的内存地址。</p>\n<p>总结：</p>\n<p>列表并不是直接存放数据对象本身，而是存放数据对象的内存地址，如果内存地址对应的内容被修改了那么列表也会被更改掉。</p>\n","source":"_posts/blogs-列表中的陷阱.md","raw":"\n<p>列表是python中常用的一种数据结构，能够存放任意的其他数据类型，int、str、list 、tuple等，但是最近发现了一个问题，代码如下</p>\n<pre class=\"python\">data = []\nbuff = dict()\nfor i in range(5):\n    buff['d'] = i\n    data.append(buff)\nprint(data)</pre>\n<p>原本以为打印的结果会是</p>\n<p>[{'d':0},{'d':1},{'d':2},{'d':3},{'d':4}]</p>\n<p>但是最终的结果为<img src=\"\" alt=\"\"><img src=\"\" alt=\"\"></p>\n<p>[{'d':4},{'d':4},{'d':4},{'d':4},{'d':4}]<br>\n</p>\n<p><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"></p>\n<p>最后发现其实当我们使用列表存储数据的时候，只是把数据的内存地址给存入列表中了而不是数据本身，所以上面的代码就不难理解我们只是在data列表中存了5个buff的内存地址，而且这5个内存地址是指向同一个数据的，当运行到最后一个循环的时候buff里面的数据就变为{'d':4},所以data最后的结果就是5个相同的内容。</p>\n<p>弄清楚了上面的问题，我们可以做以下更改来实现我们的目的</p>\n<pre class=\"html\">data = []\nbuff = dict()\nfor i in range(5):\n    buff['d'] = i\n    data.append(buff)\n    buff = dict()\nprint(data)</pre>\n<p>最终的结果如下<img src=\"\" alt=\"\"><img src=\"\" alt=\"\"></p>\n<p>[{'d':0},{'d':1},{'d':2},{'d':3},{'d':4}],</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>因为我们在append之后相当于新建了一个空字典，buff不再指向之前的内存地址了，在下次循环的时候会将数据存档在新的内存空间里面，而列表中其实是存了5个不同的内存地址。</p>\n<p>总结：</p>\n<p>列表并不是直接存放数据对象本身，而是存放数据对象的内存地址，如果内存地址对应的内容被修改了那么列表也会被更改掉。</p>\n","slug":"blogs-列表中的陷阱","published":1,"date":"2022-03-16T17:09:20.828Z","updated":"2022-03-16T17:09:20.829Z","_id":"cl0v6kesl0017yms445xsaxy9","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>列表是python中常用的一种数据结构，能够存放任意的其他数据类型，int、str、list 、tuple等，但是最近发现了一个问题，代码如下</p>\n<pre class=\"python\">data = []\nbuff = dict()\nfor i in range(5):\n    buff['d'] = i\n    data.append(buff)\nprint(data)</pre>\n<p>原本以为打印的结果会是</p>\n<p>[{'d':0},{'d':1},{'d':2},{'d':3},{'d':4}]</p>\n<p>但是最终的结果为<img src=\"\" alt=\"\"><img src=\"\" alt=\"\"></p>\n<p>[{'d':4},{'d':4},{'d':4},{'d':4},{'d':4}]<br>\n</p>\n<p><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"></p>\n<p>最后发现其实当我们使用列表存储数据的时候，只是把数据的内存地址给存入列表中了而不是数据本身，所以上面的代码就不难理解我们只是在data列表中存了5个buff的内存地址，而且这5个内存地址是指向同一个数据的，当运行到最后一个循环的时候buff里面的数据就变为{'d':4},所以data最后的结果就是5个相同的内容。</p>\n<p>弄清楚了上面的问题，我们可以做以下更改来实现我们的目的</p>\n<pre class=\"html\">data = []\nbuff = dict()\nfor i in range(5):\n    buff['d'] = i\n    data.append(buff)\n    buff = dict()\nprint(data)</pre>\n<p>最终的结果如下<img src=\"\" alt=\"\"><img src=\"\" alt=\"\"></p>\n<p>[{'d':0},{'d':1},{'d':2},{'d':3},{'d':4}],</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>因为我们在append之后相当于新建了一个空字典，buff不再指向之前的内存地址了，在下次循环的时候会将数据存档在新的内存空间里面，而列表中其实是存了5个不同的内存地址。</p>\n<p>总结：</p>\n<p>列表并不是直接存放数据对象本身，而是存放数据对象的内存地址，如果内存地址对应的内容被修改了那么列表也会被更改掉。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>列表是python中常用的一种数据结构，能够存放任意的其他数据类型，int、str、list 、tuple等，但是最近发现了一个问题，代码如下</p>\n<pre class=\"python\">data = []\nbuff = dict()\nfor i in range(5):\n    buff['d'] = i\n    data.append(buff)\nprint(data)</pre>\n<p>原本以为打印的结果会是</p>\n<p>[{'d':0},{'d':1},{'d':2},{'d':3},{'d':4}]</p>\n<p>但是最终的结果为<img src=\"\" alt=\"\"><img src=\"\" alt=\"\"></p>\n<p>[{'d':4},{'d':4},{'d':4},{'d':4},{'d':4}]<br>\n</p>\n<p><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"><img src=\"\" alt=\"\"></p>\n<p>最后发现其实当我们使用列表存储数据的时候，只是把数据的内存地址给存入列表中了而不是数据本身，所以上面的代码就不难理解我们只是在data列表中存了5个buff的内存地址，而且这5个内存地址是指向同一个数据的，当运行到最后一个循环的时候buff里面的数据就变为{'d':4},所以data最后的结果就是5个相同的内容。</p>\n<p>弄清楚了上面的问题，我们可以做以下更改来实现我们的目的</p>\n<pre class=\"html\">data = []\nbuff = dict()\nfor i in range(5):\n    buff['d'] = i\n    data.append(buff)\n    buff = dict()\nprint(data)</pre>\n<p>最终的结果如下<img src=\"\" alt=\"\"><img src=\"\" alt=\"\"></p>\n<p>[{'d':0},{'d':1},{'d':2},{'d':3},{'d':4}],</p>\n<p><img src=\"\" alt=\"\"></p>\n<p>因为我们在append之后相当于新建了一个空字典，buff不再指向之前的内存地址了，在下次循环的时候会将数据存档在新的内存空间里面，而列表中其实是存了5个不同的内存地址。</p>\n<p>总结：</p>\n<p>列表并不是直接存放数据对象本身，而是存放数据对象的内存地址，如果内存地址对应的内容被修改了那么列表也会被更改掉。</p>\n"},{"_content":"<p style=\"text-indent:50px;\">微信小程序不支持Cookie的，所以为了保存用户登录状态就必须换一个方式实现，这里采用jwt的方式，关于jwt简单来说就是第一次登录验证成功后对想要保存的信息进行加密，然后将加密过后的内容返回给前端，前端每次请求的时候都携带上这个token，后端拿到token后对其解密就能获取之前保存的信息了。</p>\n\n<h3 style=\"text-indent:0px;\">整体流程：</h3>\n\n<p style=\"text-indent:0;\">这里先看一下小程序官方给的登录流程，这只是最基础的流程，根据设计需要我们还需要添加自己的逻辑进去<br /><img alt=\"\" class=\"has\" height=\"600\" src=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/image/api-login.jpg?t=19031915\" width=\"800\" /></p>\n\n<p style=\"text-indent:0;\">下面是具体的流程图，接下来会根据这个流程图具体看看小程序端和后端应该怎么实现。<br /><img alt=\"\" class=\"has\" height=\"717\" src=\"https://img-blog.csdnimg.cn/20190319205346244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"800\" /></p>\n\n<h3 style=\"text-indent:0px;\">小程序的具体实现</h3>\n\n<p style=\"text-indent:0;\">以index页面为起始页面，当页面进行加载的时候会调用onload函数，所以可以在onload函数中检测storage中是否有jwt</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">onLoad: function() { \n    // 获取本地的jwt，如果有则跳转到home页面，否则重新获取jwt\n    wx.getStorage({\n      key: 'jwt',\n      success: function(res) {\n        wx.switchTab({\n          url: '../home/home'\n        })\n      },\n    })\n  },</code></pre>\n\n<p style=\"text-indent:0;\">如果没有找到jwt，这是会调用登录函数从后端获取jwt</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">//用户登录\nlet login = function(code) {\n  wx.request({\n    url: login_url,\n    method: 'post',\n    data: {\n      'code': code\n    },\n    success(res) {\n      // 登录成功\n      if (res.data.code === 0) {\n        // 将后台返回的jwt写入storage中保存\n        // 这里要使用同步的方法，避免异步请求的时候没有token\n        wx.setStorageSync('jwt', res.data.data)\n        // 跳回主页\n        wx.switchTab({\n          url: '../home/home'\n        })\n      }\n      // 登录失败没有找到绑定的信息，跳转到绑定页面\n      else {\n        wx.navigateTo({\n          url: '../bind/bind',\n        })\n      }\n    },\n    fail(res) {\n      wx.showToast({\n        title: '服务器错误，登录失败！',\n        duration: 1000,\n        icon: 'none',\n      })\n    }\n  })\n}</code></pre>\n\n<p>在bind页面中，需要填写我们的账户信息，这里使用了小程序的form、input组件，需要对password进行MD5加密处理后再提交输入的内容，后端会验证用户名和密码，如果成功后会将获取到的openID和这个用户绑定，并生成jwt。</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">//用户绑定\nlet bind = function(username, password) {\n  var password = md5(password)\n  //重新获取code避免长时间code失效\n  wx.login({\n    success: res =&gt; {\n      wx.request({\n        url: bind_url,\n        method: 'POST',\n        data: {\n          'username': username,\n          'password': password,\n          'code': res.code\n        },\n        success(res) {\n          // 绑定成功\n          if (res.data.code === 0) {\n            // 将后台返回的jwt写入storage中保存\n            // 这里要使用同步的方法，避免异步请求的时候没有token\n            wx.setStorageSync('jwt', res.data.data)\n            // 跳回主页\n            wx.switchTab({\n              url: '../home/home'\n            })\n          } else {\n            wx.showToast({\n              title: res.data.msg,\n              duration: 1000,\n              icon: 'none',\n            })\n          }\n        },\n        fail(res) {\n          wx.showToast({\n            title: '服务器错误，绑定失败！',\n            duration: 1000,\n            icon: 'none',\n          })\n        }\n      })\n    }\n  })\n}</code></pre>\n\n<p>注册页面和绑定页面逻辑基本类似就不在此多说了</p>\n\n<h3>后端的具体实现</h3>\n\n<p>这里使用了PyJWT去生成jwt和解码jwt<br /><strong>openid的获取</strong>，下面官方对请求参数的要求<br /><img alt=\"\" class=\"has\" height=\"292\" src=\"https://img-blog.csdnimg.cn/20190319212824237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"800\" /></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def get_openid(code):\n    \"\"\"\n    获取微信的openID\n    :param code:\n    :return: openid \n    \"\"\"\n    # 构建请求参数\n    payload = {'appid': settings.WX_APPID,\n               'secret': settings.WX_SECRET,\n               'js_code': code,\n               'grant_type': 'authorization_code'}\n    # 请求微信接口，获取用户的openID\n    recv = requests.get(\"https://api.weixin.qq.com/sns/jscode2session\", params=payload)\n    if recv.status_code == 200:\n        recv = json.loads(recv.text)\n        return recv['openid']\n    else:\n        return ''</code></pre>\n\n<p><strong>用户登录接口</strong>：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    def post(request):\n        \"\"\"\n        微信端登录\n        :param request: data{ code }\n        :return: {'code': 0, 'msg': '', 'data': jwt}\n        \"\"\"\n        res = {'code': 0, 'msg': '', 'data': ''}\n        try:\n            code = request.data.get('code')\n            if code:\n                openid = get_openid(code)\n                # 通过openID查找用户信息\n                user_obj = UserInfo.objects.filter(wx=openid).first()\n                # 找到用户后生成\n                if user_obj:\n                    # 生成jwt并返回\n                    res['data'] = create_jwt.create_jwt(user_id=user_obj.uid)\n                # 没有查找到对应用户提示先进行绑定\n                else:\n                    res['code'] = 1001\n                    res['msg'] = '请先绑定微信'\n            else:\n                res['code'] = 1002\n                res['msg'] = '登录失败'\n        except Exception :\n            res['code'] = 1003\n            res['msg'] = '登录失败'\n        return JsonResponse(res)</code></pre>\n\n<p><strong>用户绑定接口：</strong></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    def post(request):\n        \"\"\"\n        绑定微信\n        :param request: data{username, password, code}\n        :return: {'code': 0, 'msg': '', 'data': jwt}\n        \"\"\"\n        res = {'code': 0, 'msg': '', 'data': ''}\n        try:\n            print(request.data)\n            code = request.data.get('code')\n            openid = get_openid(code)\n            # 获取openID\n            data = request.data.copy()\n            data['openid'] = openid\n            # 表单验证\n            login_form = LoginForm(data)\n            # 验证失败\n            if not login_form.is_valid():\n                res['code'] = 1\n                for i, error in login_form.errors.items():\n                    res['msg'] = error[0]\n            # 验证成功，生成jwt并返回给客户端\n            else:\n                res['data'] = create_jwt.create_jwt(user_id = login_form.cleaned_data.get('uid'))\n        except Exception:\n            res['code'] = 1\n            res['msg'] = '绑定失败'\n        return JsonResponse(res)</code></pre>\n\n<p>至此这个微信小程序的登录和绑定基本完成了，下面是绑定、注册页面效果图</p>\n\n<p><img alt=\"\" class=\"has\" height=\"694\" src=\"https://img-blog.csdnimg.cn/20190319210941637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"391\" /><img alt=\"\" class=\"has\" height=\"699\" src=\"https://img-blog.csdnimg.cn/20190319214039324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"392\" /></p>\n","source":"_posts/blogs-从零开始搭建物联网平台（10）：微信登录和用户绑定.md","raw":"<p style=\"text-indent:50px;\">微信小程序不支持Cookie的，所以为了保存用户登录状态就必须换一个方式实现，这里采用jwt的方式，关于jwt简单来说就是第一次登录验证成功后对想要保存的信息进行加密，然后将加密过后的内容返回给前端，前端每次请求的时候都携带上这个token，后端拿到token后对其解密就能获取之前保存的信息了。</p>\n\n<h3 style=\"text-indent:0px;\">整体流程：</h3>\n\n<p style=\"text-indent:0;\">这里先看一下小程序官方给的登录流程，这只是最基础的流程，根据设计需要我们还需要添加自己的逻辑进去<br /><img alt=\"\" class=\"has\" height=\"600\" src=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/image/api-login.jpg?t=19031915\" width=\"800\" /></p>\n\n<p style=\"text-indent:0;\">下面是具体的流程图，接下来会根据这个流程图具体看看小程序端和后端应该怎么实现。<br /><img alt=\"\" class=\"has\" height=\"717\" src=\"https://img-blog.csdnimg.cn/20190319205346244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"800\" /></p>\n\n<h3 style=\"text-indent:0px;\">小程序的具体实现</h3>\n\n<p style=\"text-indent:0;\">以index页面为起始页面，当页面进行加载的时候会调用onload函数，所以可以在onload函数中检测storage中是否有jwt</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">onLoad: function() { \n    // 获取本地的jwt，如果有则跳转到home页面，否则重新获取jwt\n    wx.getStorage({\n      key: 'jwt',\n      success: function(res) {\n        wx.switchTab({\n          url: '../home/home'\n        })\n      },\n    })\n  },</code></pre>\n\n<p style=\"text-indent:0;\">如果没有找到jwt，这是会调用登录函数从后端获取jwt</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">//用户登录\nlet login = function(code) {\n  wx.request({\n    url: login_url,\n    method: 'post',\n    data: {\n      'code': code\n    },\n    success(res) {\n      // 登录成功\n      if (res.data.code === 0) {\n        // 将后台返回的jwt写入storage中保存\n        // 这里要使用同步的方法，避免异步请求的时候没有token\n        wx.setStorageSync('jwt', res.data.data)\n        // 跳回主页\n        wx.switchTab({\n          url: '../home/home'\n        })\n      }\n      // 登录失败没有找到绑定的信息，跳转到绑定页面\n      else {\n        wx.navigateTo({\n          url: '../bind/bind',\n        })\n      }\n    },\n    fail(res) {\n      wx.showToast({\n        title: '服务器错误，登录失败！',\n        duration: 1000,\n        icon: 'none',\n      })\n    }\n  })\n}</code></pre>\n\n<p>在bind页面中，需要填写我们的账户信息，这里使用了小程序的form、input组件，需要对password进行MD5加密处理后再提交输入的内容，后端会验证用户名和密码，如果成功后会将获取到的openID和这个用户绑定，并生成jwt。</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">//用户绑定\nlet bind = function(username, password) {\n  var password = md5(password)\n  //重新获取code避免长时间code失效\n  wx.login({\n    success: res =&gt; {\n      wx.request({\n        url: bind_url,\n        method: 'POST',\n        data: {\n          'username': username,\n          'password': password,\n          'code': res.code\n        },\n        success(res) {\n          // 绑定成功\n          if (res.data.code === 0) {\n            // 将后台返回的jwt写入storage中保存\n            // 这里要使用同步的方法，避免异步请求的时候没有token\n            wx.setStorageSync('jwt', res.data.data)\n            // 跳回主页\n            wx.switchTab({\n              url: '../home/home'\n            })\n          } else {\n            wx.showToast({\n              title: res.data.msg,\n              duration: 1000,\n              icon: 'none',\n            })\n          }\n        },\n        fail(res) {\n          wx.showToast({\n            title: '服务器错误，绑定失败！',\n            duration: 1000,\n            icon: 'none',\n          })\n        }\n      })\n    }\n  })\n}</code></pre>\n\n<p>注册页面和绑定页面逻辑基本类似就不在此多说了</p>\n\n<h3>后端的具体实现</h3>\n\n<p>这里使用了PyJWT去生成jwt和解码jwt<br /><strong>openid的获取</strong>，下面官方对请求参数的要求<br /><img alt=\"\" class=\"has\" height=\"292\" src=\"https://img-blog.csdnimg.cn/20190319212824237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"800\" /></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def get_openid(code):\n    \"\"\"\n    获取微信的openID\n    :param code:\n    :return: openid \n    \"\"\"\n    # 构建请求参数\n    payload = {'appid': settings.WX_APPID,\n               'secret': settings.WX_SECRET,\n               'js_code': code,\n               'grant_type': 'authorization_code'}\n    # 请求微信接口，获取用户的openID\n    recv = requests.get(\"https://api.weixin.qq.com/sns/jscode2session\", params=payload)\n    if recv.status_code == 200:\n        recv = json.loads(recv.text)\n        return recv['openid']\n    else:\n        return ''</code></pre>\n\n<p><strong>用户登录接口</strong>：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    def post(request):\n        \"\"\"\n        微信端登录\n        :param request: data{ code }\n        :return: {'code': 0, 'msg': '', 'data': jwt}\n        \"\"\"\n        res = {'code': 0, 'msg': '', 'data': ''}\n        try:\n            code = request.data.get('code')\n            if code:\n                openid = get_openid(code)\n                # 通过openID查找用户信息\n                user_obj = UserInfo.objects.filter(wx=openid).first()\n                # 找到用户后生成\n                if user_obj:\n                    # 生成jwt并返回\n                    res['data'] = create_jwt.create_jwt(user_id=user_obj.uid)\n                # 没有查找到对应用户提示先进行绑定\n                else:\n                    res['code'] = 1001\n                    res['msg'] = '请先绑定微信'\n            else:\n                res['code'] = 1002\n                res['msg'] = '登录失败'\n        except Exception :\n            res['code'] = 1003\n            res['msg'] = '登录失败'\n        return JsonResponse(res)</code></pre>\n\n<p><strong>用户绑定接口：</strong></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    def post(request):\n        \"\"\"\n        绑定微信\n        :param request: data{username, password, code}\n        :return: {'code': 0, 'msg': '', 'data': jwt}\n        \"\"\"\n        res = {'code': 0, 'msg': '', 'data': ''}\n        try:\n            print(request.data)\n            code = request.data.get('code')\n            openid = get_openid(code)\n            # 获取openID\n            data = request.data.copy()\n            data['openid'] = openid\n            # 表单验证\n            login_form = LoginForm(data)\n            # 验证失败\n            if not login_form.is_valid():\n                res['code'] = 1\n                for i, error in login_form.errors.items():\n                    res['msg'] = error[0]\n            # 验证成功，生成jwt并返回给客户端\n            else:\n                res['data'] = create_jwt.create_jwt(user_id = login_form.cleaned_data.get('uid'))\n        except Exception:\n            res['code'] = 1\n            res['msg'] = '绑定失败'\n        return JsonResponse(res)</code></pre>\n\n<p>至此这个微信小程序的登录和绑定基本完成了，下面是绑定、注册页面效果图</p>\n\n<p><img alt=\"\" class=\"has\" height=\"694\" src=\"https://img-blog.csdnimg.cn/20190319210941637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"391\" /><img alt=\"\" class=\"has\" height=\"699\" src=\"https://img-blog.csdnimg.cn/20190319214039324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"392\" /></p>\n","slug":"blogs-从零开始搭建物联网平台（10）：微信登录和用户绑定","published":1,"date":"2022-03-16T17:00:41.111Z","updated":"2022-03-16T17:05:30.251Z","_id":"cl0v6kesm0018yms4gaas278b","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p style=\"text-indent:50px;\">微信小程序不支持Cookie的，所以为了保存用户登录状态就必须换一个方式实现，这里采用jwt的方式，关于jwt简单来说就是第一次登录验证成功后对想要保存的信息进行加密，然后将加密过后的内容返回给前端，前端每次请求的时候都携带上这个token，后端拿到token后对其解密就能获取之前保存的信息了。</p>\n\n<h3 style=\"text-indent:0px;\">整体流程：</h3>\n\n<p style=\"text-indent:0;\">这里先看一下小程序官方给的登录流程，这只是最基础的流程，根据设计需要我们还需要添加自己的逻辑进去<br /><img alt=\"\" class=\"has\" height=\"600\" src=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/image/api-login.jpg?t=19031915\" width=\"800\" /></p>\n\n<p style=\"text-indent:0;\">下面是具体的流程图，接下来会根据这个流程图具体看看小程序端和后端应该怎么实现。<br /><img alt=\"\" class=\"has\" height=\"717\" src=\"https://img-blog.csdnimg.cn/20190319205346244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"800\" /></p>\n\n<h3 style=\"text-indent:0px;\">小程序的具体实现</h3>\n\n<p style=\"text-indent:0;\">以index页面为起始页面，当页面进行加载的时候会调用onload函数，所以可以在onload函数中检测storage中是否有jwt</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">onLoad: function() &#123; \n    // 获取本地的jwt，如果有则跳转到home页面，否则重新获取jwt\n    wx.getStorage(&#123;\n      key: 'jwt',\n      success: function(res) &#123;\n        wx.switchTab(&#123;\n          url: '../home/home'\n        &#125;)\n      &#125;,\n    &#125;)\n  &#125;,</code></pre>\n\n<p style=\"text-indent:0;\">如果没有找到jwt，这是会调用登录函数从后端获取jwt</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">//用户登录\nlet login = function(code) &#123;\n  wx.request(&#123;\n    url: login_url,\n    method: 'post',\n    data: &#123;\n      'code': code\n    &#125;,\n    success(res) &#123;\n      // 登录成功\n      if (res.data.code === 0) &#123;\n        // 将后台返回的jwt写入storage中保存\n        // 这里要使用同步的方法，避免异步请求的时候没有token\n        wx.setStorageSync('jwt', res.data.data)\n        // 跳回主页\n        wx.switchTab(&#123;\n          url: '../home/home'\n        &#125;)\n      &#125;\n      // 登录失败没有找到绑定的信息，跳转到绑定页面\n      else &#123;\n        wx.navigateTo(&#123;\n          url: '../bind/bind',\n        &#125;)\n      &#125;\n    &#125;,\n    fail(res) &#123;\n      wx.showToast(&#123;\n        title: '服务器错误，登录失败！',\n        duration: 1000,\n        icon: 'none',\n      &#125;)\n    &#125;\n  &#125;)\n&#125;</code></pre>\n\n<p>在bind页面中，需要填写我们的账户信息，这里使用了小程序的form、input组件，需要对password进行MD5加密处理后再提交输入的内容，后端会验证用户名和密码，如果成功后会将获取到的openID和这个用户绑定，并生成jwt。</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">//用户绑定\nlet bind = function(username, password) &#123;\n  var password = md5(password)\n  //重新获取code避免长时间code失效\n  wx.login(&#123;\n    success: res =&gt; &#123;\n      wx.request(&#123;\n        url: bind_url,\n        method: 'POST',\n        data: &#123;\n          'username': username,\n          'password': password,\n          'code': res.code\n        &#125;,\n        success(res) &#123;\n          // 绑定成功\n          if (res.data.code === 0) &#123;\n            // 将后台返回的jwt写入storage中保存\n            // 这里要使用同步的方法，避免异步请求的时候没有token\n            wx.setStorageSync('jwt', res.data.data)\n            // 跳回主页\n            wx.switchTab(&#123;\n              url: '../home/home'\n            &#125;)\n          &#125; else &#123;\n            wx.showToast(&#123;\n              title: res.data.msg,\n              duration: 1000,\n              icon: 'none',\n            &#125;)\n          &#125;\n        &#125;,\n        fail(res) &#123;\n          wx.showToast(&#123;\n            title: '服务器错误，绑定失败！',\n            duration: 1000,\n            icon: 'none',\n          &#125;)\n        &#125;\n      &#125;)\n    &#125;\n  &#125;)\n&#125;</code></pre>\n\n<p>注册页面和绑定页面逻辑基本类似就不在此多说了</p>\n\n<h3>后端的具体实现</h3>\n\n<p>这里使用了PyJWT去生成jwt和解码jwt<br /><strong>openid的获取</strong>，下面官方对请求参数的要求<br /><img alt=\"\" class=\"has\" height=\"292\" src=\"https://img-blog.csdnimg.cn/20190319212824237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"800\" /></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def get_openid(code):\n    \"\"\"\n    获取微信的openID\n    :param code:\n    :return: openid \n    \"\"\"\n    # 构建请求参数\n    payload = &#123;'appid': settings.WX_APPID,\n               'secret': settings.WX_SECRET,\n               'js_code': code,\n               'grant_type': 'authorization_code'&#125;\n    # 请求微信接口，获取用户的openID\n    recv = requests.get(\"https://api.weixin.qq.com/sns/jscode2session\", params=payload)\n    if recv.status_code == 200:\n        recv = json.loads(recv.text)\n        return recv['openid']\n    else:\n        return ''</code></pre>\n\n<p><strong>用户登录接口</strong>：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    def post(request):\n        \"\"\"\n        微信端登录\n        :param request: data&#123; code &#125;\n        :return: &#123;'code': 0, 'msg': '', 'data': jwt&#125;\n        \"\"\"\n        res = &#123;'code': 0, 'msg': '', 'data': ''&#125;\n        try:\n            code = request.data.get('code')\n            if code:\n                openid = get_openid(code)\n                # 通过openID查找用户信息\n                user_obj = UserInfo.objects.filter(wx=openid).first()\n                # 找到用户后生成\n                if user_obj:\n                    # 生成jwt并返回\n                    res['data'] = create_jwt.create_jwt(user_id=user_obj.uid)\n                # 没有查找到对应用户提示先进行绑定\n                else:\n                    res['code'] = 1001\n                    res['msg'] = '请先绑定微信'\n            else:\n                res['code'] = 1002\n                res['msg'] = '登录失败'\n        except Exception :\n            res['code'] = 1003\n            res['msg'] = '登录失败'\n        return JsonResponse(res)</code></pre>\n\n<p><strong>用户绑定接口：</strong></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    def post(request):\n        \"\"\"\n        绑定微信\n        :param request: data&#123;username, password, code&#125;\n        :return: &#123;'code': 0, 'msg': '', 'data': jwt&#125;\n        \"\"\"\n        res = &#123;'code': 0, 'msg': '', 'data': ''&#125;\n        try:\n            print(request.data)\n            code = request.data.get('code')\n            openid = get_openid(code)\n            # 获取openID\n            data = request.data.copy()\n            data['openid'] = openid\n            # 表单验证\n            login_form = LoginForm(data)\n            # 验证失败\n            if not login_form.is_valid():\n                res['code'] = 1\n                for i, error in login_form.errors.items():\n                    res['msg'] = error[0]\n            # 验证成功，生成jwt并返回给客户端\n            else:\n                res['data'] = create_jwt.create_jwt(user_id = login_form.cleaned_data.get('uid'))\n        except Exception:\n            res['code'] = 1\n            res['msg'] = '绑定失败'\n        return JsonResponse(res)</code></pre>\n\n<p>至此这个微信小程序的登录和绑定基本完成了，下面是绑定、注册页面效果图</p>\n\n<p><img alt=\"\" class=\"has\" height=\"694\" src=\"https://img-blog.csdnimg.cn/20190319210941637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"391\" /><img alt=\"\" class=\"has\" height=\"699\" src=\"https://img-blog.csdnimg.cn/20190319214039324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"392\" /></p>\n","site":{"data":{}},"excerpt":"","more":"<p style=\"text-indent:50px;\">微信小程序不支持Cookie的，所以为了保存用户登录状态就必须换一个方式实现，这里采用jwt的方式，关于jwt简单来说就是第一次登录验证成功后对想要保存的信息进行加密，然后将加密过后的内容返回给前端，前端每次请求的时候都携带上这个token，后端拿到token后对其解密就能获取之前保存的信息了。</p>\n\n<h3 style=\"text-indent:0px;\">整体流程：</h3>\n\n<p style=\"text-indent:0;\">这里先看一下小程序官方给的登录流程，这只是最基础的流程，根据设计需要我们还需要添加自己的逻辑进去<br /><img alt=\"\" class=\"has\" height=\"600\" src=\"https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/image/api-login.jpg?t=19031915\" width=\"800\" /></p>\n\n<p style=\"text-indent:0;\">下面是具体的流程图，接下来会根据这个流程图具体看看小程序端和后端应该怎么实现。<br /><img alt=\"\" class=\"has\" height=\"717\" src=\"https://img-blog.csdnimg.cn/20190319205346244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"800\" /></p>\n\n<h3 style=\"text-indent:0px;\">小程序的具体实现</h3>\n\n<p style=\"text-indent:0;\">以index页面为起始页面，当页面进行加载的时候会调用onload函数，所以可以在onload函数中检测storage中是否有jwt</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">onLoad: function() &#123; \n    // 获取本地的jwt，如果有则跳转到home页面，否则重新获取jwt\n    wx.getStorage(&#123;\n      key: 'jwt',\n      success: function(res) &#123;\n        wx.switchTab(&#123;\n          url: '../home/home'\n        &#125;)\n      &#125;,\n    &#125;)\n  &#125;,</code></pre>\n\n<p style=\"text-indent:0;\">如果没有找到jwt，这是会调用登录函数从后端获取jwt</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">//用户登录\nlet login = function(code) &#123;\n  wx.request(&#123;\n    url: login_url,\n    method: 'post',\n    data: &#123;\n      'code': code\n    &#125;,\n    success(res) &#123;\n      // 登录成功\n      if (res.data.code === 0) &#123;\n        // 将后台返回的jwt写入storage中保存\n        // 这里要使用同步的方法，避免异步请求的时候没有token\n        wx.setStorageSync('jwt', res.data.data)\n        // 跳回主页\n        wx.switchTab(&#123;\n          url: '../home/home'\n        &#125;)\n      &#125;\n      // 登录失败没有找到绑定的信息，跳转到绑定页面\n      else &#123;\n        wx.navigateTo(&#123;\n          url: '../bind/bind',\n        &#125;)\n      &#125;\n    &#125;,\n    fail(res) &#123;\n      wx.showToast(&#123;\n        title: '服务器错误，登录失败！',\n        duration: 1000,\n        icon: 'none',\n      &#125;)\n    &#125;\n  &#125;)\n&#125;</code></pre>\n\n<p>在bind页面中，需要填写我们的账户信息，这里使用了小程序的form、input组件，需要对password进行MD5加密处理后再提交输入的内容，后端会验证用户名和密码，如果成功后会将获取到的openID和这个用户绑定，并生成jwt。</p>\n\n<pre class=\"has\">\n<code class=\"language-javascript\">//用户绑定\nlet bind = function(username, password) &#123;\n  var password = md5(password)\n  //重新获取code避免长时间code失效\n  wx.login(&#123;\n    success: res =&gt; &#123;\n      wx.request(&#123;\n        url: bind_url,\n        method: 'POST',\n        data: &#123;\n          'username': username,\n          'password': password,\n          'code': res.code\n        &#125;,\n        success(res) &#123;\n          // 绑定成功\n          if (res.data.code === 0) &#123;\n            // 将后台返回的jwt写入storage中保存\n            // 这里要使用同步的方法，避免异步请求的时候没有token\n            wx.setStorageSync('jwt', res.data.data)\n            // 跳回主页\n            wx.switchTab(&#123;\n              url: '../home/home'\n            &#125;)\n          &#125; else &#123;\n            wx.showToast(&#123;\n              title: res.data.msg,\n              duration: 1000,\n              icon: 'none',\n            &#125;)\n          &#125;\n        &#125;,\n        fail(res) &#123;\n          wx.showToast(&#123;\n            title: '服务器错误，绑定失败！',\n            duration: 1000,\n            icon: 'none',\n          &#125;)\n        &#125;\n      &#125;)\n    &#125;\n  &#125;)\n&#125;</code></pre>\n\n<p>注册页面和绑定页面逻辑基本类似就不在此多说了</p>\n\n<h3>后端的具体实现</h3>\n\n<p>这里使用了PyJWT去生成jwt和解码jwt<br /><strong>openid的获取</strong>，下面官方对请求参数的要求<br /><img alt=\"\" class=\"has\" height=\"292\" src=\"https://img-blog.csdnimg.cn/20190319212824237.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"800\" /></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def get_openid(code):\n    \"\"\"\n    获取微信的openID\n    :param code:\n    :return: openid \n    \"\"\"\n    # 构建请求参数\n    payload = &#123;'appid': settings.WX_APPID,\n               'secret': settings.WX_SECRET,\n               'js_code': code,\n               'grant_type': 'authorization_code'&#125;\n    # 请求微信接口，获取用户的openID\n    recv = requests.get(\"https://api.weixin.qq.com/sns/jscode2session\", params=payload)\n    if recv.status_code == 200:\n        recv = json.loads(recv.text)\n        return recv['openid']\n    else:\n        return ''</code></pre>\n\n<p><strong>用户登录接口</strong>：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    def post(request):\n        \"\"\"\n        微信端登录\n        :param request: data&#123; code &#125;\n        :return: &#123;'code': 0, 'msg': '', 'data': jwt&#125;\n        \"\"\"\n        res = &#123;'code': 0, 'msg': '', 'data': ''&#125;\n        try:\n            code = request.data.get('code')\n            if code:\n                openid = get_openid(code)\n                # 通过openID查找用户信息\n                user_obj = UserInfo.objects.filter(wx=openid).first()\n                # 找到用户后生成\n                if user_obj:\n                    # 生成jwt并返回\n                    res['data'] = create_jwt.create_jwt(user_id=user_obj.uid)\n                # 没有查找到对应用户提示先进行绑定\n                else:\n                    res['code'] = 1001\n                    res['msg'] = '请先绑定微信'\n            else:\n                res['code'] = 1002\n                res['msg'] = '登录失败'\n        except Exception :\n            res['code'] = 1003\n            res['msg'] = '登录失败'\n        return JsonResponse(res)</code></pre>\n\n<p><strong>用户绑定接口：</strong></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">    def post(request):\n        \"\"\"\n        绑定微信\n        :param request: data&#123;username, password, code&#125;\n        :return: &#123;'code': 0, 'msg': '', 'data': jwt&#125;\n        \"\"\"\n        res = &#123;'code': 0, 'msg': '', 'data': ''&#125;\n        try:\n            print(request.data)\n            code = request.data.get('code')\n            openid = get_openid(code)\n            # 获取openID\n            data = request.data.copy()\n            data['openid'] = openid\n            # 表单验证\n            login_form = LoginForm(data)\n            # 验证失败\n            if not login_form.is_valid():\n                res['code'] = 1\n                for i, error in login_form.errors.items():\n                    res['msg'] = error[0]\n            # 验证成功，生成jwt并返回给客户端\n            else:\n                res['data'] = create_jwt.create_jwt(user_id = login_form.cleaned_data.get('uid'))\n        except Exception:\n            res['code'] = 1\n            res['msg'] = '绑定失败'\n        return JsonResponse(res)</code></pre>\n\n<p>至此这个微信小程序的登录和绑定基本完成了，下面是绑定、注册页面效果图</p>\n\n<p><img alt=\"\" class=\"has\" height=\"694\" src=\"https://img-blog.csdnimg.cn/20190319210941637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"391\" /><img alt=\"\" class=\"has\" height=\"699\" src=\"https://img-blog.csdnimg.cn/20190319214039324.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" width=\"392\" /></p>\n"},{"_content":"<p>首先看一个面试中非常常见的题目</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def num():\n    return [lambda x: x * i for i in range(4)]\n\n\nprint([ n(2) for n in num()])\n</code></pre>\n\n<p>先看一下num函数的作用，定义了一个匿名函数，返回传入参数乘以列表生成式的每一个元素，所以乍一看结果应该为[0,2,4,6]，如果这样想的话就落入陷阱了。这个题目考察的就是在python中闭包是延迟绑定的，当num()赋值给n的时候就已经完成for循环了，i已经等于3，所以到最后输出值都为 2 *3 也就是[6,6,6,6]</p>\n\n<p> </p>\n\n<p style=\"text-indent:50px;\">闭包就是在一个外部函数中定义一个内函数，内函数里运用了外部函数的临时变量，并且外函数的返回值是内函数的引用。如下是最简单的一个闭包：</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180920143854274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /><br />\n在python中一切皆对象，小到一个变量，大到一个函数一个类都是对象，变量名，函数名类名都是指向内存地址。因此当返回值为一个函数的引用的时候可以跟括号来调用此函数。<br />\n一般来说，当一个函数结束的时候，会将临时变量释放掉，但是在闭包中，临时变量会在内部函数中用到，因此在返回内函数的时候会将临时变量和内函数绑定在一起，外函数结束后，在调用内函数的时候依然可以使用外函数的临时变量。每次在调用外函数的时候都会在内存中创建一个内函数，并且返回的是当前的内函数地址，需要知道的的是虽然内函数被重新创建了，但是外函数的临时变量只存在一份，每次创建的内函数都是使用的同一份临时变量。如下两次调用的返回值是不同的</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/2018092014391017?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /><br />\nPython中内函数想要修改外函数的临时变量可以使用nonlocal关键字来定义变量，如下：</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180920143921274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></p>","source":"_posts/blogs-对于Python闭包的理解.md","raw":"<p>首先看一个面试中非常常见的题目</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def num():\n    return [lambda x: x * i for i in range(4)]\n\n\nprint([ n(2) for n in num()])\n</code></pre>\n\n<p>先看一下num函数的作用，定义了一个匿名函数，返回传入参数乘以列表生成式的每一个元素，所以乍一看结果应该为[0,2,4,6]，如果这样想的话就落入陷阱了。这个题目考察的就是在python中闭包是延迟绑定的，当num()赋值给n的时候就已经完成for循环了，i已经等于3，所以到最后输出值都为 2 *3 也就是[6,6,6,6]</p>\n\n<p> </p>\n\n<p style=\"text-indent:50px;\">闭包就是在一个外部函数中定义一个内函数，内函数里运用了外部函数的临时变量，并且外函数的返回值是内函数的引用。如下是最简单的一个闭包：</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180920143854274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /><br />\n在python中一切皆对象，小到一个变量，大到一个函数一个类都是对象，变量名，函数名类名都是指向内存地址。因此当返回值为一个函数的引用的时候可以跟括号来调用此函数。<br />\n一般来说，当一个函数结束的时候，会将临时变量释放掉，但是在闭包中，临时变量会在内部函数中用到，因此在返回内函数的时候会将临时变量和内函数绑定在一起，外函数结束后，在调用内函数的时候依然可以使用外函数的临时变量。每次在调用外函数的时候都会在内存中创建一个内函数，并且返回的是当前的内函数地址，需要知道的的是虽然内函数被重新创建了，但是外函数的临时变量只存在一份，每次创建的内函数都是使用的同一份临时变量。如下两次调用的返回值是不同的</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/2018092014391017?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /><br />\nPython中内函数想要修改外函数的临时变量可以使用nonlocal关键字来定义变量，如下：</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180920143921274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></p>","slug":"blogs-对于Python闭包的理解","published":1,"date":"2022-03-16T17:00:56.827Z","updated":"2022-03-16T17:05:46.258Z","_id":"cl0v6kesn0019yms4hlc7etij","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>首先看一个面试中非常常见的题目</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def num():\n    return [lambda x: x * i for i in range(4)]\n\n\nprint([ n(2) for n in num()])\n</code></pre>\n\n<p>先看一下num函数的作用，定义了一个匿名函数，返回传入参数乘以列表生成式的每一个元素，所以乍一看结果应该为[0,2,4,6]，如果这样想的话就落入陷阱了。这个题目考察的就是在python中闭包是延迟绑定的，当num()赋值给n的时候就已经完成for循环了，i已经等于3，所以到最后输出值都为 2 *3 也就是[6,6,6,6]</p>\n\n<p> </p>\n\n<p style=\"text-indent:50px;\">闭包就是在一个外部函数中定义一个内函数，内函数里运用了外部函数的临时变量，并且外函数的返回值是内函数的引用。如下是最简单的一个闭包：</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180920143854274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /><br />\n在python中一切皆对象，小到一个变量，大到一个函数一个类都是对象，变量名，函数名类名都是指向内存地址。因此当返回值为一个函数的引用的时候可以跟括号来调用此函数。<br />\n一般来说，当一个函数结束的时候，会将临时变量释放掉，但是在闭包中，临时变量会在内部函数中用到，因此在返回内函数的时候会将临时变量和内函数绑定在一起，外函数结束后，在调用内函数的时候依然可以使用外函数的临时变量。每次在调用外函数的时候都会在内存中创建一个内函数，并且返回的是当前的内函数地址，需要知道的的是虽然内函数被重新创建了，但是外函数的临时变量只存在一份，每次创建的内函数都是使用的同一份临时变量。如下两次调用的返回值是不同的</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/2018092014391017?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /><br />\nPython中内函数想要修改外函数的临时变量可以使用nonlocal关键字来定义变量，如下：</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180920143921274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></p>","site":{"data":{}},"excerpt":"","more":"<p>首先看一个面试中非常常见的题目</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def num():\n    return [lambda x: x * i for i in range(4)]\n\n\nprint([ n(2) for n in num()])\n</code></pre>\n\n<p>先看一下num函数的作用，定义了一个匿名函数，返回传入参数乘以列表生成式的每一个元素，所以乍一看结果应该为[0,2,4,6]，如果这样想的话就落入陷阱了。这个题目考察的就是在python中闭包是延迟绑定的，当num()赋值给n的时候就已经完成for循环了，i已经等于3，所以到最后输出值都为 2 *3 也就是[6,6,6,6]</p>\n\n<p> </p>\n\n<p style=\"text-indent:50px;\">闭包就是在一个外部函数中定义一个内函数，内函数里运用了外部函数的临时变量，并且外函数的返回值是内函数的引用。如下是最简单的一个闭包：</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180920143854274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /><br />\n在python中一切皆对象，小到一个变量，大到一个函数一个类都是对象，变量名，函数名类名都是指向内存地址。因此当返回值为一个函数的引用的时候可以跟括号来调用此函数。<br />\n一般来说，当一个函数结束的时候，会将临时变量释放掉，但是在闭包中，临时变量会在内部函数中用到，因此在返回内函数的时候会将临时变量和内函数绑定在一起，外函数结束后，在调用内函数的时候依然可以使用外函数的临时变量。每次在调用外函数的时候都会在内存中创建一个内函数，并且返回的是当前的内函数地址，需要知道的的是虽然内函数被重新创建了，但是外函数的临时变量只存在一份，每次创建的内函数都是使用的同一份临时变量。如下两次调用的返回值是不同的</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/2018092014391017?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /><br />\nPython中内函数想要修改外函数的临时变量可以使用nonlocal关键字来定义变量，如下：</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180920143921274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" /></p>"},{"_content":"\n想要弄明白装饰器是什么东西，首先我们需要了解一下什么是闭包，因为装饰器是闭包的一种应用。\n#### 闭包\n闭包的定义：\n\n​\t通俗的来说闭包就是在一个函数内部定义另外一个函数，这个函数又引用了外部函数的变量，并且外函数的返回值是内函数的引用，下面是一个最简单的闭包示例：\n\n```python\ndef outer():\n    a = 10\n    def inner():\n        print(a)\n    return inner\n\ndemo = outer()\ndemo()\n```\n\n那么再回到装饰器上面，我们都知道在python中任何东西都是对象，一个函数也好一个字符串也好都是对象，在传递过程中都是传递其内容的引用，当传递的是函数的时候只需在变量名后边加上()即可调用这个函数。\n\n好了基础知识了解了，那么下面来看一个简单的装饰器应用：\n\n#### 装饰器\n\n```python\ndef auth(func):\n    print('before run')\n    def wrapper():\n        func()\n    return wrapper\n\n@auth\ndef response():\n    print('this is a test function')\n    \nresponse()  \n\n###### result ######\n# before run\n# this is a test function\n```\n\n乍一看是不是和闭包一样，只不过把变量替换成函数名了\n\n##### 参数的传递\n\n上面的示例中被装饰函数是没有传递参数的，倘若被装饰函数需要传递参数的时候那么就需要稍微做一下调整。\n\n```python\ndef auth(func):\n    print('before run')\n    def wrapper(*args, **kwargs):\n        func(*args, **kwargs)\n    return wrapper\n\n@auth\ndef response(*args, **kwargs):\n    print('this is a test function')\n    print(args)\n    \nresponse(1,2)  \n\n###### result ######\n# before run\n# this is a test function\n# (1, 2)\n```\n\n#### 装饰器的高级用法\n\n有时候实际使用装饰器的时候可能并不会像上面的那样简单，例如我们可能需要给装饰器本身传递参数，来让装饰器更为灵活。先尝试不改代码看看运行的结果\n\n```python\n@auth(1,2)\ndef response(*args, **kwargs):\n    print('this is a test function')\n    print(args)\n\nresponse(1, 2)\n\n###### result ######\n# error:\n# TypeError: auth() takes 1 positional argument but 2 were given\n```\n\nauth只有一个参数，但是传递了两个参数，这是为什么呢？我们需要先看看@auth这行代码是什么意思，@auth其实是response=auth(response)的简写，你看这样的写法就只接收一个参数，那么我们不使用这种简写方式可以吗？\n\n```python\ndef auth(func, *args):\n    print('before run')\n    print(args)\n    def wrapper(*args, **kwargs):\n        func(*args, **kwargs)\n    return wrapper\n\ndef response(*args, **kwargs):\n    print('this is a test function')\n    print(args)\n\nresponse = auth(response, 1)\nresponse(1, 2)\n\n###### result ######\n# before run\n# (1,)\n# this is a test function\n# (1, 2)\n```\n\n你看还真是实现了这个功能，只不过没办法使用简写来装饰函数了。那有没有更好的解决方法呢，我们再回到装饰器的原理上（一个闭包）那如果我们在闭包函数外面再套一层函数是不是就可以解决了呢。尝试一下\n\n```python\ndef outer(*args, **kwargs):\n    print('before run')\n    print(args)\n    def inner(func):\n        def wrapper(*args, **kwargs):\n            func(*args, **kwargs)\n        return wrapper\n    return inner\n\n@outer(1, 2)\ndef response(*args, **kwargs):\n    print('this is a test function')\n    print(args)\n\nresponse(3, 4)\n\n###### result ######\n# before run\n# (1,)\n# this is a test function\n# (1, 2)\n```\n\n实现了和上一个一样的功能，此时的@outer(1,2)还原成本来样子就是 response = outer(1,2)(response)，我们打上断点看看装饰器是如何运行的\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190307021938395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n\n#### 多个装饰器同时使用\n\n先上代码看结果\n\n```python\ndef decorator1(func):\n    print('Decorator1')\n    def wrapper(*args,**kwargs):\n        print('----1----')\n        func(*args, **kwargs)\n    return wrapper\n\ndef decorator2(func):\n    print('Decorator2')\n    def wrapper(*args,**kwargs):\n        print('----2----')\n        func(*args, **kwargs)\n    return wrapper\n\n@decorator1\n@decorator2\ndef test(*args):\n    print(args)\n\ntest(1,2)\n\n###### result ######\n# Decorator2\n# Decorator1\n# ----1----\n# ----2----\n# (1, 2)\n```\n\n执行顺序并不是先执行完装饰器1然后在执行装饰器2，而是交替运行的，我们分析一下具体执行过程一探究竟。就装饰顺序来说还是按照decorator1、decorator2来对原函数装饰的，那么装饰的结果是什么呢，这里需要了解一下@符号的作用，在python中@会将紧跟着的函数名作为参数传给装饰函数，经过两个装饰器作用之后 test变成了 ：test = decorator1(decorator2(test))\n\n此时在调用test的时候，就会从里往外执行，\n\n1. 即先执行decorator2(test)，会先打印出Decorator2\n2. 返回decorator2中的内函数给decorator1，然后打印Decorator1\n3. 返回decorator1内函数给test\n4. 在调用test函数的时候就会先执行decorator1的内函数，打印出了----1----\n5. 然后运行decorator2的内函数,打印出----2----\n6. 最后才会运行test原函数\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019030702192439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n总结来说，在装饰过程中越靠近被装饰函数越先执行，内函数恰恰相反**\n#### 保留原函数的信息\n\n回到之前一个最简单的装饰器上，我们看看直接输出被装饰的函数信息是什么?\n\n```python\ndef auth(func):\n    def wrapper():\n        func()\n    return wrapper\n\n@auth\ndef response():\n    pass\n\nprint(response.__name__)\n\n###### result ######\n# wrapper\n```\n\n输出的是装饰器的内函数，原因就不说了，和之前的一样@的作用，难么我们该怎么让打印函数信息能够显示的是被装饰函数本身呢？这里就要用到functools的wraps方法，用法很简单：\n\n```python\nfrom functools import wraps\ndef auth(func):\n    @wraps(func)\n    def wrapper():\n        func()\n    return wrapper\n\n@auth\ndef response():\n    pass\n\nprint(response.__name__)\n\n###### result ######\n# response\n```\n#### 总结\n\n装饰器到此差不多都说完了，其作用就不展开说了，经过这么一连串的分析自己也对装饰器的原理有了更深的了解，算是没白浪费时间。\n","source":"_posts/blogs-对Python装饰器的理解.md","raw":"\n想要弄明白装饰器是什么东西，首先我们需要了解一下什么是闭包，因为装饰器是闭包的一种应用。\n#### 闭包\n闭包的定义：\n\n​\t通俗的来说闭包就是在一个函数内部定义另外一个函数，这个函数又引用了外部函数的变量，并且外函数的返回值是内函数的引用，下面是一个最简单的闭包示例：\n\n```python\ndef outer():\n    a = 10\n    def inner():\n        print(a)\n    return inner\n\ndemo = outer()\ndemo()\n```\n\n那么再回到装饰器上面，我们都知道在python中任何东西都是对象，一个函数也好一个字符串也好都是对象，在传递过程中都是传递其内容的引用，当传递的是函数的时候只需在变量名后边加上()即可调用这个函数。\n\n好了基础知识了解了，那么下面来看一个简单的装饰器应用：\n\n#### 装饰器\n\n```python\ndef auth(func):\n    print('before run')\n    def wrapper():\n        func()\n    return wrapper\n\n@auth\ndef response():\n    print('this is a test function')\n    \nresponse()  \n\n###### result ######\n# before run\n# this is a test function\n```\n\n乍一看是不是和闭包一样，只不过把变量替换成函数名了\n\n##### 参数的传递\n\n上面的示例中被装饰函数是没有传递参数的，倘若被装饰函数需要传递参数的时候那么就需要稍微做一下调整。\n\n```python\ndef auth(func):\n    print('before run')\n    def wrapper(*args, **kwargs):\n        func(*args, **kwargs)\n    return wrapper\n\n@auth\ndef response(*args, **kwargs):\n    print('this is a test function')\n    print(args)\n    \nresponse(1,2)  \n\n###### result ######\n# before run\n# this is a test function\n# (1, 2)\n```\n\n#### 装饰器的高级用法\n\n有时候实际使用装饰器的时候可能并不会像上面的那样简单，例如我们可能需要给装饰器本身传递参数，来让装饰器更为灵活。先尝试不改代码看看运行的结果\n\n```python\n@auth(1,2)\ndef response(*args, **kwargs):\n    print('this is a test function')\n    print(args)\n\nresponse(1, 2)\n\n###### result ######\n# error:\n# TypeError: auth() takes 1 positional argument but 2 were given\n```\n\nauth只有一个参数，但是传递了两个参数，这是为什么呢？我们需要先看看@auth这行代码是什么意思，@auth其实是response=auth(response)的简写，你看这样的写法就只接收一个参数，那么我们不使用这种简写方式可以吗？\n\n```python\ndef auth(func, *args):\n    print('before run')\n    print(args)\n    def wrapper(*args, **kwargs):\n        func(*args, **kwargs)\n    return wrapper\n\ndef response(*args, **kwargs):\n    print('this is a test function')\n    print(args)\n\nresponse = auth(response, 1)\nresponse(1, 2)\n\n###### result ######\n# before run\n# (1,)\n# this is a test function\n# (1, 2)\n```\n\n你看还真是实现了这个功能，只不过没办法使用简写来装饰函数了。那有没有更好的解决方法呢，我们再回到装饰器的原理上（一个闭包）那如果我们在闭包函数外面再套一层函数是不是就可以解决了呢。尝试一下\n\n```python\ndef outer(*args, **kwargs):\n    print('before run')\n    print(args)\n    def inner(func):\n        def wrapper(*args, **kwargs):\n            func(*args, **kwargs)\n        return wrapper\n    return inner\n\n@outer(1, 2)\ndef response(*args, **kwargs):\n    print('this is a test function')\n    print(args)\n\nresponse(3, 4)\n\n###### result ######\n# before run\n# (1,)\n# this is a test function\n# (1, 2)\n```\n\n实现了和上一个一样的功能，此时的@outer(1,2)还原成本来样子就是 response = outer(1,2)(response)，我们打上断点看看装饰器是如何运行的\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190307021938395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n\n#### 多个装饰器同时使用\n\n先上代码看结果\n\n```python\ndef decorator1(func):\n    print('Decorator1')\n    def wrapper(*args,**kwargs):\n        print('----1----')\n        func(*args, **kwargs)\n    return wrapper\n\ndef decorator2(func):\n    print('Decorator2')\n    def wrapper(*args,**kwargs):\n        print('----2----')\n        func(*args, **kwargs)\n    return wrapper\n\n@decorator1\n@decorator2\ndef test(*args):\n    print(args)\n\ntest(1,2)\n\n###### result ######\n# Decorator2\n# Decorator1\n# ----1----\n# ----2----\n# (1, 2)\n```\n\n执行顺序并不是先执行完装饰器1然后在执行装饰器2，而是交替运行的，我们分析一下具体执行过程一探究竟。就装饰顺序来说还是按照decorator1、decorator2来对原函数装饰的，那么装饰的结果是什么呢，这里需要了解一下@符号的作用，在python中@会将紧跟着的函数名作为参数传给装饰函数，经过两个装饰器作用之后 test变成了 ：test = decorator1(decorator2(test))\n\n此时在调用test的时候，就会从里往外执行，\n\n1. 即先执行decorator2(test)，会先打印出Decorator2\n2. 返回decorator2中的内函数给decorator1，然后打印Decorator1\n3. 返回decorator1内函数给test\n4. 在调用test函数的时候就会先执行decorator1的内函数，打印出了----1----\n5. 然后运行decorator2的内函数,打印出----2----\n6. 最后才会运行test原函数\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019030702192439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n总结来说，在装饰过程中越靠近被装饰函数越先执行，内函数恰恰相反**\n#### 保留原函数的信息\n\n回到之前一个最简单的装饰器上，我们看看直接输出被装饰的函数信息是什么?\n\n```python\ndef auth(func):\n    def wrapper():\n        func()\n    return wrapper\n\n@auth\ndef response():\n    pass\n\nprint(response.__name__)\n\n###### result ######\n# wrapper\n```\n\n输出的是装饰器的内函数，原因就不说了，和之前的一样@的作用，难么我们该怎么让打印函数信息能够显示的是被装饰函数本身呢？这里就要用到functools的wraps方法，用法很简单：\n\n```python\nfrom functools import wraps\ndef auth(func):\n    @wraps(func)\n    def wrapper():\n        func()\n    return wrapper\n\n@auth\ndef response():\n    pass\n\nprint(response.__name__)\n\n###### result ######\n# response\n```\n#### 总结\n\n装饰器到此差不多都说完了，其作用就不展开说了，经过这么一连串的分析自己也对装饰器的原理有了更深的了解，算是没白浪费时间。\n","slug":"blogs-对Python装饰器的理解","published":1,"date":"2022-03-16T17:00:43.525Z","updated":"2022-03-16T17:05:32.837Z","_id":"cl0v6kesn001ayms40rl1dnfb","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>想要弄明白装饰器是什么东西，首先我们需要了解一下什么是闭包，因为装饰器是闭包的一种应用。</p>\n<h4 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>闭包的定义：</p>\n<p>​    通俗的来说闭包就是在一个函数内部定义另外一个函数，这个函数又引用了外部函数的变量，并且外函数的返回值是内函数的引用，下面是一个最简单的闭包示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">outer</span>():</span><br><span class=\"line\">    a = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner</span>():</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\">demo = outer()</span><br><span class=\"line\">demo()</span><br></pre></td></tr></table></figure>\n\n<p>那么再回到装饰器上面，我们都知道在python中任何东西都是对象，一个函数也好一个字符串也好都是对象，在传递过程中都是传递其内容的引用，当传递的是函数的时候只需在变量名后边加上()即可调用这个函数。</p>\n<p>好了基础知识了解了，那么下面来看一个简单的装饰器应用：</p>\n<h4 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">auth</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;before run&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>():</span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@auth</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">response</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;this is a test function&#x27;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">response()  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># before run</span></span><br><span class=\"line\"><span class=\"comment\"># this is a test function</span></span><br></pre></td></tr></table></figure>\n\n<p>乍一看是不是和闭包一样，只不过把变量替换成函数名了</p>\n<h5 id=\"参数的传递\"><a href=\"#参数的传递\" class=\"headerlink\" title=\"参数的传递\"></a>参数的传递</h5><p>上面的示例中被装饰函数是没有传递参数的，倘若被装饰函数需要传递参数的时候那么就需要稍微做一下调整。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">auth</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;before run&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">        func(*args, **kwargs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@auth</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">response</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;this is a test function&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(args)</span><br><span class=\"line\">    </span><br><span class=\"line\">response(<span class=\"number\">1</span>,<span class=\"number\">2</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># before run</span></span><br><span class=\"line\"><span class=\"comment\"># this is a test function</span></span><br><span class=\"line\"><span class=\"comment\"># (1, 2)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"装饰器的高级用法\"><a href=\"#装饰器的高级用法\" class=\"headerlink\" title=\"装饰器的高级用法\"></a>装饰器的高级用法</h4><p>有时候实际使用装饰器的时候可能并不会像上面的那样简单，例如我们可能需要给装饰器本身传递参数，来让装饰器更为灵活。先尝试不改代码看看运行的结果</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@auth(<span class=\"params\"><span class=\"number\">1</span>,<span class=\"number\">2</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">response</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;this is a test function&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(args)</span><br><span class=\"line\"></span><br><span class=\"line\">response(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># error:</span></span><br><span class=\"line\"><span class=\"comment\"># TypeError: auth() takes 1 positional argument but 2 were given</span></span><br></pre></td></tr></table></figure>\n\n<p>auth只有一个参数，但是传递了两个参数，这是为什么呢？我们需要先看看@auth这行代码是什么意思，@auth其实是response=auth(response)的简写，你看这样的写法就只接收一个参数，那么我们不使用这种简写方式可以吗？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">auth</span>(<span class=\"params\">func, *args</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;before run&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(args)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">        func(*args, **kwargs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">response</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;this is a test function&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(args)</span><br><span class=\"line\"></span><br><span class=\"line\">response = auth(response, <span class=\"number\">1</span>)</span><br><span class=\"line\">response(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># before run</span></span><br><span class=\"line\"><span class=\"comment\"># (1,)</span></span><br><span class=\"line\"><span class=\"comment\"># this is a test function</span></span><br><span class=\"line\"><span class=\"comment\"># (1, 2)</span></span><br></pre></td></tr></table></figure>\n\n<p>你看还真是实现了这个功能，只不过没办法使用简写来装饰函数了。那有没有更好的解决方法呢，我们再回到装饰器的原理上（一个闭包）那如果我们在闭包函数外面再套一层函数是不是就可以解决了呢。尝试一下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">outer</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;before run&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(args)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">            func(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@outer(<span class=\"params\"><span class=\"number\">1</span>, <span class=\"number\">2</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">response</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;this is a test function&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(args)</span><br><span class=\"line\"></span><br><span class=\"line\">response(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># before run</span></span><br><span class=\"line\"><span class=\"comment\"># (1,)</span></span><br><span class=\"line\"><span class=\"comment\"># this is a test function</span></span><br><span class=\"line\"><span class=\"comment\"># (1, 2)</span></span><br></pre></td></tr></table></figure>\n\n<p>实现了和上一个一样的功能，此时的@outer(1,2)还原成本来样子就是 response = outer(1,2)(response)，我们打上断点看看装饰器是如何运行的</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190307021938395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"多个装饰器同时使用\"><a href=\"#多个装饰器同时使用\" class=\"headerlink\" title=\"多个装饰器同时使用\"></a>多个装饰器同时使用</h4><p>先上代码看结果</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decorator1</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Decorator1&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">*args,**kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;----1----&#x27;</span>)</span><br><span class=\"line\">        func(*args, **kwargs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decorator2</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Decorator2&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">*args,**kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;----2----&#x27;</span>)</span><br><span class=\"line\">        func(*args, **kwargs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator1</span></span><br><span class=\"line\"><span class=\"meta\">@decorator2</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">*args</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(args)</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># Decorator2</span></span><br><span class=\"line\"><span class=\"comment\"># Decorator1</span></span><br><span class=\"line\"><span class=\"comment\"># ----1----</span></span><br><span class=\"line\"><span class=\"comment\"># ----2----</span></span><br><span class=\"line\"><span class=\"comment\"># (1, 2)</span></span><br></pre></td></tr></table></figure>\n\n<p>执行顺序并不是先执行完装饰器1然后在执行装饰器2，而是交替运行的，我们分析一下具体执行过程一探究竟。就装饰顺序来说还是按照decorator1、decorator2来对原函数装饰的，那么装饰的结果是什么呢，这里需要了解一下@符号的作用，在python中@会将紧跟着的函数名作为参数传给装饰函数，经过两个装饰器作用之后 test变成了 ：test = decorator1(decorator2(test))</p>\n<p>此时在调用test的时候，就会从里往外执行，</p>\n<ol>\n<li>即先执行decorator2(test)，会先打印出Decorator2</li>\n<li>返回decorator2中的内函数给decorator1，然后打印Decorator1</li>\n<li>返回decorator1内函数给test</li>\n<li>在调用test函数的时候就会先执行decorator1的内函数，打印出了—-1—-</li>\n<li>然后运行decorator2的内函数,打印出—-2—-</li>\n<li>最后才会运行test原函数</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/2019030702192439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>总结来说，在装饰过程中越靠近被装饰函数越先执行，内函数恰恰相反**</p>\n<h4 id=\"保留原函数的信息\"><a href=\"#保留原函数的信息\" class=\"headerlink\" title=\"保留原函数的信息\"></a>保留原函数的信息</h4><p>回到之前一个最简单的装饰器上，我们看看直接输出被装饰的函数信息是什么?</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">auth</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>():</span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@auth</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">response</span>():</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># wrapper</span></span><br></pre></td></tr></table></figure>\n\n<p>输出的是装饰器的内函数，原因就不说了，和之前的一样@的作用，难么我们该怎么让打印函数信息能够显示的是被装饰函数本身呢？这里就要用到functools的wraps方法，用法很简单：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">auth</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\"><span class=\"meta\">    @wraps(<span class=\"params\">func</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>():</span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@auth</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">response</span>():</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># response</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>装饰器到此差不多都说完了，其作用就不展开说了，经过这么一连串的分析自己也对装饰器的原理有了更深的了解，算是没白浪费时间。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>想要弄明白装饰器是什么东西，首先我们需要了解一下什么是闭包，因为装饰器是闭包的一种应用。</p>\n<h4 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>闭包的定义：</p>\n<p>​    通俗的来说闭包就是在一个函数内部定义另外一个函数，这个函数又引用了外部函数的变量，并且外函数的返回值是内函数的引用，下面是一个最简单的闭包示例：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">outer</span>():</span><br><span class=\"line\">    a = <span class=\"number\">10</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner</span>():</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(a)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\">demo = outer()</span><br><span class=\"line\">demo()</span><br></pre></td></tr></table></figure>\n\n<p>那么再回到装饰器上面，我们都知道在python中任何东西都是对象，一个函数也好一个字符串也好都是对象，在传递过程中都是传递其内容的引用，当传递的是函数的时候只需在变量名后边加上()即可调用这个函数。</p>\n<p>好了基础知识了解了，那么下面来看一个简单的装饰器应用：</p>\n<h4 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h4><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">auth</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;before run&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>():</span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@auth</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">response</span>():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;this is a test function&#x27;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">response()  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># before run</span></span><br><span class=\"line\"><span class=\"comment\"># this is a test function</span></span><br></pre></td></tr></table></figure>\n\n<p>乍一看是不是和闭包一样，只不过把变量替换成函数名了</p>\n<h5 id=\"参数的传递\"><a href=\"#参数的传递\" class=\"headerlink\" title=\"参数的传递\"></a>参数的传递</h5><p>上面的示例中被装饰函数是没有传递参数的，倘若被装饰函数需要传递参数的时候那么就需要稍微做一下调整。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">auth</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;before run&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">        func(*args, **kwargs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@auth</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">response</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;this is a test function&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(args)</span><br><span class=\"line\">    </span><br><span class=\"line\">response(<span class=\"number\">1</span>,<span class=\"number\">2</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># before run</span></span><br><span class=\"line\"><span class=\"comment\"># this is a test function</span></span><br><span class=\"line\"><span class=\"comment\"># (1, 2)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"装饰器的高级用法\"><a href=\"#装饰器的高级用法\" class=\"headerlink\" title=\"装饰器的高级用法\"></a>装饰器的高级用法</h4><p>有时候实际使用装饰器的时候可能并不会像上面的那样简单，例如我们可能需要给装饰器本身传递参数，来让装饰器更为灵活。先尝试不改代码看看运行的结果</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@auth(<span class=\"params\"><span class=\"number\">1</span>,<span class=\"number\">2</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">response</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;this is a test function&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(args)</span><br><span class=\"line\"></span><br><span class=\"line\">response(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># error:</span></span><br><span class=\"line\"><span class=\"comment\"># TypeError: auth() takes 1 positional argument but 2 were given</span></span><br></pre></td></tr></table></figure>\n\n<p>auth只有一个参数，但是传递了两个参数，这是为什么呢？我们需要先看看@auth这行代码是什么意思，@auth其实是response=auth(response)的简写，你看这样的写法就只接收一个参数，那么我们不使用这种简写方式可以吗？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">auth</span>(<span class=\"params\">func, *args</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;before run&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(args)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">        func(*args, **kwargs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">response</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;this is a test function&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(args)</span><br><span class=\"line\"></span><br><span class=\"line\">response = auth(response, <span class=\"number\">1</span>)</span><br><span class=\"line\">response(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># before run</span></span><br><span class=\"line\"><span class=\"comment\"># (1,)</span></span><br><span class=\"line\"><span class=\"comment\"># this is a test function</span></span><br><span class=\"line\"><span class=\"comment\"># (1, 2)</span></span><br></pre></td></tr></table></figure>\n\n<p>你看还真是实现了这个功能，只不过没办法使用简写来装饰函数了。那有没有更好的解决方法呢，我们再回到装饰器的原理上（一个闭包）那如果我们在闭包函数外面再套一层函数是不是就可以解决了呢。尝试一下</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">outer</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;before run&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(args)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">inner</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">        <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">            func(*args, **kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inner</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@outer(<span class=\"params\"><span class=\"number\">1</span>, <span class=\"number\">2</span></span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">response</span>(<span class=\"params\">*args, **kwargs</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;this is a test function&#x27;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(args)</span><br><span class=\"line\"></span><br><span class=\"line\">response(<span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># before run</span></span><br><span class=\"line\"><span class=\"comment\"># (1,)</span></span><br><span class=\"line\"><span class=\"comment\"># this is a test function</span></span><br><span class=\"line\"><span class=\"comment\"># (1, 2)</span></span><br></pre></td></tr></table></figure>\n\n<p>实现了和上一个一样的功能，此时的@outer(1,2)还原成本来样子就是 response = outer(1,2)(response)，我们打上断点看看装饰器是如何运行的</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190307021938395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"多个装饰器同时使用\"><a href=\"#多个装饰器同时使用\" class=\"headerlink\" title=\"多个装饰器同时使用\"></a>多个装饰器同时使用</h4><p>先上代码看结果</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decorator1</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Decorator1&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">*args,**kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;----1----&#x27;</span>)</span><br><span class=\"line\">        func(*args, **kwargs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">decorator2</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;Decorator2&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>(<span class=\"params\">*args,**kwargs</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;----2----&#x27;</span>)</span><br><span class=\"line\">        func(*args, **kwargs)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator1</span></span><br><span class=\"line\"><span class=\"meta\">@decorator2</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">test</span>(<span class=\"params\">*args</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(args)</span><br><span class=\"line\"></span><br><span class=\"line\">test(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># Decorator2</span></span><br><span class=\"line\"><span class=\"comment\"># Decorator1</span></span><br><span class=\"line\"><span class=\"comment\"># ----1----</span></span><br><span class=\"line\"><span class=\"comment\"># ----2----</span></span><br><span class=\"line\"><span class=\"comment\"># (1, 2)</span></span><br></pre></td></tr></table></figure>\n\n<p>执行顺序并不是先执行完装饰器1然后在执行装饰器2，而是交替运行的，我们分析一下具体执行过程一探究竟。就装饰顺序来说还是按照decorator1、decorator2来对原函数装饰的，那么装饰的结果是什么呢，这里需要了解一下@符号的作用，在python中@会将紧跟着的函数名作为参数传给装饰函数，经过两个装饰器作用之后 test变成了 ：test = decorator1(decorator2(test))</p>\n<p>此时在调用test的时候，就会从里往外执行，</p>\n<ol>\n<li>即先执行decorator2(test)，会先打印出Decorator2</li>\n<li>返回decorator2中的内函数给decorator1，然后打印Decorator1</li>\n<li>返回decorator1内函数给test</li>\n<li>在调用test函数的时候就会先执行decorator1的内函数，打印出了—-1—-</li>\n<li>然后运行decorator2的内函数,打印出—-2—-</li>\n<li>最后才会运行test原函数</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/2019030702192439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>总结来说，在装饰过程中越靠近被装饰函数越先执行，内函数恰恰相反**</p>\n<h4 id=\"保留原函数的信息\"><a href=\"#保留原函数的信息\" class=\"headerlink\" title=\"保留原函数的信息\"></a>保留原函数的信息</h4><p>回到之前一个最简单的装饰器上，我们看看直接输出被装饰的函数信息是什么?</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">auth</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>():</span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@auth</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">response</span>():</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># wrapper</span></span><br></pre></td></tr></table></figure>\n\n<p>输出的是装饰器的内函数，原因就不说了，和之前的一样@的作用，难么我们该怎么让打印函数信息能够显示的是被装饰函数本身呢？这里就要用到functools的wraps方法，用法很简单：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> functools <span class=\"keyword\">import</span> wraps</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">auth</span>(<span class=\"params\">func</span>):</span><br><span class=\"line\"><span class=\"meta\">    @wraps(<span class=\"params\">func</span>)</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">wrapper</span>():</span><br><span class=\"line\">        func()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@auth</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">response</span>():</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(response.__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">###### result ######</span></span><br><span class=\"line\"><span class=\"comment\"># response</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>装饰器到此差不多都说完了，其作用就不展开说了，经过这么一连串的分析自己也对装饰器的原理有了更深的了解，算是没白浪费时间。</p>\n"},{"_content":"#### 微信小程序开发\n\n1.数据绑定 {{ name}} ，和vue不同的是如果直接更改data并不会重新渲染，而是要使用setData({name:data})的方法\n\n2.调用组件的方法：\n\n- 获取元素：\n\n  ```\n   const ele = this.selectComponent(id)\n  ```\n\n- 调用组建的method中的方法：\n\n  ```\n   ele.functionName()\n  ```\n\n3.组件中的`properties`和`data`的区别：\n\n- 首先properties是外部可更改的属性，data外部不能修改\n- 两者用法差不多 都是this.data.name来取值\n\n4.小程序中的传参问题\n\n​\t首先需要知道的是没有办法和vue中一样 使用函数名(参数)的形式实现，在小程序中如果想要传参数，则需要在绑定的元素中定义属性 data-参数名的形式，在回调函数中通过target.dataset属性获取，例如：\n\n```html\n<view data-streamId='{{stream.id}}' bindtap='test'></view>\n```\n\n```javascript\ntest: function (event) {\n  console.log(event.target.dataset.streamid)\n}\n```\n\n5.嵌套传参的问题：\n\n```html\n <view class='new-container' bindtap='update' data-name='{{item.name}}'>\n  <view class='title'>{{item.title}}</view>\n  <view class='num'>{{item.num}}</view>\n  <view class='tips'>点击刷新</view>\n</view>\n```\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190227130645676.png)\n\n点击内容区域的时候，如果使用target来取值会出现空，而currentTarget则不会\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190227130737881.png)\n\n在官方的文档上是这样介绍两者的![在这里插入图片描述](https://img-blog.csdnimg.cn/20190227130757825.png)\n\n\n6关于setData()修改数组对象的操作， 一般setData()传入的是一个对象,如下name是作为了key的名称\n\n```javascript\ndata:{\n    name:'fa',\n    array:[{name:'aa',num:1},{name:'bb',num:2}]\n}\n\nthis.setData({\n    name:'wx'\n})\n```\n\n当我们只是想修改array数组中的num的值，这时候按照上面的就没法实现了， 这时候可以采用'array[0].num':2来实现\n\n```javascript\nthis.setData({\n    ['array[0].num']:2\n})\n```\n\n但是呢这个’0‘又是不能动态更改的，所以呢还是需要整体修改例如：\n\n```javascript\nfor (var i = 0; i < this.data.increase.length; i++) {\n  if (this.data.array[i].name == 'aa'){\n    this.data.increase[i].num = 2\n    break\n  }\n}\nthis.setData({\n  array: this.data.array\n})\n```\n\n","source":"_posts/blogs-微信小程序开发总结.md","raw":"#### 微信小程序开发\n\n1.数据绑定 {{ name}} ，和vue不同的是如果直接更改data并不会重新渲染，而是要使用setData({name:data})的方法\n\n2.调用组件的方法：\n\n- 获取元素：\n\n  ```\n   const ele = this.selectComponent(id)\n  ```\n\n- 调用组建的method中的方法：\n\n  ```\n   ele.functionName()\n  ```\n\n3.组件中的`properties`和`data`的区别：\n\n- 首先properties是外部可更改的属性，data外部不能修改\n- 两者用法差不多 都是this.data.name来取值\n\n4.小程序中的传参问题\n\n​\t首先需要知道的是没有办法和vue中一样 使用函数名(参数)的形式实现，在小程序中如果想要传参数，则需要在绑定的元素中定义属性 data-参数名的形式，在回调函数中通过target.dataset属性获取，例如：\n\n```html\n<view data-streamId='{{stream.id}}' bindtap='test'></view>\n```\n\n```javascript\ntest: function (event) {\n  console.log(event.target.dataset.streamid)\n}\n```\n\n5.嵌套传参的问题：\n\n```html\n <view class='new-container' bindtap='update' data-name='{{item.name}}'>\n  <view class='title'>{{item.title}}</view>\n  <view class='num'>{{item.num}}</view>\n  <view class='tips'>点击刷新</view>\n</view>\n```\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190227130645676.png)\n\n点击内容区域的时候，如果使用target来取值会出现空，而currentTarget则不会\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190227130737881.png)\n\n在官方的文档上是这样介绍两者的![在这里插入图片描述](https://img-blog.csdnimg.cn/20190227130757825.png)\n\n\n6关于setData()修改数组对象的操作， 一般setData()传入的是一个对象,如下name是作为了key的名称\n\n```javascript\ndata:{\n    name:'fa',\n    array:[{name:'aa',num:1},{name:'bb',num:2}]\n}\n\nthis.setData({\n    name:'wx'\n})\n```\n\n当我们只是想修改array数组中的num的值，这时候按照上面的就没法实现了， 这时候可以采用'array[0].num':2来实现\n\n```javascript\nthis.setData({\n    ['array[0].num']:2\n})\n```\n\n但是呢这个’0‘又是不能动态更改的，所以呢还是需要整体修改例如：\n\n```javascript\nfor (var i = 0; i < this.data.increase.length; i++) {\n  if (this.data.array[i].name == 'aa'){\n    this.data.increase[i].num = 2\n    break\n  }\n}\nthis.setData({\n  array: this.data.array\n})\n```\n\n","slug":"blogs-微信小程序开发总结","published":1,"date":"2022-03-16T17:00:48.514Z","updated":"2022-03-16T17:05:37.840Z","_id":"cl0v6keso001byms4deu6g62h","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"微信小程序开发\"><a href=\"#微信小程序开发\" class=\"headerlink\" title=\"微信小程序开发\"></a>微信小程序开发</h4><p>1.数据绑定  ，和vue不同的是如果直接更改data并不会重新渲染，而是要使用setData({name:data})的方法</p>\n<p>2.调用组件的方法：</p>\n<ul>\n<li><p>获取元素：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ele = this.selectComponent(id)</span><br></pre></td></tr></table></figure></li>\n<li><p>调用组建的method中的方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele.functionName()</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>3.组件中的<code>properties</code>和<code>data</code>的区别：</p>\n<ul>\n<li>首先properties是外部可更改的属性，data外部不能修改</li>\n<li>两者用法差不多 都是this.data.name来取值</li>\n</ul>\n<p>4.小程序中的传参问题</p>\n<p>​    首先需要知道的是没有办法和vue中一样 使用函数名(参数)的形式实现，在小程序中如果想要传参数，则需要在绑定的元素中定义属性 data-参数名的形式，在回调函数中通过target.dataset属性获取，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">data-streamId</span>=<span class=\"string\">&#x27;&#123;&#123;stream.id&#125;&#125;&#x27;</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&#x27;test&#x27;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">test</span>: <span class=\"keyword\">function</span> (<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(event.<span class=\"property\">target</span>.<span class=\"property\">dataset</span>.<span class=\"property\">streamid</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.嵌套传参的问题：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;new-container&#x27;</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&#x27;update&#x27;</span> <span class=\"attr\">data-name</span>=<span class=\"string\">&#x27;&#123;&#123;item.name&#125;&#125;&#x27;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;title&#x27;</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;num&#x27;</span>&gt;</span>&#123;&#123;item.num&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;tips&#x27;</span>&gt;</span>点击刷新<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p> <img src=\"https://img-blog.csdnimg.cn/20190227130645676.png\" alt=\"在这里插入图片描述\"></p>\n<p>点击内容区域的时候，如果使用target来取值会出现空，而currentTarget则不会<br><img src=\"https://img-blog.csdnimg.cn/20190227130737881.png\" alt=\"在这里插入图片描述\"></p>\n<p>在官方的文档上是这样介绍两者的<img src=\"https://img-blog.csdnimg.cn/20190227130757825.png\" alt=\"在这里插入图片描述\"></p>\n<p>6关于setData()修改数组对象的操作， 一般setData()传入的是一个对象,如下name是作为了key的名称</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">data</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>:<span class=\"string\">&#x27;fa&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">array</span>:[&#123;<span class=\"attr\">name</span>:<span class=\"string\">&#x27;aa&#x27;</span>,<span class=\"attr\">num</span>:<span class=\"number\">1</span>&#125;,&#123;<span class=\"attr\">name</span>:<span class=\"string\">&#x27;bb&#x27;</span>,<span class=\"attr\">num</span>:<span class=\"number\">2</span>&#125;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setData</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>:<span class=\"string\">&#x27;wx&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当我们只是想修改array数组中的num的值，这时候按照上面的就没法实现了， 这时候可以采用’array[0].num’:2来实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setData</span>(&#123;</span><br><span class=\"line\">    [<span class=\"string\">&#x27;array[0].num&#x27;</span>]:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>但是呢这个’0‘又是不能动态更改的，所以呢还是需要整体修改例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>.<span class=\"property\">increase</span>.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>.<span class=\"property\">array</span>[i].<span class=\"property\">name</span> == <span class=\"string\">&#x27;aa&#x27;</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>.<span class=\"property\">increase</span>[i].<span class=\"property\">num</span> = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setData</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">array</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>.<span class=\"property\">array</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"微信小程序开发\"><a href=\"#微信小程序开发\" class=\"headerlink\" title=\"微信小程序开发\"></a>微信小程序开发</h4><p>1.数据绑定  ，和vue不同的是如果直接更改data并不会重新渲染，而是要使用setData({name:data})的方法</p>\n<p>2.调用组件的方法：</p>\n<ul>\n<li><p>获取元素：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const ele = this.selectComponent(id)</span><br></pre></td></tr></table></figure></li>\n<li><p>调用组建的method中的方法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele.functionName()</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>3.组件中的<code>properties</code>和<code>data</code>的区别：</p>\n<ul>\n<li>首先properties是外部可更改的属性，data外部不能修改</li>\n<li>两者用法差不多 都是this.data.name来取值</li>\n</ul>\n<p>4.小程序中的传参问题</p>\n<p>​    首先需要知道的是没有办法和vue中一样 使用函数名(参数)的形式实现，在小程序中如果想要传参数，则需要在绑定的元素中定义属性 data-参数名的形式，在回调函数中通过target.dataset属性获取，例如：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">data-streamId</span>=<span class=\"string\">&#x27;&#123;&#123;stream.id&#125;&#125;&#x27;</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&#x27;test&#x27;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">test</span>: <span class=\"keyword\">function</span> (<span class=\"params\">event</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(event.<span class=\"property\">target</span>.<span class=\"property\">dataset</span>.<span class=\"property\">streamid</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>5.嵌套传参的问题：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;new-container&#x27;</span> <span class=\"attr\">bindtap</span>=<span class=\"string\">&#x27;update&#x27;</span> <span class=\"attr\">data-name</span>=<span class=\"string\">&#x27;&#123;&#123;item.name&#125;&#125;&#x27;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;title&#x27;</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;num&#x27;</span>&gt;</span>&#123;&#123;item.num&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">view</span> <span class=\"attr\">class</span>=<span class=\"string\">&#x27;tips&#x27;</span>&gt;</span>点击刷新<span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">view</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p> <img src=\"https://img-blog.csdnimg.cn/20190227130645676.png\" alt=\"在这里插入图片描述\"></p>\n<p>点击内容区域的时候，如果使用target来取值会出现空，而currentTarget则不会<br><img src=\"https://img-blog.csdnimg.cn/20190227130737881.png\" alt=\"在这里插入图片描述\"></p>\n<p>在官方的文档上是这样介绍两者的<img src=\"https://img-blog.csdnimg.cn/20190227130757825.png\" alt=\"在这里插入图片描述\"></p>\n<p>6关于setData()修改数组对象的操作， 一般setData()传入的是一个对象,如下name是作为了key的名称</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">data</span>:&#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>:<span class=\"string\">&#x27;fa&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">array</span>:[&#123;<span class=\"attr\">name</span>:<span class=\"string\">&#x27;aa&#x27;</span>,<span class=\"attr\">num</span>:<span class=\"number\">1</span>&#125;,&#123;<span class=\"attr\">name</span>:<span class=\"string\">&#x27;bb&#x27;</span>,<span class=\"attr\">num</span>:<span class=\"number\">2</span>&#125;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setData</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>:<span class=\"string\">&#x27;wx&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>当我们只是想修改array数组中的num的值，这时候按照上面的就没法实现了， 这时候可以采用’array[0].num’:2来实现</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setData</span>(&#123;</span><br><span class=\"line\">    [<span class=\"string\">&#x27;array[0].num&#x27;</span>]:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>但是呢这个’0‘又是不能动态更改的，所以呢还是需要整体修改例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>.<span class=\"property\">increase</span>.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"variable language_\">this</span>.<span class=\"property\">data</span>.<span class=\"property\">array</span>[i].<span class=\"property\">name</span> == <span class=\"string\">&#x27;aa&#x27;</span>)&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>.<span class=\"property\">increase</span>[i].<span class=\"property\">num</span> = <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">this</span>.<span class=\"title function_\">setData</span>(&#123;</span><br><span class=\"line\">  <span class=\"attr\">array</span>: <span class=\"variable language_\">this</span>.<span class=\"property\">data</span>.<span class=\"property\">array</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n"},{"_content":"\n<h3>命令下发</h3>\n<div>先来看一段OneNet文档说明：</div>\n<div>\n<p>命令是指应用发送命令数据给OneNet设备云、再由OneNet设备云转发给终端设备、终端设备收到命令后可以向设备云反馈响应的一种工作机制。命令下发后，应用可以通过API查询命令状态和提取命令的响应数据。</p>\n<p>命令的执行步骤如下：</p>\n<p>1、&nbsp; 应用通过API向设备云发送命令数据；</p>\n<p>2、&nbsp; 设备云生成该命令的uuid作为该命令的唯一标识并向应用返回，同时向终端设备转发命令数据；</p>\n<p>3、&nbsp; 终端设备收到命令数据后执行命令数据，可以生成响应，也可以不响应；</p>\n<p>4、&nbsp; 设备云跟踪记录命令的响应，如果设备有响应，就关联命令uuid和响应结果；</p>\n<p>5、&nbsp; 应用通过API向设备云提取命令执行结果(API请求中携带命令uuid标识)。</p>\n<p>特别说明：</p>\n<p>命令下发到终端设备后，如果终端设备10秒内未收到响应，则此命令的状态将被设置为超时，应用通过API查询命令状态时，会反馈超时。超过10秒后收到的响应会被丢弃。</p>\n<p>终端设备针对同一条命令回复多条命令响应，只有在未超时时间内收到的第一条是有效响应，后续的响应包将会被直接丢弃。因此终端设备应该对每个命令只有一个响应包。</p>\n<p><br>\n</p>\n<p>下面是请求&#26684;式，这个地方有些坑，和官网的公开协议产品指南有所不同，刚开始按照官网的来实现始终报，后来在其他文档里面找到了这个才最终调试通了</p>\n<br>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\" width=\"621\">\n<tbody>\n<tr>\n<td valign=\"top\">\n<p>HTTP方法</p>\n</td>\n<td valign=\"top\">\n<p>POST</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>URL</p>\n</td>\n<td valign=\"top\">\n<p><span style=\"color:#333333; background:#F9F9F9\">http://&lt;API_ADDRESS&gt;</span><span style=\"color:#333333; background:white\">/cmds</span></p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>HTTP头部</p>\n</td>\n<td valign=\"top\">\n<p>api-key:xxxx-ffff-zzzzz，必须master key</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>URL参数</p>\n</td>\n<td valign=\"top\">\n<p>device_id = //接收该数据的设备ID，必填。</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>HTTP内容</p>\n</td>\n<td valign=\"top\">\n<p>用户自定义Json或二进制数据（小于64K）</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>成功返回</p>\n</td>\n<td valign=\"top\">\n<p>{</p>\n<p>&quot;errno&quot;: 0,</p>\n<p>&quot;error&quot;:“succ”，</p>\n<p>&quot;data&quot;:{</p>\n<p><em>//不超过64个字符字符串</em></p>\n<p>&quot;cmd_uuid&quot;:“2302-312-FWs”</p>\n<p>}</p>\n<p>}</p>\n</td>\n</tr>\n</tbody>\n</table>\n<br>\n<br>\n</div>\n<div><pre name=\"code\" class=\"python\">import requests\n\nclass OneNet():\n    def __init__(self,key,dev_id,cmd):\n        self.api_key = key\n        self.dev_id = dev_id\n        self.cmd = cmd\n        self.header = {'api-key': self.api_key}\n    def send_cmd(self):\n        params = {'device_id':self.dev_id}\n        url = &quot;http://api.heclouds.com/cmds?&quot;\n        r = requests.session()\n        res = r.post(url, headers=self.header, params=params,data=self.cmd)\n        print(res.content)\n\nt = OneNet(you api_key,your dec_id, cmd)\nt.send_cmd()</pre>使用自带的requests库来实现post请求</div>\n<div><br>\n</div>\n<div>最后的结果</div>\n<div><br>\n</div>\n<div><pre name=\"code\" class=\"python\">{&quot;errno&quot;:0,&quot;data&quot;:{&quot;cmd_uuid&quot;:&quot;5bdaf1a9-3854-5e5f-b662-b1e3ef57ea6e&quot;},&quot;error&quot;:&quot;succ&quot;}</pre><br>\n<br>\n<br>\n</div>\n","source":"_posts/blogs-微信公众号实现简易的物联网控制（二）.md","raw":"\n<h3>命令下发</h3>\n<div>先来看一段OneNet文档说明：</div>\n<div>\n<p>命令是指应用发送命令数据给OneNet设备云、再由OneNet设备云转发给终端设备、终端设备收到命令后可以向设备云反馈响应的一种工作机制。命令下发后，应用可以通过API查询命令状态和提取命令的响应数据。</p>\n<p>命令的执行步骤如下：</p>\n<p>1、&nbsp; 应用通过API向设备云发送命令数据；</p>\n<p>2、&nbsp; 设备云生成该命令的uuid作为该命令的唯一标识并向应用返回，同时向终端设备转发命令数据；</p>\n<p>3、&nbsp; 终端设备收到命令数据后执行命令数据，可以生成响应，也可以不响应；</p>\n<p>4、&nbsp; 设备云跟踪记录命令的响应，如果设备有响应，就关联命令uuid和响应结果；</p>\n<p>5、&nbsp; 应用通过API向设备云提取命令执行结果(API请求中携带命令uuid标识)。</p>\n<p>特别说明：</p>\n<p>命令下发到终端设备后，如果终端设备10秒内未收到响应，则此命令的状态将被设置为超时，应用通过API查询命令状态时，会反馈超时。超过10秒后收到的响应会被丢弃。</p>\n<p>终端设备针对同一条命令回复多条命令响应，只有在未超时时间内收到的第一条是有效响应，后续的响应包将会被直接丢弃。因此终端设备应该对每个命令只有一个响应包。</p>\n<p><br>\n</p>\n<p>下面是请求&#26684;式，这个地方有些坑，和官网的公开协议产品指南有所不同，刚开始按照官网的来实现始终报，后来在其他文档里面找到了这个才最终调试通了</p>\n<br>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\" width=\"621\">\n<tbody>\n<tr>\n<td valign=\"top\">\n<p>HTTP方法</p>\n</td>\n<td valign=\"top\">\n<p>POST</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>URL</p>\n</td>\n<td valign=\"top\">\n<p><span style=\"color:#333333; background:#F9F9F9\">http://&lt;API_ADDRESS&gt;</span><span style=\"color:#333333; background:white\">/cmds</span></p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>HTTP头部</p>\n</td>\n<td valign=\"top\">\n<p>api-key:xxxx-ffff-zzzzz，必须master key</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>URL参数</p>\n</td>\n<td valign=\"top\">\n<p>device_id = //接收该数据的设备ID，必填。</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>HTTP内容</p>\n</td>\n<td valign=\"top\">\n<p>用户自定义Json或二进制数据（小于64K）</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>成功返回</p>\n</td>\n<td valign=\"top\">\n<p>{</p>\n<p>&quot;errno&quot;: 0,</p>\n<p>&quot;error&quot;:“succ”，</p>\n<p>&quot;data&quot;:{</p>\n<p><em>//不超过64个字符字符串</em></p>\n<p>&quot;cmd_uuid&quot;:“2302-312-FWs”</p>\n<p>}</p>\n<p>}</p>\n</td>\n</tr>\n</tbody>\n</table>\n<br>\n<br>\n</div>\n<div><pre name=\"code\" class=\"python\">import requests\n\nclass OneNet():\n    def __init__(self,key,dev_id,cmd):\n        self.api_key = key\n        self.dev_id = dev_id\n        self.cmd = cmd\n        self.header = {'api-key': self.api_key}\n    def send_cmd(self):\n        params = {'device_id':self.dev_id}\n        url = &quot;http://api.heclouds.com/cmds?&quot;\n        r = requests.session()\n        res = r.post(url, headers=self.header, params=params,data=self.cmd)\n        print(res.content)\n\nt = OneNet(you api_key,your dec_id, cmd)\nt.send_cmd()</pre>使用自带的requests库来实现post请求</div>\n<div><br>\n</div>\n<div>最后的结果</div>\n<div><br>\n</div>\n<div><pre name=\"code\" class=\"python\">{&quot;errno&quot;:0,&quot;data&quot;:{&quot;cmd_uuid&quot;:&quot;5bdaf1a9-3854-5e5f-b662-b1e3ef57ea6e&quot;},&quot;error&quot;:&quot;succ&quot;}</pre><br>\n<br>\n<br>\n</div>\n","slug":"blogs-微信公众号实现简易的物联网控制（二）","published":1,"date":"2022-03-16T17:09:32.833Z","updated":"2022-03-16T17:09:32.837Z","_id":"cl0v6kesp001cyms49d2fbu5q","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>命令下发</h3>\n<div>先来看一段OneNet文档说明：</div>\n<div>\n<p>命令是指应用发送命令数据给OneNet设备云、再由OneNet设备云转发给终端设备、终端设备收到命令后可以向设备云反馈响应的一种工作机制。命令下发后，应用可以通过API查询命令状态和提取命令的响应数据。</p>\n<p>命令的执行步骤如下：</p>\n<p>1、&nbsp; 应用通过API向设备云发送命令数据；</p>\n<p>2、&nbsp; 设备云生成该命令的uuid作为该命令的唯一标识并向应用返回，同时向终端设备转发命令数据；</p>\n<p>3、&nbsp; 终端设备收到命令数据后执行命令数据，可以生成响应，也可以不响应；</p>\n<p>4、&nbsp; 设备云跟踪记录命令的响应，如果设备有响应，就关联命令uuid和响应结果；</p>\n<p>5、&nbsp; 应用通过API向设备云提取命令执行结果(API请求中携带命令uuid标识)。</p>\n<p>特别说明：</p>\n<p>命令下发到终端设备后，如果终端设备10秒内未收到响应，则此命令的状态将被设置为超时，应用通过API查询命令状态时，会反馈超时。超过10秒后收到的响应会被丢弃。</p>\n<p>终端设备针对同一条命令回复多条命令响应，只有在未超时时间内收到的第一条是有效响应，后续的响应包将会被直接丢弃。因此终端设备应该对每个命令只有一个响应包。</p>\n<p><br>\n</p>\n<p>下面是请求&#26684;式，这个地方有些坑，和官网的公开协议产品指南有所不同，刚开始按照官网的来实现始终报，后来在其他文档里面找到了这个才最终调试通了</p>\n<br>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\" width=\"621\">\n<tbody>\n<tr>\n<td valign=\"top\">\n<p>HTTP方法</p>\n</td>\n<td valign=\"top\">\n<p>POST</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>URL</p>\n</td>\n<td valign=\"top\">\n<p><span style=\"color:#333333; background:#F9F9F9\">http://&lt;API_ADDRESS&gt;</span><span style=\"color:#333333; background:white\">/cmds</span></p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>HTTP头部</p>\n</td>\n<td valign=\"top\">\n<p>api-key:xxxx-ffff-zzzzz，必须master key</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>URL参数</p>\n</td>\n<td valign=\"top\">\n<p>device_id = //接收该数据的设备ID，必填。</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>HTTP内容</p>\n</td>\n<td valign=\"top\">\n<p>用户自定义Json或二进制数据（小于64K）</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>成功返回</p>\n</td>\n<td valign=\"top\">\n<p>{</p>\n<p>&quot;errno&quot;: 0,</p>\n<p>&quot;error&quot;:“succ”，</p>\n<p>&quot;data&quot;:{</p>\n<p><em>//不超过64个字符字符串</em></p>\n<p>&quot;cmd_uuid&quot;:“2302-312-FWs”</p>\n<p>}</p>\n<p>}</p>\n</td>\n</tr>\n</tbody>\n</table>\n<br>\n<br>\n</div>\n<div><pre name=\"code\" class=\"python\">import requests\n\n<p>class OneNet():<br>    def <strong>init</strong>(self,key,dev_id,cmd):<br>        self.api_key = key<br>        self.dev_id = dev_id<br>        self.cmd = cmd<br>        self.header = {‘api-key’: self.api_key}<br>    def send_cmd(self):<br>        params = {‘device_id’:self.dev_id}<br>        url = &quot;<a href=\"http://api.heclouds.com/cmds\">http://api.heclouds.com/cmds</a>?&quot;<br>        r = requests.session()<br>        res = r.post(url, headers=self.header, params=params,data=self.cmd)<br>        print(res.content)</p>\n<p>t = OneNet(you api_key,your dec_id, cmd)<br>t.send_cmd()</pre>使用自带的requests库来实现post请求</div></p>\n<div><br>\n</div>\n<div>最后的结果</div>\n<div><br>\n</div>\n<div><pre name=\"code\" class=\"python\">{&quot;errno&quot;:0,&quot;data&quot;:{&quot;cmd_uuid&quot;:&quot;5bdaf1a9-3854-5e5f-b662-b1e3ef57ea6e&quot;},&quot;error&quot;:&quot;succ&quot;}</pre><br>\n<br>\n<br>\n</div>\n","site":{"data":{}},"excerpt":"","more":"<h3>命令下发</h3>\n<div>先来看一段OneNet文档说明：</div>\n<div>\n<p>命令是指应用发送命令数据给OneNet设备云、再由OneNet设备云转发给终端设备、终端设备收到命令后可以向设备云反馈响应的一种工作机制。命令下发后，应用可以通过API查询命令状态和提取命令的响应数据。</p>\n<p>命令的执行步骤如下：</p>\n<p>1、&nbsp; 应用通过API向设备云发送命令数据；</p>\n<p>2、&nbsp; 设备云生成该命令的uuid作为该命令的唯一标识并向应用返回，同时向终端设备转发命令数据；</p>\n<p>3、&nbsp; 终端设备收到命令数据后执行命令数据，可以生成响应，也可以不响应；</p>\n<p>4、&nbsp; 设备云跟踪记录命令的响应，如果设备有响应，就关联命令uuid和响应结果；</p>\n<p>5、&nbsp; 应用通过API向设备云提取命令执行结果(API请求中携带命令uuid标识)。</p>\n<p>特别说明：</p>\n<p>命令下发到终端设备后，如果终端设备10秒内未收到响应，则此命令的状态将被设置为超时，应用通过API查询命令状态时，会反馈超时。超过10秒后收到的响应会被丢弃。</p>\n<p>终端设备针对同一条命令回复多条命令响应，只有在未超时时间内收到的第一条是有效响应，后续的响应包将会被直接丢弃。因此终端设备应该对每个命令只有一个响应包。</p>\n<p><br>\n</p>\n<p>下面是请求&#26684;式，这个地方有些坑，和官网的公开协议产品指南有所不同，刚开始按照官网的来实现始终报，后来在其他文档里面找到了这个才最终调试通了</p>\n<br>\n<table border=\"1\" cellspacing=\"0\" cellpadding=\"0\" width=\"621\">\n<tbody>\n<tr>\n<td valign=\"top\">\n<p>HTTP方法</p>\n</td>\n<td valign=\"top\">\n<p>POST</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>URL</p>\n</td>\n<td valign=\"top\">\n<p><span style=\"color:#333333; background:#F9F9F9\">http://&lt;API_ADDRESS&gt;</span><span style=\"color:#333333; background:white\">/cmds</span></p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>HTTP头部</p>\n</td>\n<td valign=\"top\">\n<p>api-key:xxxx-ffff-zzzzz，必须master key</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>URL参数</p>\n</td>\n<td valign=\"top\">\n<p>device_id = //接收该数据的设备ID，必填。</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>HTTP内容</p>\n</td>\n<td valign=\"top\">\n<p>用户自定义Json或二进制数据（小于64K）</p>\n</td>\n</tr>\n<tr>\n<td valign=\"top\">\n<p>成功返回</p>\n</td>\n<td valign=\"top\">\n<p>{</p>\n<p>&quot;errno&quot;: 0,</p>\n<p>&quot;error&quot;:“succ”，</p>\n<p>&quot;data&quot;:{</p>\n<p><em>//不超过64个字符字符串</em></p>\n<p>&quot;cmd_uuid&quot;:“2302-312-FWs”</p>\n<p>}</p>\n<p>}</p>\n</td>\n</tr>\n</tbody>\n</table>\n<br>\n<br>\n</div>\n<div><pre name=\"code\" class=\"python\">import requests\n\n<p>class OneNet():<br>    def <strong>init</strong>(self,key,dev_id,cmd):<br>        self.api_key = key<br>        self.dev_id = dev_id<br>        self.cmd = cmd<br>        self.header = {‘api-key’: self.api_key}<br>    def send_cmd(self):<br>        params = {‘device_id’:self.dev_id}<br>        url = &quot;<a href=\"http://api.heclouds.com/cmds\">http://api.heclouds.com/cmds</a>?&quot;<br>        r = requests.session()<br>        res = r.post(url, headers=self.header, params=params,data=self.cmd)<br>        print(res.content)</p>\n<p>t = OneNet(you api_key,your dec_id, cmd)<br>t.send_cmd()</pre>使用自带的requests库来实现post请求</div></p>\n<div><br>\n</div>\n<div>最后的结果</div>\n<div><br>\n</div>\n<div><pre name=\"code\" class=\"python\">{&quot;errno&quot;:0,&quot;data&quot;:{&quot;cmd_uuid&quot;:&quot;5bdaf1a9-3854-5e5f-b662-b1e3ef57ea6e&quot;},&quot;error&quot;:&quot;succ&quot;}</pre><br>\n<br>\n<br>\n</div>\n"},{"_content":"\n<p>这篇主要说说如何通过微信公众号来查看室内传感器数据，至于硬件部分和物联网平台以后再详细说明。</p>\n<p><br>\n</p>\n<h2>准备工作：</h2>\n<p>1：申请微信公众号</p>\n<p>2：搭建云服务器</p>\n<p><br>\n</p>\n<p>首先说明一下整体流程：用户发送相应的指令到公众号后台，服务器根据指令的内容调用OneNET的API获取传感器数据在返回给用户</p>\n<p><br>\n</p>\n<h2>详细步骤：</h2>\n<h3><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>申请公众号后我们需要启用服务器配置，具体步骤请看微信的开发者文档，这个地方需要注意一下在填写URL的时候不要添加端口号，这样会导致验证不通过的（开发者文档上这个是错误的）</span></h3>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>在云服务器上安装运行环境：</span></div>\n<div><br>\n</div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>安装pip</span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171217162858414?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span></span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>安装libxml2</span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171217162935160?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><br>\n</span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>安装lxml</span></span></div>\n<div><span style=\"font-size:10px; white-space:pre\"><span style=\"font-size:10px; white-space:pre\"><img src=\"https://img-blog.csdn.net/20171217162943429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span><span style=\"font-size:10px\">&nbsp;&nbsp;</span></div>\n<div><span style=\"white-space:pre\"></span></div>\n<div><span style=\"white-space:pre\"></span>安装web.py</div>\n<div><span style=\"white-space:pre\"></span><img src=\"https://img-blog.csdn.net/20171217163002373?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" style=\"font-size:10px\"></div>\n<div><br>\n</div>\n<div><span style=\"white-space:pre\"></span>我们使用的物联网平台是中国移动的OneNet，它提供了很多API接口可以让我们获取数据、发送指令，在GitHub上有人用python写了常用的API调用示例，这里我们拿来直接使用就好了<a target=\"_blank\" target=\"_blank\" href=\"https://github.com/jiangxiaobai1989/pythonOneNetAPI\">https://github.com/jiangxiaobai1989/pythonOneNetAPI</a></div>\n<div><span style=\"white-space:pre\"></span>首先呢我们需要能够接收用户发过来的消息，使用者发送消息后后台收到的为lxml&#26684;式</div>\n<div><span style=\"white-space:pre\"></span><pre name=\"code\" class=\"html\">&lt;xml&gt;\n&lt;ToUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/ToUserName&gt;\n&lt;FromUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/FromUserName&gt;\n&lt;CreateTime&gt;1460541339&lt;/CreateTime&gt;\n&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;\n&lt;Content&gt;&lt;![CDATA[test]]&gt;&lt;/Content&gt;\n&lt;/xml&gt;</pre><br>\n</div>\n<div><span style=\"white-space:pre\"></span>然后呢我们需要解析这些内容</div>\n<div><span style=\"white-space:pre\"></span><pre name=\"code\" class=\"python\"># -*- coding: utf-8 -*-\n# filename: receive.py\nimport xml.etree.ElementTree as ET\n\ndef parse_xml(web_data):\n    if len(web_data) == 0:\n        return None\n    xmlData = ET.fromstring(web_data)\n    msg_type = xmlData.find('MsgType').text\n    if msg_type == 'text':\n        return TextMsg(xmlData)\n    elif msg_type == 'image':\n        return ImageMsg(xmlData)\n    elif msg_type == 'voice':\n\treturn VoiceMsg(xmlData)\n\nclass Msg(object):\n    def __init__(self, xmlData):\n        self.ToUserName = xmlData.find('ToUserName').text\n        self.FromUserName = xmlData.find('FromUserName').text\n        self.CreateTime = xmlData.find('CreateTime').text\n        self.MsgType = xmlData.find('MsgType').text\n        self.MsgId = xmlData.find('MsgId').text\n\t\n\nclass TextMsg(Msg):\n    def __init__(self, xmlData):\n        Msg.__init__(self, xmlData)\n        self.Content = xmlData.find('Content').text.encode(&quot;utf-8&quot;)\n\nclass VoiceMsg(Msg):\n\tdef __init__(self, xmlData):\n\t\tMsg.__init__(self, xmlData)\n\t\tself.Recognition = xmlData.find('Recognition').text.encode(&quot;utf-8&quot;)</pre><br>\n</div>\n<div><span style=\"white-space:pre\"></span>获取消息后我们需要服务器做出相应的反应，首先需要判断消息类型和消息内容，然后通过API获取数据后再返回个用户，例如下面这段获取室内温湿度的例子</div>\n<div><pre name=\"code\" class=\"python\"># -*- coding: utf-8 -*-\n# filename: handle.py\nimport hashlib\nimport reply\nimport receive\nimport web\nfrom getData import *\nclass Handle(object):\n    def POST(self):\n        try:\n            webData = web.data()\n            print &quot;Handle Post webdata is &quot;, webData   #后台打日志\n            recMsg = receive.parse_xml(webData)\n            if isinstance(recMsg, receive.Msg):\n                toUser = recMsg.FromUserName\n                fromUser = recMsg.ToUserName\n                if recMsg.MsgType == 'text':\n                \tif recMsg.Content == '温度':\n\t\t\t\tcontent = str(getData_time('temperature'))+'\\n室内温度为'+str(getData_value('temperature')) +'℃'\n\t\t  \telif recMsg.Content == '湿度':\n\t\t\t\tcontent = str(getData_time('humidity'))+'\\n室内湿度为'+str(getData_value('humidity')) +'%'\n\t\t\telse:\n\t\t\t\tcontent = '抱歉尚未开通这项指令功能，你可以尝试发送‘温度’、‘湿度’来查看最新的室内信息,或者发送相应的语音消息 '\n                   \treplyMsg = reply.TextMsg(toUser, fromUser, content)\n                   \treturn replyMsg.send()\n                if recMsg.MsgType == 'voice':\n                    \tif recMsg.Recognition =='温度。':\n\t\t\t\tcontent = str(getData_time('temperature'))+'\\n室内温度为'+str(getData_value('temperature')) +'℃'\n\t\t\telif recMsg.Recognition =='湿度。':\n\t\t\t\tcontent = str(getData_time('humidity'))+'\\n室内湿度为'+str(getData_value('humidity')) +'%'\n\t\t\telse:\n\t\t\t\tcontent =recMsg.Recognition+'\\n无法识别这条语音消息'\n                    \treplyMsg = reply.TextMsg(toUser, fromUser, content)\n                    \treturn replyMsg.send()\n                else:\n                    \treturn reply.Msg().send()\n            else:\n                print &quot;暂且不处理&quot;\n                return reply.Msg().send()\n        except Exception, Argment:\n            return Argment</pre><br>\n<span style=\"white-space:pre\"></span>通过API调用我们获取到的json数据，这样是不能直接给用户发送过去的，还需要对json进行处理提取主要的数据，例如提取温湿度数据和数据节点时间</div>\n<div><pre name=\"code\" class=\"python\"># -*- coding: UTF-8\n\nfrom OneNetApi import *\nimport json\n\ndef getData_value(datastreamid):\n    test = OneNetApi(&quot;***************************&quot;) #  your API\n    datastream_id = datastreamid\n    limit = 1\n    res3 = test.datapoint_get(device_id = &quot;6975064&quot;, limit = limit, datastream_id = datastream_id)\n    data = json.loads(res3.content.replace(']',' ').replace('[',' '))\n    value = data['data']['datastreams']['datapoints']['value']\n    return value\n\t\n\t\ndef getData_time(datastreamid):\n    test = OneNetApi(&quot;***************************&quot;) #  your API\n    datastream_id = datastreamid\n    limit = 1\n    res3 = test.datapoint_get(device_id = &quot;6975064&quot;, limit = limit, datastream_id = datastream_id)\n    data = json.loads(res3.content.replace(']',' ').replace('[',' '))\n    time = data['data']['datastreams']['datapoints']['at'][0:19]\n    return time</pre><br>\n<span style=\"white-space:pre\"></span>至于返回用户消息呢，依然是按照lxml&#26684;式，将我们获取到的数据和需要返回的用户信息添加进去就可以了<pre name=\"code\" class=\"python\">class TextMsg(Msg):\n    def __init__(self, toUserName, fromUserName, content):\n        self.__dict = dict()\n        self.__dict['ToUserName'] = toUserName\n        self.__dict['FromUserName'] = fromUserName\n        self.__dict['CreateTime'] = int(time.time())\n        self.__dict['Content'] = content\n\n    def send(self):\n        XmlForm = &quot;&quot;&quot;\n        &lt;xml&gt;\n        &lt;ToUserName&gt;&lt;![CDATA[{ToUserName}]]&gt;&lt;/ToUserName&gt;\n        &lt;FromUserName&gt;&lt;![CDATA[{FromUserName}]]&gt;&lt;/FromUserName&gt;\n        &lt;CreateTime&gt;{CreateTime}&lt;/CreateTime&gt;\n        &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;\n        &lt;Content&gt;&lt;![CDATA[{Content}]]&gt;&lt;/Content&gt;\n        &lt;/xml&gt;\n        &quot;&quot;&quot;\n        return XmlForm.format(**self.__dict)</pre><br>\n</div>\n<div><span style=\"white-space:pre\"></span><span style=\"white-space:pre\"></span>微信后天还提供了语音识别接口，默认是打开的，当用户发送的是语音命令的时候后台接收的lxml中会比text消息多出<span style=\"color:rgb(51,51,51); font-family:&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif; font-size:14px\">Recognition这项，把识别结果当做text一样处理就能让公众号处理语音消息了，再次不再赘述了。</span></div>\n<div><span style=\"white-space:pre\"></span>至此整个流程就结束了，当编写所有的代码后使用 python main.py 80 即可打开这项服务了，下面是效果图</div>\n<div><span style=\"white-space:pre\"></span><img src=\"https://img-blog.csdn.net/20171217173126601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</div>\n<div><br>\n</div>\n<div>国际惯例：<a target=\"_blank\" href=\"https://github.com/FanMLei/wx\">源码</a></div>\n<p><br>\n</p>\n","source":"_posts/blogs-微信公众号实现简易的物联网控制（一）.md","raw":"\n<p>这篇主要说说如何通过微信公众号来查看室内传感器数据，至于硬件部分和物联网平台以后再详细说明。</p>\n<p><br>\n</p>\n<h2>准备工作：</h2>\n<p>1：申请微信公众号</p>\n<p>2：搭建云服务器</p>\n<p><br>\n</p>\n<p>首先说明一下整体流程：用户发送相应的指令到公众号后台，服务器根据指令的内容调用OneNET的API获取传感器数据在返回给用户</p>\n<p><br>\n</p>\n<h2>详细步骤：</h2>\n<h3><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>申请公众号后我们需要启用服务器配置，具体步骤请看微信的开发者文档，这个地方需要注意一下在填写URL的时候不要添加端口号，这样会导致验证不通过的（开发者文档上这个是错误的）</span></h3>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>在云服务器上安装运行环境：</span></div>\n<div><br>\n</div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>安装pip</span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171217162858414?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span></span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>安装libxml2</span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171217162935160?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><br>\n</span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>安装lxml</span></span></div>\n<div><span style=\"font-size:10px; white-space:pre\"><span style=\"font-size:10px; white-space:pre\"><img src=\"https://img-blog.csdn.net/20171217162943429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span><span style=\"font-size:10px\">&nbsp;&nbsp;</span></div>\n<div><span style=\"white-space:pre\"></span></div>\n<div><span style=\"white-space:pre\"></span>安装web.py</div>\n<div><span style=\"white-space:pre\"></span><img src=\"https://img-blog.csdn.net/20171217163002373?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" style=\"font-size:10px\"></div>\n<div><br>\n</div>\n<div><span style=\"white-space:pre\"></span>我们使用的物联网平台是中国移动的OneNet，它提供了很多API接口可以让我们获取数据、发送指令，在GitHub上有人用python写了常用的API调用示例，这里我们拿来直接使用就好了<a target=\"_blank\" target=\"_blank\" href=\"https://github.com/jiangxiaobai1989/pythonOneNetAPI\">https://github.com/jiangxiaobai1989/pythonOneNetAPI</a></div>\n<div><span style=\"white-space:pre\"></span>首先呢我们需要能够接收用户发过来的消息，使用者发送消息后后台收到的为lxml&#26684;式</div>\n<div><span style=\"white-space:pre\"></span><pre name=\"code\" class=\"html\">&lt;xml&gt;\n&lt;ToUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/ToUserName&gt;\n&lt;FromUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/FromUserName&gt;\n&lt;CreateTime&gt;1460541339&lt;/CreateTime&gt;\n&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;\n&lt;Content&gt;&lt;![CDATA[test]]&gt;&lt;/Content&gt;\n&lt;/xml&gt;</pre><br>\n</div>\n<div><span style=\"white-space:pre\"></span>然后呢我们需要解析这些内容</div>\n<div><span style=\"white-space:pre\"></span><pre name=\"code\" class=\"python\"># -*- coding: utf-8 -*-\n# filename: receive.py\nimport xml.etree.ElementTree as ET\n\ndef parse_xml(web_data):\n    if len(web_data) == 0:\n        return None\n    xmlData = ET.fromstring(web_data)\n    msg_type = xmlData.find('MsgType').text\n    if msg_type == 'text':\n        return TextMsg(xmlData)\n    elif msg_type == 'image':\n        return ImageMsg(xmlData)\n    elif msg_type == 'voice':\n\treturn VoiceMsg(xmlData)\n\nclass Msg(object):\n    def __init__(self, xmlData):\n        self.ToUserName = xmlData.find('ToUserName').text\n        self.FromUserName = xmlData.find('FromUserName').text\n        self.CreateTime = xmlData.find('CreateTime').text\n        self.MsgType = xmlData.find('MsgType').text\n        self.MsgId = xmlData.find('MsgId').text\n\t\n\nclass TextMsg(Msg):\n    def __init__(self, xmlData):\n        Msg.__init__(self, xmlData)\n        self.Content = xmlData.find('Content').text.encode(&quot;utf-8&quot;)\n\nclass VoiceMsg(Msg):\n\tdef __init__(self, xmlData):\n\t\tMsg.__init__(self, xmlData)\n\t\tself.Recognition = xmlData.find('Recognition').text.encode(&quot;utf-8&quot;)</pre><br>\n</div>\n<div><span style=\"white-space:pre\"></span>获取消息后我们需要服务器做出相应的反应，首先需要判断消息类型和消息内容，然后通过API获取数据后再返回个用户，例如下面这段获取室内温湿度的例子</div>\n<div><pre name=\"code\" class=\"python\"># -*- coding: utf-8 -*-\n# filename: handle.py\nimport hashlib\nimport reply\nimport receive\nimport web\nfrom getData import *\nclass Handle(object):\n    def POST(self):\n        try:\n            webData = web.data()\n            print &quot;Handle Post webdata is &quot;, webData   #后台打日志\n            recMsg = receive.parse_xml(webData)\n            if isinstance(recMsg, receive.Msg):\n                toUser = recMsg.FromUserName\n                fromUser = recMsg.ToUserName\n                if recMsg.MsgType == 'text':\n                \tif recMsg.Content == '温度':\n\t\t\t\tcontent = str(getData_time('temperature'))+'\\n室内温度为'+str(getData_value('temperature')) +'℃'\n\t\t  \telif recMsg.Content == '湿度':\n\t\t\t\tcontent = str(getData_time('humidity'))+'\\n室内湿度为'+str(getData_value('humidity')) +'%'\n\t\t\telse:\n\t\t\t\tcontent = '抱歉尚未开通这项指令功能，你可以尝试发送‘温度’、‘湿度’来查看最新的室内信息,或者发送相应的语音消息 '\n                   \treplyMsg = reply.TextMsg(toUser, fromUser, content)\n                   \treturn replyMsg.send()\n                if recMsg.MsgType == 'voice':\n                    \tif recMsg.Recognition =='温度。':\n\t\t\t\tcontent = str(getData_time('temperature'))+'\\n室内温度为'+str(getData_value('temperature')) +'℃'\n\t\t\telif recMsg.Recognition =='湿度。':\n\t\t\t\tcontent = str(getData_time('humidity'))+'\\n室内湿度为'+str(getData_value('humidity')) +'%'\n\t\t\telse:\n\t\t\t\tcontent =recMsg.Recognition+'\\n无法识别这条语音消息'\n                    \treplyMsg = reply.TextMsg(toUser, fromUser, content)\n                    \treturn replyMsg.send()\n                else:\n                    \treturn reply.Msg().send()\n            else:\n                print &quot;暂且不处理&quot;\n                return reply.Msg().send()\n        except Exception, Argment:\n            return Argment</pre><br>\n<span style=\"white-space:pre\"></span>通过API调用我们获取到的json数据，这样是不能直接给用户发送过去的，还需要对json进行处理提取主要的数据，例如提取温湿度数据和数据节点时间</div>\n<div><pre name=\"code\" class=\"python\"># -*- coding: UTF-8\n\nfrom OneNetApi import *\nimport json\n\ndef getData_value(datastreamid):\n    test = OneNetApi(&quot;***************************&quot;) #  your API\n    datastream_id = datastreamid\n    limit = 1\n    res3 = test.datapoint_get(device_id = &quot;6975064&quot;, limit = limit, datastream_id = datastream_id)\n    data = json.loads(res3.content.replace(']',' ').replace('[',' '))\n    value = data['data']['datastreams']['datapoints']['value']\n    return value\n\t\n\t\ndef getData_time(datastreamid):\n    test = OneNetApi(&quot;***************************&quot;) #  your API\n    datastream_id = datastreamid\n    limit = 1\n    res3 = test.datapoint_get(device_id = &quot;6975064&quot;, limit = limit, datastream_id = datastream_id)\n    data = json.loads(res3.content.replace(']',' ').replace('[',' '))\n    time = data['data']['datastreams']['datapoints']['at'][0:19]\n    return time</pre><br>\n<span style=\"white-space:pre\"></span>至于返回用户消息呢，依然是按照lxml&#26684;式，将我们获取到的数据和需要返回的用户信息添加进去就可以了<pre name=\"code\" class=\"python\">class TextMsg(Msg):\n    def __init__(self, toUserName, fromUserName, content):\n        self.__dict = dict()\n        self.__dict['ToUserName'] = toUserName\n        self.__dict['FromUserName'] = fromUserName\n        self.__dict['CreateTime'] = int(time.time())\n        self.__dict['Content'] = content\n\n    def send(self):\n        XmlForm = &quot;&quot;&quot;\n        &lt;xml&gt;\n        &lt;ToUserName&gt;&lt;![CDATA[{ToUserName}]]&gt;&lt;/ToUserName&gt;\n        &lt;FromUserName&gt;&lt;![CDATA[{FromUserName}]]&gt;&lt;/FromUserName&gt;\n        &lt;CreateTime&gt;{CreateTime}&lt;/CreateTime&gt;\n        &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;\n        &lt;Content&gt;&lt;![CDATA[{Content}]]&gt;&lt;/Content&gt;\n        &lt;/xml&gt;\n        &quot;&quot;&quot;\n        return XmlForm.format(**self.__dict)</pre><br>\n</div>\n<div><span style=\"white-space:pre\"></span><span style=\"white-space:pre\"></span>微信后天还提供了语音识别接口，默认是打开的，当用户发送的是语音命令的时候后台接收的lxml中会比text消息多出<span style=\"color:rgb(51,51,51); font-family:&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif; font-size:14px\">Recognition这项，把识别结果当做text一样处理就能让公众号处理语音消息了，再次不再赘述了。</span></div>\n<div><span style=\"white-space:pre\"></span>至此整个流程就结束了，当编写所有的代码后使用 python main.py 80 即可打开这项服务了，下面是效果图</div>\n<div><span style=\"white-space:pre\"></span><img src=\"https://img-blog.csdn.net/20171217173126601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</div>\n<div><br>\n</div>\n<div>国际惯例：<a target=\"_blank\" href=\"https://github.com/FanMLei/wx\">源码</a></div>\n<p><br>\n</p>\n","slug":"blogs-微信公众号实现简易的物联网控制（一）","published":1,"date":"2022-03-16T17:09:40.422Z","updated":"2022-03-16T17:09:40.422Z","_id":"cl0v6kesq001dyms4g35n8wk4","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这篇主要说说如何通过微信公众号来查看室内传感器数据，至于硬件部分和物联网平台以后再详细说明。</p>\n<p><br>\n</p>\n<h2>准备工作：</h2>\n<p>1：申请微信公众号</p>\n<p>2：搭建云服务器</p>\n<p><br>\n</p>\n<p>首先说明一下整体流程：用户发送相应的指令到公众号后台，服务器根据指令的内容调用OneNET的API获取传感器数据在返回给用户</p>\n<p><br>\n</p>\n<h2>详细步骤：</h2>\n<h3><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>申请公众号后我们需要启用服务器配置，具体步骤请看微信的开发者文档，这个地方需要注意一下在填写URL的时候不要添加端口号，这样会导致验证不通过的（开发者文档上这个是错误的）</span></h3>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>在云服务器上安装运行环境：</span></div>\n<div><br>\n</div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>安装pip</span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171217162858414?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span></span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>安装libxml2</span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171217162935160?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><br>\n</span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>安装lxml</span></span></div>\n<div><span style=\"font-size:10px; white-space:pre\"><span style=\"font-size:10px; white-space:pre\"><img src=\"https://img-blog.csdn.net/20171217162943429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span><span style=\"font-size:10px\">&nbsp;&nbsp;</span></div>\n<div><span style=\"white-space:pre\"></span></div>\n<div><span style=\"white-space:pre\"></span>安装web.py</div>\n<div><span style=\"white-space:pre\"></span><img src=\"https://img-blog.csdn.net/20171217163002373?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" style=\"font-size:10px\"></div>\n<div><br>\n</div>\n<div><span style=\"white-space:pre\"></span>我们使用的物联网平台是中国移动的OneNet，它提供了很多API接口可以让我们获取数据、发送指令，在GitHub上有人用python写了常用的API调用示例，这里我们拿来直接使用就好了<a target=\"_blank\" target=\"_blank\" href=\"https://github.com/jiangxiaobai1989/pythonOneNetAPI\">https://github.com/jiangxiaobai1989/pythonOneNetAPI</a></div>\n<div><span style=\"white-space:pre\"></span>首先呢我们需要能够接收用户发过来的消息，使用者发送消息后后台收到的为lxml&#26684;式</div>\n<div><span style=\"white-space:pre\"></span><pre name=\"code\" class=\"html\">&lt;xml&gt;\n&lt;ToUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/ToUserName&gt;\n&lt;FromUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/FromUserName&gt;\n&lt;CreateTime&gt;1460541339&lt;/CreateTime&gt;\n&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;\n&lt;Content&gt;&lt;![CDATA[test]]&gt;&lt;/Content&gt;\n&lt;/xml&gt;</pre><br>\n</div>\n<div><span style=\"white-space:pre\"></span>然后呢我们需要解析这些内容</div>\n<div><span style=\"white-space:pre\"></span><pre name=\"code\" class=\"python\"># -*- coding: utf-8 -*-\n# filename: receive.py\nimport xml.etree.ElementTree as ET\n\n<p>def parse_xml(web_data):<br>    if len(web_data) == 0:<br>        return None<br>    xmlData = ET.fromstring(web_data)<br>    msg_type = xmlData.find(‘MsgType’).text<br>    if msg_type == ‘text’:<br>        return TextMsg(xmlData)<br>    elif msg_type == ‘image’:<br>        return ImageMsg(xmlData)<br>    elif msg_type == ‘voice’:<br>    return VoiceMsg(xmlData)</p>\n<p>class Msg(object):<br>    def <strong>init</strong>(self, xmlData):<br>        self.ToUserName = xmlData.find(‘ToUserName’).text<br>        self.FromUserName = xmlData.find(‘FromUserName’).text<br>        self.CreateTime = xmlData.find(‘CreateTime’).text<br>        self.MsgType = xmlData.find(‘MsgType’).text<br>        self.MsgId = xmlData.find(‘MsgId’).text</p>\n<p>class TextMsg(Msg):<br>    def <strong>init</strong>(self, xmlData):<br>        Msg.<strong>init</strong>(self, xmlData)<br>        self.Content = xmlData.find(‘Content’).text.encode(&quot;utf-8&quot;)</p>\n<p>class VoiceMsg(Msg):<br>    def <strong>init</strong>(self, xmlData):<br>        Msg.<strong>init</strong>(self, xmlData)<br>        self.Recognition = xmlData.find(‘Recognition’).text.encode(&quot;utf-8&quot;)</pre><br></p>\n</div>\n<div><span style=\"white-space:pre\"></span>获取消息后我们需要服务器做出相应的反应，首先需要判断消息类型和消息内容，然后通过API获取数据后再返回个用户，例如下面这段获取室内温湿度的例子</div>\n<div><pre name=\"code\" class=\"python\"># -*- coding: utf-8 -*-\n# filename: handle.py\nimport hashlib\nimport reply\nimport receive\nimport web\nfrom getData import *\nclass Handle(object):\n    def POST(self):\n        try:\n            webData = web.data()\n            print &quot;Handle Post webdata is &quot;, webData   #后台打日志\n            recMsg = receive.parse_xml(webData)\n            if isinstance(recMsg, receive.Msg):\n                toUser = recMsg.FromUserName\n                fromUser = recMsg.ToUserName\n                if recMsg.MsgType == 'text':\n                    if recMsg.Content == '温度':\n                content = str(getData_time('temperature'))+'\\n室内温度为'+str(getData_value('temperature')) +'℃'\n              elif recMsg.Content == '湿度':\n                content = str(getData_time('humidity'))+'\\n室内湿度为'+str(getData_value('humidity')) +'%'\n            else:\n                content = '抱歉尚未开通这项指令功能，你可以尝试发送‘温度’、‘湿度’来查看最新的室内信息,或者发送相应的语音消息 '\n                       replyMsg = reply.TextMsg(toUser, fromUser, content)\n                       return replyMsg.send()\n                if recMsg.MsgType == 'voice':\n                        if recMsg.Recognition =='温度。':\n                content = str(getData_time('temperature'))+'\\n室内温度为'+str(getData_value('temperature')) +'℃'\n            elif recMsg.Recognition =='湿度。':\n                content = str(getData_time('humidity'))+'\\n室内湿度为'+str(getData_value('humidity')) +'%'\n            else:\n                content =recMsg.Recognition+'\\n无法识别这条语音消息'\n                        replyMsg = reply.TextMsg(toUser, fromUser, content)\n                        return replyMsg.send()\n                else:\n                        return reply.Msg().send()\n            else:\n                print &quot;暂且不处理&quot;\n                return reply.Msg().send()\n        except Exception, Argment:\n            return Argment</pre><br>\n<span style=\"white-space:pre\"></span>通过API调用我们获取到的json数据，这样是不能直接给用户发送过去的，还需要对json进行处理提取主要的数据，例如提取温湿度数据和数据节点时间</div>\n<div><pre name=\"code\" class=\"python\"># -*- coding: UTF-8\n\n<p>from OneNetApi import *<br>import json</p>\n<p>def getData_value(datastreamid):<br>    test = OneNetApi(&quot;***************************&quot;) #  your API<br>    datastream_id = datastreamid<br>    limit = 1<br>    res3 = test.datapoint_get(device_id = &quot;6975064&quot;, limit = limit, datastream_id = datastream_id)<br>    data = json.loads(res3.content.replace(‘]’,’ ‘).replace(‘[‘,’ ‘))<br>    value = data[‘data’][‘datastreams’][‘datapoints’][‘value’]<br>    return value</p>\n<p>def getData_time(datastreamid):<br>    test = OneNetApi(&quot;***************************&quot;) #  your API<br>    datastream_id = datastreamid<br>    limit = 1<br>    res3 = test.datapoint_get(device_id = &quot;6975064&quot;, limit = limit, datastream_id = datastream_id)<br>    data = json.loads(res3.content.replace(‘]’,’ ‘).replace(‘[‘,’ ‘))<br>    time = data[‘data’][‘datastreams’][‘datapoints’][‘at’][0:19]<br>    return time</pre><br><br><span style=\"white-space:pre\"></span>至于返回用户消息呢，依然是按照lxml&#26684;式，将我们获取到的数据和需要返回的用户信息添加进去就可以了<pre name=\"code\" class=\"python\">class TextMsg(Msg):<br>    def <strong>init</strong>(self, toUserName, fromUserName, content):<br>        self.__dict = dict()<br>        self.__dict['ToUserName'] = toUserName<br>        self.__dict['FromUserName'] = fromUserName<br>        self.__dict['CreateTime'] = int(time.time())<br>        self.__dict['Content'] = content</p>\n<pre><code>def send(self):\n    XmlForm = &amp;quot;&amp;quot;&amp;quot;\n    &amp;lt;xml&amp;gt;\n    &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[&#123;ToUserName&#125;]]&amp;gt;&amp;lt;/ToUserName&amp;gt;\n    &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[&#123;FromUserName&#125;]]&amp;gt;&amp;lt;/FromUserName&amp;gt;\n    &amp;lt;CreateTime&amp;gt;&#123;CreateTime&#125;&amp;lt;/CreateTime&amp;gt;\n    &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[text]]&amp;gt;&amp;lt;/MsgType&amp;gt;\n    &amp;lt;Content&amp;gt;&amp;lt;![CDATA[&#123;Content&#125;]]&amp;gt;&amp;lt;/Content&amp;gt;\n    &amp;lt;/xml&amp;gt;\n    &amp;quot;&amp;quot;&amp;quot;\n    return XmlForm.format(**self.__dict)&lt;/pre&gt;&lt;br&gt;\n</code></pre>\n</div>\n<div><span style=\"white-space:pre\"></span><span style=\"white-space:pre\"></span>微信后天还提供了语音识别接口，默认是打开的，当用户发送的是语音命令的时候后台接收的lxml中会比text消息多出<span style=\"color:rgb(51,51,51); font-family:&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif; font-size:14px\">Recognition这项，把识别结果当做text一样处理就能让公众号处理语音消息了，再次不再赘述了。</span></div>\n<div><span style=\"white-space:pre\"></span>至此整个流程就结束了，当编写所有的代码后使用 python main.py 80 即可打开这项服务了，下面是效果图</div>\n<div><span style=\"white-space:pre\"></span><img src=\"https://img-blog.csdn.net/20171217173126601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</div>\n<div><br>\n</div>\n<div>国际惯例：<a target=\"_blank\" href=\"https://github.com/FanMLei/wx\">源码</a></div>\n<p><br>\n</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这篇主要说说如何通过微信公众号来查看室内传感器数据，至于硬件部分和物联网平台以后再详细说明。</p>\n<p><br>\n</p>\n<h2>准备工作：</h2>\n<p>1：申请微信公众号</p>\n<p>2：搭建云服务器</p>\n<p><br>\n</p>\n<p>首先说明一下整体流程：用户发送相应的指令到公众号后台，服务器根据指令的内容调用OneNET的API获取传感器数据在返回给用户</p>\n<p><br>\n</p>\n<h2>详细步骤：</h2>\n<h3><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>申请公众号后我们需要启用服务器配置，具体步骤请看微信的开发者文档，这个地方需要注意一下在填写URL的时候不要添加端口号，这样会导致验证不通过的（开发者文档上这个是错误的）</span></h3>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>在云服务器上安装运行环境：</span></div>\n<div><br>\n</div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>安装pip</span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171217162858414?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span></span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"></span>安装libxml2</span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171217162935160?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><br>\n</span></span></div>\n<div><span style=\"font-size:10px; font-weight:normal\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>安装lxml</span></span></div>\n<div><span style=\"font-size:10px; white-space:pre\"><span style=\"font-size:10px; white-space:pre\"><img src=\"https://img-blog.csdn.net/20171217162943429?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span><span style=\"font-size:10px\">&nbsp;&nbsp;</span></div>\n<div><span style=\"white-space:pre\"></span></div>\n<div><span style=\"white-space:pre\"></span>安装web.py</div>\n<div><span style=\"white-space:pre\"></span><img src=\"https://img-blog.csdn.net/20171217163002373?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\" style=\"font-size:10px\"></div>\n<div><br>\n</div>\n<div><span style=\"white-space:pre\"></span>我们使用的物联网平台是中国移动的OneNet，它提供了很多API接口可以让我们获取数据、发送指令，在GitHub上有人用python写了常用的API调用示例，这里我们拿来直接使用就好了<a target=\"_blank\" target=\"_blank\" href=\"https://github.com/jiangxiaobai1989/pythonOneNetAPI\">https://github.com/jiangxiaobai1989/pythonOneNetAPI</a></div>\n<div><span style=\"white-space:pre\"></span>首先呢我们需要能够接收用户发过来的消息，使用者发送消息后后台收到的为lxml&#26684;式</div>\n<div><span style=\"white-space:pre\"></span><pre name=\"code\" class=\"html\">&lt;xml&gt;\n&lt;ToUserName&gt;&lt;![CDATA[粉丝号]]&gt;&lt;/ToUserName&gt;\n&lt;FromUserName&gt;&lt;![CDATA[公众号]]&gt;&lt;/FromUserName&gt;\n&lt;CreateTime&gt;1460541339&lt;/CreateTime&gt;\n&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;\n&lt;Content&gt;&lt;![CDATA[test]]&gt;&lt;/Content&gt;\n&lt;/xml&gt;</pre><br>\n</div>\n<div><span style=\"white-space:pre\"></span>然后呢我们需要解析这些内容</div>\n<div><span style=\"white-space:pre\"></span><pre name=\"code\" class=\"python\"># -*- coding: utf-8 -*-\n# filename: receive.py\nimport xml.etree.ElementTree as ET\n\n<p>def parse_xml(web_data):<br>    if len(web_data) == 0:<br>        return None<br>    xmlData = ET.fromstring(web_data)<br>    msg_type = xmlData.find(‘MsgType’).text<br>    if msg_type == ‘text’:<br>        return TextMsg(xmlData)<br>    elif msg_type == ‘image’:<br>        return ImageMsg(xmlData)<br>    elif msg_type == ‘voice’:<br>    return VoiceMsg(xmlData)</p>\n<p>class Msg(object):<br>    def <strong>init</strong>(self, xmlData):<br>        self.ToUserName = xmlData.find(‘ToUserName’).text<br>        self.FromUserName = xmlData.find(‘FromUserName’).text<br>        self.CreateTime = xmlData.find(‘CreateTime’).text<br>        self.MsgType = xmlData.find(‘MsgType’).text<br>        self.MsgId = xmlData.find(‘MsgId’).text</p>\n<p>class TextMsg(Msg):<br>    def <strong>init</strong>(self, xmlData):<br>        Msg.<strong>init</strong>(self, xmlData)<br>        self.Content = xmlData.find(‘Content’).text.encode(&quot;utf-8&quot;)</p>\n<p>class VoiceMsg(Msg):<br>    def <strong>init</strong>(self, xmlData):<br>        Msg.<strong>init</strong>(self, xmlData)<br>        self.Recognition = xmlData.find(‘Recognition’).text.encode(&quot;utf-8&quot;)</pre><br></p>\n</div>\n<div><span style=\"white-space:pre\"></span>获取消息后我们需要服务器做出相应的反应，首先需要判断消息类型和消息内容，然后通过API获取数据后再返回个用户，例如下面这段获取室内温湿度的例子</div>\n<div><pre name=\"code\" class=\"python\"># -*- coding: utf-8 -*-\n# filename: handle.py\nimport hashlib\nimport reply\nimport receive\nimport web\nfrom getData import *\nclass Handle(object):\n    def POST(self):\n        try:\n            webData = web.data()\n            print &quot;Handle Post webdata is &quot;, webData   #后台打日志\n            recMsg = receive.parse_xml(webData)\n            if isinstance(recMsg, receive.Msg):\n                toUser = recMsg.FromUserName\n                fromUser = recMsg.ToUserName\n                if recMsg.MsgType == 'text':\n                    if recMsg.Content == '温度':\n                content = str(getData_time('temperature'))+'\\n室内温度为'+str(getData_value('temperature')) +'℃'\n              elif recMsg.Content == '湿度':\n                content = str(getData_time('humidity'))+'\\n室内湿度为'+str(getData_value('humidity')) +'%'\n            else:\n                content = '抱歉尚未开通这项指令功能，你可以尝试发送‘温度’、‘湿度’来查看最新的室内信息,或者发送相应的语音消息 '\n                       replyMsg = reply.TextMsg(toUser, fromUser, content)\n                       return replyMsg.send()\n                if recMsg.MsgType == 'voice':\n                        if recMsg.Recognition =='温度。':\n                content = str(getData_time('temperature'))+'\\n室内温度为'+str(getData_value('temperature')) +'℃'\n            elif recMsg.Recognition =='湿度。':\n                content = str(getData_time('humidity'))+'\\n室内湿度为'+str(getData_value('humidity')) +'%'\n            else:\n                content =recMsg.Recognition+'\\n无法识别这条语音消息'\n                        replyMsg = reply.TextMsg(toUser, fromUser, content)\n                        return replyMsg.send()\n                else:\n                        return reply.Msg().send()\n            else:\n                print &quot;暂且不处理&quot;\n                return reply.Msg().send()\n        except Exception, Argment:\n            return Argment</pre><br>\n<span style=\"white-space:pre\"></span>通过API调用我们获取到的json数据，这样是不能直接给用户发送过去的，还需要对json进行处理提取主要的数据，例如提取温湿度数据和数据节点时间</div>\n<div><pre name=\"code\" class=\"python\"># -*- coding: UTF-8\n\n<p>from OneNetApi import *<br>import json</p>\n<p>def getData_value(datastreamid):<br>    test = OneNetApi(&quot;***************************&quot;) #  your API<br>    datastream_id = datastreamid<br>    limit = 1<br>    res3 = test.datapoint_get(device_id = &quot;6975064&quot;, limit = limit, datastream_id = datastream_id)<br>    data = json.loads(res3.content.replace(‘]’,’ ‘).replace(‘[‘,’ ‘))<br>    value = data[‘data’][‘datastreams’][‘datapoints’][‘value’]<br>    return value</p>\n<p>def getData_time(datastreamid):<br>    test = OneNetApi(&quot;***************************&quot;) #  your API<br>    datastream_id = datastreamid<br>    limit = 1<br>    res3 = test.datapoint_get(device_id = &quot;6975064&quot;, limit = limit, datastream_id = datastream_id)<br>    data = json.loads(res3.content.replace(‘]’,’ ‘).replace(‘[‘,’ ‘))<br>    time = data[‘data’][‘datastreams’][‘datapoints’][‘at’][0:19]<br>    return time</pre><br><br><span style=\"white-space:pre\"></span>至于返回用户消息呢，依然是按照lxml&#26684;式，将我们获取到的数据和需要返回的用户信息添加进去就可以了<pre name=\"code\" class=\"python\">class TextMsg(Msg):<br>    def <strong>init</strong>(self, toUserName, fromUserName, content):<br>        self.__dict = dict()<br>        self.__dict['ToUserName'] = toUserName<br>        self.__dict['FromUserName'] = fromUserName<br>        self.__dict['CreateTime'] = int(time.time())<br>        self.__dict['Content'] = content</p>\n<pre><code>def send(self):\n    XmlForm = &amp;quot;&amp;quot;&amp;quot;\n    &amp;lt;xml&amp;gt;\n    &amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[&#123;ToUserName&#125;]]&amp;gt;&amp;lt;/ToUserName&amp;gt;\n    &amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[&#123;FromUserName&#125;]]&amp;gt;&amp;lt;/FromUserName&amp;gt;\n    &amp;lt;CreateTime&amp;gt;&#123;CreateTime&#125;&amp;lt;/CreateTime&amp;gt;\n    &amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[text]]&amp;gt;&amp;lt;/MsgType&amp;gt;\n    &amp;lt;Content&amp;gt;&amp;lt;![CDATA[&#123;Content&#125;]]&amp;gt;&amp;lt;/Content&amp;gt;\n    &amp;lt;/xml&amp;gt;\n    &amp;quot;&amp;quot;&amp;quot;\n    return XmlForm.format(**self.__dict)&lt;/pre&gt;&lt;br&gt;\n</code></pre>\n</div>\n<div><span style=\"white-space:pre\"></span><span style=\"white-space:pre\"></span>微信后天还提供了语音识别接口，默认是打开的，当用户发送的是语音命令的时候后台接收的lxml中会比text消息多出<span style=\"color:rgb(51,51,51); font-family:&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif; font-size:14px\">Recognition这项，把识别结果当做text一样处理就能让公众号处理语音消息了，再次不再赘述了。</span></div>\n<div><span style=\"white-space:pre\"></span>至此整个流程就结束了，当编写所有的代码后使用 python main.py 80 即可打开这项服务了，下面是效果图</div>\n<div><span style=\"white-space:pre\"></span><img src=\"https://img-blog.csdn.net/20171217173126601?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</div>\n<div><br>\n</div>\n<div>国际惯例：<a target=\"_blank\" href=\"https://github.com/FanMLei/wx\">源码</a></div>\n<p><br>\n</p>\n"},{"_content":"<h1 style=\"margin-left:0pt;\"><strong>原题链接：</strong><a href=\"https://www.cnblogs.com/wupeiqi/p/9078770.html\">https://www.cnblogs.com/wupeiqi/p/9078770.html</a></h1>\n\n<p style=\"margin-left:0pt;\">部分图片是从其他博客上整理出来的，时间有些久了当初是写在word上的忘记参考出路了，有些答案我也不知道是否回答准确，如有错误还请提出，谢谢</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>基础部分</strong></strong></p>\n\n<p><span style=\"color:#333333;\">1.简述解释型和编译型编程语言？</span></p>\n\n<p style=\"margin-left:18pt;\"> 解释型语言在运行之前不会有编译过程，由解释器在运行的过程中解释运行的常见的解释型语言还有PHP、JS、ruby等等。</p>\n\n<p style=\"margin-left:18pt;\"> 编译型语言在运行之前需要使用编译器编译成机器码，计算机就可以直接运行编译过后的文件了。</p>\n\n<p style=\"margin-left:18pt;\">一般来说编译型语言要比解释型语言运行速度要快的，应为解释型语言每执行一次就需要翻译一次，效率比较慢。</p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">2.Python解释器种类以及特点</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      常见的解释器有5个CPython</span><span style=\"color:#333333;\">、</span><span style=\"color:#333333;\">IPython</span><span style=\"color:#333333;\">、</span><span style=\"color:#333333;\">PyPy</span><span style=\"color:#333333;\">、</span><span style=\"color:#333333;\">Jython</span><span style=\"color:#333333;\">、IronP</span><span style=\"color:#333333;\">ython</span><span style=\"color:#333333;\">.</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      CPython</span><span style=\"color:#333333;\">是官方版本的解释器，由C语言编写，运用也是最为广泛的。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      IPython是基于CPython的，只是在交互上做出了进一步的改善，例如代码补全。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      PyPy采用了JIT技术，可以动态编译python程序，提高其工作效率。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      Jython是在Java平台上运行的解释器，可在将python程序编译成Java字节码运行。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      IronP</span><span style=\"color:#333333;\">ython和Jython类似，运行在.NET平台上。</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">3.位和字节的关系？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">位（bit）是计算机存储中的最小单位。只有0、1两种状态</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">字节（Byte）一个字节由8个bit组成，是计算机数据处理的最小单位。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">4.使用python进制转换</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">二进制转换成十进制：v = “0b1111011”</span> <br /><span style=\"color:#333333;\">十进制转换成二进制：v = 18</span>  <br /><span style=\"color:#333333;\">八进制转换成十进制：v = “011”</span>  <br /><span style=\"color:#333333;\">十进制转换成八进制：v = 30</span>  <br /><span style=\"color:#333333;\">十六进制转换成十进制：v = “0x12”</span>  <br /><span style=\"color:#333333;\">十进制转换成十六进制：v = 87</span><br /><img alt=\"\" class=\"has\" height=\"200\" src=\"https://img-blog.csdn.net/201809201420160?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"341\" /></p>\n\n<p><span style=\"color:#333333;\">5.请编写一个函数实现将IP地址转换成一个整数。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">如 10.3.9.12 转换规则为：</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">      10          </span> <span style=\"color:#333333;\">00001010</span></p>\n\n<p style=\"margin-left:18pt;\"> <span style=\"color:#333333;\">       3           </span> <span style=\"color:#333333;\">00000011</span> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">       9           </span> <span style=\"color:#333333;\">00001001</span></p>\n\n<p style=\"margin-left:18pt;\"> <span style=\"color:#333333;\">      12          </span> <span style=\"color:#333333;\">00001100</span> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 = ？</span><br /><img alt=\"\" class=\"has\" height=\"144\" src=\"https://img-blog.csdn.net/20180920142100367?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"488\" /></p>\n\n<p><span style=\"color:#333333;\">6.python递归的最大层数？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython默认递归的最大层数为</span><span style=\"color:#333333;\">998</span><span style=\"color:#333333;\">层。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">7.求结果：</span><br /><span style=\"color:#333333;\">v1 = 1 or 3</span> <br /><span style=\"color:#333333;\">v2 = 1 and 3</span> <br /><span style=\"color:#333333;\">v3 = 0 and 2 and 1</span><br /><span style=\"color:#333333;\">v4 = 0 and 2 or 1</span><br /><span style=\"color:#333333;\">v5 = 0 and 2 or 1 or 4</span><br /><span style=\"color:#333333;\">v6 = 0 or False and 1</span></p>\n\n<p><span style=\"color:#333333;\">V1 = 1  V2 = 3   V3 = 0   V4 = 1  V5 = 1  V6 = False<br />\n(使用and如果第一个条件满足那么结果为第二个条件，如果第一个不满足结果为第一个条件。使用or如果第一个条件满足那么结果为第一个条件，如果第一个条件不满足结果为第二个条件）</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">8.ascii、unicode、utf-8、gbk 区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">A</span><span style=\"color:#333333;\">scii只占一个字节，其中包含英文字母、数字和一些符号。无法表示其他的文字。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Unicode</span><span style=\"color:#333333;\">占两个字节，生僻字符占四个字节。但是如果全是英文字母的话会比较浪费空间。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">U</span><span style=\"color:#333333;\">tf-8中英文占一个字节中文占三个字节，其他的生僻字占4-</span><span style=\"color:#333333;\">6</span><span style=\"color:#333333;\">个字节。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">GBK占两个字节是中国制定的包含大部分汉字和其他的一些符号。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">9.三元运算规则以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython的三元运算格式为</span><strong><span style=\"color:#333333;\"><strong>res = 值1 if 条件 else 值2 </strong></span></strong><span style=\"color:#333333;\">，</span><span style=\"color:#333333;\">当条件满足时返回值1否则返回值2。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">可以用于只存在两种结果的if判断语句中。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">10.列举 Python2和Python3的区别？</span></p>\n\n<ol><li><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">rint函数：2中不需要括号将输出语句括起来，3中需要使用()</span></li>\n\t<li><span style=\"color:#333333;\">编码：</span><span style=\"color:#333333;\">Python3</span><span style=\"color:#333333;\">源码文件默认使用utf-8编码，支持中文</span></li>\n\t<li><span style=\"color:#333333;\">除法运算：</span><br /><span style=\"color:#333333;\">首先是'/'  :</span><br />\n\t    <span style=\"color:#333333;\">python</span><span style=\"color:#333333;\">3:   1 / 2 = 0.5 </span><br />\n\t    p<span style=\"color:#333333;\">ython2:</span>   <span style=\"color:#333333;\">1 / 2 = 0</span>        <span style=\"color:#333333;\">1.0 / 2.0 = 0.5</span></li>\n</ol><p style=\"margin-left:0pt;\">         <span style=\"color:#333333;\">其次是</span><span style=\"color:#333333;\">’//’<br />\n              Python</span><span style=\"color:#333333;\">3： 1 // 2 = 0<br />\n              Python2:    1 // 2 = 0</span></p>\n\n<p><span style=\"color:#333333;\">     4.不等运算符：2中不等于有两种表示!=和&lt;&gt;,3中只有!=</span></p>\n\n<p><span style=\"color:#333333;\">     5.数据类型：3中不支持long类型了只有一种整形int</span> <span style=\"color:#333333;\">和2中的long差不多的操作</span></p>\n\n<p style=\"margin-left:36pt;\"> </p>\n\n<p><span style=\"color:#333333;\">11.用一行代码实现数值交换：</span><span style=\"color:#333333;\">a = 1 ,b = 2</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">(a, b) = (b, a)</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">12.Python3和Python2中 int 和 long的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython3中没有long类型只有int但是</span><span style=\"color:#333333;\">3</span><span style=\"color:#333333;\">中的int操作包含2中的long操作。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">13.xrange和range的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">R</span><span style=\"color:#333333;\">ange([start,]stop</span><span style=\"color:#333333;\">[,step])</span><span style=\"color:#333333;\">更具指定的范围和步长生成一个序列。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Xrange()和range操作一样，不同的是它返回的是一个生成器。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">例如当我们使用range(10)的时候返回的是一个[0,1,2,3,4,5,6,7,8,9]的列表。而xrange(10)不会返回一个列表，而是每次调用的时候返回其中的值。这样在生成一个很大的操作的时候xrange的性能会更好。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">14文件操作时：xreadlines和readlines的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">和上面的range和xrange一样的区别，readlines将文件中读取的数据读取出来生成一个列表存放着，而x</span><span style=\"color:#333333;\">readlines</span><span style=\"color:#333333;\">返回的是一个迭代器每次调用的时候返回下一个值。所以对于数据量比较大的时候使用迭代器的方法会更好一些。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">15.列举布尔值为False的常见值？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">0、None、</span><span style=\"color:#333333;\">””、[]、{}</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">16.字符串、列表、元组、字典每个常用的5个方法？</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">字符串：isdigit()判断是否只包含数字 is</span><span style=\"color:#333333;\">lower()</span><span style=\"color:#333333;\">判断是否全为小写 is</span><span style=\"color:#333333;\">upper()</span><span style=\"color:#333333;\">判断是否全为大写  strip()去掉首尾空格  split()以指定字符切片</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">列表：append()在列表后面追加  count()统计次数  pop(</span><span style=\"color:#333333;\">index=-1</span><span style=\"color:#333333;\">)默认移除最后一个元素并返回 </span> <span style=\"color:#333333;\">sort()排序  reverse()反向列表中的元素 min</span><span style=\"color:#333333;\">()、</span><span style=\"color:#333333;\">max</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">返回最小最大值。</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">元组：cmp</span><span style=\"color:#333333;\">(tuple1,tuple2)</span><span style=\"color:#333333;\">比较两个元组元素  len</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">计算元组元素个数  max()返回最大值  min</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">返回最小值 tuple</span><span style=\"color:#333333;\">(list)</span><span style=\"color:#333333;\">将列表转为元组。</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">字典：get</span><span style=\"color:#333333;\">(key,default=None)</span><span style=\"color:#333333;\">返回指定键的值，没有返回默认值  copy</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">返回一个字典的浅复制  update(</span><span style=\"color:#333333;\">dict2</span><span style=\"color:#333333;\">)将dict</span><span style=\"color:#333333;\">2</span><span style=\"color:#333333;\">更新到原字典中 </span> <span style=\"color:#333333;\">value()返回所有值 key</span><span style=\"color:#333333;\">s()</span><span style=\"color:#333333;\">返回所有键  pop</span><span style=\"color:#333333;\">(key)</span><span style=\"color:#333333;\">删除并返回指定的key的值</span><span style=\"color:#333333;\">   popitem()</span><span style=\"color:#333333;\">随机删除并返回一个键值对。</span></p>\n\n<p style=\"margin-left:5.9pt;\"> </p>\n\n<p><span style=\"color:#333333;\">17.lambda表达式格式以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">L</span><span style=\"color:#333333;\">ambda语句中冒号前面的为参数，可以有多个，用逗号隔开。冒号右边的为返回值，如：add</span><span style=\"color:#333333;\"> = lambda x, y : x + y </span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">   add(1,3) </span><span style=\"color:#333333;\">结果为</span><span style=\"color:#333333;\">4</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">L</span><span style=\"color:#ff0000;\">ambda表达式通常是在需要一个函数，但是又不想费神去命名一个函数的时候使用</span><span style=\"color:#ff0000;\">，</span><span style=\"color:#ff0000;\">通常应用在函数式编程中、闭包</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">18.pass的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ass是空语句，为了保持程序结构的完整性，不做任何操作，一般只用做占位语句。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">19.*arg</span><span style=\"color:#333333;\">s</span><span style=\"color:#333333;\">和**kwarg</span><span style=\"color:#333333;\">s</span><span style=\"color:#333333;\">作用</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">如果我们不确定往一个函数中传入多少参数，或者我们希望以元组tuple或者列表list的形式传参数的时候，我们可以使用*args。如果我们不知道往函数中传递多少个关键词参数或者想传入字典的值作为关键词参数的时候我们可以使用**kwargs，args、kwargs两个标识符是约定俗成的用法。另一种答法：当函数的参数前面有一个星号*号的时候表示这是一个可变的位置参数，两个星号**表示这个是一个可变的关键词参数。星号*把序列或者集合解包（unpack）成位置参数，两个星号**把字典解包成关键词参数。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">20.is和==的区别</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      is比较的是两个实例对象是不是完全相同的，他们是不是同一个对象，占用的内存地址是否相同。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      ==</span><span style=\"color:#333333;\">比较的是两个对象的内容是否相等，内存地址可以不同，内容一样就可以了。</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">21.简述Python的深浅拷贝以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython的变量只存储了这个变量的内存地址，而不是值的本身，对于像list</span> <span style=\"color:#333333;\">set</span> <span style=\"color:#333333;\">dict这种复杂的数据结构来说里面存储的也仅仅是每个元素的地址而已</span><br /><img alt=\"\" class=\"has\" height=\"440\" src=\"https://img-blog.csdn.net/20180920142752928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"634\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">赋值：变量的每一次初始化都会在内存里面开辟一个新的空间，并将这个内存地址赋值给变量，例如：</span><br /><img alt=\"\" class=\"has\" height=\"101\" src=\"https://img-blog.csdn.net/20180920142812348?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"200\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">给str</span><span style=\"color:#333333;\">1</span><span style=\"color:#333333;\">两次赋值，两次的内存地址发生改变，第一次赋值hello的时候将hello在内存中的地址给了str</span><span style=\"color:#333333;\">1，</span><span style=\"color:#333333;\">第二次赋值world的时候再次将world的内存地址给了str</span><span style=\"color:#333333;\">1，</span><span style=\"color:#333333;\">但是此时hello并没有从内存中消失，只是现在没有变量指向他。当我们再次赋值的时候str1又指向了hello。</span><br /><img alt=\"\" class=\"has\" height=\"148\" src=\"https://img-blog.csdn.net/20180920142825292?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"177\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">深拷贝：</span><br /><img alt=\"\" class=\"has\" height=\"604\" src=\"https://img-blog.csdn.net/20180920142838291?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"687\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">深拷贝可以完全复制原变量的所有数据，我们修改其中一个的时候不会对复制的那份造成影响。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">浅拷贝：</span><br /><img alt=\"\" class=\"has\" height=\"467\" src=\"https://img-blog.csdn.net/20180920142855885?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"648\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">不管多么复杂的数据结构，浅拷贝只会copy一层。对于像int float str这种单一的数据是可以独立出来，但是对于更为复杂的数据结构就会出问题，因为在复制的时候只是将列表 字典等的整个的存放地址给复制过来了，并没有复制里面元素的内存地址，这样导致修改的时候会同时发生变化。例如：</span><br /><img alt=\"\" class=\"has\" height=\"287\" src=\"https://img-blog.csdn.net/20180920142907504?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"465\" /></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"199\" src=\"https://img-blog.csdn.net/20180920142913193?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"340\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">22.Python垃圾回收机制？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython的垃圾回收机制默认的方式是引用计数法，其原理是为每一个对象维护一个ob</span><span style=\"color:#333333;\">_ref</span><span style=\"color:#333333;\">字段，用来记录该对象当前被引用的次数，有新的引用指向过来的时候计数加一，引用失效时计数减一，当对象的引用计数为0的时候，对象会被回收，释放内存空间。除了这个还有标记清除法和分代回收。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">23.Python的可变类型和不可变类型？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">数字、字符串、元组是不可变的，列表字典是可变的，对于不可变类型的变量重新赋值的时候实际上是重新创建一个新的对象，原变量指向新的对象内存地址，除浮点型变量之外，对于值相同的变量可能都会指向同一个内存地址。可变类型例如列表在新增一个元素的时候，变量还是指向原来的那个内存地址，只是其中的元素指向发生了改变。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">24.求结果：</span><br />\n <span style=\"color:#333333;\">  v = dict.fromkeys(['k1','k2'],[])</span>  <br /><span style=\"color:#333333;\">   v[‘k1’].append(666)</span><br />\n <span style=\"color:#333333;\">  print(v)</span> <br /><span style=\"color:#333333;\">   v[‘k1’] = 777</span><br />\n <span style=\"color:#333333;\">  print(v)</span></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>{'k1': [666], 'k2': [666]}</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>{'k1': 777, 'k2': [666]}</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>猜测原因是，在创建v这个字典的时候k1 k2 都指向了同一个空列表，当我们修改了这个列表的内容之后两个会同时发生改变，第二次单独修改k1的时候重新开辟了一个空间并指向新的内存地址。</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">25.求结果：</span><br /><img alt=\"\" class=\"has\" height=\"72\" src=\"https://img-blog.csdn.net/20180920143009219?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"298\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>[6, 6, 6, 6]</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>解释见：</strong></span></strong><a href=\"https://www.cnblogs.com/imhurley/p/3898289.html\"><strong><u><span style=\"color:#0563c1;\"><strong><u>https://www.cnblogs.com/imhurley/p/3898289.html</u></strong></span></u></strong></a></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">26.列举常见的内置函数？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">abs() </span><span style=\"color:#333333;\">绝对值  len()序列长度 divmod</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">取模 pow</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">乘方 round()浮点数</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">27.filter、map、reduce的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>fi</strong></span></strong><strong><span style=\"color:#333333;\"><strong>lter()函数：</strong></span></strong><span style=\"color:#333333;\">filter()函数接收两个参数，一个是bool函数，一个是序列，依次将序列中的每一个元素传入到bool函数中，返回值为非零的元素添加到新的列表中。</span><br /><img alt=\"\" class=\"has\" height=\"149\" src=\"https://img-blog.csdn.net/20180920143036526?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"331\" /></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>map()</strong></span></strong><strong><span style=\"color:#333333;\"><strong>函数</strong></span></strong><span style=\"color:#333333;\">：map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回</span><br /><img alt=\"\" class=\"has\" height=\"102\" src=\"https://img-blog.csdn.net/20180920143049468?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"289\" /></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\">reduce</span><span style=\"color:#333333;\">()</span></strong><span style=\"color:#333333;\"><strong>函数</strong>：三个参数，一个需要两个参数的函数，一个序列，一个初始值，执行顺序为：将序列中的第一个值和初始值进行func处理，然后将结果和序列第二个值处理直到结束。</span><br /><img alt=\"\" class=\"has\" height=\"97\" src=\"https://img-blog.csdn.net/20180920143109928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"287\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">28.一行代码实现9*9乘法表</span></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#006699;\"><strong>      print</strong></span></strong> <span style=\"color:#0000ff;\">\"\\n\"</span><span style=\"color:#000000;\">.join(</span><span style=\"color:#0000ff;\">\"\\t\"</span><span style=\"color:#000000;\">.join([</span><span style=\"color:#0000ff;\">\"%s*%s=%s\"</span><span style=\"color:#000000;\"> %(x,y,x*y) </span><strong><span style=\"color:#006699;\"><strong>for</strong></span></strong><span style=\"color:#000000;\"> y </span><strong><span style=\"color:#006699;\"><strong>in</strong></span></strong><span style=\"color:#000000;\"> range(1, x+1)]) </span><strong><span style=\"color:#006699;\"><strong>for</strong></span></strong><span style=\"color:#000000;\"> x </span><strong><span style=\"color:#006699;\"><strong>in</strong></span></strong><span style=\"color:#000000;\"> range(1, 10))  </span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">29.re的match和search区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Match</span><span style=\"color:#333333;\">是从头开始匹配 search从任意位置匹配</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">30.什么是正则的贪婪匹配？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">贪婪匹配就死趋于最大长度的匹配</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">非贪婪匹配就是匹配到结果就好</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">31.def func(a,b=[]) 这种写法有什么坑？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">函数的第二个参数是一个list，当第一次执行的时候实例化了一个list，第二次执行的时候还是用的是第一次实例化的那个list</span></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"179\" src=\"https://img-blog.csdn.net/20180920143300580?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"243\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">32.如何实现 “1,2,3” 变成 [‘1’,’2’,’3’] ?</span></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"51\" src=\"https://img-blog.csdn.net/20180920143308681?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"185\" /></p>\n\n<ol><li><span style=\"color:#333333;\">如何实现[‘1’,’2’,’3’]变成[1,2,3] ?</span></li>\n</ol><p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"51\" src=\"https://img-blog.csdn.net/20180920143312837?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"241\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">34.比较： a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 </span><span style=\"color:#333333;\">c</span><span style=\"color:#333333;\"> = [(1,),(2,),(3,) ] 的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">a是一个列表,其中的元素为整数</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">a和b</span> <span style=\"color:#333333;\">的内容一样但是在内存中的地址不同，也就是 a</span><span style=\"color:#333333;\">==b </span><span style=\"color:#333333;\">成立 a</span><span style=\"color:#333333;\"> is b </span><span style=\"color:#333333;\">不成立</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">c也是一个列表，只不过其中的元素为元组</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">35.如何用一行代码生成[1,4,9,16,25,36,49,64,81,100] ?</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">     1：list(map(lambda x:x*x ,[1,2,3,4,5,6,7,8,9,10]))</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">2：</span><span style=\"color:#333333;\">list</span><span style=\"color:#333333;\">(x*x for x in range(1,11))</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">36.一行代码实现删除列表中重复的值 ?</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">list1 = list(set(list1))</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">37.如何在函数中设置一个全局变量 ?</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">使用global声明变量</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">38.logging模块的作用？以及应用场景？</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">       l</span><span style=\"color:#333333;\">ogging模块是python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、保存路径、日志文件回滚等。可用于记录程序运行状态。</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">39.请用代码</span><span style=\"color:#333333;\">简单</span><span style=\"color:#333333;\">实现stack 。</span></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Stack(object):\n    # 初始化栈为空列表\n    def __init__(self):\n        self.items = []\n\n    # 判断栈是否为空，返回布尔值\n    def is_empty(self):\n        return self.items == []\n\n    # 返回栈顶元素\n    def peek(self):\n        return self.items[len(self.items) - 1]\n\n    # 返回栈的大小\n    def size(self):\n        return len(self.items)\n\n    # 进栈\n    def push(self, item):\n        self.items.append(item)\n\n    # 出栈\n    def pop(self, item):\n        return self.items.pop()</code></pre>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">40.常用字符串格式化哪几种？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">主要有两种 %</span> <span style=\"color:#333333;\">和format</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">示例1：</span><span style=\"color:#333333;\">”%s%d” %(‘hello’,1)</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">示例2：</span><span style=\"color:#333333;\">\"i am {} age {} sex:{}\".format('alex',38,'male')</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">             \"i am {1} age {1} sex:{2}\".format('alex',38,'male')</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">41.简述 生成器、迭代器、可迭代对象 以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>生成器：</strong></span></strong><span style=\"color:#333333;\">生成器其实是一种特殊的迭代器，生成器一定是迭代器反之不成立，不需要写__iter__()和__next__()方法，只需要一个yield关键字。<br />\n例如：斐波那契的例子</span></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def fib():\n    prev, curr = 0, 1\n    while True:\n        yield curr\n        prev, curr = curr, curr + prev\n\n&gt;&gt;&gt; f = fib()\n&gt;&gt;&gt; from itertools import islice\n&gt;&gt;&gt; list(islice(f, 0, 10))\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code></pre>\n\n<p style=\"margin-left:0pt;\">     <span style=\"color:#333333;\"><strong>生成器表达式</strong>：是列表推倒式的生成器版本，看起来像列表推导式，但是他返回的是一个生成器对象而不是列表对象 </span><br />\n    <img alt=\"\" class=\"has\" height=\"53\" src=\"https://img-blog.csdn.net/20180920143718651?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"330\" /></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>迭代器：</strong></span></strong><span style=\"color:#333333;\">可以被next调用并不断返回下一个值的对象称为迭代器，迭代器内部有一个状态，该状态用于记录当前迭代所在的位置，__iter__()返回迭代器本身，__next__()返回容器中的下一个值。</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>可迭代对象：</strong></span></strong><span style=\"color:#333333;\">但凡可以返回一个迭代器的对象都可以称之为可迭代对象，更为直观点可以使用for循环的对象，如列表，元组，字典，集合，字符串，打开的文件，socket等。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">42.用Python实现一个二分查找的函数。 <br />\n     </span><img alt=\"\" class=\"has\" height=\"247\" src=\"https://img-blog.csdn.net/20180920143746615?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"359\" /></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">43.谈谈你对闭包的理解？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">闭包就是在一个外部函数中定义一个内函数，内函数里运用了外部函数的临时变量，并且外函数的返回值是内函数的引用。如下是最简单的一个闭包：</span><br /><img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180920143854274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"246\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">在python中一切皆对象，小到一个变量，大到一个函数一个类都是对象，变量名，函数名类名都是指向内存地址。因此当返回值为一个函数的引用的时候可以跟括号来调用此函数。<br />\n一般来说，当一个函数结束的时候，会将临时变量释放掉，但是在闭包中，临时变量会在内部函数中用到，因此在返回内函数的时候会将临时变量和内函数绑定在一起，外函数结束后，在调用内函数的时候依然可以使用外函数的临时变量。每次在调用外函数的时候都会在内存中创建一个内函数，并且返回的是当前的内函数地址，需要知道的的是虽然内函数被重新创建了，但是外函数的临时变量只存在一份，每次创建的内函数都是使用的同一份临时变量。如下两次调用的返回值是不同的</span><br /><img alt=\"\" class=\"has\" height=\"133\" src=\"https://img-blog.csdn.net/2018092014391017?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"180\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Python中内函数想要修改外函数的临时变量可以使用nonlocal关键字来定义变量，如下：</span><br /><img alt=\"\" class=\"has\" height=\"209\" src=\"https://img-blog.csdn.net/20180920143921274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"216\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">闭包的应用：装饰器、单例模式</span></p>\n\n<p><span style=\"color:#333333;\">44.os和sys模块的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">os 模块提供了一种方便的使用操作系统函数的方法。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">sys模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">45.如何生成一个随机数？<br />\n     </span><img alt=\"\" class=\"has\" height=\"49\" src=\"https://img-blog.csdn.net/2018092014395514?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"204\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">46.如何使用python删除一个文件？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">o</span><span style=\"color:#333333;\">s</span><span style=\"color:#333333;\">.remove(file_path)</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">os.rmdir(dir_path)</span></p>\n\n<p><span style=\"color:#333333;\">47.面向对象深度优先和广度优先是什么？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Python 中类的多继承分为深度优先和广度优先，新式类会按照深度优先方法查找，金典类会按照广度优先的方式查找。</span><br /><img alt=\"\" class=\"has\" height=\"266\" src=\"https://img-blog.csdn.net/20180920144033707?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"687\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">48.面向对象中super的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">S</span><span style=\"color:#333333;\">uper(</span><span style=\"color:#333333;\">)</span><span style=\"color:#333333;\">可以保证公共的父类仅被执行一次。按照MRO的顺序执行</span><span style=\"color:#ff0000;\">原理待更新：</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">49.列举面向对象中带爽下划线的特殊方法，如：__new__、__init__</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__doc__  </span><span style=\"color:#333333;\">表示类的描述信息</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__module__ 表示当前操作的对象在那个模块</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__class__ 表示当前操作的对象的类是什么</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__init__  </span><span style=\"color:#333333;\">构造方法，通过类创建对象时，自动触发执行</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__del__ 析构方法，当对象在内存中被释放的时候，自动触发执行</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">_</span><span style=\"color:#333333;\">_call__ </span><span style=\"color:#333333;\">对象后面加括号，触发执行</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">_</span><span style=\"color:#333333;\">_dict__ </span><span style=\"color:#333333;\">类或对象中的所有成员</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__str__ </span><span style=\"color:#333333;\">如果一个类中定义了这个方法那么在打印对象的时候默认输出该方法的返回值</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__getitem__、__setitem__、__delitem__ 用于索引操作，如字典。分别表示获取、设置、删除数据</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__getslice__、__setslice__、__delslice__分别用于切片操作，如列表</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__iter__ </span><span style=\"color:#333333;\">用于迭代器</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">__new__</span><span style=\"color:#ff0000;\">和__metaclass__</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">50.如何判断是函数还是方法？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">根据__call__属性判断： if(hasattr(func,</span><span style=\"color:#ff0000;\">’__call__’)):</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">利用callable判断: if(callable(func)):</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">利用isfunction判断：if</span><span style=\"color:#ff0000;\">(isfunction(add)):</span></p>\n\n<p><span style=\"color:#333333;\">51.静态方法和类方法区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">类方法必须有一个指向类对象的引用作为第一个参数，但是静态方法可以没有任何参数，</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">52.列举面向对象中的特殊成员以及应用场景</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">53.   1、2、3、4、5 能组成多少个互不相同且无重复的三位数</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">        A</span><span style=\"color:#333333;\">53 = </span><span style=\"color:#333333;\">60个</span></p>\n\n<p><span style=\"color:#333333;\">54. 什么是反射？以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">其实，反射就是通过字符串的形式，导入模块；通过字符串的形式去模块寻找指定的函数并执行。利用字符串的形式去对象（模块）中操作（查找、获取、删除、添加）成员，是一种基于字符串的事件驱动。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">g</span><span style=\"color:#333333;\">etattr</span><span style=\"color:#333333;\">(</span><span style=\"color:#333333;\">object, name [,defaukt])函数是python内置函数，用于返回一个对象属性值,若不存在且为设置默认值则触发异常，如果设置了默认值则返回默认值。</span><br /><img alt=\"\" class=\"has\" height=\"229\" src=\"https://img-blog.csdn.net/20180920144219728?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"450\" /><br /><img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180920144237505?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"262\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">hasattr</span><span style=\"color:#333333;\">(object,name):</span><span style=\"color:#333333;\">判断对象object是否包含名为name的特性（hasattr是通过调用getattr()是否抛出异常来实现的）。如果有该属性则返回True否则返回False</span><br /><img alt=\"\" class=\"has\" height=\"162\" src=\"https://img-blog.csdn.net/20180920144248353?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"277\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">setattr</span><span style=\"color:#333333;\">(object, name, value):</span><span style=\"color:#333333;\">对应函数getattr(),用于设置属性值，或者增加某个属性。</span><br /><img alt=\"\" class=\"has\" height=\"131\" src=\"https://img-blog.csdn.net/20180920144301230?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"209\" /></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"49\" src=\"https://img-blog.csdn.net/20180920144314576?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"231\" /><br /><img alt=\"\" class=\"has\" height=\"115\" src=\"https://img-blog.csdn.net/20180920144359561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"281\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">delattr</span><span style=\"color:#333333;\">(object, name):</span><span style=\"color:#333333;\">用于删除属性，操作类似不举示例了。</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>应用：</strong></span></strong><span style=\"color:#333333;\">实现一个简单的url路由器的功能，实现动态导入模块</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">55.metaclass作用？以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">M</span><span style=\"color:#333333;\">etaclass</span> <span style=\"color:#333333;\">的实例化结果是类。而class实例化结果是instance，metaclass是创建类的模版，所有的类都是通过他来创建的，这使得我们可以自由控制创建类的过程。实现自由的修改、增加、删除 类或者实例中的方法或者属性。可批量对某些方法使用装饰器，而不需要每次都在方法上面增加@decorator_func。</span><span style=\"color:#333333;\">等等</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">56.用尽量多的方法实现单例模式。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">单例模式的主要目的是确保某一个类只有一个实例存在，主要的实现方式有以下几种：</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">1：使用模块。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">2：使用装饰器。<br />\n      </span><img alt=\"\" class=\"has\" height=\"119\" src=\"https://img-blog.csdn.net/20180920144440324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"534\" /><br />\n      <img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180920144453324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"293\" /><br />\n      <img alt=\"\" class=\"has\" height=\"71\" src=\"https://img-blog.csdn.net/20180920144514219?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"173\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">3：基于__new__方法实现。<br />\n      在实例化一个类的时候，首先执行了类的__new__方法，然后执行__init__方法，</span><span style=\"color:#333333;\">在实例化的时候先检查有没有已经实例化过，如果有则返回已经实例化候的对象，否则创建新的。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">     4：基于metaclass方法实现<br />\n        1.类由type创建，创建类时，type的__init__方法自动执行，类() 执行type的 __call__方法(类的__new__方法,类的__init__       方法)。<br />\n        2.对象由类创建，创建对象时，类的__init__方法自动执行，对象()执行类的 __call__ 方法。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">57.装饰器的写法以及应用场景。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">python的装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数和闭包一样，所以装饰器是闭包的一种应用，使用装饰器可以不用在更改原函数的前提下给函数增加新的功能，当有多个装饰器的时候从上到下依次执行。<br />\n装饰器的原理：和闭包类似<br />\n最简单的一个装饰器</span><br /><img alt=\"\" class=\"has\" height=\"227\" src=\"https://img-blog.csdn.net/2018092014463326?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"292\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">主要用户一些认证功能，日志，授权</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">58.异常处理写法以及如何主动抛出异常（应用场景）<br />\n     </span><img alt=\"\" class=\"has\" height=\"116\" src=\"https://img-blog.csdn.net/20180920144704838?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"220\" /><br />\n     <img alt=\"\" class=\"has\" height=\"272\" src=\"https://img-blog.csdn.net/20180920144712593?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"412\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">59.什么是面向对象的mro</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">60.isinstance作用以及应用场景？<br />\n      用来判断一个对象是否是一个已知类型，类似type(),</span><span style=\"color:#333333;\">和type不同的是type()不会认为子类是一种父类类型，不考虑继承关系，而isinstance（）会认为子类是一种父类类型，会考虑继承关系。如果要判断两个类型是否相同的时候最好使用isinstance</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">61.写代码并实现：</span><br /><span style=\"color:#333333;\">       给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br />\n       你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</span><br /><span style=\"color:#333333;\">       Example:</span> <br />\n         <span style=\"color:#333333;\">       Given nums = [2, 7, 11, 15], target = 9,</span><br />\n                 <span style=\"color:#333333;\">Because nums[0] + nums[1] = 2 + 7 = 9,</span> <br />\n                <span style=\"color:#333333;\">return [0, 1]   </span><br />\n       <img alt=\"\" class=\"has\" height=\"300\" src=\"https://img-blog.csdn.net/20180920144810113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"428\" /></p>\n\n<p><span style=\"color:#333333;\">62.json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">       可处理的数据类型有:字符串、列表、元组、字典、整数，不支持集合。定制支持datetime:首先写一个类：将用于判断是否         为datetime类型的数据格式，如果是则将其转换成字符串类型。再交给json处理。使用的时候指定cls参数即可。<br />\n       </span><img alt=\"\" class=\"has\" height=\"196\" src=\"https://img-blog.csdn.net/20180920144932516?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"588\" /></p>\n\n<p><span style=\"color:#333333;\">63.json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？<br />\n     </span><img alt=\"\" class=\"has\" height=\"51\" src=\"https://img-blog.csdn.net/20180920144955556?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"348\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">64.什么是断言？应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">assert断言用来检查一个条件，如果为真那么不做任何事，如果错误则会抛出AssertionError错误并且包含错误信息，应用场景：程序常量，检查逻辑，检查文，档检查约定</span><span style=\"color:#333333;\">。</span><span style=\"color:#333333;\">格式为 assert</span> <span style=\"color:#333333;\">语句, 报错输出</span><br /><img alt=\"\" class=\"has\" height=\"85\" src=\"https://img-blog.csdn.net/20180920145015421?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"370\" /></p>","source":"_posts/blogs-沛齐的315面试题基础部分解答（一）.md","raw":"<h1 style=\"margin-left:0pt;\"><strong>原题链接：</strong><a href=\"https://www.cnblogs.com/wupeiqi/p/9078770.html\">https://www.cnblogs.com/wupeiqi/p/9078770.html</a></h1>\n\n<p style=\"margin-left:0pt;\">部分图片是从其他博客上整理出来的，时间有些久了当初是写在word上的忘记参考出路了，有些答案我也不知道是否回答准确，如有错误还请提出，谢谢</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>基础部分</strong></strong></p>\n\n<p><span style=\"color:#333333;\">1.简述解释型和编译型编程语言？</span></p>\n\n<p style=\"margin-left:18pt;\"> 解释型语言在运行之前不会有编译过程，由解释器在运行的过程中解释运行的常见的解释型语言还有PHP、JS、ruby等等。</p>\n\n<p style=\"margin-left:18pt;\"> 编译型语言在运行之前需要使用编译器编译成机器码，计算机就可以直接运行编译过后的文件了。</p>\n\n<p style=\"margin-left:18pt;\">一般来说编译型语言要比解释型语言运行速度要快的，应为解释型语言每执行一次就需要翻译一次，效率比较慢。</p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">2.Python解释器种类以及特点</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      常见的解释器有5个CPython</span><span style=\"color:#333333;\">、</span><span style=\"color:#333333;\">IPython</span><span style=\"color:#333333;\">、</span><span style=\"color:#333333;\">PyPy</span><span style=\"color:#333333;\">、</span><span style=\"color:#333333;\">Jython</span><span style=\"color:#333333;\">、IronP</span><span style=\"color:#333333;\">ython</span><span style=\"color:#333333;\">.</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      CPython</span><span style=\"color:#333333;\">是官方版本的解释器，由C语言编写，运用也是最为广泛的。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      IPython是基于CPython的，只是在交互上做出了进一步的改善，例如代码补全。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      PyPy采用了JIT技术，可以动态编译python程序，提高其工作效率。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      Jython是在Java平台上运行的解释器，可在将python程序编译成Java字节码运行。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      IronP</span><span style=\"color:#333333;\">ython和Jython类似，运行在.NET平台上。</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">3.位和字节的关系？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">位（bit）是计算机存储中的最小单位。只有0、1两种状态</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">字节（Byte）一个字节由8个bit组成，是计算机数据处理的最小单位。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">4.使用python进制转换</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">二进制转换成十进制：v = “0b1111011”</span> <br /><span style=\"color:#333333;\">十进制转换成二进制：v = 18</span>  <br /><span style=\"color:#333333;\">八进制转换成十进制：v = “011”</span>  <br /><span style=\"color:#333333;\">十进制转换成八进制：v = 30</span>  <br /><span style=\"color:#333333;\">十六进制转换成十进制：v = “0x12”</span>  <br /><span style=\"color:#333333;\">十进制转换成十六进制：v = 87</span><br /><img alt=\"\" class=\"has\" height=\"200\" src=\"https://img-blog.csdn.net/201809201420160?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"341\" /></p>\n\n<p><span style=\"color:#333333;\">5.请编写一个函数实现将IP地址转换成一个整数。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">如 10.3.9.12 转换规则为：</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">      10          </span> <span style=\"color:#333333;\">00001010</span></p>\n\n<p style=\"margin-left:18pt;\"> <span style=\"color:#333333;\">       3           </span> <span style=\"color:#333333;\">00000011</span> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">       9           </span> <span style=\"color:#333333;\">00001001</span></p>\n\n<p style=\"margin-left:18pt;\"> <span style=\"color:#333333;\">      12          </span> <span style=\"color:#333333;\">00001100</span> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 = ？</span><br /><img alt=\"\" class=\"has\" height=\"144\" src=\"https://img-blog.csdn.net/20180920142100367?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"488\" /></p>\n\n<p><span style=\"color:#333333;\">6.python递归的最大层数？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython默认递归的最大层数为</span><span style=\"color:#333333;\">998</span><span style=\"color:#333333;\">层。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">7.求结果：</span><br /><span style=\"color:#333333;\">v1 = 1 or 3</span> <br /><span style=\"color:#333333;\">v2 = 1 and 3</span> <br /><span style=\"color:#333333;\">v3 = 0 and 2 and 1</span><br /><span style=\"color:#333333;\">v4 = 0 and 2 or 1</span><br /><span style=\"color:#333333;\">v5 = 0 and 2 or 1 or 4</span><br /><span style=\"color:#333333;\">v6 = 0 or False and 1</span></p>\n\n<p><span style=\"color:#333333;\">V1 = 1  V2 = 3   V3 = 0   V4 = 1  V5 = 1  V6 = False<br />\n(使用and如果第一个条件满足那么结果为第二个条件，如果第一个不满足结果为第一个条件。使用or如果第一个条件满足那么结果为第一个条件，如果第一个条件不满足结果为第二个条件）</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">8.ascii、unicode、utf-8、gbk 区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">A</span><span style=\"color:#333333;\">scii只占一个字节，其中包含英文字母、数字和一些符号。无法表示其他的文字。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Unicode</span><span style=\"color:#333333;\">占两个字节，生僻字符占四个字节。但是如果全是英文字母的话会比较浪费空间。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">U</span><span style=\"color:#333333;\">tf-8中英文占一个字节中文占三个字节，其他的生僻字占4-</span><span style=\"color:#333333;\">6</span><span style=\"color:#333333;\">个字节。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">GBK占两个字节是中国制定的包含大部分汉字和其他的一些符号。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">9.三元运算规则以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython的三元运算格式为</span><strong><span style=\"color:#333333;\"><strong>res = 值1 if 条件 else 值2 </strong></span></strong><span style=\"color:#333333;\">，</span><span style=\"color:#333333;\">当条件满足时返回值1否则返回值2。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">可以用于只存在两种结果的if判断语句中。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">10.列举 Python2和Python3的区别？</span></p>\n\n<ol><li><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">rint函数：2中不需要括号将输出语句括起来，3中需要使用()</span></li>\n\t<li><span style=\"color:#333333;\">编码：</span><span style=\"color:#333333;\">Python3</span><span style=\"color:#333333;\">源码文件默认使用utf-8编码，支持中文</span></li>\n\t<li><span style=\"color:#333333;\">除法运算：</span><br /><span style=\"color:#333333;\">首先是'/'  :</span><br />\n\t    <span style=\"color:#333333;\">python</span><span style=\"color:#333333;\">3:   1 / 2 = 0.5 </span><br />\n\t    p<span style=\"color:#333333;\">ython2:</span>   <span style=\"color:#333333;\">1 / 2 = 0</span>        <span style=\"color:#333333;\">1.0 / 2.0 = 0.5</span></li>\n</ol><p style=\"margin-left:0pt;\">         <span style=\"color:#333333;\">其次是</span><span style=\"color:#333333;\">’//’<br />\n              Python</span><span style=\"color:#333333;\">3： 1 // 2 = 0<br />\n              Python2:    1 // 2 = 0</span></p>\n\n<p><span style=\"color:#333333;\">     4.不等运算符：2中不等于有两种表示!=和&lt;&gt;,3中只有!=</span></p>\n\n<p><span style=\"color:#333333;\">     5.数据类型：3中不支持long类型了只有一种整形int</span> <span style=\"color:#333333;\">和2中的long差不多的操作</span></p>\n\n<p style=\"margin-left:36pt;\"> </p>\n\n<p><span style=\"color:#333333;\">11.用一行代码实现数值交换：</span><span style=\"color:#333333;\">a = 1 ,b = 2</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">(a, b) = (b, a)</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">12.Python3和Python2中 int 和 long的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython3中没有long类型只有int但是</span><span style=\"color:#333333;\">3</span><span style=\"color:#333333;\">中的int操作包含2中的long操作。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">13.xrange和range的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">R</span><span style=\"color:#333333;\">ange([start,]stop</span><span style=\"color:#333333;\">[,step])</span><span style=\"color:#333333;\">更具指定的范围和步长生成一个序列。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Xrange()和range操作一样，不同的是它返回的是一个生成器。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">例如当我们使用range(10)的时候返回的是一个[0,1,2,3,4,5,6,7,8,9]的列表。而xrange(10)不会返回一个列表，而是每次调用的时候返回其中的值。这样在生成一个很大的操作的时候xrange的性能会更好。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">14文件操作时：xreadlines和readlines的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">和上面的range和xrange一样的区别，readlines将文件中读取的数据读取出来生成一个列表存放着，而x</span><span style=\"color:#333333;\">readlines</span><span style=\"color:#333333;\">返回的是一个迭代器每次调用的时候返回下一个值。所以对于数据量比较大的时候使用迭代器的方法会更好一些。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">15.列举布尔值为False的常见值？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">0、None、</span><span style=\"color:#333333;\">””、[]、{}</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">16.字符串、列表、元组、字典每个常用的5个方法？</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">字符串：isdigit()判断是否只包含数字 is</span><span style=\"color:#333333;\">lower()</span><span style=\"color:#333333;\">判断是否全为小写 is</span><span style=\"color:#333333;\">upper()</span><span style=\"color:#333333;\">判断是否全为大写  strip()去掉首尾空格  split()以指定字符切片</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">列表：append()在列表后面追加  count()统计次数  pop(</span><span style=\"color:#333333;\">index=-1</span><span style=\"color:#333333;\">)默认移除最后一个元素并返回 </span> <span style=\"color:#333333;\">sort()排序  reverse()反向列表中的元素 min</span><span style=\"color:#333333;\">()、</span><span style=\"color:#333333;\">max</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">返回最小最大值。</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">元组：cmp</span><span style=\"color:#333333;\">(tuple1,tuple2)</span><span style=\"color:#333333;\">比较两个元组元素  len</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">计算元组元素个数  max()返回最大值  min</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">返回最小值 tuple</span><span style=\"color:#333333;\">(list)</span><span style=\"color:#333333;\">将列表转为元组。</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">字典：get</span><span style=\"color:#333333;\">(key,default=None)</span><span style=\"color:#333333;\">返回指定键的值，没有返回默认值  copy</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">返回一个字典的浅复制  update(</span><span style=\"color:#333333;\">dict2</span><span style=\"color:#333333;\">)将dict</span><span style=\"color:#333333;\">2</span><span style=\"color:#333333;\">更新到原字典中 </span> <span style=\"color:#333333;\">value()返回所有值 key</span><span style=\"color:#333333;\">s()</span><span style=\"color:#333333;\">返回所有键  pop</span><span style=\"color:#333333;\">(key)</span><span style=\"color:#333333;\">删除并返回指定的key的值</span><span style=\"color:#333333;\">   popitem()</span><span style=\"color:#333333;\">随机删除并返回一个键值对。</span></p>\n\n<p style=\"margin-left:5.9pt;\"> </p>\n\n<p><span style=\"color:#333333;\">17.lambda表达式格式以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">L</span><span style=\"color:#333333;\">ambda语句中冒号前面的为参数，可以有多个，用逗号隔开。冒号右边的为返回值，如：add</span><span style=\"color:#333333;\"> = lambda x, y : x + y </span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">   add(1,3) </span><span style=\"color:#333333;\">结果为</span><span style=\"color:#333333;\">4</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">L</span><span style=\"color:#ff0000;\">ambda表达式通常是在需要一个函数，但是又不想费神去命名一个函数的时候使用</span><span style=\"color:#ff0000;\">，</span><span style=\"color:#ff0000;\">通常应用在函数式编程中、闭包</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">18.pass的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ass是空语句，为了保持程序结构的完整性，不做任何操作，一般只用做占位语句。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">19.*arg</span><span style=\"color:#333333;\">s</span><span style=\"color:#333333;\">和**kwarg</span><span style=\"color:#333333;\">s</span><span style=\"color:#333333;\">作用</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">如果我们不确定往一个函数中传入多少参数，或者我们希望以元组tuple或者列表list的形式传参数的时候，我们可以使用*args。如果我们不知道往函数中传递多少个关键词参数或者想传入字典的值作为关键词参数的时候我们可以使用**kwargs，args、kwargs两个标识符是约定俗成的用法。另一种答法：当函数的参数前面有一个星号*号的时候表示这是一个可变的位置参数，两个星号**表示这个是一个可变的关键词参数。星号*把序列或者集合解包（unpack）成位置参数，两个星号**把字典解包成关键词参数。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">20.is和==的区别</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      is比较的是两个实例对象是不是完全相同的，他们是不是同一个对象，占用的内存地址是否相同。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      ==</span><span style=\"color:#333333;\">比较的是两个对象的内容是否相等，内存地址可以不同，内容一样就可以了。</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">21.简述Python的深浅拷贝以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython的变量只存储了这个变量的内存地址，而不是值的本身，对于像list</span> <span style=\"color:#333333;\">set</span> <span style=\"color:#333333;\">dict这种复杂的数据结构来说里面存储的也仅仅是每个元素的地址而已</span><br /><img alt=\"\" class=\"has\" height=\"440\" src=\"https://img-blog.csdn.net/20180920142752928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"634\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">赋值：变量的每一次初始化都会在内存里面开辟一个新的空间，并将这个内存地址赋值给变量，例如：</span><br /><img alt=\"\" class=\"has\" height=\"101\" src=\"https://img-blog.csdn.net/20180920142812348?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"200\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">给str</span><span style=\"color:#333333;\">1</span><span style=\"color:#333333;\">两次赋值，两次的内存地址发生改变，第一次赋值hello的时候将hello在内存中的地址给了str</span><span style=\"color:#333333;\">1，</span><span style=\"color:#333333;\">第二次赋值world的时候再次将world的内存地址给了str</span><span style=\"color:#333333;\">1，</span><span style=\"color:#333333;\">但是此时hello并没有从内存中消失，只是现在没有变量指向他。当我们再次赋值的时候str1又指向了hello。</span><br /><img alt=\"\" class=\"has\" height=\"148\" src=\"https://img-blog.csdn.net/20180920142825292?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"177\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">深拷贝：</span><br /><img alt=\"\" class=\"has\" height=\"604\" src=\"https://img-blog.csdn.net/20180920142838291?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"687\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">深拷贝可以完全复制原变量的所有数据，我们修改其中一个的时候不会对复制的那份造成影响。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">浅拷贝：</span><br /><img alt=\"\" class=\"has\" height=\"467\" src=\"https://img-blog.csdn.net/20180920142855885?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"648\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">不管多么复杂的数据结构，浅拷贝只会copy一层。对于像int float str这种单一的数据是可以独立出来，但是对于更为复杂的数据结构就会出问题，因为在复制的时候只是将列表 字典等的整个的存放地址给复制过来了，并没有复制里面元素的内存地址，这样导致修改的时候会同时发生变化。例如：</span><br /><img alt=\"\" class=\"has\" height=\"287\" src=\"https://img-blog.csdn.net/20180920142907504?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"465\" /></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"199\" src=\"https://img-blog.csdn.net/20180920142913193?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"340\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">22.Python垃圾回收机制？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython的垃圾回收机制默认的方式是引用计数法，其原理是为每一个对象维护一个ob</span><span style=\"color:#333333;\">_ref</span><span style=\"color:#333333;\">字段，用来记录该对象当前被引用的次数，有新的引用指向过来的时候计数加一，引用失效时计数减一，当对象的引用计数为0的时候，对象会被回收，释放内存空间。除了这个还有标记清除法和分代回收。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">23.Python的可变类型和不可变类型？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">数字、字符串、元组是不可变的，列表字典是可变的，对于不可变类型的变量重新赋值的时候实际上是重新创建一个新的对象，原变量指向新的对象内存地址，除浮点型变量之外，对于值相同的变量可能都会指向同一个内存地址。可变类型例如列表在新增一个元素的时候，变量还是指向原来的那个内存地址，只是其中的元素指向发生了改变。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">24.求结果：</span><br />\n <span style=\"color:#333333;\">  v = dict.fromkeys(['k1','k2'],[])</span>  <br /><span style=\"color:#333333;\">   v[‘k1’].append(666)</span><br />\n <span style=\"color:#333333;\">  print(v)</span> <br /><span style=\"color:#333333;\">   v[‘k1’] = 777</span><br />\n <span style=\"color:#333333;\">  print(v)</span></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>{'k1': [666], 'k2': [666]}</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>{'k1': 777, 'k2': [666]}</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>猜测原因是，在创建v这个字典的时候k1 k2 都指向了同一个空列表，当我们修改了这个列表的内容之后两个会同时发生改变，第二次单独修改k1的时候重新开辟了一个空间并指向新的内存地址。</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">25.求结果：</span><br /><img alt=\"\" class=\"has\" height=\"72\" src=\"https://img-blog.csdn.net/20180920143009219?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"298\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>[6, 6, 6, 6]</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>解释见：</strong></span></strong><a href=\"https://www.cnblogs.com/imhurley/p/3898289.html\"><strong><u><span style=\"color:#0563c1;\"><strong><u>https://www.cnblogs.com/imhurley/p/3898289.html</u></strong></span></u></strong></a></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">26.列举常见的内置函数？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">abs() </span><span style=\"color:#333333;\">绝对值  len()序列长度 divmod</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">取模 pow</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">乘方 round()浮点数</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">27.filter、map、reduce的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>fi</strong></span></strong><strong><span style=\"color:#333333;\"><strong>lter()函数：</strong></span></strong><span style=\"color:#333333;\">filter()函数接收两个参数，一个是bool函数，一个是序列，依次将序列中的每一个元素传入到bool函数中，返回值为非零的元素添加到新的列表中。</span><br /><img alt=\"\" class=\"has\" height=\"149\" src=\"https://img-blog.csdn.net/20180920143036526?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"331\" /></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>map()</strong></span></strong><strong><span style=\"color:#333333;\"><strong>函数</strong></span></strong><span style=\"color:#333333;\">：map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回</span><br /><img alt=\"\" class=\"has\" height=\"102\" src=\"https://img-blog.csdn.net/20180920143049468?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"289\" /></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\">reduce</span><span style=\"color:#333333;\">()</span></strong><span style=\"color:#333333;\"><strong>函数</strong>：三个参数，一个需要两个参数的函数，一个序列，一个初始值，执行顺序为：将序列中的第一个值和初始值进行func处理，然后将结果和序列第二个值处理直到结束。</span><br /><img alt=\"\" class=\"has\" height=\"97\" src=\"https://img-blog.csdn.net/20180920143109928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"287\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">28.一行代码实现9*9乘法表</span></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#006699;\"><strong>      print</strong></span></strong> <span style=\"color:#0000ff;\">\"\\n\"</span><span style=\"color:#000000;\">.join(</span><span style=\"color:#0000ff;\">\"\\t\"</span><span style=\"color:#000000;\">.join([</span><span style=\"color:#0000ff;\">\"%s*%s=%s\"</span><span style=\"color:#000000;\"> %(x,y,x*y) </span><strong><span style=\"color:#006699;\"><strong>for</strong></span></strong><span style=\"color:#000000;\"> y </span><strong><span style=\"color:#006699;\"><strong>in</strong></span></strong><span style=\"color:#000000;\"> range(1, x+1)]) </span><strong><span style=\"color:#006699;\"><strong>for</strong></span></strong><span style=\"color:#000000;\"> x </span><strong><span style=\"color:#006699;\"><strong>in</strong></span></strong><span style=\"color:#000000;\"> range(1, 10))  </span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">29.re的match和search区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Match</span><span style=\"color:#333333;\">是从头开始匹配 search从任意位置匹配</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">30.什么是正则的贪婪匹配？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">贪婪匹配就死趋于最大长度的匹配</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">非贪婪匹配就是匹配到结果就好</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">31.def func(a,b=[]) 这种写法有什么坑？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">函数的第二个参数是一个list，当第一次执行的时候实例化了一个list，第二次执行的时候还是用的是第一次实例化的那个list</span></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"179\" src=\"https://img-blog.csdn.net/20180920143300580?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"243\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">32.如何实现 “1,2,3” 变成 [‘1’,’2’,’3’] ?</span></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"51\" src=\"https://img-blog.csdn.net/20180920143308681?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"185\" /></p>\n\n<ol><li><span style=\"color:#333333;\">如何实现[‘1’,’2’,’3’]变成[1,2,3] ?</span></li>\n</ol><p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"51\" src=\"https://img-blog.csdn.net/20180920143312837?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"241\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">34.比较： a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 </span><span style=\"color:#333333;\">c</span><span style=\"color:#333333;\"> = [(1,),(2,),(3,) ] 的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">a是一个列表,其中的元素为整数</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">a和b</span> <span style=\"color:#333333;\">的内容一样但是在内存中的地址不同，也就是 a</span><span style=\"color:#333333;\">==b </span><span style=\"color:#333333;\">成立 a</span><span style=\"color:#333333;\"> is b </span><span style=\"color:#333333;\">不成立</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">c也是一个列表，只不过其中的元素为元组</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">35.如何用一行代码生成[1,4,9,16,25,36,49,64,81,100] ?</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">     1：list(map(lambda x:x*x ,[1,2,3,4,5,6,7,8,9,10]))</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">2：</span><span style=\"color:#333333;\">list</span><span style=\"color:#333333;\">(x*x for x in range(1,11))</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">36.一行代码实现删除列表中重复的值 ?</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">list1 = list(set(list1))</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">37.如何在函数中设置一个全局变量 ?</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">使用global声明变量</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">38.logging模块的作用？以及应用场景？</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">       l</span><span style=\"color:#333333;\">ogging模块是python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、保存路径、日志文件回滚等。可用于记录程序运行状态。</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">39.请用代码</span><span style=\"color:#333333;\">简单</span><span style=\"color:#333333;\">实现stack 。</span></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Stack(object):\n    # 初始化栈为空列表\n    def __init__(self):\n        self.items = []\n\n    # 判断栈是否为空，返回布尔值\n    def is_empty(self):\n        return self.items == []\n\n    # 返回栈顶元素\n    def peek(self):\n        return self.items[len(self.items) - 1]\n\n    # 返回栈的大小\n    def size(self):\n        return len(self.items)\n\n    # 进栈\n    def push(self, item):\n        self.items.append(item)\n\n    # 出栈\n    def pop(self, item):\n        return self.items.pop()</code></pre>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">40.常用字符串格式化哪几种？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">主要有两种 %</span> <span style=\"color:#333333;\">和format</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">示例1：</span><span style=\"color:#333333;\">”%s%d” %(‘hello’,1)</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">示例2：</span><span style=\"color:#333333;\">\"i am {} age {} sex:{}\".format('alex',38,'male')</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">             \"i am {1} age {1} sex:{2}\".format('alex',38,'male')</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">41.简述 生成器、迭代器、可迭代对象 以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>生成器：</strong></span></strong><span style=\"color:#333333;\">生成器其实是一种特殊的迭代器，生成器一定是迭代器反之不成立，不需要写__iter__()和__next__()方法，只需要一个yield关键字。<br />\n例如：斐波那契的例子</span></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def fib():\n    prev, curr = 0, 1\n    while True:\n        yield curr\n        prev, curr = curr, curr + prev\n\n&gt;&gt;&gt; f = fib()\n&gt;&gt;&gt; from itertools import islice\n&gt;&gt;&gt; list(islice(f, 0, 10))\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code></pre>\n\n<p style=\"margin-left:0pt;\">     <span style=\"color:#333333;\"><strong>生成器表达式</strong>：是列表推倒式的生成器版本，看起来像列表推导式，但是他返回的是一个生成器对象而不是列表对象 </span><br />\n    <img alt=\"\" class=\"has\" height=\"53\" src=\"https://img-blog.csdn.net/20180920143718651?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"330\" /></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>迭代器：</strong></span></strong><span style=\"color:#333333;\">可以被next调用并不断返回下一个值的对象称为迭代器，迭代器内部有一个状态，该状态用于记录当前迭代所在的位置，__iter__()返回迭代器本身，__next__()返回容器中的下一个值。</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>可迭代对象：</strong></span></strong><span style=\"color:#333333;\">但凡可以返回一个迭代器的对象都可以称之为可迭代对象，更为直观点可以使用for循环的对象，如列表，元组，字典，集合，字符串，打开的文件，socket等。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">42.用Python实现一个二分查找的函数。 <br />\n     </span><img alt=\"\" class=\"has\" height=\"247\" src=\"https://img-blog.csdn.net/20180920143746615?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"359\" /></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">43.谈谈你对闭包的理解？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">闭包就是在一个外部函数中定义一个内函数，内函数里运用了外部函数的临时变量，并且外函数的返回值是内函数的引用。如下是最简单的一个闭包：</span><br /><img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180920143854274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"246\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">在python中一切皆对象，小到一个变量，大到一个函数一个类都是对象，变量名，函数名类名都是指向内存地址。因此当返回值为一个函数的引用的时候可以跟括号来调用此函数。<br />\n一般来说，当一个函数结束的时候，会将临时变量释放掉，但是在闭包中，临时变量会在内部函数中用到，因此在返回内函数的时候会将临时变量和内函数绑定在一起，外函数结束后，在调用内函数的时候依然可以使用外函数的临时变量。每次在调用外函数的时候都会在内存中创建一个内函数，并且返回的是当前的内函数地址，需要知道的的是虽然内函数被重新创建了，但是外函数的临时变量只存在一份，每次创建的内函数都是使用的同一份临时变量。如下两次调用的返回值是不同的</span><br /><img alt=\"\" class=\"has\" height=\"133\" src=\"https://img-blog.csdn.net/2018092014391017?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"180\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Python中内函数想要修改外函数的临时变量可以使用nonlocal关键字来定义变量，如下：</span><br /><img alt=\"\" class=\"has\" height=\"209\" src=\"https://img-blog.csdn.net/20180920143921274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"216\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">闭包的应用：装饰器、单例模式</span></p>\n\n<p><span style=\"color:#333333;\">44.os和sys模块的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">os 模块提供了一种方便的使用操作系统函数的方法。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">sys模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">45.如何生成一个随机数？<br />\n     </span><img alt=\"\" class=\"has\" height=\"49\" src=\"https://img-blog.csdn.net/2018092014395514?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"204\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">46.如何使用python删除一个文件？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">o</span><span style=\"color:#333333;\">s</span><span style=\"color:#333333;\">.remove(file_path)</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">os.rmdir(dir_path)</span></p>\n\n<p><span style=\"color:#333333;\">47.面向对象深度优先和广度优先是什么？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Python 中类的多继承分为深度优先和广度优先，新式类会按照深度优先方法查找，金典类会按照广度优先的方式查找。</span><br /><img alt=\"\" class=\"has\" height=\"266\" src=\"https://img-blog.csdn.net/20180920144033707?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"687\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">48.面向对象中super的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">S</span><span style=\"color:#333333;\">uper(</span><span style=\"color:#333333;\">)</span><span style=\"color:#333333;\">可以保证公共的父类仅被执行一次。按照MRO的顺序执行</span><span style=\"color:#ff0000;\">原理待更新：</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">49.列举面向对象中带爽下划线的特殊方法，如：__new__、__init__</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__doc__  </span><span style=\"color:#333333;\">表示类的描述信息</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__module__ 表示当前操作的对象在那个模块</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__class__ 表示当前操作的对象的类是什么</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__init__  </span><span style=\"color:#333333;\">构造方法，通过类创建对象时，自动触发执行</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__del__ 析构方法，当对象在内存中被释放的时候，自动触发执行</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">_</span><span style=\"color:#333333;\">_call__ </span><span style=\"color:#333333;\">对象后面加括号，触发执行</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">_</span><span style=\"color:#333333;\">_dict__ </span><span style=\"color:#333333;\">类或对象中的所有成员</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__str__ </span><span style=\"color:#333333;\">如果一个类中定义了这个方法那么在打印对象的时候默认输出该方法的返回值</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__getitem__、__setitem__、__delitem__ 用于索引操作，如字典。分别表示获取、设置、删除数据</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__getslice__、__setslice__、__delslice__分别用于切片操作，如列表</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__iter__ </span><span style=\"color:#333333;\">用于迭代器</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">__new__</span><span style=\"color:#ff0000;\">和__metaclass__</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">50.如何判断是函数还是方法？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">根据__call__属性判断： if(hasattr(func,</span><span style=\"color:#ff0000;\">’__call__’)):</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">利用callable判断: if(callable(func)):</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">利用isfunction判断：if</span><span style=\"color:#ff0000;\">(isfunction(add)):</span></p>\n\n<p><span style=\"color:#333333;\">51.静态方法和类方法区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">类方法必须有一个指向类对象的引用作为第一个参数，但是静态方法可以没有任何参数，</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">52.列举面向对象中的特殊成员以及应用场景</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">53.   1、2、3、4、5 能组成多少个互不相同且无重复的三位数</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">        A</span><span style=\"color:#333333;\">53 = </span><span style=\"color:#333333;\">60个</span></p>\n\n<p><span style=\"color:#333333;\">54. 什么是反射？以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">其实，反射就是通过字符串的形式，导入模块；通过字符串的形式去模块寻找指定的函数并执行。利用字符串的形式去对象（模块）中操作（查找、获取、删除、添加）成员，是一种基于字符串的事件驱动。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">g</span><span style=\"color:#333333;\">etattr</span><span style=\"color:#333333;\">(</span><span style=\"color:#333333;\">object, name [,defaukt])函数是python内置函数，用于返回一个对象属性值,若不存在且为设置默认值则触发异常，如果设置了默认值则返回默认值。</span><br /><img alt=\"\" class=\"has\" height=\"229\" src=\"https://img-blog.csdn.net/20180920144219728?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"450\" /><br /><img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180920144237505?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"262\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">hasattr</span><span style=\"color:#333333;\">(object,name):</span><span style=\"color:#333333;\">判断对象object是否包含名为name的特性（hasattr是通过调用getattr()是否抛出异常来实现的）。如果有该属性则返回True否则返回False</span><br /><img alt=\"\" class=\"has\" height=\"162\" src=\"https://img-blog.csdn.net/20180920144248353?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"277\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">setattr</span><span style=\"color:#333333;\">(object, name, value):</span><span style=\"color:#333333;\">对应函数getattr(),用于设置属性值，或者增加某个属性。</span><br /><img alt=\"\" class=\"has\" height=\"131\" src=\"https://img-blog.csdn.net/20180920144301230?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"209\" /></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"49\" src=\"https://img-blog.csdn.net/20180920144314576?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"231\" /><br /><img alt=\"\" class=\"has\" height=\"115\" src=\"https://img-blog.csdn.net/20180920144359561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"281\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">delattr</span><span style=\"color:#333333;\">(object, name):</span><span style=\"color:#333333;\">用于删除属性，操作类似不举示例了。</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>应用：</strong></span></strong><span style=\"color:#333333;\">实现一个简单的url路由器的功能，实现动态导入模块</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">55.metaclass作用？以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">M</span><span style=\"color:#333333;\">etaclass</span> <span style=\"color:#333333;\">的实例化结果是类。而class实例化结果是instance，metaclass是创建类的模版，所有的类都是通过他来创建的，这使得我们可以自由控制创建类的过程。实现自由的修改、增加、删除 类或者实例中的方法或者属性。可批量对某些方法使用装饰器，而不需要每次都在方法上面增加@decorator_func。</span><span style=\"color:#333333;\">等等</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">56.用尽量多的方法实现单例模式。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">单例模式的主要目的是确保某一个类只有一个实例存在，主要的实现方式有以下几种：</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">1：使用模块。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">2：使用装饰器。<br />\n      </span><img alt=\"\" class=\"has\" height=\"119\" src=\"https://img-blog.csdn.net/20180920144440324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"534\" /><br />\n      <img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180920144453324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"293\" /><br />\n      <img alt=\"\" class=\"has\" height=\"71\" src=\"https://img-blog.csdn.net/20180920144514219?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"173\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">3：基于__new__方法实现。<br />\n      在实例化一个类的时候，首先执行了类的__new__方法，然后执行__init__方法，</span><span style=\"color:#333333;\">在实例化的时候先检查有没有已经实例化过，如果有则返回已经实例化候的对象，否则创建新的。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">     4：基于metaclass方法实现<br />\n        1.类由type创建，创建类时，type的__init__方法自动执行，类() 执行type的 __call__方法(类的__new__方法,类的__init__       方法)。<br />\n        2.对象由类创建，创建对象时，类的__init__方法自动执行，对象()执行类的 __call__ 方法。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">57.装饰器的写法以及应用场景。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">python的装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数和闭包一样，所以装饰器是闭包的一种应用，使用装饰器可以不用在更改原函数的前提下给函数增加新的功能，当有多个装饰器的时候从上到下依次执行。<br />\n装饰器的原理：和闭包类似<br />\n最简单的一个装饰器</span><br /><img alt=\"\" class=\"has\" height=\"227\" src=\"https://img-blog.csdn.net/2018092014463326?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"292\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">主要用户一些认证功能，日志，授权</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">58.异常处理写法以及如何主动抛出异常（应用场景）<br />\n     </span><img alt=\"\" class=\"has\" height=\"116\" src=\"https://img-blog.csdn.net/20180920144704838?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"220\" /><br />\n     <img alt=\"\" class=\"has\" height=\"272\" src=\"https://img-blog.csdn.net/20180920144712593?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"412\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">59.什么是面向对象的mro</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">60.isinstance作用以及应用场景？<br />\n      用来判断一个对象是否是一个已知类型，类似type(),</span><span style=\"color:#333333;\">和type不同的是type()不会认为子类是一种父类类型，不考虑继承关系，而isinstance（）会认为子类是一种父类类型，会考虑继承关系。如果要判断两个类型是否相同的时候最好使用isinstance</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">61.写代码并实现：</span><br /><span style=\"color:#333333;\">       给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br />\n       你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</span><br /><span style=\"color:#333333;\">       Example:</span> <br />\n         <span style=\"color:#333333;\">       Given nums = [2, 7, 11, 15], target = 9,</span><br />\n                 <span style=\"color:#333333;\">Because nums[0] + nums[1] = 2 + 7 = 9,</span> <br />\n                <span style=\"color:#333333;\">return [0, 1]   </span><br />\n       <img alt=\"\" class=\"has\" height=\"300\" src=\"https://img-blog.csdn.net/20180920144810113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"428\" /></p>\n\n<p><span style=\"color:#333333;\">62.json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">       可处理的数据类型有:字符串、列表、元组、字典、整数，不支持集合。定制支持datetime:首先写一个类：将用于判断是否         为datetime类型的数据格式，如果是则将其转换成字符串类型。再交给json处理。使用的时候指定cls参数即可。<br />\n       </span><img alt=\"\" class=\"has\" height=\"196\" src=\"https://img-blog.csdn.net/20180920144932516?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"588\" /></p>\n\n<p><span style=\"color:#333333;\">63.json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？<br />\n     </span><img alt=\"\" class=\"has\" height=\"51\" src=\"https://img-blog.csdn.net/20180920144955556?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"348\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">64.什么是断言？应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">assert断言用来检查一个条件，如果为真那么不做任何事，如果错误则会抛出AssertionError错误并且包含错误信息，应用场景：程序常量，检查逻辑，检查文，档检查约定</span><span style=\"color:#333333;\">。</span><span style=\"color:#333333;\">格式为 assert</span> <span style=\"color:#333333;\">语句, 报错输出</span><br /><img alt=\"\" class=\"has\" height=\"85\" src=\"https://img-blog.csdn.net/20180920145015421?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"370\" /></p>","slug":"blogs-沛齐的315面试题基础部分解答（一）","published":1,"date":"2022-03-16T17:09:04.153Z","updated":"2022-03-16T17:09:04.154Z","_id":"cl0v6kesr001eyms47n0t7hv1","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 style=\"margin-left:0pt;\"><strong>原题链接：</strong><a href=\"https://www.cnblogs.com/wupeiqi/p/9078770.html\">https://www.cnblogs.com/wupeiqi/p/9078770.html</a></h1>\n\n<p style=\"margin-left:0pt;\">部分图片是从其他博客上整理出来的，时间有些久了当初是写在word上的忘记参考出路了，有些答案我也不知道是否回答准确，如有错误还请提出，谢谢</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>基础部分</strong></strong></p>\n\n<p><span style=\"color:#333333;\">1.简述解释型和编译型编程语言？</span></p>\n\n<p style=\"margin-left:18pt;\"> 解释型语言在运行之前不会有编译过程，由解释器在运行的过程中解释运行的常见的解释型语言还有PHP、JS、ruby等等。</p>\n\n<p style=\"margin-left:18pt;\"> 编译型语言在运行之前需要使用编译器编译成机器码，计算机就可以直接运行编译过后的文件了。</p>\n\n<p style=\"margin-left:18pt;\">一般来说编译型语言要比解释型语言运行速度要快的，应为解释型语言每执行一次就需要翻译一次，效率比较慢。</p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">2.Python解释器种类以及特点</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      常见的解释器有5个CPython</span><span style=\"color:#333333;\">、</span><span style=\"color:#333333;\">IPython</span><span style=\"color:#333333;\">、</span><span style=\"color:#333333;\">PyPy</span><span style=\"color:#333333;\">、</span><span style=\"color:#333333;\">Jython</span><span style=\"color:#333333;\">、IronP</span><span style=\"color:#333333;\">ython</span><span style=\"color:#333333;\">.</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      CPython</span><span style=\"color:#333333;\">是官方版本的解释器，由C语言编写，运用也是最为广泛的。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      IPython是基于CPython的，只是在交互上做出了进一步的改善，例如代码补全。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      PyPy采用了JIT技术，可以动态编译python程序，提高其工作效率。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      Jython是在Java平台上运行的解释器，可在将python程序编译成Java字节码运行。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      IronP</span><span style=\"color:#333333;\">ython和Jython类似，运行在.NET平台上。</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">3.位和字节的关系？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">位（bit）是计算机存储中的最小单位。只有0、1两种状态</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">字节（Byte）一个字节由8个bit组成，是计算机数据处理的最小单位。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">4.使用python进制转换</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">二进制转换成十进制：v = “0b1111011”</span> <br /><span style=\"color:#333333;\">十进制转换成二进制：v = 18</span>  <br /><span style=\"color:#333333;\">八进制转换成十进制：v = “011”</span>  <br /><span style=\"color:#333333;\">十进制转换成八进制：v = 30</span>  <br /><span style=\"color:#333333;\">十六进制转换成十进制：v = “0x12”</span>  <br /><span style=\"color:#333333;\">十进制转换成十六进制：v = 87</span><br /><img alt=\"\" class=\"has\" height=\"200\" src=\"https://img-blog.csdn.net/201809201420160?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"341\" /></p>\n\n<p><span style=\"color:#333333;\">5.请编写一个函数实现将IP地址转换成一个整数。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">如 10.3.9.12 转换规则为：</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">      10          </span> <span style=\"color:#333333;\">00001010</span></p>\n\n<p style=\"margin-left:18pt;\"> <span style=\"color:#333333;\">       3           </span> <span style=\"color:#333333;\">00000011</span> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">       9           </span> <span style=\"color:#333333;\">00001001</span></p>\n\n<p style=\"margin-left:18pt;\"> <span style=\"color:#333333;\">      12          </span> <span style=\"color:#333333;\">00001100</span> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 = ？</span><br /><img alt=\"\" class=\"has\" height=\"144\" src=\"https://img-blog.csdn.net/20180920142100367?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"488\" /></p>\n\n<p><span style=\"color:#333333;\">6.python递归的最大层数？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython默认递归的最大层数为</span><span style=\"color:#333333;\">998</span><span style=\"color:#333333;\">层。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">7.求结果：</span><br /><span style=\"color:#333333;\">v1 = 1 or 3</span> <br /><span style=\"color:#333333;\">v2 = 1 and 3</span> <br /><span style=\"color:#333333;\">v3 = 0 and 2 and 1</span><br /><span style=\"color:#333333;\">v4 = 0 and 2 or 1</span><br /><span style=\"color:#333333;\">v5 = 0 and 2 or 1 or 4</span><br /><span style=\"color:#333333;\">v6 = 0 or False and 1</span></p>\n\n<p><span style=\"color:#333333;\">V1 = 1  V2 = 3   V3 = 0   V4 = 1  V5 = 1  V6 = False<br />\n(使用and如果第一个条件满足那么结果为第二个条件，如果第一个不满足结果为第一个条件。使用or如果第一个条件满足那么结果为第一个条件，如果第一个条件不满足结果为第二个条件）</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">8.ascii、unicode、utf-8、gbk 区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">A</span><span style=\"color:#333333;\">scii只占一个字节，其中包含英文字母、数字和一些符号。无法表示其他的文字。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Unicode</span><span style=\"color:#333333;\">占两个字节，生僻字符占四个字节。但是如果全是英文字母的话会比较浪费空间。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">U</span><span style=\"color:#333333;\">tf-8中英文占一个字节中文占三个字节，其他的生僻字占4-</span><span style=\"color:#333333;\">6</span><span style=\"color:#333333;\">个字节。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">GBK占两个字节是中国制定的包含大部分汉字和其他的一些符号。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">9.三元运算规则以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython的三元运算格式为</span><strong><span style=\"color:#333333;\"><strong>res = 值1 if 条件 else 值2 </strong></span></strong><span style=\"color:#333333;\">，</span><span style=\"color:#333333;\">当条件满足时返回值1否则返回值2。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">可以用于只存在两种结果的if判断语句中。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">10.列举 Python2和Python3的区别？</span></p>\n\n<ol><li><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">rint函数：2中不需要括号将输出语句括起来，3中需要使用()</span></li>\n    <li><span style=\"color:#333333;\">编码：</span><span style=\"color:#333333;\">Python3</span><span style=\"color:#333333;\">源码文件默认使用utf-8编码，支持中文</span></li>\n    <li><span style=\"color:#333333;\">除法运算：</span><br /><span style=\"color:#333333;\">首先是'/'  :</span><br />\n        <span style=\"color:#333333;\">python</span><span style=\"color:#333333;\">3:   1 / 2 = 0.5 </span><br />\n        p<span style=\"color:#333333;\">ython2:</span>   <span style=\"color:#333333;\">1 / 2 = 0</span>        <span style=\"color:#333333;\">1.0 / 2.0 = 0.5</span></li>\n</ol><p style=\"margin-left:0pt;\">         <span style=\"color:#333333;\">其次是</span><span style=\"color:#333333;\">’//’<br />\n              Python</span><span style=\"color:#333333;\">3： 1 // 2 = 0<br />\n              Python2:    1 // 2 = 0</span></p>\n\n<p><span style=\"color:#333333;\">     4.不等运算符：2中不等于有两种表示!=和&lt;&gt;,3中只有!=</span></p>\n\n<p><span style=\"color:#333333;\">     5.数据类型：3中不支持long类型了只有一种整形int</span> <span style=\"color:#333333;\">和2中的long差不多的操作</span></p>\n\n<p style=\"margin-left:36pt;\"> </p>\n\n<p><span style=\"color:#333333;\">11.用一行代码实现数值交换：</span><span style=\"color:#333333;\">a = 1 ,b = 2</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">(a, b) = (b, a)</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">12.Python3和Python2中 int 和 long的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython3中没有long类型只有int但是</span><span style=\"color:#333333;\">3</span><span style=\"color:#333333;\">中的int操作包含2中的long操作。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">13.xrange和range的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">R</span><span style=\"color:#333333;\">ange([start,]stop</span><span style=\"color:#333333;\">[,step])</span><span style=\"color:#333333;\">更具指定的范围和步长生成一个序列。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Xrange()和range操作一样，不同的是它返回的是一个生成器。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">例如当我们使用range(10)的时候返回的是一个[0,1,2,3,4,5,6,7,8,9]的列表。而xrange(10)不会返回一个列表，而是每次调用的时候返回其中的值。这样在生成一个很大的操作的时候xrange的性能会更好。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">14文件操作时：xreadlines和readlines的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">和上面的range和xrange一样的区别，readlines将文件中读取的数据读取出来生成一个列表存放着，而x</span><span style=\"color:#333333;\">readlines</span><span style=\"color:#333333;\">返回的是一个迭代器每次调用的时候返回下一个值。所以对于数据量比较大的时候使用迭代器的方法会更好一些。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">15.列举布尔值为False的常见值？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">0、None、</span><span style=\"color:#333333;\">””、[]、{}</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">16.字符串、列表、元组、字典每个常用的5个方法？</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">字符串：isdigit()判断是否只包含数字 is</span><span style=\"color:#333333;\">lower()</span><span style=\"color:#333333;\">判断是否全为小写 is</span><span style=\"color:#333333;\">upper()</span><span style=\"color:#333333;\">判断是否全为大写  strip()去掉首尾空格  split()以指定字符切片</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">列表：append()在列表后面追加  count()统计次数  pop(</span><span style=\"color:#333333;\">index=-1</span><span style=\"color:#333333;\">)默认移除最后一个元素并返回 </span> <span style=\"color:#333333;\">sort()排序  reverse()反向列表中的元素 min</span><span style=\"color:#333333;\">()、</span><span style=\"color:#333333;\">max</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">返回最小最大值。</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">元组：cmp</span><span style=\"color:#333333;\">(tuple1,tuple2)</span><span style=\"color:#333333;\">比较两个元组元素  len</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">计算元组元素个数  max()返回最大值  min</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">返回最小值 tuple</span><span style=\"color:#333333;\">(list)</span><span style=\"color:#333333;\">将列表转为元组。</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">字典：get</span><span style=\"color:#333333;\">(key,default=None)</span><span style=\"color:#333333;\">返回指定键的值，没有返回默认值  copy</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">返回一个字典的浅复制  update(</span><span style=\"color:#333333;\">dict2</span><span style=\"color:#333333;\">)将dict</span><span style=\"color:#333333;\">2</span><span style=\"color:#333333;\">更新到原字典中 </span> <span style=\"color:#333333;\">value()返回所有值 key</span><span style=\"color:#333333;\">s()</span><span style=\"color:#333333;\">返回所有键  pop</span><span style=\"color:#333333;\">(key)</span><span style=\"color:#333333;\">删除并返回指定的key的值</span><span style=\"color:#333333;\">   popitem()</span><span style=\"color:#333333;\">随机删除并返回一个键值对。</span></p>\n\n<p style=\"margin-left:5.9pt;\"> </p>\n\n<p><span style=\"color:#333333;\">17.lambda表达式格式以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">L</span><span style=\"color:#333333;\">ambda语句中冒号前面的为参数，可以有多个，用逗号隔开。冒号右边的为返回值，如：add</span><span style=\"color:#333333;\"> = lambda x, y : x + y </span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">   add(1,3) </span><span style=\"color:#333333;\">结果为</span><span style=\"color:#333333;\">4</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">L</span><span style=\"color:#ff0000;\">ambda表达式通常是在需要一个函数，但是又不想费神去命名一个函数的时候使用</span><span style=\"color:#ff0000;\">，</span><span style=\"color:#ff0000;\">通常应用在函数式编程中、闭包</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">18.pass的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ass是空语句，为了保持程序结构的完整性，不做任何操作，一般只用做占位语句。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">19.*arg</span><span style=\"color:#333333;\">s</span><span style=\"color:#333333;\">和**kwarg</span><span style=\"color:#333333;\">s</span><span style=\"color:#333333;\">作用</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">如果我们不确定往一个函数中传入多少参数，或者我们希望以元组tuple或者列表list的形式传参数的时候，我们可以使用*args。如果我们不知道往函数中传递多少个关键词参数或者想传入字典的值作为关键词参数的时候我们可以使用**kwargs，args、kwargs两个标识符是约定俗成的用法。另一种答法：当函数的参数前面有一个星号*号的时候表示这是一个可变的位置参数，两个星号**表示这个是一个可变的关键词参数。星号*把序列或者集合解包（unpack）成位置参数，两个星号**把字典解包成关键词参数。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">20.is和==的区别</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      is比较的是两个实例对象是不是完全相同的，他们是不是同一个对象，占用的内存地址是否相同。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      ==</span><span style=\"color:#333333;\">比较的是两个对象的内容是否相等，内存地址可以不同，内容一样就可以了。</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">21.简述Python的深浅拷贝以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython的变量只存储了这个变量的内存地址，而不是值的本身，对于像list</span> <span style=\"color:#333333;\">set</span> <span style=\"color:#333333;\">dict这种复杂的数据结构来说里面存储的也仅仅是每个元素的地址而已</span><br /><img alt=\"\" class=\"has\" height=\"440\" src=\"https://img-blog.csdn.net/20180920142752928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"634\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">赋值：变量的每一次初始化都会在内存里面开辟一个新的空间，并将这个内存地址赋值给变量，例如：</span><br /><img alt=\"\" class=\"has\" height=\"101\" src=\"https://img-blog.csdn.net/20180920142812348?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"200\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">给str</span><span style=\"color:#333333;\">1</span><span style=\"color:#333333;\">两次赋值，两次的内存地址发生改变，第一次赋值hello的时候将hello在内存中的地址给了str</span><span style=\"color:#333333;\">1，</span><span style=\"color:#333333;\">第二次赋值world的时候再次将world的内存地址给了str</span><span style=\"color:#333333;\">1，</span><span style=\"color:#333333;\">但是此时hello并没有从内存中消失，只是现在没有变量指向他。当我们再次赋值的时候str1又指向了hello。</span><br /><img alt=\"\" class=\"has\" height=\"148\" src=\"https://img-blog.csdn.net/20180920142825292?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"177\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">深拷贝：</span><br /><img alt=\"\" class=\"has\" height=\"604\" src=\"https://img-blog.csdn.net/20180920142838291?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"687\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">深拷贝可以完全复制原变量的所有数据，我们修改其中一个的时候不会对复制的那份造成影响。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">浅拷贝：</span><br /><img alt=\"\" class=\"has\" height=\"467\" src=\"https://img-blog.csdn.net/20180920142855885?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"648\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">不管多么复杂的数据结构，浅拷贝只会copy一层。对于像int float str这种单一的数据是可以独立出来，但是对于更为复杂的数据结构就会出问题，因为在复制的时候只是将列表 字典等的整个的存放地址给复制过来了，并没有复制里面元素的内存地址，这样导致修改的时候会同时发生变化。例如：</span><br /><img alt=\"\" class=\"has\" height=\"287\" src=\"https://img-blog.csdn.net/20180920142907504?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"465\" /></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"199\" src=\"https://img-blog.csdn.net/20180920142913193?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"340\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">22.Python垃圾回收机制？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython的垃圾回收机制默认的方式是引用计数法，其原理是为每一个对象维护一个ob</span><span style=\"color:#333333;\">_ref</span><span style=\"color:#333333;\">字段，用来记录该对象当前被引用的次数，有新的引用指向过来的时候计数加一，引用失效时计数减一，当对象的引用计数为0的时候，对象会被回收，释放内存空间。除了这个还有标记清除法和分代回收。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">23.Python的可变类型和不可变类型？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">数字、字符串、元组是不可变的，列表字典是可变的，对于不可变类型的变量重新赋值的时候实际上是重新创建一个新的对象，原变量指向新的对象内存地址，除浮点型变量之外，对于值相同的变量可能都会指向同一个内存地址。可变类型例如列表在新增一个元素的时候，变量还是指向原来的那个内存地址，只是其中的元素指向发生了改变。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">24.求结果：</span><br />\n <span style=\"color:#333333;\">  v = dict.fromkeys(['k1','k2'],[])</span>  <br /><span style=\"color:#333333;\">   v[‘k1’].append(666)</span><br />\n <span style=\"color:#333333;\">  print(v)</span> <br /><span style=\"color:#333333;\">   v[‘k1’] = 777</span><br />\n <span style=\"color:#333333;\">  print(v)</span></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>{'k1': [666], 'k2': [666]}</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>{'k1': 777, 'k2': [666]}</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>猜测原因是，在创建v这个字典的时候k1 k2 都指向了同一个空列表，当我们修改了这个列表的内容之后两个会同时发生改变，第二次单独修改k1的时候重新开辟了一个空间并指向新的内存地址。</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">25.求结果：</span><br /><img alt=\"\" class=\"has\" height=\"72\" src=\"https://img-blog.csdn.net/20180920143009219?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"298\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>[6, 6, 6, 6]</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>解释见：</strong></span></strong><a href=\"https://www.cnblogs.com/imhurley/p/3898289.html\"><strong><u><span style=\"color:#0563c1;\"><strong><u>https://www.cnblogs.com/imhurley/p/3898289.html</u></strong></span></u></strong></a></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">26.列举常见的内置函数？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">abs() </span><span style=\"color:#333333;\">绝对值  len()序列长度 divmod</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">取模 pow</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">乘方 round()浮点数</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">27.filter、map、reduce的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>fi</strong></span></strong><strong><span style=\"color:#333333;\"><strong>lter()函数：</strong></span></strong><span style=\"color:#333333;\">filter()函数接收两个参数，一个是bool函数，一个是序列，依次将序列中的每一个元素传入到bool函数中，返回值为非零的元素添加到新的列表中。</span><br /><img alt=\"\" class=\"has\" height=\"149\" src=\"https://img-blog.csdn.net/20180920143036526?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"331\" /></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>map()</strong></span></strong><strong><span style=\"color:#333333;\"><strong>函数</strong></span></strong><span style=\"color:#333333;\">：map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回</span><br /><img alt=\"\" class=\"has\" height=\"102\" src=\"https://img-blog.csdn.net/20180920143049468?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"289\" /></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\">reduce</span><span style=\"color:#333333;\">()</span></strong><span style=\"color:#333333;\"><strong>函数</strong>：三个参数，一个需要两个参数的函数，一个序列，一个初始值，执行顺序为：将序列中的第一个值和初始值进行func处理，然后将结果和序列第二个值处理直到结束。</span><br /><img alt=\"\" class=\"has\" height=\"97\" src=\"https://img-blog.csdn.net/20180920143109928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"287\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">28.一行代码实现9*9乘法表</span></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#006699;\"><strong>      print</strong></span></strong> <span style=\"color:#0000ff;\">\"\\n\"</span><span style=\"color:#000000;\">.join(</span><span style=\"color:#0000ff;\">\"\\t\"</span><span style=\"color:#000000;\">.join([</span><span style=\"color:#0000ff;\">\"%s*%s=%s\"</span><span style=\"color:#000000;\"> %(x,y,x*y) </span><strong><span style=\"color:#006699;\"><strong>for</strong></span></strong><span style=\"color:#000000;\"> y </span><strong><span style=\"color:#006699;\"><strong>in</strong></span></strong><span style=\"color:#000000;\"> range(1, x+1)]) </span><strong><span style=\"color:#006699;\"><strong>for</strong></span></strong><span style=\"color:#000000;\"> x </span><strong><span style=\"color:#006699;\"><strong>in</strong></span></strong><span style=\"color:#000000;\"> range(1, 10))  </span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">29.re的match和search区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Match</span><span style=\"color:#333333;\">是从头开始匹配 search从任意位置匹配</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">30.什么是正则的贪婪匹配？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">贪婪匹配就死趋于最大长度的匹配</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">非贪婪匹配就是匹配到结果就好</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">31.def func(a,b=[]) 这种写法有什么坑？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">函数的第二个参数是一个list，当第一次执行的时候实例化了一个list，第二次执行的时候还是用的是第一次实例化的那个list</span></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"179\" src=\"https://img-blog.csdn.net/20180920143300580?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"243\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">32.如何实现 “1,2,3” 变成 [‘1’,’2’,’3’] ?</span></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"51\" src=\"https://img-blog.csdn.net/20180920143308681?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"185\" /></p>\n\n<ol><li><span style=\"color:#333333;\">如何实现[‘1’,’2’,’3’]变成[1,2,3] ?</span></li>\n</ol><p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"51\" src=\"https://img-blog.csdn.net/20180920143312837?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"241\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">34.比较： a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 </span><span style=\"color:#333333;\">c</span><span style=\"color:#333333;\"> = [(1,),(2,),(3,) ] 的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">a是一个列表,其中的元素为整数</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">a和b</span> <span style=\"color:#333333;\">的内容一样但是在内存中的地址不同，也就是 a</span><span style=\"color:#333333;\">==b </span><span style=\"color:#333333;\">成立 a</span><span style=\"color:#333333;\"> is b </span><span style=\"color:#333333;\">不成立</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">c也是一个列表，只不过其中的元素为元组</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">35.如何用一行代码生成[1,4,9,16,25,36,49,64,81,100] ?</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">     1：list(map(lambda x:x*x ,[1,2,3,4,5,6,7,8,9,10]))</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">2：</span><span style=\"color:#333333;\">list</span><span style=\"color:#333333;\">(x*x for x in range(1,11))</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">36.一行代码实现删除列表中重复的值 ?</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">list1 = list(set(list1))</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">37.如何在函数中设置一个全局变量 ?</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">使用global声明变量</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">38.logging模块的作用？以及应用场景？</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">       l</span><span style=\"color:#333333;\">ogging模块是python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、保存路径、日志文件回滚等。可用于记录程序运行状态。</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">39.请用代码</span><span style=\"color:#333333;\">简单</span><span style=\"color:#333333;\">实现stack 。</span></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Stack(object):\n    # 初始化栈为空列表\n    def __init__(self):\n        self.items = []\n\n    # 判断栈是否为空，返回布尔值\n    def is_empty(self):\n        return self.items == []\n\n    # 返回栈顶元素\n    def peek(self):\n        return self.items[len(self.items) - 1]\n\n    # 返回栈的大小\n    def size(self):\n        return len(self.items)\n\n    # 进栈\n    def push(self, item):\n        self.items.append(item)\n\n    # 出栈\n    def pop(self, item):\n        return self.items.pop()</code></pre>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">40.常用字符串格式化哪几种？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">主要有两种 %</span> <span style=\"color:#333333;\">和format</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">示例1：</span><span style=\"color:#333333;\">”%s%d” %(‘hello’,1)</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">示例2：</span><span style=\"color:#333333;\">\"i am {} age {} sex:{}\".format('alex',38,'male')</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">             \"i am {1} age {1} sex:{2}\".format('alex',38,'male')</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">41.简述 生成器、迭代器、可迭代对象 以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>生成器：</strong></span></strong><span style=\"color:#333333;\">生成器其实是一种特殊的迭代器，生成器一定是迭代器反之不成立，不需要写__iter__()和__next__()方法，只需要一个yield关键字。<br />\n例如：斐波那契的例子</span></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def fib():\n    prev, curr = 0, 1\n    while True:\n        yield curr\n        prev, curr = curr, curr + prev\n\n&gt;&gt;&gt; f = fib()\n&gt;&gt;&gt; from itertools import islice\n&gt;&gt;&gt; list(islice(f, 0, 10))\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code></pre>\n\n<p style=\"margin-left:0pt;\">     <span style=\"color:#333333;\"><strong>生成器表达式</strong>：是列表推倒式的生成器版本，看起来像列表推导式，但是他返回的是一个生成器对象而不是列表对象 </span><br />\n    <img alt=\"\" class=\"has\" height=\"53\" src=\"https://img-blog.csdn.net/20180920143718651?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"330\" /></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>迭代器：</strong></span></strong><span style=\"color:#333333;\">可以被next调用并不断返回下一个值的对象称为迭代器，迭代器内部有一个状态，该状态用于记录当前迭代所在的位置，__iter__()返回迭代器本身，__next__()返回容器中的下一个值。</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>可迭代对象：</strong></span></strong><span style=\"color:#333333;\">但凡可以返回一个迭代器的对象都可以称之为可迭代对象，更为直观点可以使用for循环的对象，如列表，元组，字典，集合，字符串，打开的文件，socket等。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">42.用Python实现一个二分查找的函数。 <br />\n     </span><img alt=\"\" class=\"has\" height=\"247\" src=\"https://img-blog.csdn.net/20180920143746615?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"359\" /></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">43.谈谈你对闭包的理解？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">闭包就是在一个外部函数中定义一个内函数，内函数里运用了外部函数的临时变量，并且外函数的返回值是内函数的引用。如下是最简单的一个闭包：</span><br /><img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180920143854274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"246\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">在python中一切皆对象，小到一个变量，大到一个函数一个类都是对象，变量名，函数名类名都是指向内存地址。因此当返回值为一个函数的引用的时候可以跟括号来调用此函数。<br />\n一般来说，当一个函数结束的时候，会将临时变量释放掉，但是在闭包中，临时变量会在内部函数中用到，因此在返回内函数的时候会将临时变量和内函数绑定在一起，外函数结束后，在调用内函数的时候依然可以使用外函数的临时变量。每次在调用外函数的时候都会在内存中创建一个内函数，并且返回的是当前的内函数地址，需要知道的的是虽然内函数被重新创建了，但是外函数的临时变量只存在一份，每次创建的内函数都是使用的同一份临时变量。如下两次调用的返回值是不同的</span><br /><img alt=\"\" class=\"has\" height=\"133\" src=\"https://img-blog.csdn.net/2018092014391017?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"180\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Python中内函数想要修改外函数的临时变量可以使用nonlocal关键字来定义变量，如下：</span><br /><img alt=\"\" class=\"has\" height=\"209\" src=\"https://img-blog.csdn.net/20180920143921274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"216\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">闭包的应用：装饰器、单例模式</span></p>\n\n<p><span style=\"color:#333333;\">44.os和sys模块的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">os 模块提供了一种方便的使用操作系统函数的方法。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">sys模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">45.如何生成一个随机数？<br />\n     </span><img alt=\"\" class=\"has\" height=\"49\" src=\"https://img-blog.csdn.net/2018092014395514?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"204\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">46.如何使用python删除一个文件？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">o</span><span style=\"color:#333333;\">s</span><span style=\"color:#333333;\">.remove(file_path)</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">os.rmdir(dir_path)</span></p>\n\n<p><span style=\"color:#333333;\">47.面向对象深度优先和广度优先是什么？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Python 中类的多继承分为深度优先和广度优先，新式类会按照深度优先方法查找，金典类会按照广度优先的方式查找。</span><br /><img alt=\"\" class=\"has\" height=\"266\" src=\"https://img-blog.csdn.net/20180920144033707?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"687\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">48.面向对象中super的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">S</span><span style=\"color:#333333;\">uper(</span><span style=\"color:#333333;\">)</span><span style=\"color:#333333;\">可以保证公共的父类仅被执行一次。按照MRO的顺序执行</span><span style=\"color:#ff0000;\">原理待更新：</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">49.列举面向对象中带爽下划线的特殊方法，如：__new__、__init__</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__doc__  </span><span style=\"color:#333333;\">表示类的描述信息</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__module__ 表示当前操作的对象在那个模块</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__class__ 表示当前操作的对象的类是什么</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__init__  </span><span style=\"color:#333333;\">构造方法，通过类创建对象时，自动触发执行</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__del__ 析构方法，当对象在内存中被释放的时候，自动触发执行</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">_</span><span style=\"color:#333333;\">_call__ </span><span style=\"color:#333333;\">对象后面加括号，触发执行</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">_</span><span style=\"color:#333333;\">_dict__ </span><span style=\"color:#333333;\">类或对象中的所有成员</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__str__ </span><span style=\"color:#333333;\">如果一个类中定义了这个方法那么在打印对象的时候默认输出该方法的返回值</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__getitem__、__setitem__、__delitem__ 用于索引操作，如字典。分别表示获取、设置、删除数据</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__getslice__、__setslice__、__delslice__分别用于切片操作，如列表</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__iter__ </span><span style=\"color:#333333;\">用于迭代器</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">__new__</span><span style=\"color:#ff0000;\">和__metaclass__</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">50.如何判断是函数还是方法？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">根据__call__属性判断： if(hasattr(func,</span><span style=\"color:#ff0000;\">’__call__’)):</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">利用callable判断: if(callable(func)):</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">利用isfunction判断：if</span><span style=\"color:#ff0000;\">(isfunction(add)):</span></p>\n\n<p><span style=\"color:#333333;\">51.静态方法和类方法区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">类方法必须有一个指向类对象的引用作为第一个参数，但是静态方法可以没有任何参数，</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">52.列举面向对象中的特殊成员以及应用场景</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">53.   1、2、3、4、5 能组成多少个互不相同且无重复的三位数</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">        A</span><span style=\"color:#333333;\">53 = </span><span style=\"color:#333333;\">60个</span></p>\n\n<p><span style=\"color:#333333;\">54. 什么是反射？以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">其实，反射就是通过字符串的形式，导入模块；通过字符串的形式去模块寻找指定的函数并执行。利用字符串的形式去对象（模块）中操作（查找、获取、删除、添加）成员，是一种基于字符串的事件驱动。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">g</span><span style=\"color:#333333;\">etattr</span><span style=\"color:#333333;\">(</span><span style=\"color:#333333;\">object, name [,defaukt])函数是python内置函数，用于返回一个对象属性值,若不存在且为设置默认值则触发异常，如果设置了默认值则返回默认值。</span><br /><img alt=\"\" class=\"has\" height=\"229\" src=\"https://img-blog.csdn.net/20180920144219728?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"450\" /><br /><img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180920144237505?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"262\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">hasattr</span><span style=\"color:#333333;\">(object,name):</span><span style=\"color:#333333;\">判断对象object是否包含名为name的特性（hasattr是通过调用getattr()是否抛出异常来实现的）。如果有该属性则返回True否则返回False</span><br /><img alt=\"\" class=\"has\" height=\"162\" src=\"https://img-blog.csdn.net/20180920144248353?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"277\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">setattr</span><span style=\"color:#333333;\">(object, name, value):</span><span style=\"color:#333333;\">对应函数getattr(),用于设置属性值，或者增加某个属性。</span><br /><img alt=\"\" class=\"has\" height=\"131\" src=\"https://img-blog.csdn.net/20180920144301230?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"209\" /></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"49\" src=\"https://img-blog.csdn.net/20180920144314576?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"231\" /><br /><img alt=\"\" class=\"has\" height=\"115\" src=\"https://img-blog.csdn.net/20180920144359561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"281\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">delattr</span><span style=\"color:#333333;\">(object, name):</span><span style=\"color:#333333;\">用于删除属性，操作类似不举示例了。</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>应用：</strong></span></strong><span style=\"color:#333333;\">实现一个简单的url路由器的功能，实现动态导入模块</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">55.metaclass作用？以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">M</span><span style=\"color:#333333;\">etaclass</span> <span style=\"color:#333333;\">的实例化结果是类。而class实例化结果是instance，metaclass是创建类的模版，所有的类都是通过他来创建的，这使得我们可以自由控制创建类的过程。实现自由的修改、增加、删除 类或者实例中的方法或者属性。可批量对某些方法使用装饰器，而不需要每次都在方法上面增加@decorator_func。</span><span style=\"color:#333333;\">等等</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">56.用尽量多的方法实现单例模式。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">单例模式的主要目的是确保某一个类只有一个实例存在，主要的实现方式有以下几种：</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">1：使用模块。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">2：使用装饰器。<br />\n      </span><img alt=\"\" class=\"has\" height=\"119\" src=\"https://img-blog.csdn.net/20180920144440324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"534\" /><br />\n      <img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180920144453324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"293\" /><br />\n      <img alt=\"\" class=\"has\" height=\"71\" src=\"https://img-blog.csdn.net/20180920144514219?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"173\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">3：基于__new__方法实现。<br />\n      在实例化一个类的时候，首先执行了类的__new__方法，然后执行__init__方法，</span><span style=\"color:#333333;\">在实例化的时候先检查有没有已经实例化过，如果有则返回已经实例化候的对象，否则创建新的。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">     4：基于metaclass方法实现<br />\n        1.类由type创建，创建类时，type的__init__方法自动执行，类() 执行type的 __call__方法(类的__new__方法,类的__init__       方法)。<br />\n        2.对象由类创建，创建对象时，类的__init__方法自动执行，对象()执行类的 __call__ 方法。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">57.装饰器的写法以及应用场景。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">python的装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数和闭包一样，所以装饰器是闭包的一种应用，使用装饰器可以不用在更改原函数的前提下给函数增加新的功能，当有多个装饰器的时候从上到下依次执行。<br />\n装饰器的原理：和闭包类似<br />\n最简单的一个装饰器</span><br /><img alt=\"\" class=\"has\" height=\"227\" src=\"https://img-blog.csdn.net/2018092014463326?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"292\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">主要用户一些认证功能，日志，授权</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">58.异常处理写法以及如何主动抛出异常（应用场景）<br />\n     </span><img alt=\"\" class=\"has\" height=\"116\" src=\"https://img-blog.csdn.net/20180920144704838?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"220\" /><br />\n     <img alt=\"\" class=\"has\" height=\"272\" src=\"https://img-blog.csdn.net/20180920144712593?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"412\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">59.什么是面向对象的mro</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">60.isinstance作用以及应用场景？<br />\n      用来判断一个对象是否是一个已知类型，类似type(),</span><span style=\"color:#333333;\">和type不同的是type()不会认为子类是一种父类类型，不考虑继承关系，而isinstance（）会认为子类是一种父类类型，会考虑继承关系。如果要判断两个类型是否相同的时候最好使用isinstance</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">61.写代码并实现：</span><br /><span style=\"color:#333333;\">       给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br />\n       你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</span><br /><span style=\"color:#333333;\">       Example:</span> <br />\n         <span style=\"color:#333333;\">       Given nums = [2, 7, 11, 15], target = 9,</span><br />\n                 <span style=\"color:#333333;\">Because nums[0] + nums[1] = 2 + 7 = 9,</span> <br />\n                <span style=\"color:#333333;\">return [0, 1]   </span><br />\n       <img alt=\"\" class=\"has\" height=\"300\" src=\"https://img-blog.csdn.net/20180920144810113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"428\" /></p>\n\n<p><span style=\"color:#333333;\">62.json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">       可处理的数据类型有:字符串、列表、元组、字典、整数，不支持集合。定制支持datetime:首先写一个类：将用于判断是否         为datetime类型的数据格式，如果是则将其转换成字符串类型。再交给json处理。使用的时候指定cls参数即可。<br />\n       </span><img alt=\"\" class=\"has\" height=\"196\" src=\"https://img-blog.csdn.net/20180920144932516?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"588\" /></p>\n\n<p><span style=\"color:#333333;\">63.json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？<br />\n     </span><img alt=\"\" class=\"has\" height=\"51\" src=\"https://img-blog.csdn.net/20180920144955556?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"348\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">64.什么是断言？应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">assert断言用来检查一个条件，如果为真那么不做任何事，如果错误则会抛出AssertionError错误并且包含错误信息，应用场景：程序常量，检查逻辑，检查文，档检查约定</span><span style=\"color:#333333;\">。</span><span style=\"color:#333333;\">格式为 assert</span> <span style=\"color:#333333;\">语句, 报错输出</span><br /><img alt=\"\" class=\"has\" height=\"85\" src=\"https://img-blog.csdn.net/20180920145015421?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"370\" /></p>","site":{"data":{}},"excerpt":"","more":"<h1 style=\"margin-left:0pt;\"><strong>原题链接：</strong><a href=\"https://www.cnblogs.com/wupeiqi/p/9078770.html\">https://www.cnblogs.com/wupeiqi/p/9078770.html</a></h1>\n\n<p style=\"margin-left:0pt;\">部分图片是从其他博客上整理出来的，时间有些久了当初是写在word上的忘记参考出路了，有些答案我也不知道是否回答准确，如有错误还请提出，谢谢</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>基础部分</strong></strong></p>\n\n<p><span style=\"color:#333333;\">1.简述解释型和编译型编程语言？</span></p>\n\n<p style=\"margin-left:18pt;\"> 解释型语言在运行之前不会有编译过程，由解释器在运行的过程中解释运行的常见的解释型语言还有PHP、JS、ruby等等。</p>\n\n<p style=\"margin-left:18pt;\"> 编译型语言在运行之前需要使用编译器编译成机器码，计算机就可以直接运行编译过后的文件了。</p>\n\n<p style=\"margin-left:18pt;\">一般来说编译型语言要比解释型语言运行速度要快的，应为解释型语言每执行一次就需要翻译一次，效率比较慢。</p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">2.Python解释器种类以及特点</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      常见的解释器有5个CPython</span><span style=\"color:#333333;\">、</span><span style=\"color:#333333;\">IPython</span><span style=\"color:#333333;\">、</span><span style=\"color:#333333;\">PyPy</span><span style=\"color:#333333;\">、</span><span style=\"color:#333333;\">Jython</span><span style=\"color:#333333;\">、IronP</span><span style=\"color:#333333;\">ython</span><span style=\"color:#333333;\">.</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      CPython</span><span style=\"color:#333333;\">是官方版本的解释器，由C语言编写，运用也是最为广泛的。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      IPython是基于CPython的，只是在交互上做出了进一步的改善，例如代码补全。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      PyPy采用了JIT技术，可以动态编译python程序，提高其工作效率。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      Jython是在Java平台上运行的解释器，可在将python程序编译成Java字节码运行。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      IronP</span><span style=\"color:#333333;\">ython和Jython类似，运行在.NET平台上。</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">3.位和字节的关系？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">位（bit）是计算机存储中的最小单位。只有0、1两种状态</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">字节（Byte）一个字节由8个bit组成，是计算机数据处理的最小单位。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">4.使用python进制转换</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">二进制转换成十进制：v = “0b1111011”</span> <br /><span style=\"color:#333333;\">十进制转换成二进制：v = 18</span>  <br /><span style=\"color:#333333;\">八进制转换成十进制：v = “011”</span>  <br /><span style=\"color:#333333;\">十进制转换成八进制：v = 30</span>  <br /><span style=\"color:#333333;\">十六进制转换成十进制：v = “0x12”</span>  <br /><span style=\"color:#333333;\">十进制转换成十六进制：v = 87</span><br /><img alt=\"\" class=\"has\" height=\"200\" src=\"https://img-blog.csdn.net/201809201420160?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"341\" /></p>\n\n<p><span style=\"color:#333333;\">5.请编写一个函数实现将IP地址转换成一个整数。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">如 10.3.9.12 转换规则为：</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">      10          </span> <span style=\"color:#333333;\">00001010</span></p>\n\n<p style=\"margin-left:18pt;\"> <span style=\"color:#333333;\">       3           </span> <span style=\"color:#333333;\">00000011</span> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">       9           </span> <span style=\"color:#333333;\">00001001</span></p>\n\n<p style=\"margin-left:18pt;\"> <span style=\"color:#333333;\">      12          </span> <span style=\"color:#333333;\">00001100</span> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 = ？</span><br /><img alt=\"\" class=\"has\" height=\"144\" src=\"https://img-blog.csdn.net/20180920142100367?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"488\" /></p>\n\n<p><span style=\"color:#333333;\">6.python递归的最大层数？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython默认递归的最大层数为</span><span style=\"color:#333333;\">998</span><span style=\"color:#333333;\">层。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">7.求结果：</span><br /><span style=\"color:#333333;\">v1 = 1 or 3</span> <br /><span style=\"color:#333333;\">v2 = 1 and 3</span> <br /><span style=\"color:#333333;\">v3 = 0 and 2 and 1</span><br /><span style=\"color:#333333;\">v4 = 0 and 2 or 1</span><br /><span style=\"color:#333333;\">v5 = 0 and 2 or 1 or 4</span><br /><span style=\"color:#333333;\">v6 = 0 or False and 1</span></p>\n\n<p><span style=\"color:#333333;\">V1 = 1  V2 = 3   V3 = 0   V4 = 1  V5 = 1  V6 = False<br />\n(使用and如果第一个条件满足那么结果为第二个条件，如果第一个不满足结果为第一个条件。使用or如果第一个条件满足那么结果为第一个条件，如果第一个条件不满足结果为第二个条件）</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">8.ascii、unicode、utf-8、gbk 区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">A</span><span style=\"color:#333333;\">scii只占一个字节，其中包含英文字母、数字和一些符号。无法表示其他的文字。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Unicode</span><span style=\"color:#333333;\">占两个字节，生僻字符占四个字节。但是如果全是英文字母的话会比较浪费空间。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">U</span><span style=\"color:#333333;\">tf-8中英文占一个字节中文占三个字节，其他的生僻字占4-</span><span style=\"color:#333333;\">6</span><span style=\"color:#333333;\">个字节。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">GBK占两个字节是中国制定的包含大部分汉字和其他的一些符号。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">9.三元运算规则以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython的三元运算格式为</span><strong><span style=\"color:#333333;\"><strong>res = 值1 if 条件 else 值2 </strong></span></strong><span style=\"color:#333333;\">，</span><span style=\"color:#333333;\">当条件满足时返回值1否则返回值2。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">可以用于只存在两种结果的if判断语句中。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">10.列举 Python2和Python3的区别？</span></p>\n\n<ol><li><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">rint函数：2中不需要括号将输出语句括起来，3中需要使用()</span></li>\n    <li><span style=\"color:#333333;\">编码：</span><span style=\"color:#333333;\">Python3</span><span style=\"color:#333333;\">源码文件默认使用utf-8编码，支持中文</span></li>\n    <li><span style=\"color:#333333;\">除法运算：</span><br /><span style=\"color:#333333;\">首先是'/'  :</span><br />\n        <span style=\"color:#333333;\">python</span><span style=\"color:#333333;\">3:   1 / 2 = 0.5 </span><br />\n        p<span style=\"color:#333333;\">ython2:</span>   <span style=\"color:#333333;\">1 / 2 = 0</span>        <span style=\"color:#333333;\">1.0 / 2.0 = 0.5</span></li>\n</ol><p style=\"margin-left:0pt;\">         <span style=\"color:#333333;\">其次是</span><span style=\"color:#333333;\">’//’<br />\n              Python</span><span style=\"color:#333333;\">3： 1 // 2 = 0<br />\n              Python2:    1 // 2 = 0</span></p>\n\n<p><span style=\"color:#333333;\">     4.不等运算符：2中不等于有两种表示!=和&lt;&gt;,3中只有!=</span></p>\n\n<p><span style=\"color:#333333;\">     5.数据类型：3中不支持long类型了只有一种整形int</span> <span style=\"color:#333333;\">和2中的long差不多的操作</span></p>\n\n<p style=\"margin-left:36pt;\"> </p>\n\n<p><span style=\"color:#333333;\">11.用一行代码实现数值交换：</span><span style=\"color:#333333;\">a = 1 ,b = 2</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">(a, b) = (b, a)</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">12.Python3和Python2中 int 和 long的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython3中没有long类型只有int但是</span><span style=\"color:#333333;\">3</span><span style=\"color:#333333;\">中的int操作包含2中的long操作。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">13.xrange和range的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">R</span><span style=\"color:#333333;\">ange([start,]stop</span><span style=\"color:#333333;\">[,step])</span><span style=\"color:#333333;\">更具指定的范围和步长生成一个序列。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Xrange()和range操作一样，不同的是它返回的是一个生成器。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">例如当我们使用range(10)的时候返回的是一个[0,1,2,3,4,5,6,7,8,9]的列表。而xrange(10)不会返回一个列表，而是每次调用的时候返回其中的值。这样在生成一个很大的操作的时候xrange的性能会更好。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">14文件操作时：xreadlines和readlines的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">和上面的range和xrange一样的区别，readlines将文件中读取的数据读取出来生成一个列表存放着，而x</span><span style=\"color:#333333;\">readlines</span><span style=\"color:#333333;\">返回的是一个迭代器每次调用的时候返回下一个值。所以对于数据量比较大的时候使用迭代器的方法会更好一些。</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">15.列举布尔值为False的常见值？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">0、None、</span><span style=\"color:#333333;\">””、[]、{}</span></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">16.字符串、列表、元组、字典每个常用的5个方法？</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">字符串：isdigit()判断是否只包含数字 is</span><span style=\"color:#333333;\">lower()</span><span style=\"color:#333333;\">判断是否全为小写 is</span><span style=\"color:#333333;\">upper()</span><span style=\"color:#333333;\">判断是否全为大写  strip()去掉首尾空格  split()以指定字符切片</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">列表：append()在列表后面追加  count()统计次数  pop(</span><span style=\"color:#333333;\">index=-1</span><span style=\"color:#333333;\">)默认移除最后一个元素并返回 </span> <span style=\"color:#333333;\">sort()排序  reverse()反向列表中的元素 min</span><span style=\"color:#333333;\">()、</span><span style=\"color:#333333;\">max</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">返回最小最大值。</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">元组：cmp</span><span style=\"color:#333333;\">(tuple1,tuple2)</span><span style=\"color:#333333;\">比较两个元组元素  len</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">计算元组元素个数  max()返回最大值  min</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">返回最小值 tuple</span><span style=\"color:#333333;\">(list)</span><span style=\"color:#333333;\">将列表转为元组。</span></p>\n\n<p style=\"margin-left:5.9pt;\"><span style=\"color:#333333;\">字典：get</span><span style=\"color:#333333;\">(key,default=None)</span><span style=\"color:#333333;\">返回指定键的值，没有返回默认值  copy</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">返回一个字典的浅复制  update(</span><span style=\"color:#333333;\">dict2</span><span style=\"color:#333333;\">)将dict</span><span style=\"color:#333333;\">2</span><span style=\"color:#333333;\">更新到原字典中 </span> <span style=\"color:#333333;\">value()返回所有值 key</span><span style=\"color:#333333;\">s()</span><span style=\"color:#333333;\">返回所有键  pop</span><span style=\"color:#333333;\">(key)</span><span style=\"color:#333333;\">删除并返回指定的key的值</span><span style=\"color:#333333;\">   popitem()</span><span style=\"color:#333333;\">随机删除并返回一个键值对。</span></p>\n\n<p style=\"margin-left:5.9pt;\"> </p>\n\n<p><span style=\"color:#333333;\">17.lambda表达式格式以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">L</span><span style=\"color:#333333;\">ambda语句中冒号前面的为参数，可以有多个，用逗号隔开。冒号右边的为返回值，如：add</span><span style=\"color:#333333;\"> = lambda x, y : x + y </span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">   add(1,3) </span><span style=\"color:#333333;\">结果为</span><span style=\"color:#333333;\">4</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">L</span><span style=\"color:#ff0000;\">ambda表达式通常是在需要一个函数，但是又不想费神去命名一个函数的时候使用</span><span style=\"color:#ff0000;\">，</span><span style=\"color:#ff0000;\">通常应用在函数式编程中、闭包</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">18.pass的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ass是空语句，为了保持程序结构的完整性，不做任何操作，一般只用做占位语句。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">19.*arg</span><span style=\"color:#333333;\">s</span><span style=\"color:#333333;\">和**kwarg</span><span style=\"color:#333333;\">s</span><span style=\"color:#333333;\">作用</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">如果我们不确定往一个函数中传入多少参数，或者我们希望以元组tuple或者列表list的形式传参数的时候，我们可以使用*args。如果我们不知道往函数中传递多少个关键词参数或者想传入字典的值作为关键词参数的时候我们可以使用**kwargs，args、kwargs两个标识符是约定俗成的用法。另一种答法：当函数的参数前面有一个星号*号的时候表示这是一个可变的位置参数，两个星号**表示这个是一个可变的关键词参数。星号*把序列或者集合解包（unpack）成位置参数，两个星号**把字典解包成关键词参数。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">20.is和==的区别</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      is比较的是两个实例对象是不是完全相同的，他们是不是同一个对象，占用的内存地址是否相同。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">      ==</span><span style=\"color:#333333;\">比较的是两个对象的内容是否相等，内存地址可以不同，内容一样就可以了。</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">21.简述Python的深浅拷贝以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython的变量只存储了这个变量的内存地址，而不是值的本身，对于像list</span> <span style=\"color:#333333;\">set</span> <span style=\"color:#333333;\">dict这种复杂的数据结构来说里面存储的也仅仅是每个元素的地址而已</span><br /><img alt=\"\" class=\"has\" height=\"440\" src=\"https://img-blog.csdn.net/20180920142752928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"634\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">赋值：变量的每一次初始化都会在内存里面开辟一个新的空间，并将这个内存地址赋值给变量，例如：</span><br /><img alt=\"\" class=\"has\" height=\"101\" src=\"https://img-blog.csdn.net/20180920142812348?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"200\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">给str</span><span style=\"color:#333333;\">1</span><span style=\"color:#333333;\">两次赋值，两次的内存地址发生改变，第一次赋值hello的时候将hello在内存中的地址给了str</span><span style=\"color:#333333;\">1，</span><span style=\"color:#333333;\">第二次赋值world的时候再次将world的内存地址给了str</span><span style=\"color:#333333;\">1，</span><span style=\"color:#333333;\">但是此时hello并没有从内存中消失，只是现在没有变量指向他。当我们再次赋值的时候str1又指向了hello。</span><br /><img alt=\"\" class=\"has\" height=\"148\" src=\"https://img-blog.csdn.net/20180920142825292?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"177\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">深拷贝：</span><br /><img alt=\"\" class=\"has\" height=\"604\" src=\"https://img-blog.csdn.net/20180920142838291?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"687\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">深拷贝可以完全复制原变量的所有数据，我们修改其中一个的时候不会对复制的那份造成影响。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">浅拷贝：</span><br /><img alt=\"\" class=\"has\" height=\"467\" src=\"https://img-blog.csdn.net/20180920142855885?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"648\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">不管多么复杂的数据结构，浅拷贝只会copy一层。对于像int float str这种单一的数据是可以独立出来，但是对于更为复杂的数据结构就会出问题，因为在复制的时候只是将列表 字典等的整个的存放地址给复制过来了，并没有复制里面元素的内存地址，这样导致修改的时候会同时发生变化。例如：</span><br /><img alt=\"\" class=\"has\" height=\"287\" src=\"https://img-blog.csdn.net/20180920142907504?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"465\" /></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"199\" src=\"https://img-blog.csdn.net/20180920142913193?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"340\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">22.Python垃圾回收机制？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">P</span><span style=\"color:#333333;\">ython的垃圾回收机制默认的方式是引用计数法，其原理是为每一个对象维护一个ob</span><span style=\"color:#333333;\">_ref</span><span style=\"color:#333333;\">字段，用来记录该对象当前被引用的次数，有新的引用指向过来的时候计数加一，引用失效时计数减一，当对象的引用计数为0的时候，对象会被回收，释放内存空间。除了这个还有标记清除法和分代回收。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">23.Python的可变类型和不可变类型？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">数字、字符串、元组是不可变的，列表字典是可变的，对于不可变类型的变量重新赋值的时候实际上是重新创建一个新的对象，原变量指向新的对象内存地址，除浮点型变量之外，对于值相同的变量可能都会指向同一个内存地址。可变类型例如列表在新增一个元素的时候，变量还是指向原来的那个内存地址，只是其中的元素指向发生了改变。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">24.求结果：</span><br />\n <span style=\"color:#333333;\">  v = dict.fromkeys(['k1','k2'],[])</span>  <br /><span style=\"color:#333333;\">   v[‘k1’].append(666)</span><br />\n <span style=\"color:#333333;\">  print(v)</span> <br /><span style=\"color:#333333;\">   v[‘k1’] = 777</span><br />\n <span style=\"color:#333333;\">  print(v)</span></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>{'k1': [666], 'k2': [666]}</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>{'k1': 777, 'k2': [666]}</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>猜测原因是，在创建v这个字典的时候k1 k2 都指向了同一个空列表，当我们修改了这个列表的内容之后两个会同时发生改变，第二次单独修改k1的时候重新开辟了一个空间并指向新的内存地址。</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">25.求结果：</span><br /><img alt=\"\" class=\"has\" height=\"72\" src=\"https://img-blog.csdn.net/20180920143009219?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"298\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>[6, 6, 6, 6]</strong></span></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#333333;\"><strong>解释见：</strong></span></strong><a href=\"https://www.cnblogs.com/imhurley/p/3898289.html\"><strong><u><span style=\"color:#0563c1;\"><strong><u>https://www.cnblogs.com/imhurley/p/3898289.html</u></strong></span></u></strong></a></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">26.列举常见的内置函数？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">abs() </span><span style=\"color:#333333;\">绝对值  len()序列长度 divmod</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">取模 pow</span><span style=\"color:#333333;\">()</span><span style=\"color:#333333;\">乘方 round()浮点数</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">27.filter、map、reduce的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>fi</strong></span></strong><strong><span style=\"color:#333333;\"><strong>lter()函数：</strong></span></strong><span style=\"color:#333333;\">filter()函数接收两个参数，一个是bool函数，一个是序列，依次将序列中的每一个元素传入到bool函数中，返回值为非零的元素添加到新的列表中。</span><br /><img alt=\"\" class=\"has\" height=\"149\" src=\"https://img-blog.csdn.net/20180920143036526?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"331\" /></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>map()</strong></span></strong><strong><span style=\"color:#333333;\"><strong>函数</strong></span></strong><span style=\"color:#333333;\">：map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回</span><br /><img alt=\"\" class=\"has\" height=\"102\" src=\"https://img-blog.csdn.net/20180920143049468?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"289\" /></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\">reduce</span><span style=\"color:#333333;\">()</span></strong><span style=\"color:#333333;\"><strong>函数</strong>：三个参数，一个需要两个参数的函数，一个序列，一个初始值，执行顺序为：将序列中的第一个值和初始值进行func处理，然后将结果和序列第二个值处理直到结束。</span><br /><img alt=\"\" class=\"has\" height=\"97\" src=\"https://img-blog.csdn.net/20180920143109928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"287\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">28.一行代码实现9*9乘法表</span></p>\n\n<p style=\"margin-left:0pt;\"><strong><span style=\"color:#006699;\"><strong>      print</strong></span></strong> <span style=\"color:#0000ff;\">\"\\n\"</span><span style=\"color:#000000;\">.join(</span><span style=\"color:#0000ff;\">\"\\t\"</span><span style=\"color:#000000;\">.join([</span><span style=\"color:#0000ff;\">\"%s*%s=%s\"</span><span style=\"color:#000000;\"> %(x,y,x*y) </span><strong><span style=\"color:#006699;\"><strong>for</strong></span></strong><span style=\"color:#000000;\"> y </span><strong><span style=\"color:#006699;\"><strong>in</strong></span></strong><span style=\"color:#000000;\"> range(1, x+1)]) </span><strong><span style=\"color:#006699;\"><strong>for</strong></span></strong><span style=\"color:#000000;\"> x </span><strong><span style=\"color:#006699;\"><strong>in</strong></span></strong><span style=\"color:#000000;\"> range(1, 10))  </span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">29.re的match和search区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Match</span><span style=\"color:#333333;\">是从头开始匹配 search从任意位置匹配</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">30.什么是正则的贪婪匹配？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">贪婪匹配就死趋于最大长度的匹配</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">非贪婪匹配就是匹配到结果就好</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">31.def func(a,b=[]) 这种写法有什么坑？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">函数的第二个参数是一个list，当第一次执行的时候实例化了一个list，第二次执行的时候还是用的是第一次实例化的那个list</span></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"179\" src=\"https://img-blog.csdn.net/20180920143300580?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"243\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">32.如何实现 “1,2,3” 变成 [‘1’,’2’,’3’] ?</span></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"51\" src=\"https://img-blog.csdn.net/20180920143308681?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"185\" /></p>\n\n<ol><li><span style=\"color:#333333;\">如何实现[‘1’,’2’,’3’]变成[1,2,3] ?</span></li>\n</ol><p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"51\" src=\"https://img-blog.csdn.net/20180920143312837?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"241\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">34.比较： a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 </span><span style=\"color:#333333;\">c</span><span style=\"color:#333333;\"> = [(1,),(2,),(3,) ] 的区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">a是一个列表,其中的元素为整数</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">a和b</span> <span style=\"color:#333333;\">的内容一样但是在内存中的地址不同，也就是 a</span><span style=\"color:#333333;\">==b </span><span style=\"color:#333333;\">成立 a</span><span style=\"color:#333333;\"> is b </span><span style=\"color:#333333;\">不成立</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">c也是一个列表，只不过其中的元素为元组</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">35.如何用一行代码生成[1,4,9,16,25,36,49,64,81,100] ?</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">     1：list(map(lambda x:x*x ,[1,2,3,4,5,6,7,8,9,10]))</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">2：</span><span style=\"color:#333333;\">list</span><span style=\"color:#333333;\">(x*x for x in range(1,11))</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">36.一行代码实现删除列表中重复的值 ?</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">list1 = list(set(list1))</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">37.如何在函数中设置一个全局变量 ?</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">使用global声明变量</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">38.logging模块的作用？以及应用场景？</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">       l</span><span style=\"color:#333333;\">ogging模块是python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、保存路径、日志文件回滚等。可用于记录程序运行状态。</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">39.请用代码</span><span style=\"color:#333333;\">简单</span><span style=\"color:#333333;\">实现stack 。</span></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Stack(object):\n    # 初始化栈为空列表\n    def __init__(self):\n        self.items = []\n\n    # 判断栈是否为空，返回布尔值\n    def is_empty(self):\n        return self.items == []\n\n    # 返回栈顶元素\n    def peek(self):\n        return self.items[len(self.items) - 1]\n\n    # 返回栈的大小\n    def size(self):\n        return len(self.items)\n\n    # 进栈\n    def push(self, item):\n        self.items.append(item)\n\n    # 出栈\n    def pop(self, item):\n        return self.items.pop()</code></pre>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">40.常用字符串格式化哪几种？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">主要有两种 %</span> <span style=\"color:#333333;\">和format</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">示例1：</span><span style=\"color:#333333;\">”%s%d” %(‘hello’,1)</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">示例2：</span><span style=\"color:#333333;\">\"i am {} age {} sex:{}\".format('alex',38,'male')</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">             \"i am {1} age {1} sex:{2}\".format('alex',38,'male')</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">41.简述 生成器、迭代器、可迭代对象 以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>生成器：</strong></span></strong><span style=\"color:#333333;\">生成器其实是一种特殊的迭代器，生成器一定是迭代器反之不成立，不需要写__iter__()和__next__()方法，只需要一个yield关键字。<br />\n例如：斐波那契的例子</span></p>\n\n<pre class=\"has\">\n<code class=\"language-python\">def fib():\n    prev, curr = 0, 1\n    while True:\n        yield curr\n        prev, curr = curr, curr + prev\n\n&gt;&gt;&gt; f = fib()\n&gt;&gt;&gt; from itertools import islice\n&gt;&gt;&gt; list(islice(f, 0, 10))\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code></pre>\n\n<p style=\"margin-left:0pt;\">     <span style=\"color:#333333;\"><strong>生成器表达式</strong>：是列表推倒式的生成器版本，看起来像列表推导式，但是他返回的是一个生成器对象而不是列表对象 </span><br />\n    <img alt=\"\" class=\"has\" height=\"53\" src=\"https://img-blog.csdn.net/20180920143718651?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"330\" /></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>迭代器：</strong></span></strong><span style=\"color:#333333;\">可以被next调用并不断返回下一个值的对象称为迭代器，迭代器内部有一个状态，该状态用于记录当前迭代所在的位置，__iter__()返回迭代器本身，__next__()返回容器中的下一个值。</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>可迭代对象：</strong></span></strong><span style=\"color:#333333;\">但凡可以返回一个迭代器的对象都可以称之为可迭代对象，更为直观点可以使用for循环的对象，如列表，元组，字典，集合，字符串，打开的文件，socket等。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">42.用Python实现一个二分查找的函数。 <br />\n     </span><img alt=\"\" class=\"has\" height=\"247\" src=\"https://img-blog.csdn.net/20180920143746615?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"359\" /></p>\n\n<p> </p>\n\n<p><span style=\"color:#333333;\">43.谈谈你对闭包的理解？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">闭包就是在一个外部函数中定义一个内函数，内函数里运用了外部函数的临时变量，并且外函数的返回值是内函数的引用。如下是最简单的一个闭包：</span><br /><img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180920143854274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"246\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">在python中一切皆对象，小到一个变量，大到一个函数一个类都是对象，变量名，函数名类名都是指向内存地址。因此当返回值为一个函数的引用的时候可以跟括号来调用此函数。<br />\n一般来说，当一个函数结束的时候，会将临时变量释放掉，但是在闭包中，临时变量会在内部函数中用到，因此在返回内函数的时候会将临时变量和内函数绑定在一起，外函数结束后，在调用内函数的时候依然可以使用外函数的临时变量。每次在调用外函数的时候都会在内存中创建一个内函数，并且返回的是当前的内函数地址，需要知道的的是虽然内函数被重新创建了，但是外函数的临时变量只存在一份，每次创建的内函数都是使用的同一份临时变量。如下两次调用的返回值是不同的</span><br /><img alt=\"\" class=\"has\" height=\"133\" src=\"https://img-blog.csdn.net/2018092014391017?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"180\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Python中内函数想要修改外函数的临时变量可以使用nonlocal关键字来定义变量，如下：</span><br /><img alt=\"\" class=\"has\" height=\"209\" src=\"https://img-blog.csdn.net/20180920143921274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"216\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">闭包的应用：装饰器、单例模式</span></p>\n\n<p><span style=\"color:#333333;\">44.os和sys模块的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">os 模块提供了一种方便的使用操作系统函数的方法。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">sys模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">45.如何生成一个随机数？<br />\n     </span><img alt=\"\" class=\"has\" height=\"49\" src=\"https://img-blog.csdn.net/2018092014395514?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"204\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">46.如何使用python删除一个文件？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">o</span><span style=\"color:#333333;\">s</span><span style=\"color:#333333;\">.remove(file_path)</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">os.rmdir(dir_path)</span></p>\n\n<p><span style=\"color:#333333;\">47.面向对象深度优先和广度优先是什么？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">Python 中类的多继承分为深度优先和广度优先，新式类会按照深度优先方法查找，金典类会按照广度优先的方式查找。</span><br /><img alt=\"\" class=\"has\" height=\"266\" src=\"https://img-blog.csdn.net/20180920144033707?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"687\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">48.面向对象中super的作用？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">S</span><span style=\"color:#333333;\">uper(</span><span style=\"color:#333333;\">)</span><span style=\"color:#333333;\">可以保证公共的父类仅被执行一次。按照MRO的顺序执行</span><span style=\"color:#ff0000;\">原理待更新：</span></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p><span style=\"color:#333333;\">49.列举面向对象中带爽下划线的特殊方法，如：__new__、__init__</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__doc__  </span><span style=\"color:#333333;\">表示类的描述信息</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__module__ 表示当前操作的对象在那个模块</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__class__ 表示当前操作的对象的类是什么</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__init__  </span><span style=\"color:#333333;\">构造方法，通过类创建对象时，自动触发执行</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__del__ 析构方法，当对象在内存中被释放的时候，自动触发执行</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">_</span><span style=\"color:#333333;\">_call__ </span><span style=\"color:#333333;\">对象后面加括号，触发执行</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">_</span><span style=\"color:#333333;\">_dict__ </span><span style=\"color:#333333;\">类或对象中的所有成员</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__str__ </span><span style=\"color:#333333;\">如果一个类中定义了这个方法那么在打印对象的时候默认输出该方法的返回值</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__getitem__、__setitem__、__delitem__ 用于索引操作，如字典。分别表示获取、设置、删除数据</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__getslice__、__setslice__、__delslice__分别用于切片操作，如列表</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">__iter__ </span><span style=\"color:#333333;\">用于迭代器</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">__new__</span><span style=\"color:#ff0000;\">和__metaclass__</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">50.如何判断是函数还是方法？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">根据__call__属性判断： if(hasattr(func,</span><span style=\"color:#ff0000;\">’__call__’)):</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">利用callable判断: if(callable(func)):</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#ff0000;\">利用isfunction判断：if</span><span style=\"color:#ff0000;\">(isfunction(add)):</span></p>\n\n<p><span style=\"color:#333333;\">51.静态方法和类方法区别？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">类方法必须有一个指向类对象的引用作为第一个参数，但是静态方法可以没有任何参数，</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">52.列举面向对象中的特殊成员以及应用场景</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">53.   1、2、3、4、5 能组成多少个互不相同且无重复的三位数</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">        A</span><span style=\"color:#333333;\">53 = </span><span style=\"color:#333333;\">60个</span></p>\n\n<p><span style=\"color:#333333;\">54. 什么是反射？以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">其实，反射就是通过字符串的形式，导入模块；通过字符串的形式去模块寻找指定的函数并执行。利用字符串的形式去对象（模块）中操作（查找、获取、删除、添加）成员，是一种基于字符串的事件驱动。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">g</span><span style=\"color:#333333;\">etattr</span><span style=\"color:#333333;\">(</span><span style=\"color:#333333;\">object, name [,defaukt])函数是python内置函数，用于返回一个对象属性值,若不存在且为设置默认值则触发异常，如果设置了默认值则返回默认值。</span><br /><img alt=\"\" class=\"has\" height=\"229\" src=\"https://img-blog.csdn.net/20180920144219728?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"450\" /><br /><img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180920144237505?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"262\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">hasattr</span><span style=\"color:#333333;\">(object,name):</span><span style=\"color:#333333;\">判断对象object是否包含名为name的特性（hasattr是通过调用getattr()是否抛出异常来实现的）。如果有该属性则返回True否则返回False</span><br /><img alt=\"\" class=\"has\" height=\"162\" src=\"https://img-blog.csdn.net/20180920144248353?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"277\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">setattr</span><span style=\"color:#333333;\">(object, name, value):</span><span style=\"color:#333333;\">对应函数getattr(),用于设置属性值，或者增加某个属性。</span><br /><img alt=\"\" class=\"has\" height=\"131\" src=\"https://img-blog.csdn.net/20180920144301230?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"209\" /></p>\n\n<p style=\"margin-left:18pt;\"><img alt=\"\" class=\"has\" height=\"49\" src=\"https://img-blog.csdn.net/20180920144314576?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"231\" /><br /><img alt=\"\" class=\"has\" height=\"115\" src=\"https://img-blog.csdn.net/20180920144359561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"281\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">delattr</span><span style=\"color:#333333;\">(object, name):</span><span style=\"color:#333333;\">用于删除属性，操作类似不举示例了。</span></p>\n\n<p style=\"margin-left:18pt;\"><strong><span style=\"color:#333333;\"><strong>应用：</strong></span></strong><span style=\"color:#333333;\">实现一个简单的url路由器的功能，实现动态导入模块</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">55.metaclass作用？以及应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">M</span><span style=\"color:#333333;\">etaclass</span> <span style=\"color:#333333;\">的实例化结果是类。而class实例化结果是instance，metaclass是创建类的模版，所有的类都是通过他来创建的，这使得我们可以自由控制创建类的过程。实现自由的修改、增加、删除 类或者实例中的方法或者属性。可批量对某些方法使用装饰器，而不需要每次都在方法上面增加@decorator_func。</span><span style=\"color:#333333;\">等等</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">56.用尽量多的方法实现单例模式。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">单例模式的主要目的是确保某一个类只有一个实例存在，主要的实现方式有以下几种：</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">1：使用模块。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">2：使用装饰器。<br />\n      </span><img alt=\"\" class=\"has\" height=\"119\" src=\"https://img-blog.csdn.net/20180920144440324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"534\" /><br />\n      <img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180920144453324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"293\" /><br />\n      <img alt=\"\" class=\"has\" height=\"71\" src=\"https://img-blog.csdn.net/20180920144514219?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"173\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">3：基于__new__方法实现。<br />\n      在实例化一个类的时候，首先执行了类的__new__方法，然后执行__init__方法，</span><span style=\"color:#333333;\">在实例化的时候先检查有没有已经实例化过，如果有则返回已经实例化候的对象，否则创建新的。</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">     4：基于metaclass方法实现<br />\n        1.类由type创建，创建类时，type的__init__方法自动执行，类() 执行type的 __call__方法(类的__new__方法,类的__init__       方法)。<br />\n        2.对象由类创建，创建对象时，类的__init__方法自动执行，对象()执行类的 __call__ 方法。</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">57.装饰器的写法以及应用场景。</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">python的装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数和闭包一样，所以装饰器是闭包的一种应用，使用装饰器可以不用在更改原函数的前提下给函数增加新的功能，当有多个装饰器的时候从上到下依次执行。<br />\n装饰器的原理：和闭包类似<br />\n最简单的一个装饰器</span><br /><img alt=\"\" class=\"has\" height=\"227\" src=\"https://img-blog.csdn.net/2018092014463326?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"292\" /></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">主要用户一些认证功能，日志，授权</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">58.异常处理写法以及如何主动抛出异常（应用场景）<br />\n     </span><img alt=\"\" class=\"has\" height=\"116\" src=\"https://img-blog.csdn.net/20180920144704838?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"220\" /><br />\n     <img alt=\"\" class=\"has\" height=\"272\" src=\"https://img-blog.csdn.net/20180920144712593?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"412\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">59.什么是面向对象的mro</span></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">60.isinstance作用以及应用场景？<br />\n      用来判断一个对象是否是一个已知类型，类似type(),</span><span style=\"color:#333333;\">和type不同的是type()不会认为子类是一种父类类型，不考虑继承关系，而isinstance（）会认为子类是一种父类类型，会考虑继承关系。如果要判断两个类型是否相同的时候最好使用isinstance</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">61.写代码并实现：</span><br /><span style=\"color:#333333;\">       给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br />\n       你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</span><br /><span style=\"color:#333333;\">       Example:</span> <br />\n         <span style=\"color:#333333;\">       Given nums = [2, 7, 11, 15], target = 9,</span><br />\n                 <span style=\"color:#333333;\">Because nums[0] + nums[1] = 2 + 7 = 9,</span> <br />\n                <span style=\"color:#333333;\">return [0, 1]   </span><br />\n       <img alt=\"\" class=\"has\" height=\"300\" src=\"https://img-blog.csdn.net/20180920144810113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"428\" /></p>\n\n<p><span style=\"color:#333333;\">62.json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？</span></p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#333333;\">       可处理的数据类型有:字符串、列表、元组、字典、整数，不支持集合。定制支持datetime:首先写一个类：将用于判断是否         为datetime类型的数据格式，如果是则将其转换成字符串类型。再交给json处理。使用的时候指定cls参数即可。<br />\n       </span><img alt=\"\" class=\"has\" height=\"196\" src=\"https://img-blog.csdn.net/20180920144932516?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"588\" /></p>\n\n<p><span style=\"color:#333333;\">63.json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？<br />\n     </span><img alt=\"\" class=\"has\" height=\"51\" src=\"https://img-blog.csdn.net/20180920144955556?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"348\" /></p>\n\n<p style=\"margin-left:18pt;\"> </p>\n\n<p><span style=\"color:#333333;\">64.什么是断言？应用场景？</span></p>\n\n<p style=\"margin-left:18pt;\"><span style=\"color:#333333;\">assert断言用来检查一个条件，如果为真那么不做任何事，如果错误则会抛出AssertionError错误并且包含错误信息，应用场景：程序常量，检查逻辑，检查文，档检查约定</span><span style=\"color:#333333;\">。</span><span style=\"color:#333333;\">格式为 assert</span> <span style=\"color:#333333;\">语句, 报错输出</span><br /><img alt=\"\" class=\"has\" height=\"85\" src=\"https://img-blog.csdn.net/20180920145015421?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"370\" /></p>"},{"_content":"<p>88.合并两个有序数组     56ms  提交中击败了47.05% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: void Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        for i in range(n):\n            temp = nums2[i]\n            j = m-1\n            while j &gt;=0 and nums1[j] &gt; temp:\n                nums1[j+1] = nums1[j]\n                j -= 1\n            nums1[j+1] = temp\n            m += 1</code></pre>\n\n<p>100. 相同的树   48 ms 击败了58.92% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        if p and q and p.val == q.val:\n            left = self.isSameTree(p.left,q.left)\n            right = self.isSameTree(p.right,q.right)\n            return left and right\n        else:\n            return False</code></pre>\n\n<p>101. 对称二叉树   56 ms 击败了81.40% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def isSame(left,right):\n            if not left:\n                return right == None\n            if not right:\n                return left == None\n            if left.val == right.val:\n                return isSame(left.left,right.right) and isSame(left.right,right.left)\n            else:\n                return False\n        if not root:\n            return True\n        return isSame(root.left, root.right)</code></pre>\n\n<p>104. 二叉树的最大深度 : 64 ms 击败了79.70% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"         \n        if not root:\n            return 0\n        left =  self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        return 1 + max(left,right)</code></pre>\n\n<p> </p>","source":"_posts/blogs-Leet Code OJ 简单（四）.md","raw":"<p>88.合并两个有序数组     56ms  提交中击败了47.05% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: void Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        for i in range(n):\n            temp = nums2[i]\n            j = m-1\n            while j &gt;=0 and nums1[j] &gt; temp:\n                nums1[j+1] = nums1[j]\n                j -= 1\n            nums1[j+1] = temp\n            m += 1</code></pre>\n\n<p>100. 相同的树   48 ms 击败了58.92% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        if p and q and p.val == q.val:\n            left = self.isSameTree(p.left,q.left)\n            right = self.isSameTree(p.right,q.right)\n            return left and right\n        else:\n            return False</code></pre>\n\n<p>101. 对称二叉树   56 ms 击败了81.40% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def isSame(left,right):\n            if not left:\n                return right == None\n            if not right:\n                return left == None\n            if left.val == right.val:\n                return isSame(left.left,right.right) and isSame(left.right,right.left)\n            else:\n                return False\n        if not root:\n            return True\n        return isSame(root.left, root.right)</code></pre>\n\n<p>104. 二叉树的最大深度 : 64 ms 击败了79.70% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"         \n        if not root:\n            return 0\n        left =  self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        return 1 + max(left,right)</code></pre>\n\n<p> </p>","slug":"blogs-Leet Code OJ 简单（四）","published":1,"date":"2022-03-16T17:00:58.000Z","updated":"2022-03-16T17:05:47.439Z","_id":"cl0v6kevf001fyms45jaafwc1","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>88.合并两个有序数组     56ms  提交中击败了47.05% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: void Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        for i in range(n):\n            temp = nums2[i]\n            j = m-1\n            while j &gt;=0 and nums1[j] &gt; temp:\n                nums1[j+1] = nums1[j]\n                j -= 1\n            nums1[j+1] = temp\n            m += 1</code></pre>\n\n<p>100. 相同的树   48 ms 击败了58.92% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        if p and q and p.val == q.val:\n            left = self.isSameTree(p.left,q.left)\n            right = self.isSameTree(p.right,q.right)\n            return left and right\n        else:\n            return False</code></pre>\n\n<p>101. 对称二叉树   56 ms 击败了81.40% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def isSame(left,right):\n            if not left:\n                return right == None\n            if not right:\n                return left == None\n            if left.val == right.val:\n                return isSame(left.left,right.right) and isSame(left.right,right.left)\n            else:\n                return False\n        if not root:\n            return True\n        return isSame(root.left, root.right)</code></pre>\n\n<p>104. 二叉树的最大深度 : 64 ms 击败了79.70% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"         \n        if not root:\n            return 0\n        left =  self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        return 1 + max(left,right)</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<p>88.合并两个有序数组     56ms  提交中击败了47.05% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: void Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        for i in range(n):\n            temp = nums2[i]\n            j = m-1\n            while j &gt;=0 and nums1[j] &gt; temp:\n                nums1[j+1] = nums1[j]\n                j -= 1\n            nums1[j+1] = temp\n            m += 1</code></pre>\n\n<p>100. 相同的树   48 ms 击败了58.92% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        if p and q and p.val == q.val:\n            left = self.isSameTree(p.left,q.left)\n            right = self.isSameTree(p.right,q.right)\n            return left and right\n        else:\n            return False</code></pre>\n\n<p>101. 对称二叉树   56 ms 击败了81.40% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        def isSame(left,right):\n            if not left:\n                return right == None\n            if not right:\n                return left == None\n            if left.val == right.val:\n                return isSame(left.left,right.right) and isSame(left.right,right.left)\n            else:\n                return False\n        if not root:\n            return True\n        return isSame(root.left, root.right)</code></pre>\n\n<p>104. 二叉树的最大深度 : 64 ms 击败了79.70% 的用户</p>\n\n<pre class=\"has\">\n<code class=\"language-python\"># Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"         \n        if not root:\n            return 0\n        left =  self.maxDepth(root.left)\n        right = self.maxDepth(root.right)\n        return 1 + max(left,right)</code></pre>\n\n<p> </p>"},{"_content":"<p>58.最后一个单词的长度  52ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        s = s.split(' ')\n        while \"\" in s:\n            s.remove(\"\")\n        if not s:\n            return 0\n        return len(s[-1])</code></pre>\n\n<p>66.加一 56ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        sum = 0\n        r = []\n        for index, i in enumerate(digits):\n            sum += i*pow(10,len(digits)-index-1)\n        sum += 1\n        while sum:\n            i = 1\n            r.append(sum % pow(10,i))\n            sum = sum // pow(10,i)\n            i += 1\n\n        r.reverse()\n        return r</code></pre>\n\n<p>67.二进制求和 60ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        return (bin(int(a, 2) + int(b, 2))[2:])</code></pre>\n\n<p>69.x的平方根 76ms    击败了81.06% 的用户</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        return int(pow(x, 0.5))</code></pre>\n\n<p>83.删除排序链表重复元素  76ms  击败了48.84% 的用户</p>\n\n<pre class=\"has\">\n<code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        cur = head\n        while cur.next:\n            if cur.val == cur.next.val:\n                if cur.next.next:\n                    t = cur.next.next\n                    cur.next = t\n                else:\n                    cur.next = None\n            else:\n                cur = cur.next\n        return head</code></pre>\n\n<p> </p>","source":"_posts/blogs-Leet Code OJ 简单（三）.md","raw":"<p>58.最后一个单词的长度  52ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        s = s.split(' ')\n        while \"\" in s:\n            s.remove(\"\")\n        if not s:\n            return 0\n        return len(s[-1])</code></pre>\n\n<p>66.加一 56ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        sum = 0\n        r = []\n        for index, i in enumerate(digits):\n            sum += i*pow(10,len(digits)-index-1)\n        sum += 1\n        while sum:\n            i = 1\n            r.append(sum % pow(10,i))\n            sum = sum // pow(10,i)\n            i += 1\n\n        r.reverse()\n        return r</code></pre>\n\n<p>67.二进制求和 60ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        return (bin(int(a, 2) + int(b, 2))[2:])</code></pre>\n\n<p>69.x的平方根 76ms    击败了81.06% 的用户</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        return int(pow(x, 0.5))</code></pre>\n\n<p>83.删除排序链表重复元素  76ms  击败了48.84% 的用户</p>\n\n<pre class=\"has\">\n<code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        cur = head\n        while cur.next:\n            if cur.val == cur.next.val:\n                if cur.next.next:\n                    t = cur.next.next\n                    cur.next = t\n                else:\n                    cur.next = None\n            else:\n                cur = cur.next\n        return head</code></pre>\n\n<p> </p>","slug":"blogs-Leet Code OJ 简单（三）","published":1,"date":"2022-03-16T17:01:19.519Z","updated":"2022-03-16T17:06:09.267Z","_id":"cl0v6kevj001gyms413ite4o5","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>58.最后一个单词的长度  52ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        s = s.split(' ')\n        while \"\" in s:\n            s.remove(\"\")\n        if not s:\n            return 0\n        return len(s[-1])</code></pre>\n\n<p>66.加一 56ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        sum = 0\n        r = []\n        for index, i in enumerate(digits):\n            sum += i*pow(10,len(digits)-index-1)\n        sum += 1\n        while sum:\n            i = 1\n            r.append(sum % pow(10,i))\n            sum = sum // pow(10,i)\n            i += 1\n\n        r.reverse()\n        return r</code></pre>\n\n<p>67.二进制求和 60ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        return (bin(int(a, 2) + int(b, 2))[2:])</code></pre>\n\n<p>69.x的平方根 76ms    击败了81.06% 的用户</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        return int(pow(x, 0.5))</code></pre>\n\n<p>83.删除排序链表重复元素  76ms  击败了48.84% 的用户</p>\n\n<pre class=\"has\">\n<code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        cur = head\n        while cur.next:\n            if cur.val == cur.next.val:\n                if cur.next.next:\n                    t = cur.next.next\n                    cur.next = t\n                else:\n                    cur.next = None\n            else:\n                cur = cur.next\n        return head</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<p>58.最后一个单词的长度  52ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        s = s.split(' ')\n        while \"\" in s:\n            s.remove(\"\")\n        if not s:\n            return 0\n        return len(s[-1])</code></pre>\n\n<p>66.加一 56ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        sum = 0\n        r = []\n        for index, i in enumerate(digits):\n            sum += i*pow(10,len(digits)-index-1)\n        sum += 1\n        while sum:\n            i = 1\n            r.append(sum % pow(10,i))\n            sum = sum // pow(10,i)\n            i += 1\n\n        r.reverse()\n        return r</code></pre>\n\n<p>67.二进制求和 60ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        return (bin(int(a, 2) + int(b, 2))[2:])</code></pre>\n\n<p>69.x的平方根 76ms    击败了81.06% 的用户</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        return int(pow(x, 0.5))</code></pre>\n\n<p>83.删除排序链表重复元素  76ms  击败了48.84% 的用户</p>\n\n<pre class=\"has\">\n<code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        cur = head\n        while cur.next:\n            if cur.val == cur.next.val:\n                if cur.next.next:\n                    t = cur.next.next\n                    cur.next = t\n                else:\n                    cur.next = None\n            else:\n                cur = cur.next\n        return head</code></pre>\n\n<p> </p>"},{"_content":"<p>20. 有效括号  48ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) % 2 :\n            return False\n        brackets = {'(': ')', '{': '}', '[': ']'}\n        stack = []\n        for i in s:\n            if i in brackets:\n                stack.append(i)\n            else:\n                if not stack or brackets[stack.pop()] != i:\n                    return False\n        if stack:\n            return False\n        return True</code></pre>\n\n<p>26.删除排序数组中的重复项  96ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) &lt;= 1:\n            return len(nums)\n        s = 0\n        for f in range(1, len(nums)):\n            if nums[s] != nums[f]:\n                s += 1\n                nums[s] = nums[f]\n        return s + 1</code></pre>\n\n<p>27.移除元素  56ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        if val not in nums:\n            return len(nums)\n        while val in nums:\n            nums.remove(val)\n        return len(nums)</code></pre>\n\n<p>28.实现strStr()  48ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if not needle:\n            return 0\n        if needle not in haystack:\n            return -1\n        else:\n            return haystack.index(needle)</code></pre>\n\n<p>35.搜索插入位置  48ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target in nums:\n            return nums.index(target)\n        if target &lt; nums[0]:\n            return 0\n        if target &gt; nums[-1]:\n            return len(nums)\n        for i in range(len(nums)-1):\n            if nums[i]&lt;target and nums[i+1]&gt;target:\n                return i+1</code></pre>\n\n<p> </p>","source":"_posts/blogs-Leet Code OJ 简单（二）.md","raw":"<p>20. 有效括号  48ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) % 2 :\n            return False\n        brackets = {'(': ')', '{': '}', '[': ']'}\n        stack = []\n        for i in s:\n            if i in brackets:\n                stack.append(i)\n            else:\n                if not stack or brackets[stack.pop()] != i:\n                    return False\n        if stack:\n            return False\n        return True</code></pre>\n\n<p>26.删除排序数组中的重复项  96ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) &lt;= 1:\n            return len(nums)\n        s = 0\n        for f in range(1, len(nums)):\n            if nums[s] != nums[f]:\n                s += 1\n                nums[s] = nums[f]\n        return s + 1</code></pre>\n\n<p>27.移除元素  56ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        if val not in nums:\n            return len(nums)\n        while val in nums:\n            nums.remove(val)\n        return len(nums)</code></pre>\n\n<p>28.实现strStr()  48ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if not needle:\n            return 0\n        if needle not in haystack:\n            return -1\n        else:\n            return haystack.index(needle)</code></pre>\n\n<p>35.搜索插入位置  48ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target in nums:\n            return nums.index(target)\n        if target &lt; nums[0]:\n            return 0\n        if target &gt; nums[-1]:\n            return len(nums)\n        for i in range(len(nums)-1):\n            if nums[i]&lt;target and nums[i+1]&gt;target:\n                return i+1</code></pre>\n\n<p> </p>","slug":"blogs-Leet Code OJ 简单（二）","published":1,"date":"2022-03-16T17:01:20.761Z","updated":"2022-03-16T17:06:10.473Z","_id":"cl0v6kevk001hyms483o10uwl","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>20. 有效括号  48ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) % 2 :\n            return False\n        brackets = &#123;'(': ')', '&#123;': '&#125;', '[': ']'&#125;\n        stack = []\n        for i in s:\n            if i in brackets:\n                stack.append(i)\n            else:\n                if not stack or brackets[stack.pop()] != i:\n                    return False\n        if stack:\n            return False\n        return True</code></pre>\n\n<p>26.删除排序数组中的重复项  96ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) &lt;= 1:\n            return len(nums)\n        s = 0\n        for f in range(1, len(nums)):\n            if nums[s] != nums[f]:\n                s += 1\n                nums[s] = nums[f]\n        return s + 1</code></pre>\n\n<p>27.移除元素  56ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        if val not in nums:\n            return len(nums)\n        while val in nums:\n            nums.remove(val)\n        return len(nums)</code></pre>\n\n<p>28.实现strStr()  48ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if not needle:\n            return 0\n        if needle not in haystack:\n            return -1\n        else:\n            return haystack.index(needle)</code></pre>\n\n<p>35.搜索插入位置  48ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target in nums:\n            return nums.index(target)\n        if target &lt; nums[0]:\n            return 0\n        if target &gt; nums[-1]:\n            return len(nums)\n        for i in range(len(nums)-1):\n            if nums[i]&lt;target and nums[i+1]&gt;target:\n                return i+1</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<p>20. 有效括号  48ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        if len(s) % 2 :\n            return False\n        brackets = &#123;'(': ')', '&#123;': '&#125;', '[': ']'&#125;\n        stack = []\n        for i in s:\n            if i in brackets:\n                stack.append(i)\n            else:\n                if not stack or brackets[stack.pop()] != i:\n                    return False\n        if stack:\n            return False\n        return True</code></pre>\n\n<p>26.删除排序数组中的重复项  96ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) &lt;= 1:\n            return len(nums)\n        s = 0\n        for f in range(1, len(nums)):\n            if nums[s] != nums[f]:\n                s += 1\n                nums[s] = nums[f]\n        return s + 1</code></pre>\n\n<p>27.移除元素  56ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        if val not in nums:\n            return len(nums)\n        while val in nums:\n            nums.remove(val)\n        return len(nums)</code></pre>\n\n<p>28.实现strStr()  48ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if not needle:\n            return 0\n        if needle not in haystack:\n            return -1\n        else:\n            return haystack.index(needle)</code></pre>\n\n<p>35.搜索插入位置  48ms</p>\n\n<pre class=\"has\">\n<code>class Solution:\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if target in nums:\n            return nums.index(target)\n        if target &lt; nums[0]:\n            return 0\n        if target &gt; nums[-1]:\n            return len(nums)\n        for i in range(len(nums)-1):\n            if nums[i]&lt;target and nums[i+1]&gt;target:\n                return i+1</code></pre>\n\n<p> </p>"},{"_content":"<p>1.两数之和  3780ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for i in range(len(nums)):\n            for m in range(i+1, len(nums)):\n                if nums[i]+nums[m] == target:\n                    return [i, m]</code></pre>\n\n<p>7.反转整数 80ms （python的负数取余和C语言 不同）</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        y = 0\n        while x:\n            if x &gt; 0:\n                y *= 10\n                y += x % 10\n                x = x // 10\n            else:\n                y *= 10\n                if x % 10:\n                    y += x % 10 - 10\n                    x = x // 10 + 1\n                else:\n                    y += x % 10\n                    x = x // 10\n\n        if y &gt; -pow(2, 31) and y &lt; pow(2, 31) - 1:\n            return y\n        else:\n            return 0</code></pre>\n\n<p>9.回文数  408ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        x = str(x)\n        for i in range(len(x)):\n            if x[i] != x[-i-1]:\n                return False\n        return True</code></pre>\n\n<p>13.罗马数字转整数 212ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        rec = 0\n        num = {'I': 1, 'IV': 4, 'V': 5, 'IX': 9, 'X': 10, 'XL': 40, 'L': 50, 'XC': 90, 'C': 100, 'CD': 400, 'D': 500, 'CM': 900, 'M': 1000}\n        while s:\n            for i in range(2, 0, -1):\n                if s[:i] in num:\n                    rec += num[s[:i]]\n                    s = s[i:]\n                    break\n        return rec  </code></pre>\n\n<p>14.最长公共前缀 54ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if strs:\n            for i in range(len(strs[0])+1):\n                for s in range(1, len(strs)):\n                    if strs[0][:i] != strs[s][:i]:\n                        if strs[0][:i - 1]:\n                            return strs[0][:i-1]\n                        else:\n                            return \"\"\n            return strs[0]\n\n        else:\n            return \"\"</code></pre>\n\n<p> </p>","source":"_posts/blogs-Leet Code OJ  简单（一）.md","raw":"<p>1.两数之和  3780ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for i in range(len(nums)):\n            for m in range(i+1, len(nums)):\n                if nums[i]+nums[m] == target:\n                    return [i, m]</code></pre>\n\n<p>7.反转整数 80ms （python的负数取余和C语言 不同）</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        y = 0\n        while x:\n            if x &gt; 0:\n                y *= 10\n                y += x % 10\n                x = x // 10\n            else:\n                y *= 10\n                if x % 10:\n                    y += x % 10 - 10\n                    x = x // 10 + 1\n                else:\n                    y += x % 10\n                    x = x // 10\n\n        if y &gt; -pow(2, 31) and y &lt; pow(2, 31) - 1:\n            return y\n        else:\n            return 0</code></pre>\n\n<p>9.回文数  408ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        x = str(x)\n        for i in range(len(x)):\n            if x[i] != x[-i-1]:\n                return False\n        return True</code></pre>\n\n<p>13.罗马数字转整数 212ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        rec = 0\n        num = {'I': 1, 'IV': 4, 'V': 5, 'IX': 9, 'X': 10, 'XL': 40, 'L': 50, 'XC': 90, 'C': 100, 'CD': 400, 'D': 500, 'CM': 900, 'M': 1000}\n        while s:\n            for i in range(2, 0, -1):\n                if s[:i] in num:\n                    rec += num[s[:i]]\n                    s = s[i:]\n                    break\n        return rec  </code></pre>\n\n<p>14.最长公共前缀 54ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if strs:\n            for i in range(len(strs[0])+1):\n                for s in range(1, len(strs)):\n                    if strs[0][:i] != strs[s][:i]:\n                        if strs[0][:i - 1]:\n                            return strs[0][:i-1]\n                        else:\n                            return \"\"\n            return strs[0]\n\n        else:\n            return \"\"</code></pre>\n\n<p> </p>","slug":"blogs-Leet Code OJ  简单（一）","published":1,"date":"2022-03-16T17:01:22.009Z","updated":"2022-03-16T17:06:11.697Z","_id":"cl0v6kevl001iyms4b1cifwl4","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>1.两数之和  3780ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for i in range(len(nums)):\n            for m in range(i+1, len(nums)):\n                if nums[i]+nums[m] == target:\n                    return [i, m]</code></pre>\n\n<p>7.反转整数 80ms （python的负数取余和C语言 不同）</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        y = 0\n        while x:\n            if x &gt; 0:\n                y *= 10\n                y += x % 10\n                x = x // 10\n            else:\n                y *= 10\n                if x % 10:\n                    y += x % 10 - 10\n                    x = x // 10 + 1\n                else:\n                    y += x % 10\n                    x = x // 10\n\n        if y &gt; -pow(2, 31) and y &lt; pow(2, 31) - 1:\n            return y\n        else:\n            return 0</code></pre>\n\n<p>9.回文数  408ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        x = str(x)\n        for i in range(len(x)):\n            if x[i] != x[-i-1]:\n                return False\n        return True</code></pre>\n\n<p>13.罗马数字转整数 212ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        rec = 0\n        num = &#123;'I': 1, 'IV': 4, 'V': 5, 'IX': 9, 'X': 10, 'XL': 40, 'L': 50, 'XC': 90, 'C': 100, 'CD': 400, 'D': 500, 'CM': 900, 'M': 1000&#125;\n        while s:\n            for i in range(2, 0, -1):\n                if s[:i] in num:\n                    rec += num[s[:i]]\n                    s = s[i:]\n                    break\n        return rec  </code></pre>\n\n<p>14.最长公共前缀 54ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if strs:\n            for i in range(len(strs[0])+1):\n                for s in range(1, len(strs)):\n                    if strs[0][:i] != strs[s][:i]:\n                        if strs[0][:i - 1]:\n                            return strs[0][:i-1]\n                        else:\n                            return \"\"\n            return strs[0]\n\n        else:\n            return \"\"</code></pre>\n\n<p> </p>","site":{"data":{}},"excerpt":"","more":"<p>1.两数之和  3780ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for i in range(len(nums)):\n            for m in range(i+1, len(nums)):\n                if nums[i]+nums[m] == target:\n                    return [i, m]</code></pre>\n\n<p>7.反转整数 80ms （python的负数取余和C语言 不同）</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        y = 0\n        while x:\n            if x &gt; 0:\n                y *= 10\n                y += x % 10\n                x = x // 10\n            else:\n                y *= 10\n                if x % 10:\n                    y += x % 10 - 10\n                    x = x // 10 + 1\n                else:\n                    y += x % 10\n                    x = x // 10\n\n        if y &gt; -pow(2, 31) and y &lt; pow(2, 31) - 1:\n            return y\n        else:\n            return 0</code></pre>\n\n<p>9.回文数  408ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        x = str(x)\n        for i in range(len(x)):\n            if x[i] != x[-i-1]:\n                return False\n        return True</code></pre>\n\n<p>13.罗马数字转整数 212ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        rec = 0\n        num = &#123;'I': 1, 'IV': 4, 'V': 5, 'IX': 9, 'X': 10, 'XL': 40, 'L': 50, 'XC': 90, 'C': 100, 'CD': 400, 'D': 500, 'CM': 900, 'M': 1000&#125;\n        while s:\n            for i in range(2, 0, -1):\n                if s[:i] in num:\n                    rec += num[s[:i]]\n                    s = s[i:]\n                    break\n        return rec  </code></pre>\n\n<p>14.最长公共前缀 54ms</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Solution:\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if strs:\n            for i in range(len(strs[0])+1):\n                for s in range(1, len(strs)):\n                    if strs[0][:i] != strs[s][:i]:\n                        if strs[0][:i - 1]:\n                            return strs[0][:i-1]\n                        else:\n                            return \"\"\n            return strs[0]\n\n        else:\n            return \"\"</code></pre>\n\n<p> </p>"},{"_content":"<p style=\"margin-left:0pt;\"><strong><strong>显示所有数据库：</strong></strong>show databases;<br /><img alt=\"\" class=\"has\" height=\"176\" src=\"https://img-blog.csdn.net/20180818091228226?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"260\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>新建数据库：</strong></strong>create database dbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除数据库：</strong></strong>drop database dbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>切换数据库：</strong></strong>use dbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>新建表：</strong></strong>create table tbname(clo1 type ,col2 type,……);<br /><img alt=\"\" class=\"has\" height=\"158\" src=\"https://img-blog.csdn.net/20180818091257226?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"350\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>显示所有表：</strong></strong>show tables;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>根据已有表结构创建新表：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\">create table new_table_name like old_table_name;</p>\n\n<p style=\"margin-left:0pt;\">create table new_table as select col1,col2,…. from old_table only;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>显示表结构：</strong></strong>describe table_name;<br /><img alt=\"\" class=\"has\" height=\"119\" src=\"https://img-blog.csdn.net/20180818091433792?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"412\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除表：</strong></strong>drop table table_name;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增加一列：</strong></strong>alter table tbname add column col type;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除一列：</strong></strong>alter table tbname drop column name;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>修改列属性:</strong></strong>alter table tbname modify col typr;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增加主键：</strong></strong>alter table tbname add primary key (col);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除主键：</strong></strong>alter table tbname drop primary key(col);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>修改表名：</strong></strong>alter table tbname rename new;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>创建索引：</strong></strong>create index idxname on tbname (col,….);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除索引：</strong></strong>drop index idxname on tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>查看索引：</strong></strong>show index from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>创建视图：</strong></strong>create view name as select (col,….) from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除视图：</strong></strong>drop view name;</p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增删改查：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增：</strong></strong>insert into tbname (col,col,…) values(value1,value2,…);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删：</strong></strong>delete from tbname where 条件;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>改：</strong></strong>update tbname set field=value where条件;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>查：</strong></strong>select filed from tbname where 条件;</p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>求和：</strong></strong>select sum(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>平均：</strong></strong>select avg(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>最大：</strong></strong>select max(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>最小：</strong></strong>select min(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>外键定义：</strong></strong>外键是指引用另一个表中的一列或者多列，被引用的列应该具有主键约束或者唯一约束，外键用于建立和加强两个表数据之间的连接，被引用的表是主表，引用外键的表是从表。</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>多表操作：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>建立外键：</strong></strong>alter table tbname add constraint 外键名 froeign key(外键字段名) references 外表表名(主键字段名);</p>\n\n<p style=\"margin-left:0pt;\">示例：alter table student add constraint fk_id foreign key(gid) references grade(id);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除外键：</strong></strong>alter table tbname drop foreign key 外键名;</p>\n\n<p style=\"margin-left:0pt;\">示例：alter table student drop foreign key fk_id;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>添加数据：</strong></strong>当有外键的表添加数据的时候其字段值只能是被关联表中已有的数据，例如grade中id字段只有1和2，那么student中的gid值只能设为1和2.</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除数据：</strong></strong>因为grade表和student表具有关联关系，参照列中的被参照值是不能被删除的，所以想删除grade表中的数据必须先将student中关联数据都删除掉后再删除grade中的数据。</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>连接查询：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\">首先建立两个表：</p>\n\n<p style=\"margin-left:0pt;\">表1：create table department (did int not null primary key, dname varchar(32));</p>\n\n<p style=\"margin-left:0pt;\">表2：create table employee(id int not null primary key, name varchar(32), age int, did int not null);</p>\n\n<p style=\"margin-left:0pt;\">插入数据</p>\n\n<p style=\"margin-left:0pt;\">insert into department(did,dname)VALUES (1,'网络部'),(2,'媒体部'),(3,'研发部'),(5,'人事部');</p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#000000;\">I</span><span style=\"color:#000000;\">nsert into</span><span style=\"color:#000000;\"> employee(id,name,age,did)</span> <span style=\"color:#000000;\">VALUES (1,'王红',20,1),(2,'李强',22,1),(3,'赵四',20,2),(4,'郝娟',20,4);</span></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>交叉连接：</strong></strong>交叉连接返回的结果是两个连接表中所有数据的笛卡尔集，即返回第一个表中符合条件的数据乘以第二个表中符合条件的数据。</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname1 cross join tbname2;</p>\n\n<p style=\"margin-left:0pt;\">例如：select * from department cross join employee;</p>\n\n<p style=\"margin-left:0pt;\">返回结果为：有16行（4*4）</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>内连接：</strong></strong>使用比较运算符对两个表中的数据进行比较，并列出与连接条件匹配的数据</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname1 [inner] join tbname2 on tbname1.关系字段=tbname2.关系字段;</p>\n\n<p style=\"margin-left:0pt;\">例如 select name from employee join department on employee.did=department.did;</p>\n\n<p style=\"margin-left:0pt;\">返回结果为：3行（did为1，2，3的数据）<br /><img alt=\"\" class=\"has\" height=\"109\" src=\"https://img-blog.csdn.net/20180818091518909?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"123\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>自连接：</strong></strong>如果在一个连接查询中涉及的两个表其实是同一个表，这种查询称为自连接查询</p>\n\n<p style=\"margin-left:0pt;\">语句：select p1.* from tbname as p1 join tbname as p2 on p1.字段 = p2.字段;</p>\n\n<p style=\"margin-left:0pt;\">示例：查询 name为王红的人所属部门员工</p>\n\n<p style=\"margin-left:0pt;\">select p1.* from employee as p1 join employee as p2 on p1.did = p2.did where p2.name = ‘王红’;</p>\n\n<p style=\"margin-left:0pt;\">返回结果为：2行（网络部的两个：王红和李强）<br /><img alt=\"\" class=\"has\" height=\"114\" src=\"https://img-blog.csdn.net/20180818091540331?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"229\" /></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>外连接：</strong></strong>外连接分为左连接和右连接，当返回的查询结果不仅需要包括符合条件的数据，还需要包含其中的一个表或者两个表的所有数据的时候，需要用到外连接查询</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname1 left|right [outer] join tbname2;</p>\n\n<p style=\"margin-left:0pt;\">左连接：left join：返回包括左表中的所有记录和右表中符合条件的记录。</p>\n\n<p style=\"margin-left:0pt;\">例如：select department.dname,employee.name from department left join employee on department.did = employee.did;</p>\n\n<p style=\"margin-left:0pt;\"><img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180818091604776?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"157\" /></p>\n\n<p style=\"margin-left:0pt;\">右连接：right join：返回包括右表的所有记录和左表符合条件的记录。</p>\n\n<p style=\"margin-left:0pt;\">例如：select department.dname,employee.name from department right join employee on department.did = employee.did;</p>\n\n<p style=\"margin-left:0pt;\"><img alt=\"\" class=\"has\" height=\"123\" src=\"https://img-blog.csdn.net/20180818091619299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"155\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>子查询：</strong></strong>指一个查询语句嵌套在另一个查询语句内部的查询，在执行的时候会先执行子查询中的语句，然后将返回的结果作为外层查询的过滤条件。<strong><strong>需要注意的是第一个条件的判断字段要包含在第二个查询语句的字段中，否则报错。</strong></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>IN/NOT IN语句</em></strong></em></strong>：select 字段from tbname where 条件 in /not in (select 字段 where 条件)  </p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>EXISTS语句</em></strong></em></strong>：EXISTS关键字后面的参数可以是任何一个子查询，但是不会产生任何数据，只返回TRUE或者FALSE，当返回TRUE的时候外层查询才会执行。</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname where exists (select 字段 from tbname where 条件)</p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>ANY语句：</em></strong></em></strong>ANY关键字表示只要满足内层子查询中的任意一个条件，就会返回一个结果作为外层查询条件。</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段from tbname where 字段 比较符 any(select字段 from tbnamewhere条件)</p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>ALL语句</em></strong></em></strong>：类似于ANY只是他需要满足所有条件</p>\n\n<p style=\"margin-left:0pt;\">语句：select字段 from tbname where 字段 比较符 all(select 字段 from tbname where条件)</p>\n\n<p style=\"margin-left:0pt;\"> </p>","source":"_posts/blogs-MySQL常用命令总结.md","raw":"<p style=\"margin-left:0pt;\"><strong><strong>显示所有数据库：</strong></strong>show databases;<br /><img alt=\"\" class=\"has\" height=\"176\" src=\"https://img-blog.csdn.net/20180818091228226?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"260\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>新建数据库：</strong></strong>create database dbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除数据库：</strong></strong>drop database dbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>切换数据库：</strong></strong>use dbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>新建表：</strong></strong>create table tbname(clo1 type ,col2 type,……);<br /><img alt=\"\" class=\"has\" height=\"158\" src=\"https://img-blog.csdn.net/20180818091257226?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"350\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>显示所有表：</strong></strong>show tables;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>根据已有表结构创建新表：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\">create table new_table_name like old_table_name;</p>\n\n<p style=\"margin-left:0pt;\">create table new_table as select col1,col2,…. from old_table only;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>显示表结构：</strong></strong>describe table_name;<br /><img alt=\"\" class=\"has\" height=\"119\" src=\"https://img-blog.csdn.net/20180818091433792?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"412\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除表：</strong></strong>drop table table_name;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增加一列：</strong></strong>alter table tbname add column col type;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除一列：</strong></strong>alter table tbname drop column name;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>修改列属性:</strong></strong>alter table tbname modify col typr;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增加主键：</strong></strong>alter table tbname add primary key (col);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除主键：</strong></strong>alter table tbname drop primary key(col);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>修改表名：</strong></strong>alter table tbname rename new;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>创建索引：</strong></strong>create index idxname on tbname (col,….);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除索引：</strong></strong>drop index idxname on tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>查看索引：</strong></strong>show index from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>创建视图：</strong></strong>create view name as select (col,….) from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除视图：</strong></strong>drop view name;</p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增删改查：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增：</strong></strong>insert into tbname (col,col,…) values(value1,value2,…);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删：</strong></strong>delete from tbname where 条件;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>改：</strong></strong>update tbname set field=value where条件;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>查：</strong></strong>select filed from tbname where 条件;</p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>求和：</strong></strong>select sum(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>平均：</strong></strong>select avg(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>最大：</strong></strong>select max(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>最小：</strong></strong>select min(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>外键定义：</strong></strong>外键是指引用另一个表中的一列或者多列，被引用的列应该具有主键约束或者唯一约束，外键用于建立和加强两个表数据之间的连接，被引用的表是主表，引用外键的表是从表。</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>多表操作：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>建立外键：</strong></strong>alter table tbname add constraint 外键名 froeign key(外键字段名) references 外表表名(主键字段名);</p>\n\n<p style=\"margin-left:0pt;\">示例：alter table student add constraint fk_id foreign key(gid) references grade(id);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除外键：</strong></strong>alter table tbname drop foreign key 外键名;</p>\n\n<p style=\"margin-left:0pt;\">示例：alter table student drop foreign key fk_id;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>添加数据：</strong></strong>当有外键的表添加数据的时候其字段值只能是被关联表中已有的数据，例如grade中id字段只有1和2，那么student中的gid值只能设为1和2.</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除数据：</strong></strong>因为grade表和student表具有关联关系，参照列中的被参照值是不能被删除的，所以想删除grade表中的数据必须先将student中关联数据都删除掉后再删除grade中的数据。</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>连接查询：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\">首先建立两个表：</p>\n\n<p style=\"margin-left:0pt;\">表1：create table department (did int not null primary key, dname varchar(32));</p>\n\n<p style=\"margin-left:0pt;\">表2：create table employee(id int not null primary key, name varchar(32), age int, did int not null);</p>\n\n<p style=\"margin-left:0pt;\">插入数据</p>\n\n<p style=\"margin-left:0pt;\">insert into department(did,dname)VALUES (1,'网络部'),(2,'媒体部'),(3,'研发部'),(5,'人事部');</p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#000000;\">I</span><span style=\"color:#000000;\">nsert into</span><span style=\"color:#000000;\"> employee(id,name,age,did)</span> <span style=\"color:#000000;\">VALUES (1,'王红',20,1),(2,'李强',22,1),(3,'赵四',20,2),(4,'郝娟',20,4);</span></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>交叉连接：</strong></strong>交叉连接返回的结果是两个连接表中所有数据的笛卡尔集，即返回第一个表中符合条件的数据乘以第二个表中符合条件的数据。</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname1 cross join tbname2;</p>\n\n<p style=\"margin-left:0pt;\">例如：select * from department cross join employee;</p>\n\n<p style=\"margin-left:0pt;\">返回结果为：有16行（4*4）</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>内连接：</strong></strong>使用比较运算符对两个表中的数据进行比较，并列出与连接条件匹配的数据</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname1 [inner] join tbname2 on tbname1.关系字段=tbname2.关系字段;</p>\n\n<p style=\"margin-left:0pt;\">例如 select name from employee join department on employee.did=department.did;</p>\n\n<p style=\"margin-left:0pt;\">返回结果为：3行（did为1，2，3的数据）<br /><img alt=\"\" class=\"has\" height=\"109\" src=\"https://img-blog.csdn.net/20180818091518909?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"123\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>自连接：</strong></strong>如果在一个连接查询中涉及的两个表其实是同一个表，这种查询称为自连接查询</p>\n\n<p style=\"margin-left:0pt;\">语句：select p1.* from tbname as p1 join tbname as p2 on p1.字段 = p2.字段;</p>\n\n<p style=\"margin-left:0pt;\">示例：查询 name为王红的人所属部门员工</p>\n\n<p style=\"margin-left:0pt;\">select p1.* from employee as p1 join employee as p2 on p1.did = p2.did where p2.name = ‘王红’;</p>\n\n<p style=\"margin-left:0pt;\">返回结果为：2行（网络部的两个：王红和李强）<br /><img alt=\"\" class=\"has\" height=\"114\" src=\"https://img-blog.csdn.net/20180818091540331?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"229\" /></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>外连接：</strong></strong>外连接分为左连接和右连接，当返回的查询结果不仅需要包括符合条件的数据，还需要包含其中的一个表或者两个表的所有数据的时候，需要用到外连接查询</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname1 left|right [outer] join tbname2;</p>\n\n<p style=\"margin-left:0pt;\">左连接：left join：返回包括左表中的所有记录和右表中符合条件的记录。</p>\n\n<p style=\"margin-left:0pt;\">例如：select department.dname,employee.name from department left join employee on department.did = employee.did;</p>\n\n<p style=\"margin-left:0pt;\"><img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180818091604776?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"157\" /></p>\n\n<p style=\"margin-left:0pt;\">右连接：right join：返回包括右表的所有记录和左表符合条件的记录。</p>\n\n<p style=\"margin-left:0pt;\">例如：select department.dname,employee.name from department right join employee on department.did = employee.did;</p>\n\n<p style=\"margin-left:0pt;\"><img alt=\"\" class=\"has\" height=\"123\" src=\"https://img-blog.csdn.net/20180818091619299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"155\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>子查询：</strong></strong>指一个查询语句嵌套在另一个查询语句内部的查询，在执行的时候会先执行子查询中的语句，然后将返回的结果作为外层查询的过滤条件。<strong><strong>需要注意的是第一个条件的判断字段要包含在第二个查询语句的字段中，否则报错。</strong></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>IN/NOT IN语句</em></strong></em></strong>：select 字段from tbname where 条件 in /not in (select 字段 where 条件)  </p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>EXISTS语句</em></strong></em></strong>：EXISTS关键字后面的参数可以是任何一个子查询，但是不会产生任何数据，只返回TRUE或者FALSE，当返回TRUE的时候外层查询才会执行。</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname where exists (select 字段 from tbname where 条件)</p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>ANY语句：</em></strong></em></strong>ANY关键字表示只要满足内层子查询中的任意一个条件，就会返回一个结果作为外层查询条件。</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段from tbname where 字段 比较符 any(select字段 from tbnamewhere条件)</p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>ALL语句</em></strong></em></strong>：类似于ANY只是他需要满足所有条件</p>\n\n<p style=\"margin-left:0pt;\">语句：select字段 from tbname where 字段 比较符 all(select 字段 from tbname where条件)</p>\n\n<p style=\"margin-left:0pt;\"> </p>","slug":"blogs-MySQL常用命令总结","published":1,"date":"2022-03-16T17:09:07.787Z","updated":"2022-03-16T17:09:07.787Z","_id":"cl0v6kevl001jyms489442tkf","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p style=\"margin-left:0pt;\"><strong><strong>显示所有数据库：</strong></strong>show databases;<br /><img alt=\"\" class=\"has\" height=\"176\" src=\"https://img-blog.csdn.net/20180818091228226?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"260\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>新建数据库：</strong></strong>create database dbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除数据库：</strong></strong>drop database dbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>切换数据库：</strong></strong>use dbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>新建表：</strong></strong>create table tbname(clo1 type ,col2 type,……);<br /><img alt=\"\" class=\"has\" height=\"158\" src=\"https://img-blog.csdn.net/20180818091257226?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"350\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>显示所有表：</strong></strong>show tables;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>根据已有表结构创建新表：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\">create table new_table_name like old_table_name;</p>\n\n<p style=\"margin-left:0pt;\">create table new_table as select col1,col2,…. from old_table only;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>显示表结构：</strong></strong>describe table_name;<br /><img alt=\"\" class=\"has\" height=\"119\" src=\"https://img-blog.csdn.net/20180818091433792?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"412\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除表：</strong></strong>drop table table_name;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增加一列：</strong></strong>alter table tbname add column col type;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除一列：</strong></strong>alter table tbname drop column name;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>修改列属性:</strong></strong>alter table tbname modify col typr;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增加主键：</strong></strong>alter table tbname add primary key (col);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除主键：</strong></strong>alter table tbname drop primary key(col);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>修改表名：</strong></strong>alter table tbname rename new;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>创建索引：</strong></strong>create index idxname on tbname (col,….);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除索引：</strong></strong>drop index idxname on tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>查看索引：</strong></strong>show index from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>创建视图：</strong></strong>create view name as select (col,….) from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除视图：</strong></strong>drop view name;</p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增删改查：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增：</strong></strong>insert into tbname (col,col,…) values(value1,value2,…);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删：</strong></strong>delete from tbname where 条件;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>改：</strong></strong>update tbname set field=value where条件;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>查：</strong></strong>select filed from tbname where 条件;</p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>求和：</strong></strong>select sum(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>平均：</strong></strong>select avg(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>最大：</strong></strong>select max(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>最小：</strong></strong>select min(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>外键定义：</strong></strong>外键是指引用另一个表中的一列或者多列，被引用的列应该具有主键约束或者唯一约束，外键用于建立和加强两个表数据之间的连接，被引用的表是主表，引用外键的表是从表。</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>多表操作：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>建立外键：</strong></strong>alter table tbname add constraint 外键名 froeign key(外键字段名) references 外表表名(主键字段名);</p>\n\n<p style=\"margin-left:0pt;\">示例：alter table student add constraint fk_id foreign key(gid) references grade(id);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除外键：</strong></strong>alter table tbname drop foreign key 外键名;</p>\n\n<p style=\"margin-left:0pt;\">示例：alter table student drop foreign key fk_id;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>添加数据：</strong></strong>当有外键的表添加数据的时候其字段值只能是被关联表中已有的数据，例如grade中id字段只有1和2，那么student中的gid值只能设为1和2.</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除数据：</strong></strong>因为grade表和student表具有关联关系，参照列中的被参照值是不能被删除的，所以想删除grade表中的数据必须先将student中关联数据都删除掉后再删除grade中的数据。</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>连接查询：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\">首先建立两个表：</p>\n\n<p style=\"margin-left:0pt;\">表1：create table department (did int not null primary key, dname varchar(32));</p>\n\n<p style=\"margin-left:0pt;\">表2：create table employee(id int not null primary key, name varchar(32), age int, did int not null);</p>\n\n<p style=\"margin-left:0pt;\">插入数据</p>\n\n<p style=\"margin-left:0pt;\">insert into department(did,dname)VALUES (1,'网络部'),(2,'媒体部'),(3,'研发部'),(5,'人事部');</p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#000000;\">I</span><span style=\"color:#000000;\">nsert into</span><span style=\"color:#000000;\"> employee(id,name,age,did)</span> <span style=\"color:#000000;\">VALUES (1,'王红',20,1),(2,'李强',22,1),(3,'赵四',20,2),(4,'郝娟',20,4);</span></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>交叉连接：</strong></strong>交叉连接返回的结果是两个连接表中所有数据的笛卡尔集，即返回第一个表中符合条件的数据乘以第二个表中符合条件的数据。</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname1 cross join tbname2;</p>\n\n<p style=\"margin-left:0pt;\">例如：select * from department cross join employee;</p>\n\n<p style=\"margin-left:0pt;\">返回结果为：有16行（4*4）</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>内连接：</strong></strong>使用比较运算符对两个表中的数据进行比较，并列出与连接条件匹配的数据</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname1 [inner] join tbname2 on tbname1.关系字段=tbname2.关系字段;</p>\n\n<p style=\"margin-left:0pt;\">例如 select name from employee join department on employee.did=department.did;</p>\n\n<p style=\"margin-left:0pt;\">返回结果为：3行（did为1，2，3的数据）<br /><img alt=\"\" class=\"has\" height=\"109\" src=\"https://img-blog.csdn.net/20180818091518909?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"123\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>自连接：</strong></strong>如果在一个连接查询中涉及的两个表其实是同一个表，这种查询称为自连接查询</p>\n\n<p style=\"margin-left:0pt;\">语句：select p1.* from tbname as p1 join tbname as p2 on p1.字段 = p2.字段;</p>\n\n<p style=\"margin-left:0pt;\">示例：查询 name为王红的人所属部门员工</p>\n\n<p style=\"margin-left:0pt;\">select p1.* from employee as p1 join employee as p2 on p1.did = p2.did where p2.name = ‘王红’;</p>\n\n<p style=\"margin-left:0pt;\">返回结果为：2行（网络部的两个：王红和李强）<br /><img alt=\"\" class=\"has\" height=\"114\" src=\"https://img-blog.csdn.net/20180818091540331?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"229\" /></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>外连接：</strong></strong>外连接分为左连接和右连接，当返回的查询结果不仅需要包括符合条件的数据，还需要包含其中的一个表或者两个表的所有数据的时候，需要用到外连接查询</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname1 left|right [outer] join tbname2;</p>\n\n<p style=\"margin-left:0pt;\">左连接：left join：返回包括左表中的所有记录和右表中符合条件的记录。</p>\n\n<p style=\"margin-left:0pt;\">例如：select department.dname,employee.name from department left join employee on department.did = employee.did;</p>\n\n<p style=\"margin-left:0pt;\"><img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180818091604776?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"157\" /></p>\n\n<p style=\"margin-left:0pt;\">右连接：right join：返回包括右表的所有记录和左表符合条件的记录。</p>\n\n<p style=\"margin-left:0pt;\">例如：select department.dname,employee.name from department right join employee on department.did = employee.did;</p>\n\n<p style=\"margin-left:0pt;\"><img alt=\"\" class=\"has\" height=\"123\" src=\"https://img-blog.csdn.net/20180818091619299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"155\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>子查询：</strong></strong>指一个查询语句嵌套在另一个查询语句内部的查询，在执行的时候会先执行子查询中的语句，然后将返回的结果作为外层查询的过滤条件。<strong><strong>需要注意的是第一个条件的判断字段要包含在第二个查询语句的字段中，否则报错。</strong></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>IN/NOT IN语句</em></strong></em></strong>：select 字段from tbname where 条件 in /not in (select 字段 where 条件)  </p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>EXISTS语句</em></strong></em></strong>：EXISTS关键字后面的参数可以是任何一个子查询，但是不会产生任何数据，只返回TRUE或者FALSE，当返回TRUE的时候外层查询才会执行。</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname where exists (select 字段 from tbname where 条件)</p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>ANY语句：</em></strong></em></strong>ANY关键字表示只要满足内层子查询中的任意一个条件，就会返回一个结果作为外层查询条件。</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段from tbname where 字段 比较符 any(select字段 from tbnamewhere条件)</p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>ALL语句</em></strong></em></strong>：类似于ANY只是他需要满足所有条件</p>\n\n<p style=\"margin-left:0pt;\">语句：select字段 from tbname where 字段 比较符 all(select 字段 from tbname where条件)</p>\n\n<p style=\"margin-left:0pt;\"> </p>","site":{"data":{}},"excerpt":"","more":"<p style=\"margin-left:0pt;\"><strong><strong>显示所有数据库：</strong></strong>show databases;<br /><img alt=\"\" class=\"has\" height=\"176\" src=\"https://img-blog.csdn.net/20180818091228226?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"260\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>新建数据库：</strong></strong>create database dbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除数据库：</strong></strong>drop database dbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>切换数据库：</strong></strong>use dbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>新建表：</strong></strong>create table tbname(clo1 type ,col2 type,……);<br /><img alt=\"\" class=\"has\" height=\"158\" src=\"https://img-blog.csdn.net/20180818091257226?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"350\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>显示所有表：</strong></strong>show tables;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>根据已有表结构创建新表：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\">create table new_table_name like old_table_name;</p>\n\n<p style=\"margin-left:0pt;\">create table new_table as select col1,col2,…. from old_table only;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>显示表结构：</strong></strong>describe table_name;<br /><img alt=\"\" class=\"has\" height=\"119\" src=\"https://img-blog.csdn.net/20180818091433792?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"412\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除表：</strong></strong>drop table table_name;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增加一列：</strong></strong>alter table tbname add column col type;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除一列：</strong></strong>alter table tbname drop column name;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>修改列属性:</strong></strong>alter table tbname modify col typr;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增加主键：</strong></strong>alter table tbname add primary key (col);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除主键：</strong></strong>alter table tbname drop primary key(col);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>修改表名：</strong></strong>alter table tbname rename new;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>创建索引：</strong></strong>create index idxname on tbname (col,….);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除索引：</strong></strong>drop index idxname on tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>查看索引：</strong></strong>show index from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>创建视图：</strong></strong>create view name as select (col,….) from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除视图：</strong></strong>drop view name;</p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增删改查：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>增：</strong></strong>insert into tbname (col,col,…) values(value1,value2,…);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删：</strong></strong>delete from tbname where 条件;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>改：</strong></strong>update tbname set field=value where条件;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>查：</strong></strong>select filed from tbname where 条件;</p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>求和：</strong></strong>select sum(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>平均：</strong></strong>select avg(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>最大：</strong></strong>select max(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>最小：</strong></strong>select min(col) as name from tbname;</p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>外键定义：</strong></strong>外键是指引用另一个表中的一列或者多列，被引用的列应该具有主键约束或者唯一约束，外键用于建立和加强两个表数据之间的连接，被引用的表是主表，引用外键的表是从表。</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>多表操作：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>建立外键：</strong></strong>alter table tbname add constraint 外键名 froeign key(外键字段名) references 外表表名(主键字段名);</p>\n\n<p style=\"margin-left:0pt;\">示例：alter table student add constraint fk_id foreign key(gid) references grade(id);</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除外键：</strong></strong>alter table tbname drop foreign key 外键名;</p>\n\n<p style=\"margin-left:0pt;\">示例：alter table student drop foreign key fk_id;</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>添加数据：</strong></strong>当有外键的表添加数据的时候其字段值只能是被关联表中已有的数据，例如grade中id字段只有1和2，那么student中的gid值只能设为1和2.</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>删除数据：</strong></strong>因为grade表和student表具有关联关系，参照列中的被参照值是不能被删除的，所以想删除grade表中的数据必须先将student中关联数据都删除掉后再删除grade中的数据。</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>连接查询：</strong></strong></p>\n\n<p style=\"margin-left:0pt;\">首先建立两个表：</p>\n\n<p style=\"margin-left:0pt;\">表1：create table department (did int not null primary key, dname varchar(32));</p>\n\n<p style=\"margin-left:0pt;\">表2：create table employee(id int not null primary key, name varchar(32), age int, did int not null);</p>\n\n<p style=\"margin-left:0pt;\">插入数据</p>\n\n<p style=\"margin-left:0pt;\">insert into department(did,dname)VALUES (1,'网络部'),(2,'媒体部'),(3,'研发部'),(5,'人事部');</p>\n\n<p style=\"margin-left:0pt;\"><span style=\"color:#000000;\">I</span><span style=\"color:#000000;\">nsert into</span><span style=\"color:#000000;\"> employee(id,name,age,did)</span> <span style=\"color:#000000;\">VALUES (1,'王红',20,1),(2,'李强',22,1),(3,'赵四',20,2),(4,'郝娟',20,4);</span></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>交叉连接：</strong></strong>交叉连接返回的结果是两个连接表中所有数据的笛卡尔集，即返回第一个表中符合条件的数据乘以第二个表中符合条件的数据。</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname1 cross join tbname2;</p>\n\n<p style=\"margin-left:0pt;\">例如：select * from department cross join employee;</p>\n\n<p style=\"margin-left:0pt;\">返回结果为：有16行（4*4）</p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>内连接：</strong></strong>使用比较运算符对两个表中的数据进行比较，并列出与连接条件匹配的数据</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname1 [inner] join tbname2 on tbname1.关系字段=tbname2.关系字段;</p>\n\n<p style=\"margin-left:0pt;\">例如 select name from employee join department on employee.did=department.did;</p>\n\n<p style=\"margin-left:0pt;\">返回结果为：3行（did为1，2，3的数据）<br /><img alt=\"\" class=\"has\" height=\"109\" src=\"https://img-blog.csdn.net/20180818091518909?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"123\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>自连接：</strong></strong>如果在一个连接查询中涉及的两个表其实是同一个表，这种查询称为自连接查询</p>\n\n<p style=\"margin-left:0pt;\">语句：select p1.* from tbname as p1 join tbname as p2 on p1.字段 = p2.字段;</p>\n\n<p style=\"margin-left:0pt;\">示例：查询 name为王红的人所属部门员工</p>\n\n<p style=\"margin-left:0pt;\">select p1.* from employee as p1 join employee as p2 on p1.did = p2.did where p2.name = ‘王红’;</p>\n\n<p style=\"margin-left:0pt;\">返回结果为：2行（网络部的两个：王红和李强）<br /><img alt=\"\" class=\"has\" height=\"114\" src=\"https://img-blog.csdn.net/20180818091540331?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"229\" /></p>\n\n<p style=\"margin-left:0pt;\"> </p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>外连接：</strong></strong>外连接分为左连接和右连接，当返回的查询结果不仅需要包括符合条件的数据，还需要包含其中的一个表或者两个表的所有数据的时候，需要用到外连接查询</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname1 left|right [outer] join tbname2;</p>\n\n<p style=\"margin-left:0pt;\">左连接：left join：返回包括左表中的所有记录和右表中符合条件的记录。</p>\n\n<p style=\"margin-left:0pt;\">例如：select department.dname,employee.name from department left join employee on department.did = employee.did;</p>\n\n<p style=\"margin-left:0pt;\"><img alt=\"\" class=\"has\" height=\"146\" src=\"https://img-blog.csdn.net/20180818091604776?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"157\" /></p>\n\n<p style=\"margin-left:0pt;\">右连接：right join：返回包括右表的所有记录和左表符合条件的记录。</p>\n\n<p style=\"margin-left:0pt;\">例如：select department.dname,employee.name from department right join employee on department.did = employee.did;</p>\n\n<p style=\"margin-left:0pt;\"><img alt=\"\" class=\"has\" height=\"123\" src=\"https://img-blog.csdn.net/20180818091619299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"155\" /></p>\n\n<p style=\"margin-left:0pt;\"><strong><strong>子查询：</strong></strong>指一个查询语句嵌套在另一个查询语句内部的查询，在执行的时候会先执行子查询中的语句，然后将返回的结果作为外层查询的过滤条件。<strong><strong>需要注意的是第一个条件的判断字段要包含在第二个查询语句的字段中，否则报错。</strong></strong></p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>IN/NOT IN语句</em></strong></em></strong>：select 字段from tbname where 条件 in /not in (select 字段 where 条件)  </p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>EXISTS语句</em></strong></em></strong>：EXISTS关键字后面的参数可以是任何一个子查询，但是不会产生任何数据，只返回TRUE或者FALSE，当返回TRUE的时候外层查询才会执行。</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段 from tbname where exists (select 字段 from tbname where 条件)</p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>ANY语句：</em></strong></em></strong>ANY关键字表示只要满足内层子查询中的任意一个条件，就会返回一个结果作为外层查询条件。</p>\n\n<p style=\"margin-left:0pt;\">语句：select 字段from tbname where 字段 比较符 any(select字段 from tbnamewhere条件)</p>\n\n<p style=\"margin-left:0pt;\"><strong><em><strong><em>ALL语句</em></strong></em></strong>：类似于ANY只是他需要满足所有条件</p>\n\n<p style=\"margin-left:0pt;\">语句：select字段 from tbname where 字段 比较符 all(select 字段 from tbname where条件)</p>\n\n<p style=\"margin-left:0pt;\"> </p>"},{"_content":"## HTTP协议基础\n**总结于图解HTTP协议**\n\n\n### 什么是URI和URL？\n\nURI（统一资源标识符）表示的是某一个互联网资源， URL（统一资源定位符）相交于URI我们对于URL要更为熟悉一些，我们在浏览器上输入的网站地址其实就是一个URL 例如：http://www.google.com ，URL表示的是资源的地点，所以呢URL是URI的一个子集，URI中包含URL的。\n\n用一个形象点的例子来说明URI和URL的区别：我们每一个人都有身份证，每一个人的身份证号都是不同的，可以根据这个号码来找到这个唯一的人，这就相当于URI，而URL呢则类似于身份证上的地址信息，例如（某某省/某某市/某某区/某某街道/某某门牌号/姓名）通过这个地址我们也能找到这个人。\n\n### URI格式\n\n绝对URI格式\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305020813962.png)\n一个绝对的URI包含了\n\n1. 协议名\n   - 使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号\n2. 认证信息（可选）\n   - 指定用户名和密码作为从服务器端获取资源时必要的登录信息\n3. 服务器地址\n   - 使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似google.com 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。\n4. 服务器端口号（可选）\n   - 指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。\n5. 带层次的文件路径\n   - 指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。\n6. 查询字符串（可选）\n   - 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。\n7. 片段标识位（可选）\n\n\n\n\n\n### HTTP协议用于客户端和服务器端之间的通信\n\n在应用HTTP协议的时候必定一端为客户端而另一端为服务端角色，客户端通过请求，服务器端反馈响应实现两者之间的通信（请求必定是客户端发送的，服务器端在没有接收到请求的时候是不能发送响应的）\n\n- 发送请求\n\n  一个简单的请求报文内容\n\n  ```http\n  GET /index.html HTTP/1.1\n  Host: baidu.com\n  Connection: keep-alive\n  ```\n\n  起始行首先声明了请求访问服务器的类型为GET ， 随后的字符串`/index.html`指明了请求访问的资源对象，最后是HTTP协议的版本号\n\n  下面的是请求首部字段，这里面通常会有Host、Connection、Content-Type等等，除了这些可能还会包含内容实体用于发送请求的数据\n\n- 返回响应\n\n  ```http\n  HTTP/1.1 200 OK\n  Date: Mon, 04 Mar 2019 07:34:18 GMT\n  Content-Type: text/html\n  \n  <html>\n  </html>\n  ```\n\n  同样的在第一行中HTTP/1.1 表示了服务器对应的HTTP版本， 200 OK表示请求的处理结构的状态码和原因短语，第二行显示了创建响应的日期和时间，接着空一行，之后的就是响应的资源实体了\n\n- **HTTP协议是不保存状态的协议**\n\n  HTTP本身是无状态的协议，自身不会对请求和响应之间的通信状态进行保存，但是往往我们在浏览网页的时候进行页面跳转需要保留我们的登陆信息以便服务器知道每次请求是谁发送的，所以就有了Cookie技术\n\n- **使用Cooke实现状态管理**\n\n  Cookie技术通过在请求和响应报文中写入Cookie信息来实现对客户端的状态的控制\n\n  首先Cookie会根据服务器端响应报文内的set-cookie字段信息通知客户端保存cookie，下次客户端再请求的时候将接收到的cookie值添加到请求报文中发出\n\n  客户端在接收到携带有cookie的请求后会根据cookie值和服务器上的记录进行比对以此来确定客户端的状态\n\n  - 没有cookie时候的请求报文\n\n    ```http\n    GET /index.html HTTP/1.1\n    Host: baidu.com\n    ```\n\n  - 服务器接收到没有cookie的响应返回\n\n    ```http\n    HTTP/1.1 200 OK\n    Date: Mon, 04 Mar 2019 07:34:18 GMT\n    Content-Type: text/html\n    ＜Set-Cookie: sid=1342077140226724; path=/; expires=Mon, 04 Mar 2019 07:34:18 GMT＞\n    \n    <html>\n    </html>\n    ```\n\n  - 客户端携带cookie发送请求\n\n    ```http\n    GET /index.html HTTP/1.1\n    Host: baidu.com\n    Cookie: sid=1342077140226724\n    ```\n\n- **更进一步：session的使用**\n\n  session的应用是基于cookie的，cookie无法存储复杂的数据，这时候就需要用到session来实现，session保存于服务器端类似以key-value结构，其中key值可以使用cookie存放，每次请求过来时候服务器端可以通过cookie值去session中获取对应的用户信息，以此记录控制客户端的状态（cookie存放在客户端中，session保存于服务器端）\n\n- **http请求方法**\n\n  - GET：获取资源\n\n  - POST：传输实体主体\n\n  - PUT：传输文件\n\n  - DELETE：删除文件\n\n  - HEAD：获取报文首部\n\n  - OPTIONS：询问支持的方法\n\n    响应报文\n\n    ```http\n    HTTP/1.1 200 OK\n    Allow: GET, POST, HEAD, OPTIONS\n    ```\n\n  - TRACE：追踪路径，让服务器端将之前的请求通信环回给客户端（可以用来查询请求是如何加工或者传递到服务器端的）\n\n  - CONNECT: 使用隧道协议连接代理\n\n    CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305020900941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n- 长连接\n\n  在早期的http协议中，每次通信就需要断开TCP连接，随着时代的发展一个页面可能需要请求很多次，这样一来就会不断的断开连接增加通信的开销，所以在1.1和部分1.0版本中出现了持久连接，只要一端没有明确提出断开连接，那么就会保持TCP的连接状态\n\n- HTTP报文内的HTTP信息\n\n  HTTP报文大致可分为报文首部+报文主体两块，两者通过（CR+LF）来划分\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305020933712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n\n- 获取部分内容的范围请求\n\n  执行范围请求的时候，请求体的首部字段Range需要用来指定资源的byte范围\n\n  ```http\n  GET /index.html HTTP/1.1\n  Range: bytes=5001-10000   请求50001-10000字节内容\n  Range: bytes=5001-        请求5001之后的所有内容    \n  Range: bytes=-3000, 6000-7000   请求前3000字节和6000-7000字节内容的多重范围\n  ```\n\n  范围请求的响应会返回状态码为206 Partial Content的响应报文，多重范围响应会在首部字段Content-type标明multipart/byteranges，如果服务器不支持范围请求那么会返回200 OK和全部实体内容\n\n\n\n### HTTP状态码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305021012587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n- 2XX成功   （服务器返回2XX表明请求被正常处理了）\n\n  - 200 OK\n\n    表示客服端发送的请求被服务器端正常处理了\n\n  - 204 No Content\n\n    表示客服端发送的请求被服务器端正常处理了，但是在返回的响应报文中不包含实体部分\n\n  - 206 Partial Content\n\n    就是上面说的范围请求响应\n\n- 3XX重定向  （浏览器需要执行某些其他的处理才能服务器端才能正常处理请求）\n\n  - 301 Moved Permanently\n\n    永久性的重定向，表明改请求资源的URI发生更改了，需要请求新的URI\n\n  - **302 Found**\n\n    临时重定向，和上面的不同，服务器希望本次使用新的URI进行访问，只是临时性的\n\n  - 303 See Other\n\n    表示请求的资源存在另一个URI，应该使用GET方法请求该资源，例如使用POST方法访问某个资源，但是服务器处理的结果是希望客户端使用GET方法来请求这个资源\n\n  - 304 Not Modified\n\n    该状态码表示客户端使用GET方法并且请求报文中包含 If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since 中任一首部，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。\n\n  - 307 Temporary Redirect\n\n    临时重定向和302相同，但是禁止POST变成GET\n\n- 4XX 客户端错误 （客服端发送的请求服务器无法正确处理）\n\n  - **400Bad Request**\n\n    请求报文中存在语法错误\n\n  - 401 Unauthorized\n\n    需要通过HTTP认证才可访问（BASIC认证、DIGEST认证）\n\n  - **403 Forbidden**\n\n    这次请求被服务器拒绝了\n\n  - **404 Not Found**\n\n    服务器无法找到此次请求的资源\n\n- 5XX 服务器错误\n\n  - **500 Internal Server Error**\n\n    服务器处理请求是发生错误\n\n  - 503 Service Unavailable\n\n    服务器超载，无法处理请求\n\n\n\n### WEB服务器\n\n- 在一台主机上部署多个web站点\n\n  在HTTP/1.1协议规范中允许一台服务器搭建多个web网站，假如一台服务器中绑定了www.baidu.com和www.google.com 两个域名的时候，我们输入这两个域名的时候都会解析到同一个IP地址上，这个时候如果想要区分用户请求的是那个域名就必须在请求首部Host指定域名。\n\n- 代理服务器\n\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305021046421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n\n  代理服务器最基本的功能就是接受客户端的请求，并将请求转发给其他的服务器，代理并不会改变请求的URL，会直接将请求进行转发，每次通过代理服务器转发请求的或者响应的时候都会在首部添加Via信息，最常见的代理服务就是我们使用的翻墙服务。\n\n  代理服务还细分为正向代理和反向代理，通俗来说正向代理是针对于客户端（服务器端并不知道客户端的真实信息），反向代理是针对于服务器端（客户端不知道服务器端的实际地址）\n\n  \n\n  正向代理的作用：\n\n  1. 翻墙（访问客户端无法访问的资源）\n  2. 缓存，加速访问速度\n  3. 对外隐藏真实的客户端信息\n\n  反向代理的作用：\n\n  1. 保证内网的安全\n  2. 负载均衡\n\n- 网关\n\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305021103779.png)\n\n  网关和代理的作用很类似，但是网关能够实现非HTTP协议的服务，利用网关可以提高通信的安全性。\n\n- 隧道\n\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019030502111797.png)\n\n  在客户端和服务器端建立一条加密的通信线路，确保客户端和服务器端的安全通信，隧道本身不会解析HTTP请求，会原样将请求转发给服务器。\n\n\n\n### HTTP首部\n\n之前提到过一个HTTP的报文主要分为首部和主体两个部分，主体部分不是客户端和服务器端根据操作生成的所以没有办法去介绍，在此只介绍部分常见的首部字段的作用和用法。\n\n下图是分别是请求报文和响应报文的首部构成：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305021127721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n\n字段结构：**字段名：字段值1, 字段值2....**\n\n报文首部主要分为以下四个部分： \n\n1. 通用首都字段\n2. 实体首部字段\n3. 请求实体字段\n4. 响应实体字段\n\n**常见字段一览**\n\n- 通用首部字段\n\n  | 字段名            | 说明                       |\n  | ----------------- | -------------------------- |\n  | Cache-Control     | 控制缓存行为               |\n  | Connection        | 逐跳首部、连接的管理       |\n  | Date              | 创建报文的时间和日期       |\n  | Pragma            | 报文指令                   |\n  | Trailer           | 报文末端的首部一览         |\n  | Transfer-Encoding | 指定报文主体的传输编码方式 |\n  | Upgrade           | 升级为其他协议             |\n  | Via               | 代理服务器相关信息         |\n  | Warning           | 错误通知                   |\n\n- 实体首部字段\n\n  | 字段名           | 说明                         |\n  | ---------------- | ---------------------------- |\n  | Allow            | 资源可支持的HTTP方法         |\n  | Content-Encoding | 实体主体适用的编码方式       |\n  | Content-Language | 实体主体的自然语言           |\n  | Content-Length   | 实体主体的大小（单位：字节） |\n  | Content-Location | 替代对应资源的URI            |\n  | Content-MD5      | 实体主体的报文摘要           |\n  | Content-Range    | 实体主体的范围位置           |\n  | Content-Type     | 实体主体的媒体类型           |\n  | Expires          | 实体主题过期的日期和时间     |\n  | Last-Modified    | 资源的最后修改日期和时间     |\n\n- 请求首部字段\n\n  | 字段名              | 说明                                          |\n  | ------------------- | --------------------------------------------- |\n  | Accept              | 用户代理可处理的媒体类型                      |\n  | Accept-Charset      | 优先的字符集                                  |\n  | Accept-Encoding     | 优先的内容编码                                |\n  | Accept-Language     | 优先的自然语言                                |\n  | Authorization       | Web认证信息                                   |\n  | Expect              | 期待服务器的特定行为                          |\n  | From                | 用户的电子邮箱地址                            |\n  | Host                | 请求资源所在服务器                            |\n  | If-Match            | 比较实体标记（ETag)                           |\n  | If-Modified-Since   | 比较资源的更新时间                            |\n  | If-None-Match       | 比较实体标记（与If-Match想法）                |\n  | If-Range            | 资源为更新时发送实体Byte的范围请求            |\n  | If-Unmodified-Since | 比较资源的更新时间（与If-Modified-Since相反） |\n  | Max-Forwards        | 最大传输逐跳数                                |\n  | Proxy-Authorization | 代理服务器要求客户端的认证信息                |\n  | Range               | 实体的字节范围请求                            |\n  | User-Agent          | HTTP客户端程序的信息                          |\n\n- 响应首部字段\n\n  | 字段名             | 说明                         |\n  | ------------------ | ---------------------------- |\n  | Accept-Ranges      | 是否接收字节范围请求         |\n  | Age                | 推算资源创建经过的时间       |\n  | Etag               | 资源的匹配信息               |\n  | Location           | 命令客户端重定向至指定URI    |\n  | Proxy-Authenticate | 代理服务器对客户端的认证信息 |\n  | Retry-After        | 对再次发送请求的时机要求     |\n  | Server             | HTTP服务器安装信息           |\n  | Vary               | 代理服务器缓存的管理信息     |\n  | WWW-Authenticate   | 服务器对客户端的认证信息     |\n\n\n\n","source":"_posts/blogs-HTTP协议基础.md","raw":"## HTTP协议基础\n**总结于图解HTTP协议**\n\n\n### 什么是URI和URL？\n\nURI（统一资源标识符）表示的是某一个互联网资源， URL（统一资源定位符）相交于URI我们对于URL要更为熟悉一些，我们在浏览器上输入的网站地址其实就是一个URL 例如：http://www.google.com ，URL表示的是资源的地点，所以呢URL是URI的一个子集，URI中包含URL的。\n\n用一个形象点的例子来说明URI和URL的区别：我们每一个人都有身份证，每一个人的身份证号都是不同的，可以根据这个号码来找到这个唯一的人，这就相当于URI，而URL呢则类似于身份证上的地址信息，例如（某某省/某某市/某某区/某某街道/某某门牌号/姓名）通过这个地址我们也能找到这个人。\n\n### URI格式\n\n绝对URI格式\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305020813962.png)\n一个绝对的URI包含了\n\n1. 协议名\n   - 使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号\n2. 认证信息（可选）\n   - 指定用户名和密码作为从服务器端获取资源时必要的登录信息\n3. 服务器地址\n   - 使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似google.com 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。\n4. 服务器端口号（可选）\n   - 指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。\n5. 带层次的文件路径\n   - 指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。\n6. 查询字符串（可选）\n   - 针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。\n7. 片段标识位（可选）\n\n\n\n\n\n### HTTP协议用于客户端和服务器端之间的通信\n\n在应用HTTP协议的时候必定一端为客户端而另一端为服务端角色，客户端通过请求，服务器端反馈响应实现两者之间的通信（请求必定是客户端发送的，服务器端在没有接收到请求的时候是不能发送响应的）\n\n- 发送请求\n\n  一个简单的请求报文内容\n\n  ```http\n  GET /index.html HTTP/1.1\n  Host: baidu.com\n  Connection: keep-alive\n  ```\n\n  起始行首先声明了请求访问服务器的类型为GET ， 随后的字符串`/index.html`指明了请求访问的资源对象，最后是HTTP协议的版本号\n\n  下面的是请求首部字段，这里面通常会有Host、Connection、Content-Type等等，除了这些可能还会包含内容实体用于发送请求的数据\n\n- 返回响应\n\n  ```http\n  HTTP/1.1 200 OK\n  Date: Mon, 04 Mar 2019 07:34:18 GMT\n  Content-Type: text/html\n  \n  <html>\n  </html>\n  ```\n\n  同样的在第一行中HTTP/1.1 表示了服务器对应的HTTP版本， 200 OK表示请求的处理结构的状态码和原因短语，第二行显示了创建响应的日期和时间，接着空一行，之后的就是响应的资源实体了\n\n- **HTTP协议是不保存状态的协议**\n\n  HTTP本身是无状态的协议，自身不会对请求和响应之间的通信状态进行保存，但是往往我们在浏览网页的时候进行页面跳转需要保留我们的登陆信息以便服务器知道每次请求是谁发送的，所以就有了Cookie技术\n\n- **使用Cooke实现状态管理**\n\n  Cookie技术通过在请求和响应报文中写入Cookie信息来实现对客户端的状态的控制\n\n  首先Cookie会根据服务器端响应报文内的set-cookie字段信息通知客户端保存cookie，下次客户端再请求的时候将接收到的cookie值添加到请求报文中发出\n\n  客户端在接收到携带有cookie的请求后会根据cookie值和服务器上的记录进行比对以此来确定客户端的状态\n\n  - 没有cookie时候的请求报文\n\n    ```http\n    GET /index.html HTTP/1.1\n    Host: baidu.com\n    ```\n\n  - 服务器接收到没有cookie的响应返回\n\n    ```http\n    HTTP/1.1 200 OK\n    Date: Mon, 04 Mar 2019 07:34:18 GMT\n    Content-Type: text/html\n    ＜Set-Cookie: sid=1342077140226724; path=/; expires=Mon, 04 Mar 2019 07:34:18 GMT＞\n    \n    <html>\n    </html>\n    ```\n\n  - 客户端携带cookie发送请求\n\n    ```http\n    GET /index.html HTTP/1.1\n    Host: baidu.com\n    Cookie: sid=1342077140226724\n    ```\n\n- **更进一步：session的使用**\n\n  session的应用是基于cookie的，cookie无法存储复杂的数据，这时候就需要用到session来实现，session保存于服务器端类似以key-value结构，其中key值可以使用cookie存放，每次请求过来时候服务器端可以通过cookie值去session中获取对应的用户信息，以此记录控制客户端的状态（cookie存放在客户端中，session保存于服务器端）\n\n- **http请求方法**\n\n  - GET：获取资源\n\n  - POST：传输实体主体\n\n  - PUT：传输文件\n\n  - DELETE：删除文件\n\n  - HEAD：获取报文首部\n\n  - OPTIONS：询问支持的方法\n\n    响应报文\n\n    ```http\n    HTTP/1.1 200 OK\n    Allow: GET, POST, HEAD, OPTIONS\n    ```\n\n  - TRACE：追踪路径，让服务器端将之前的请求通信环回给客户端（可以用来查询请求是如何加工或者传递到服务器端的）\n\n  - CONNECT: 使用隧道协议连接代理\n\n    CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305020900941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n- 长连接\n\n  在早期的http协议中，每次通信就需要断开TCP连接，随着时代的发展一个页面可能需要请求很多次，这样一来就会不断的断开连接增加通信的开销，所以在1.1和部分1.0版本中出现了持久连接，只要一端没有明确提出断开连接，那么就会保持TCP的连接状态\n\n- HTTP报文内的HTTP信息\n\n  HTTP报文大致可分为报文首部+报文主体两块，两者通过（CR+LF）来划分\n ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305020933712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n\n- 获取部分内容的范围请求\n\n  执行范围请求的时候，请求体的首部字段Range需要用来指定资源的byte范围\n\n  ```http\n  GET /index.html HTTP/1.1\n  Range: bytes=5001-10000   请求50001-10000字节内容\n  Range: bytes=5001-        请求5001之后的所有内容    \n  Range: bytes=-3000, 6000-7000   请求前3000字节和6000-7000字节内容的多重范围\n  ```\n\n  范围请求的响应会返回状态码为206 Partial Content的响应报文，多重范围响应会在首部字段Content-type标明multipart/byteranges，如果服务器不支持范围请求那么会返回200 OK和全部实体内容\n\n\n\n### HTTP状态码\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305021012587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n- 2XX成功   （服务器返回2XX表明请求被正常处理了）\n\n  - 200 OK\n\n    表示客服端发送的请求被服务器端正常处理了\n\n  - 204 No Content\n\n    表示客服端发送的请求被服务器端正常处理了，但是在返回的响应报文中不包含实体部分\n\n  - 206 Partial Content\n\n    就是上面说的范围请求响应\n\n- 3XX重定向  （浏览器需要执行某些其他的处理才能服务器端才能正常处理请求）\n\n  - 301 Moved Permanently\n\n    永久性的重定向，表明改请求资源的URI发生更改了，需要请求新的URI\n\n  - **302 Found**\n\n    临时重定向，和上面的不同，服务器希望本次使用新的URI进行访问，只是临时性的\n\n  - 303 See Other\n\n    表示请求的资源存在另一个URI，应该使用GET方法请求该资源，例如使用POST方法访问某个资源，但是服务器处理的结果是希望客户端使用GET方法来请求这个资源\n\n  - 304 Not Modified\n\n    该状态码表示客户端使用GET方法并且请求报文中包含 If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since 中任一首部，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。\n\n  - 307 Temporary Redirect\n\n    临时重定向和302相同，但是禁止POST变成GET\n\n- 4XX 客户端错误 （客服端发送的请求服务器无法正确处理）\n\n  - **400Bad Request**\n\n    请求报文中存在语法错误\n\n  - 401 Unauthorized\n\n    需要通过HTTP认证才可访问（BASIC认证、DIGEST认证）\n\n  - **403 Forbidden**\n\n    这次请求被服务器拒绝了\n\n  - **404 Not Found**\n\n    服务器无法找到此次请求的资源\n\n- 5XX 服务器错误\n\n  - **500 Internal Server Error**\n\n    服务器处理请求是发生错误\n\n  - 503 Service Unavailable\n\n    服务器超载，无法处理请求\n\n\n\n### WEB服务器\n\n- 在一台主机上部署多个web站点\n\n  在HTTP/1.1协议规范中允许一台服务器搭建多个web网站，假如一台服务器中绑定了www.baidu.com和www.google.com 两个域名的时候，我们输入这两个域名的时候都会解析到同一个IP地址上，这个时候如果想要区分用户请求的是那个域名就必须在请求首部Host指定域名。\n\n- 代理服务器\n\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305021046421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n\n  代理服务器最基本的功能就是接受客户端的请求，并将请求转发给其他的服务器，代理并不会改变请求的URL，会直接将请求进行转发，每次通过代理服务器转发请求的或者响应的时候都会在首部添加Via信息，最常见的代理服务就是我们使用的翻墙服务。\n\n  代理服务还细分为正向代理和反向代理，通俗来说正向代理是针对于客户端（服务器端并不知道客户端的真实信息），反向代理是针对于服务器端（客户端不知道服务器端的实际地址）\n\n  \n\n  正向代理的作用：\n\n  1. 翻墙（访问客户端无法访问的资源）\n  2. 缓存，加速访问速度\n  3. 对外隐藏真实的客户端信息\n\n  反向代理的作用：\n\n  1. 保证内网的安全\n  2. 负载均衡\n\n- 网关\n\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305021103779.png)\n\n  网关和代理的作用很类似，但是网关能够实现非HTTP协议的服务，利用网关可以提高通信的安全性。\n\n- 隧道\n\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019030502111797.png)\n\n  在客户端和服务器端建立一条加密的通信线路，确保客户端和服务器端的安全通信，隧道本身不会解析HTTP请求，会原样将请求转发给服务器。\n\n\n\n### HTTP首部\n\n之前提到过一个HTTP的报文主要分为首部和主体两个部分，主体部分不是客户端和服务器端根据操作生成的所以没有办法去介绍，在此只介绍部分常见的首部字段的作用和用法。\n\n下图是分别是请求报文和响应报文的首部构成：\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190305021127721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n\n字段结构：**字段名：字段值1, 字段值2....**\n\n报文首部主要分为以下四个部分： \n\n1. 通用首都字段\n2. 实体首部字段\n3. 请求实体字段\n4. 响应实体字段\n\n**常见字段一览**\n\n- 通用首部字段\n\n  | 字段名            | 说明                       |\n  | ----------------- | -------------------------- |\n  | Cache-Control     | 控制缓存行为               |\n  | Connection        | 逐跳首部、连接的管理       |\n  | Date              | 创建报文的时间和日期       |\n  | Pragma            | 报文指令                   |\n  | Trailer           | 报文末端的首部一览         |\n  | Transfer-Encoding | 指定报文主体的传输编码方式 |\n  | Upgrade           | 升级为其他协议             |\n  | Via               | 代理服务器相关信息         |\n  | Warning           | 错误通知                   |\n\n- 实体首部字段\n\n  | 字段名           | 说明                         |\n  | ---------------- | ---------------------------- |\n  | Allow            | 资源可支持的HTTP方法         |\n  | Content-Encoding | 实体主体适用的编码方式       |\n  | Content-Language | 实体主体的自然语言           |\n  | Content-Length   | 实体主体的大小（单位：字节） |\n  | Content-Location | 替代对应资源的URI            |\n  | Content-MD5      | 实体主体的报文摘要           |\n  | Content-Range    | 实体主体的范围位置           |\n  | Content-Type     | 实体主体的媒体类型           |\n  | Expires          | 实体主题过期的日期和时间     |\n  | Last-Modified    | 资源的最后修改日期和时间     |\n\n- 请求首部字段\n\n  | 字段名              | 说明                                          |\n  | ------------------- | --------------------------------------------- |\n  | Accept              | 用户代理可处理的媒体类型                      |\n  | Accept-Charset      | 优先的字符集                                  |\n  | Accept-Encoding     | 优先的内容编码                                |\n  | Accept-Language     | 优先的自然语言                                |\n  | Authorization       | Web认证信息                                   |\n  | Expect              | 期待服务器的特定行为                          |\n  | From                | 用户的电子邮箱地址                            |\n  | Host                | 请求资源所在服务器                            |\n  | If-Match            | 比较实体标记（ETag)                           |\n  | If-Modified-Since   | 比较资源的更新时间                            |\n  | If-None-Match       | 比较实体标记（与If-Match想法）                |\n  | If-Range            | 资源为更新时发送实体Byte的范围请求            |\n  | If-Unmodified-Since | 比较资源的更新时间（与If-Modified-Since相反） |\n  | Max-Forwards        | 最大传输逐跳数                                |\n  | Proxy-Authorization | 代理服务器要求客户端的认证信息                |\n  | Range               | 实体的字节范围请求                            |\n  | User-Agent          | HTTP客户端程序的信息                          |\n\n- 响应首部字段\n\n  | 字段名             | 说明                         |\n  | ------------------ | ---------------------------- |\n  | Accept-Ranges      | 是否接收字节范围请求         |\n  | Age                | 推算资源创建经过的时间       |\n  | Etag               | 资源的匹配信息               |\n  | Location           | 命令客户端重定向至指定URI    |\n  | Proxy-Authenticate | 代理服务器对客户端的认证信息 |\n  | Retry-After        | 对再次发送请求的时机要求     |\n  | Server             | HTTP服务器安装信息           |\n  | Vary               | 代理服务器缓存的管理信息     |\n  | WWW-Authenticate   | 服务器对客户端的认证信息     |\n\n\n\n","slug":"blogs-HTTP协议基础","published":1,"date":"2022-03-16T17:00:44.821Z","updated":"2022-03-16T17:05:34.162Z","_id":"cl0v6kevm001kyms4c4p46fov","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"HTTP协议基础\"><a href=\"#HTTP协议基础\" class=\"headerlink\" title=\"HTTP协议基础\"></a>HTTP协议基础</h2><p><strong>总结于图解HTTP协议</strong></p>\n<h3 id=\"什么是URI和URL？\"><a href=\"#什么是URI和URL？\" class=\"headerlink\" title=\"什么是URI和URL？\"></a>什么是URI和URL？</h3><p>URI（统一资源标识符）表示的是某一个互联网资源， URL（统一资源定位符）相交于URI我们对于URL要更为熟悉一些，我们在浏览器上输入的网站地址其实就是一个URL 例如：<a href=\"http://www.google.com/\">http://www.google.com</a> ，URL表示的是资源的地点，所以呢URL是URI的一个子集，URI中包含URL的。</p>\n<p>用一个形象点的例子来说明URI和URL的区别：我们每一个人都有身份证，每一个人的身份证号都是不同的，可以根据这个号码来找到这个唯一的人，这就相当于URI，而URL呢则类似于身份证上的地址信息，例如（某某省/某某市/某某区/某某街道/某某门牌号/姓名）通过这个地址我们也能找到这个人。</p>\n<h3 id=\"URI格式\"><a href=\"#URI格式\" class=\"headerlink\" title=\"URI格式\"></a>URI格式</h3><p>绝对URI格式<br><img src=\"https://img-blog.csdnimg.cn/20190305020813962.png\" alt=\"在这里插入图片描述\"><br>一个绝对的URI包含了</p>\n<ol>\n<li>协议名<ul>\n<li>使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号</li>\n</ul>\n</li>\n<li>认证信息（可选）<ul>\n<li>指定用户名和密码作为从服务器端获取资源时必要的登录信息</li>\n</ul>\n</li>\n<li>服务器地址<ul>\n<li>使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似google.com 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。</li>\n</ul>\n</li>\n<li>服务器端口号（可选）<ul>\n<li>指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。</li>\n</ul>\n</li>\n<li>带层次的文件路径<ul>\n<li>指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。</li>\n</ul>\n</li>\n<li>查询字符串（可选）<ul>\n<li>针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。</li>\n</ul>\n</li>\n<li>片段标识位（可选）</li>\n</ol>\n<h3 id=\"HTTP协议用于客户端和服务器端之间的通信\"><a href=\"#HTTP协议用于客户端和服务器端之间的通信\" class=\"headerlink\" title=\"HTTP协议用于客户端和服务器端之间的通信\"></a>HTTP协议用于客户端和服务器端之间的通信</h3><p>在应用HTTP协议的时候必定一端为客户端而另一端为服务端角色，客户端通过请求，服务器端反馈响应实现两者之间的通信（请求必定是客户端发送的，服务器端在没有接收到请求的时候是不能发送响应的）</p>\n<ul>\n<li><p>发送请求</p>\n<p>一个简单的请求报文内容</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> <span class=\"meta\">HTTP/1.1</span></span><br><span class=\"line\"><span class=\"attribute\">Host</span><span class=\"punctuation\">: </span>baidu.com</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>keep-alive</span><br></pre></td></tr></table></figure>\n\n<p>起始行首先声明了请求访问服务器的类型为GET ， 随后的字符串<code>/index.html</code>指明了请求访问的资源对象，最后是HTTP协议的版本号</p>\n<p>下面的是请求首部字段，这里面通常会有Host、Connection、Content-Type等等，除了这些可能还会包含内容实体用于发送请求的数据</p>\n</li>\n<li><p>返回响应</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">HTTP/1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Date</span><span class=\"punctuation\">: </span>Mon, 04 Mar 2019 07:34:18 GMT</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>text/html</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-apache\"><span class=\"section\">&lt;html&gt;</span></span></span><br><span class=\"line\"><span class=\"language-apache\"><span class=\"section\">&lt;/html&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>同样的在第一行中HTTP/1.1 表示了服务器对应的HTTP版本， 200 OK表示请求的处理结构的状态码和原因短语，第二行显示了创建响应的日期和时间，接着空一行，之后的就是响应的资源实体了</p>\n</li>\n<li><p><strong>HTTP协议是不保存状态的协议</strong></p>\n<p>HTTP本身是无状态的协议，自身不会对请求和响应之间的通信状态进行保存，但是往往我们在浏览网页的时候进行页面跳转需要保留我们的登陆信息以便服务器知道每次请求是谁发送的，所以就有了Cookie技术</p>\n</li>\n<li><p><strong>使用Cooke实现状态管理</strong></p>\n<p>Cookie技术通过在请求和响应报文中写入Cookie信息来实现对客户端的状态的控制</p>\n<p>首先Cookie会根据服务器端响应报文内的set-cookie字段信息通知客户端保存cookie，下次客户端再请求的时候将接收到的cookie值添加到请求报文中发出</p>\n<p>客户端在接收到携带有cookie的请求后会根据cookie值和服务器上的记录进行比对以此来确定客户端的状态</p>\n<ul>\n<li><p>没有cookie时候的请求报文</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> <span class=\"meta\">HTTP/1.1</span></span><br><span class=\"line\"><span class=\"attribute\">Host</span><span class=\"punctuation\">: </span>baidu.com</span><br></pre></td></tr></table></figure></li>\n<li><p>服务器接收到没有cookie的响应返回</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">HTTP/1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Date</span><span class=\"punctuation\">: </span>Mon, 04 Mar 2019 07:34:18 GMT</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>text/html</span><br><span class=\"line\">＜Set-Cookie: sid=1342077140226724; path=/; expires=Mon, 04 Mar 2019 07:34:18 GMT＞</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-apache\"><span class=\"section\">&lt;html&gt;</span></span></span><br><span class=\"line\"><span class=\"language-apache\"><span class=\"section\">&lt;/html&gt;</span></span></span><br></pre></td></tr></table></figure></li>\n<li><p>客户端携带cookie发送请求</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> <span class=\"meta\">HTTP/1.1</span></span><br><span class=\"line\"><span class=\"attribute\">Host</span><span class=\"punctuation\">: </span>baidu.com</span><br><span class=\"line\"><span class=\"attribute\">Cookie</span><span class=\"punctuation\">: </span>sid=1342077140226724</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>更进一步：session的使用</strong></p>\n<p>session的应用是基于cookie的，cookie无法存储复杂的数据，这时候就需要用到session来实现，session保存于服务器端类似以key-value结构，其中key值可以使用cookie存放，每次请求过来时候服务器端可以通过cookie值去session中获取对应的用户信息，以此记录控制客户端的状态（cookie存放在客户端中，session保存于服务器端）</p>\n</li>\n<li><p><strong>http请求方法</strong></p>\n<ul>\n<li><p>GET：获取资源</p>\n</li>\n<li><p>POST：传输实体主体</p>\n</li>\n<li><p>PUT：传输文件</p>\n</li>\n<li><p>DELETE：删除文件</p>\n</li>\n<li><p>HEAD：获取报文首部</p>\n</li>\n<li><p>OPTIONS：询问支持的方法</p>\n<p>响应报文</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">HTTP/1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Allow</span><span class=\"punctuation\">: </span>GET, POST, HEAD, OPTIONS</span><br></pre></td></tr></table></figure></li>\n<li><p>TRACE：追踪路径，让服务器端将之前的请求通信环回给客户端（可以用来查询请求是如何加工或者传递到服务器端的）</p>\n</li>\n<li><p>CONNECT: 使用隧道协议连接代理</p>\n<p>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。<br><img src=\"https://img-blog.csdnimg.cn/20190305020900941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n</li>\n<li><p>长连接</p>\n<p>在早期的http协议中，每次通信就需要断开TCP连接，随着时代的发展一个页面可能需要请求很多次，这样一来就会不断的断开连接增加通信的开销，所以在1.1和部分1.0版本中出现了持久连接，只要一端没有明确提出断开连接，那么就会保持TCP的连接状态</p>\n</li>\n<li><p>HTTP报文内的HTTP信息</p>\n<p>HTTP报文大致可分为报文首部+报文主体两块，两者通过（CR+LF）来划分<br><img src=\"https://img-blog.csdnimg.cn/20190305020933712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>获取部分内容的范围请求</p>\n<p>执行范围请求的时候，请求体的首部字段Range需要用来指定资源的byte范围</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> <span class=\"meta\">HTTP/1.1</span></span><br><span class=\"line\"><span class=\"attribute\">Range</span><span class=\"punctuation\">: </span>bytes=5001-10000   请求50001-10000字节内容</span><br><span class=\"line\"><span class=\"attribute\">Range</span><span class=\"punctuation\">: </span>bytes=5001-        请求5001之后的所有内容    </span><br><span class=\"line\"><span class=\"attribute\">Range</span><span class=\"punctuation\">: </span>bytes=-3000, 6000-7000   请求前3000字节和6000-7000字节内容的多重范围</span><br></pre></td></tr></table></figure>\n\n<p>范围请求的响应会返回状态码为206 Partial Content的响应报文，多重范围响应会在首部字段Content-type标明multipart/byteranges，如果服务器不支持范围请求那么会返回200 OK和全部实体内容</p>\n</li>\n</ul>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><p><img src=\"https://img-blog.csdnimg.cn/20190305021012587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>2XX成功   （服务器返回2XX表明请求被正常处理了）</p>\n<ul>\n<li><p>200 OK</p>\n<p>表示客服端发送的请求被服务器端正常处理了</p>\n</li>\n<li><p>204 No Content</p>\n<p>表示客服端发送的请求被服务器端正常处理了，但是在返回的响应报文中不包含实体部分</p>\n</li>\n<li><p>206 Partial Content</p>\n<p>就是上面说的范围请求响应</p>\n</li>\n</ul>\n</li>\n<li><p>3XX重定向  （浏览器需要执行某些其他的处理才能服务器端才能正常处理请求）</p>\n<ul>\n<li><p>301 Moved Permanently</p>\n<p>永久性的重定向，表明改请求资源的URI发生更改了，需要请求新的URI</p>\n</li>\n<li><p><strong>302 Found</strong></p>\n<p>临时重定向，和上面的不同，服务器希望本次使用新的URI进行访问，只是临时性的</p>\n</li>\n<li><p>303 See Other</p>\n<p>表示请求的资源存在另一个URI，应该使用GET方法请求该资源，例如使用POST方法访问某个资源，但是服务器处理的结果是希望客户端使用GET方法来请求这个资源</p>\n</li>\n<li><p>304 Not Modified</p>\n<p>该状态码表示客户端使用GET方法并且请求报文中包含 If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since 中任一首部，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。</p>\n</li>\n<li><p>307 Temporary Redirect</p>\n<p>临时重定向和302相同，但是禁止POST变成GET</p>\n</li>\n</ul>\n</li>\n<li><p>4XX 客户端错误 （客服端发送的请求服务器无法正确处理）</p>\n<ul>\n<li><p><strong>400Bad Request</strong></p>\n<p>请求报文中存在语法错误</p>\n</li>\n<li><p>401 Unauthorized</p>\n<p>需要通过HTTP认证才可访问（BASIC认证、DIGEST认证）</p>\n</li>\n<li><p><strong>403 Forbidden</strong></p>\n<p>这次请求被服务器拒绝了</p>\n</li>\n<li><p><strong>404 Not Found</strong></p>\n<p>服务器无法找到此次请求的资源</p>\n</li>\n</ul>\n</li>\n<li><p>5XX 服务器错误</p>\n<ul>\n<li><p><strong>500 Internal Server Error</strong></p>\n<p>服务器处理请求是发生错误</p>\n</li>\n<li><p>503 Service Unavailable</p>\n<p>服务器超载，无法处理请求</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"WEB服务器\"><a href=\"#WEB服务器\" class=\"headerlink\" title=\"WEB服务器\"></a>WEB服务器</h3><ul>\n<li><p>在一台主机上部署多个web站点</p>\n<p>在HTTP/1.1协议规范中允许一台服务器搭建多个web网站，假如一台服务器中绑定了<a href=\"http://www.baidu.com和www.google.com/\">www.baidu.com和www.google.com</a> 两个域名的时候，我们输入这两个域名的时候都会解析到同一个IP地址上，这个时候如果想要区分用户请求的是那个域名就必须在请求首部Host指定域名。</p>\n</li>\n<li><p>代理服务器</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190305021046421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>代理服务器最基本的功能就是接受客户端的请求，并将请求转发给其他的服务器，代理并不会改变请求的URL，会直接将请求进行转发，每次通过代理服务器转发请求的或者响应的时候都会在首部添加Via信息，最常见的代理服务就是我们使用的翻墙服务。</p>\n<p>代理服务还细分为正向代理和反向代理，通俗来说正向代理是针对于客户端（服务器端并不知道客户端的真实信息），反向代理是针对于服务器端（客户端不知道服务器端的实际地址）</p>\n<p>正向代理的作用：</p>\n<ol>\n<li>翻墙（访问客户端无法访问的资源）</li>\n<li>缓存，加速访问速度</li>\n<li>对外隐藏真实的客户端信息</li>\n</ol>\n<p>反向代理的作用：</p>\n<ol>\n<li>保证内网的安全</li>\n<li>负载均衡</li>\n</ol>\n</li>\n<li><p>网关</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190305021103779.png\" alt=\"在这里插入图片描述\"></p>\n<p>网关和代理的作用很类似，但是网关能够实现非HTTP协议的服务，利用网关可以提高通信的安全性。</p>\n</li>\n<li><p>隧道</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019030502111797.png\" alt=\"在这里插入图片描述\"></p>\n<p>在客户端和服务器端建立一条加密的通信线路，确保客户端和服务器端的安全通信，隧道本身不会解析HTTP请求，会原样将请求转发给服务器。</p>\n</li>\n</ul>\n<h3 id=\"HTTP首部\"><a href=\"#HTTP首部\" class=\"headerlink\" title=\"HTTP首部\"></a>HTTP首部</h3><p>之前提到过一个HTTP的报文主要分为首部和主体两个部分，主体部分不是客户端和服务器端根据操作生成的所以没有办法去介绍，在此只介绍部分常见的首部字段的作用和用法。</p>\n<p>下图是分别是请求报文和响应报文的首部构成：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190305021127721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>字段结构：<strong>字段名：字段值1, 字段值2….</strong></p>\n<p>报文首部主要分为以下四个部分： </p>\n<ol>\n<li>通用首都字段</li>\n<li>实体首部字段</li>\n<li>请求实体字段</li>\n<li>响应实体字段</li>\n</ol>\n<p><strong>常见字段一览</strong></p>\n<ul>\n<li><p>通用首部字段</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache-Control</td>\n<td>控制缓存行为</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>逐跳首部、连接的管理</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>创建报文的时间和日期</td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>报文指令</td>\n</tr>\n<tr>\n<td>Trailer</td>\n<td>报文末端的首部一览</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>指定报文主体的传输编码方式</td>\n</tr>\n<tr>\n<td>Upgrade</td>\n<td>升级为其他协议</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>代理服务器相关信息</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>错误通知</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>实体首部字段</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Allow</td>\n<td>资源可支持的HTTP方法</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>实体主体适用的编码方式</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>实体主体的自然语言</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>实体主体的大小（单位：字节）</td>\n</tr>\n<tr>\n<td>Content-Location</td>\n<td>替代对应资源的URI</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>实体主体的报文摘要</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>实体主体的范围位置</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>实体主体的媒体类型</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体主题过期的日期和时间</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>资源的最后修改日期和时间</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>请求首部字段</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Accept</td>\n<td>用户代理可处理的媒体类型</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>优先的字符集</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>优先的内容编码</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>优先的自然语言</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>Web认证信息</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>期待服务器的特定行为</td>\n</tr>\n<tr>\n<td>From</td>\n<td>用户的电子邮箱地址</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>请求资源所在服务器</td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>比较实体标记（ETag)</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>比较资源的更新时间</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>比较实体标记（与If-Match想法）</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>资源为更新时发送实体Byte的范围请求</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>比较资源的更新时间（与If-Modified-Since相反）</td>\n</tr>\n<tr>\n<td>Max-Forwards</td>\n<td>最大传输逐跳数</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>代理服务器要求客户端的认证信息</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>实体的字节范围请求</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>HTTP客户端程序的信息</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>响应首部字段</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Accept-Ranges</td>\n<td>是否接收字节范围请求</td>\n</tr>\n<tr>\n<td>Age</td>\n<td>推算资源创建经过的时间</td>\n</tr>\n<tr>\n<td>Etag</td>\n<td>资源的匹配信息</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>命令客户端重定向至指定URI</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>代理服务器对客户端的认证信息</td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>对再次发送请求的时机要求</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>HTTP服务器安装信息</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>代理服务器缓存的管理信息</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>服务器对客户端的认证信息</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HTTP协议基础\"><a href=\"#HTTP协议基础\" class=\"headerlink\" title=\"HTTP协议基础\"></a>HTTP协议基础</h2><p><strong>总结于图解HTTP协议</strong></p>\n<h3 id=\"什么是URI和URL？\"><a href=\"#什么是URI和URL？\" class=\"headerlink\" title=\"什么是URI和URL？\"></a>什么是URI和URL？</h3><p>URI（统一资源标识符）表示的是某一个互联网资源， URL（统一资源定位符）相交于URI我们对于URL要更为熟悉一些，我们在浏览器上输入的网站地址其实就是一个URL 例如：<a href=\"http://www.google.com/\">http://www.google.com</a> ，URL表示的是资源的地点，所以呢URL是URI的一个子集，URI中包含URL的。</p>\n<p>用一个形象点的例子来说明URI和URL的区别：我们每一个人都有身份证，每一个人的身份证号都是不同的，可以根据这个号码来找到这个唯一的人，这就相当于URI，而URL呢则类似于身份证上的地址信息，例如（某某省/某某市/某某区/某某街道/某某门牌号/姓名）通过这个地址我们也能找到这个人。</p>\n<h3 id=\"URI格式\"><a href=\"#URI格式\" class=\"headerlink\" title=\"URI格式\"></a>URI格式</h3><p>绝对URI格式<br><img src=\"https://img-blog.csdnimg.cn/20190305020813962.png\" alt=\"在这里插入图片描述\"><br>一个绝对的URI包含了</p>\n<ol>\n<li>协议名<ul>\n<li>使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号</li>\n</ul>\n</li>\n<li>认证信息（可选）<ul>\n<li>指定用户名和密码作为从服务器端获取资源时必要的登录信息</li>\n</ul>\n</li>\n<li>服务器地址<ul>\n<li>使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似google.com 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。</li>\n</ul>\n</li>\n<li>服务器端口号（可选）<ul>\n<li>指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。</li>\n</ul>\n</li>\n<li>带层次的文件路径<ul>\n<li>指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。</li>\n</ul>\n</li>\n<li>查询字符串（可选）<ul>\n<li>针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。</li>\n</ul>\n</li>\n<li>片段标识位（可选）</li>\n</ol>\n<h3 id=\"HTTP协议用于客户端和服务器端之间的通信\"><a href=\"#HTTP协议用于客户端和服务器端之间的通信\" class=\"headerlink\" title=\"HTTP协议用于客户端和服务器端之间的通信\"></a>HTTP协议用于客户端和服务器端之间的通信</h3><p>在应用HTTP协议的时候必定一端为客户端而另一端为服务端角色，客户端通过请求，服务器端反馈响应实现两者之间的通信（请求必定是客户端发送的，服务器端在没有接收到请求的时候是不能发送响应的）</p>\n<ul>\n<li><p>发送请求</p>\n<p>一个简单的请求报文内容</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> <span class=\"meta\">HTTP/1.1</span></span><br><span class=\"line\"><span class=\"attribute\">Host</span><span class=\"punctuation\">: </span>baidu.com</span><br><span class=\"line\"><span class=\"attribute\">Connection</span><span class=\"punctuation\">: </span>keep-alive</span><br></pre></td></tr></table></figure>\n\n<p>起始行首先声明了请求访问服务器的类型为GET ， 随后的字符串<code>/index.html</code>指明了请求访问的资源对象，最后是HTTP协议的版本号</p>\n<p>下面的是请求首部字段，这里面通常会有Host、Connection、Content-Type等等，除了这些可能还会包含内容实体用于发送请求的数据</p>\n</li>\n<li><p>返回响应</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">HTTP/1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Date</span><span class=\"punctuation\">: </span>Mon, 04 Mar 2019 07:34:18 GMT</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>text/html</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-apache\"><span class=\"section\">&lt;html&gt;</span></span></span><br><span class=\"line\"><span class=\"language-apache\"><span class=\"section\">&lt;/html&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<p>同样的在第一行中HTTP/1.1 表示了服务器对应的HTTP版本， 200 OK表示请求的处理结构的状态码和原因短语，第二行显示了创建响应的日期和时间，接着空一行，之后的就是响应的资源实体了</p>\n</li>\n<li><p><strong>HTTP协议是不保存状态的协议</strong></p>\n<p>HTTP本身是无状态的协议，自身不会对请求和响应之间的通信状态进行保存，但是往往我们在浏览网页的时候进行页面跳转需要保留我们的登陆信息以便服务器知道每次请求是谁发送的，所以就有了Cookie技术</p>\n</li>\n<li><p><strong>使用Cooke实现状态管理</strong></p>\n<p>Cookie技术通过在请求和响应报文中写入Cookie信息来实现对客户端的状态的控制</p>\n<p>首先Cookie会根据服务器端响应报文内的set-cookie字段信息通知客户端保存cookie，下次客户端再请求的时候将接收到的cookie值添加到请求报文中发出</p>\n<p>客户端在接收到携带有cookie的请求后会根据cookie值和服务器上的记录进行比对以此来确定客户端的状态</p>\n<ul>\n<li><p>没有cookie时候的请求报文</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> <span class=\"meta\">HTTP/1.1</span></span><br><span class=\"line\"><span class=\"attribute\">Host</span><span class=\"punctuation\">: </span>baidu.com</span><br></pre></td></tr></table></figure></li>\n<li><p>服务器接收到没有cookie的响应返回</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">HTTP/1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Date</span><span class=\"punctuation\">: </span>Mon, 04 Mar 2019 07:34:18 GMT</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>text/html</span><br><span class=\"line\">＜Set-Cookie: sid=1342077140226724; path=/; expires=Mon, 04 Mar 2019 07:34:18 GMT＞</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-apache\"><span class=\"section\">&lt;html&gt;</span></span></span><br><span class=\"line\"><span class=\"language-apache\"><span class=\"section\">&lt;/html&gt;</span></span></span><br></pre></td></tr></table></figure></li>\n<li><p>客户端携带cookie发送请求</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> <span class=\"meta\">HTTP/1.1</span></span><br><span class=\"line\"><span class=\"attribute\">Host</span><span class=\"punctuation\">: </span>baidu.com</span><br><span class=\"line\"><span class=\"attribute\">Cookie</span><span class=\"punctuation\">: </span>sid=1342077140226724</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>更进一步：session的使用</strong></p>\n<p>session的应用是基于cookie的，cookie无法存储复杂的数据，这时候就需要用到session来实现，session保存于服务器端类似以key-value结构，其中key值可以使用cookie存放，每次请求过来时候服务器端可以通过cookie值去session中获取对应的用户信息，以此记录控制客户端的状态（cookie存放在客户端中，session保存于服务器端）</p>\n</li>\n<li><p><strong>http请求方法</strong></p>\n<ul>\n<li><p>GET：获取资源</p>\n</li>\n<li><p>POST：传输实体主体</p>\n</li>\n<li><p>PUT：传输文件</p>\n</li>\n<li><p>DELETE：删除文件</p>\n</li>\n<li><p>HEAD：获取报文首部</p>\n</li>\n<li><p>OPTIONS：询问支持的方法</p>\n<p>响应报文</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">HTTP/1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Allow</span><span class=\"punctuation\">: </span>GET, POST, HEAD, OPTIONS</span><br></pre></td></tr></table></figure></li>\n<li><p>TRACE：追踪路径，让服务器端将之前的请求通信环回给客户端（可以用来查询请求是如何加工或者传递到服务器端的）</p>\n</li>\n<li><p>CONNECT: 使用隧道协议连接代理</p>\n<p>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。<br><img src=\"https://img-blog.csdnimg.cn/20190305020900941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n</li>\n<li><p>长连接</p>\n<p>在早期的http协议中，每次通信就需要断开TCP连接，随着时代的发展一个页面可能需要请求很多次，这样一来就会不断的断开连接增加通信的开销，所以在1.1和部分1.0版本中出现了持久连接，只要一端没有明确提出断开连接，那么就会保持TCP的连接状态</p>\n</li>\n<li><p>HTTP报文内的HTTP信息</p>\n<p>HTTP报文大致可分为报文首部+报文主体两块，两者通过（CR+LF）来划分<br><img src=\"https://img-blog.csdnimg.cn/20190305020933712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p>获取部分内容的范围请求</p>\n<p>执行范围请求的时候，请求体的首部字段Range需要用来指定资源的byte范围</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/index.html</span> <span class=\"meta\">HTTP/1.1</span></span><br><span class=\"line\"><span class=\"attribute\">Range</span><span class=\"punctuation\">: </span>bytes=5001-10000   请求50001-10000字节内容</span><br><span class=\"line\"><span class=\"attribute\">Range</span><span class=\"punctuation\">: </span>bytes=5001-        请求5001之后的所有内容    </span><br><span class=\"line\"><span class=\"attribute\">Range</span><span class=\"punctuation\">: </span>bytes=-3000, 6000-7000   请求前3000字节和6000-7000字节内容的多重范围</span><br></pre></td></tr></table></figure>\n\n<p>范围请求的响应会返回状态码为206 Partial Content的响应报文，多重范围响应会在首部字段Content-type标明multipart/byteranges，如果服务器不支持范围请求那么会返回200 OK和全部实体内容</p>\n</li>\n</ul>\n<h3 id=\"HTTP状态码\"><a href=\"#HTTP状态码\" class=\"headerlink\" title=\"HTTP状态码\"></a>HTTP状态码</h3><p><img src=\"https://img-blog.csdnimg.cn/20190305021012587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><p>2XX成功   （服务器返回2XX表明请求被正常处理了）</p>\n<ul>\n<li><p>200 OK</p>\n<p>表示客服端发送的请求被服务器端正常处理了</p>\n</li>\n<li><p>204 No Content</p>\n<p>表示客服端发送的请求被服务器端正常处理了，但是在返回的响应报文中不包含实体部分</p>\n</li>\n<li><p>206 Partial Content</p>\n<p>就是上面说的范围请求响应</p>\n</li>\n</ul>\n</li>\n<li><p>3XX重定向  （浏览器需要执行某些其他的处理才能服务器端才能正常处理请求）</p>\n<ul>\n<li><p>301 Moved Permanently</p>\n<p>永久性的重定向，表明改请求资源的URI发生更改了，需要请求新的URI</p>\n</li>\n<li><p><strong>302 Found</strong></p>\n<p>临时重定向，和上面的不同，服务器希望本次使用新的URI进行访问，只是临时性的</p>\n</li>\n<li><p>303 See Other</p>\n<p>表示请求的资源存在另一个URI，应该使用GET方法请求该资源，例如使用POST方法访问某个资源，但是服务器处理的结果是希望客户端使用GET方法来请求这个资源</p>\n</li>\n<li><p>304 Not Modified</p>\n<p>该状态码表示客户端使用GET方法并且请求报文中包含 If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since 中任一首部，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。</p>\n</li>\n<li><p>307 Temporary Redirect</p>\n<p>临时重定向和302相同，但是禁止POST变成GET</p>\n</li>\n</ul>\n</li>\n<li><p>4XX 客户端错误 （客服端发送的请求服务器无法正确处理）</p>\n<ul>\n<li><p><strong>400Bad Request</strong></p>\n<p>请求报文中存在语法错误</p>\n</li>\n<li><p>401 Unauthorized</p>\n<p>需要通过HTTP认证才可访问（BASIC认证、DIGEST认证）</p>\n</li>\n<li><p><strong>403 Forbidden</strong></p>\n<p>这次请求被服务器拒绝了</p>\n</li>\n<li><p><strong>404 Not Found</strong></p>\n<p>服务器无法找到此次请求的资源</p>\n</li>\n</ul>\n</li>\n<li><p>5XX 服务器错误</p>\n<ul>\n<li><p><strong>500 Internal Server Error</strong></p>\n<p>服务器处理请求是发生错误</p>\n</li>\n<li><p>503 Service Unavailable</p>\n<p>服务器超载，无法处理请求</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"WEB服务器\"><a href=\"#WEB服务器\" class=\"headerlink\" title=\"WEB服务器\"></a>WEB服务器</h3><ul>\n<li><p>在一台主机上部署多个web站点</p>\n<p>在HTTP/1.1协议规范中允许一台服务器搭建多个web网站，假如一台服务器中绑定了<a href=\"http://www.baidu.com和www.google.com/\">www.baidu.com和www.google.com</a> 两个域名的时候，我们输入这两个域名的时候都会解析到同一个IP地址上，这个时候如果想要区分用户请求的是那个域名就必须在请求首部Host指定域名。</p>\n</li>\n<li><p>代理服务器</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190305021046421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>代理服务器最基本的功能就是接受客户端的请求，并将请求转发给其他的服务器，代理并不会改变请求的URL，会直接将请求进行转发，每次通过代理服务器转发请求的或者响应的时候都会在首部添加Via信息，最常见的代理服务就是我们使用的翻墙服务。</p>\n<p>代理服务还细分为正向代理和反向代理，通俗来说正向代理是针对于客户端（服务器端并不知道客户端的真实信息），反向代理是针对于服务器端（客户端不知道服务器端的实际地址）</p>\n<p>正向代理的作用：</p>\n<ol>\n<li>翻墙（访问客户端无法访问的资源）</li>\n<li>缓存，加速访问速度</li>\n<li>对外隐藏真实的客户端信息</li>\n</ol>\n<p>反向代理的作用：</p>\n<ol>\n<li>保证内网的安全</li>\n<li>负载均衡</li>\n</ol>\n</li>\n<li><p>网关</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190305021103779.png\" alt=\"在这里插入图片描述\"></p>\n<p>网关和代理的作用很类似，但是网关能够实现非HTTP协议的服务，利用网关可以提高通信的安全性。</p>\n</li>\n<li><p>隧道</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2019030502111797.png\" alt=\"在这里插入图片描述\"></p>\n<p>在客户端和服务器端建立一条加密的通信线路，确保客户端和服务器端的安全通信，隧道本身不会解析HTTP请求，会原样将请求转发给服务器。</p>\n</li>\n</ul>\n<h3 id=\"HTTP首部\"><a href=\"#HTTP首部\" class=\"headerlink\" title=\"HTTP首部\"></a>HTTP首部</h3><p>之前提到过一个HTTP的报文主要分为首部和主体两个部分，主体部分不是客户端和服务器端根据操作生成的所以没有办法去介绍，在此只介绍部分常见的首部字段的作用和用法。</p>\n<p>下图是分别是请求报文和响应报文的首部构成：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190305021127721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<p>字段结构：<strong>字段名：字段值1, 字段值2….</strong></p>\n<p>报文首部主要分为以下四个部分： </p>\n<ol>\n<li>通用首都字段</li>\n<li>实体首部字段</li>\n<li>请求实体字段</li>\n<li>响应实体字段</li>\n</ol>\n<p><strong>常见字段一览</strong></p>\n<ul>\n<li><p>通用首部字段</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cache-Control</td>\n<td>控制缓存行为</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>逐跳首部、连接的管理</td>\n</tr>\n<tr>\n<td>Date</td>\n<td>创建报文的时间和日期</td>\n</tr>\n<tr>\n<td>Pragma</td>\n<td>报文指令</td>\n</tr>\n<tr>\n<td>Trailer</td>\n<td>报文末端的首部一览</td>\n</tr>\n<tr>\n<td>Transfer-Encoding</td>\n<td>指定报文主体的传输编码方式</td>\n</tr>\n<tr>\n<td>Upgrade</td>\n<td>升级为其他协议</td>\n</tr>\n<tr>\n<td>Via</td>\n<td>代理服务器相关信息</td>\n</tr>\n<tr>\n<td>Warning</td>\n<td>错误通知</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>实体首部字段</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Allow</td>\n<td>资源可支持的HTTP方法</td>\n</tr>\n<tr>\n<td>Content-Encoding</td>\n<td>实体主体适用的编码方式</td>\n</tr>\n<tr>\n<td>Content-Language</td>\n<td>实体主体的自然语言</td>\n</tr>\n<tr>\n<td>Content-Length</td>\n<td>实体主体的大小（单位：字节）</td>\n</tr>\n<tr>\n<td>Content-Location</td>\n<td>替代对应资源的URI</td>\n</tr>\n<tr>\n<td>Content-MD5</td>\n<td>实体主体的报文摘要</td>\n</tr>\n<tr>\n<td>Content-Range</td>\n<td>实体主体的范围位置</td>\n</tr>\n<tr>\n<td>Content-Type</td>\n<td>实体主体的媒体类型</td>\n</tr>\n<tr>\n<td>Expires</td>\n<td>实体主题过期的日期和时间</td>\n</tr>\n<tr>\n<td>Last-Modified</td>\n<td>资源的最后修改日期和时间</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>请求首部字段</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Accept</td>\n<td>用户代理可处理的媒体类型</td>\n</tr>\n<tr>\n<td>Accept-Charset</td>\n<td>优先的字符集</td>\n</tr>\n<tr>\n<td>Accept-Encoding</td>\n<td>优先的内容编码</td>\n</tr>\n<tr>\n<td>Accept-Language</td>\n<td>优先的自然语言</td>\n</tr>\n<tr>\n<td>Authorization</td>\n<td>Web认证信息</td>\n</tr>\n<tr>\n<td>Expect</td>\n<td>期待服务器的特定行为</td>\n</tr>\n<tr>\n<td>From</td>\n<td>用户的电子邮箱地址</td>\n</tr>\n<tr>\n<td>Host</td>\n<td>请求资源所在服务器</td>\n</tr>\n<tr>\n<td>If-Match</td>\n<td>比较实体标记（ETag)</td>\n</tr>\n<tr>\n<td>If-Modified-Since</td>\n<td>比较资源的更新时间</td>\n</tr>\n<tr>\n<td>If-None-Match</td>\n<td>比较实体标记（与If-Match想法）</td>\n</tr>\n<tr>\n<td>If-Range</td>\n<td>资源为更新时发送实体Byte的范围请求</td>\n</tr>\n<tr>\n<td>If-Unmodified-Since</td>\n<td>比较资源的更新时间（与If-Modified-Since相反）</td>\n</tr>\n<tr>\n<td>Max-Forwards</td>\n<td>最大传输逐跳数</td>\n</tr>\n<tr>\n<td>Proxy-Authorization</td>\n<td>代理服务器要求客户端的认证信息</td>\n</tr>\n<tr>\n<td>Range</td>\n<td>实体的字节范围请求</td>\n</tr>\n<tr>\n<td>User-Agent</td>\n<td>HTTP客户端程序的信息</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>响应首部字段</p>\n<table>\n<thead>\n<tr>\n<th>字段名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Accept-Ranges</td>\n<td>是否接收字节范围请求</td>\n</tr>\n<tr>\n<td>Age</td>\n<td>推算资源创建经过的时间</td>\n</tr>\n<tr>\n<td>Etag</td>\n<td>资源的匹配信息</td>\n</tr>\n<tr>\n<td>Location</td>\n<td>命令客户端重定向至指定URI</td>\n</tr>\n<tr>\n<td>Proxy-Authenticate</td>\n<td>代理服务器对客户端的认证信息</td>\n</tr>\n<tr>\n<td>Retry-After</td>\n<td>对再次发送请求的时机要求</td>\n</tr>\n<tr>\n<td>Server</td>\n<td>HTTP服务器安装信息</td>\n</tr>\n<tr>\n<td>Vary</td>\n<td>代理服务器缓存的管理信息</td>\n</tr>\n<tr>\n<td>WWW-Authenticate</td>\n<td>服务器对客户端的认证信息</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n"},{"_content":"#### 去重\n\nMySQL中不能部分使用DISTINCT，DISTINCT关键字会应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT score,age，除非指定的两个列都不同，否则所有行都将被检索出来。\n\n例如如下的表\n\n| name  | score | age  |\n| ----- | ----- | ---- |\n| test1 | 11    | 11   |\n| test2 | 11    | 11   |\n| test3 | 123   | 123  |\n| test4 | 123   | 11   |\n\n```sql\nSELECT DISTINCT score ,age FROM `student` \n```\n\n结果：\n\n| score | age  |\n| :---- | :--- |\n| 11    | 11   |\n| 123   | 123  |\n| 123   | 11   |\n\n#### 排序\n\n- 按单个列排序\n\n  ```sql\n  SELECT score FROM 'student' ORDER BY score\n  ```\n\n  | score |\n  | ----- |\n  | 11    |\n  | 11    |\n  | 123   |\n  | 123   |\n\n- 按多个列排序\n\n  会先按照第一列排序，如果第一列存在相同的会根据后面的列继续排列，换句话说就是当第一列所有数据全部不同，那么是不会根据后面的列再次排序的\n\n  ```sql\n  SELECT score, age FROM 'student' ORDER BY score, age\n  ```\n\n  | score | age  |\n  | ----- | ---- |\n  | 11    | 11   |\n  | 11    | 11   |\n  | 123   | 11   |\n  | 123   | 123  |\n\n- 指定排序方向\n\n  MySQL中默认为升序排序，如果想用降序排序需要指定DESC关键字，和DISTINCT不同的是DESC只会作用于它前面的列，想要每列都已降序排序就必须对每列都指定DESC关键字。\n\n  ```sql\n  SELECT score, age FROM 'student' ORDER BY score DESC，age\n  ```\n\n  | score | age  |\n  | ----- | ---- |\n  | 123   | 11   |\n  | 123   | 123  |\n  | 11    | 11   |\n  | 11    | 11   |\n\n- 排序规则\n\n  在对文本性的数据排序时，MySQL默认是不区分大小写的，即A和a相同，如果想要区分的话可能需要对数据库的设置做更改\n\n#### 过滤数据\n\n- WHERE语句的操作符\n\n  | 操作符        | 作用             |\n  | ------------- | ---------------- |\n  | =             | 等于             |\n  | <>            | 不等于           |\n  | !=            | 不等于           |\n  | <             |                  |\n  | <=            |                  |\n  | >             |                  |\n  | >=            |                  |\n  | BETWEEN… AND… | 在两个指定值之间 |\n\n- 匹配操作\n\n  MySQL在执行WHERE语句匹配时默认不区分大小写，Abc和abc是一样的\n\n  ```sql\n  select name from tbnaem where name='Abc';\n  select name from tbnaem where name='abc';\n  ```\n\n- 空值检查\n\n  NULL和0、空字符串是不同的，如果要匹配NULL需要用IS NULL子句实现\n\n  ```sql\n  select * from tbname where name IS NULL\n  ```\n\n- 组合过滤\n\n  - AND操作符\n\n    会对每个判断条件取与，满足所有条件才会返回\n\n  - OR操作符\n\n    满足任意一个条件即符合要求\n\n  - 同时使用AND和OR操作符\n\n    MySQL会优先处理AND操作符，例如 ：\n\n    ```sql\n    select name, price from tbname where id = 2 or id = 3 and price<10\n    ```\n\n    上面这个SQL语句会过滤出ID等于2或者ID等于3并且价格小于10的行，这显然和我们的意图不一样（ID等于2或者3，并且价格小于10）。为了解决这个问题，需使用圆括号将操作符分组区分开来，改为下面这种：\n\n    ```sql\n    select name, price from tbname where (id = 2 or id = 3) and price<10\n    ```\n\n    **因此在使用具有AND和OR操作符的where子句时，应当使用圆括号将操作符分组处理，不要依赖于默认的计算顺序以免出现错误。**\n\n- IN操作符\n\n  IN操作符可以指定条件范围，范围中的每个条件都可以进行匹配，类似于之前的OR操作符\n\n  ```sql\n  select name, price from tbname where id in (2,3)\n  ```\n\n  相交于OR操作符，在更多的过滤条件下显得更为简洁直观，会有比OR操作符更好的性能，另外IN操作符可以包含其他的SELECT语句：\n\n- NOT操作符\n\n  NOT操作符只有一个功能，否定它之后所跟的任何条件，例如IN、BETWEEN、EXISTS\n\n  ```sql\n  select name from tbname where id not in (2,3)\n  ```\n\n  选取ID不是2,3的行。\n\n- 通配符过滤（LIKE操作符）\n\n  - 百分号（%）通配符\n\n    %可以表示任何字符串出现任何次数，例如找到name是以`fml`开头的行\n\n    ```sql\n    select name from tbname where name LIKE 'fml%'\n    ```\n\n    或者包含abc的行\n\n    ```sql\n    select name from tbname where name LIKE '%abc%'\n    ```\n\n    或者以a开头c结尾的行\n\n    ```sql\n    select name from tbname where name LIKE 'a%c'\n    ```\n\n    **%看似可以匹配任何东西，但是NULL是例外的， LIKE  ‘’%‘’无法匹配值为NULL的行，另外值得注意的是尾空格可能也会干扰通配符的匹配**\n\n  - 下划线（_）通配符\n\n    _只能匹配单个字符其他的和%一样\n\n  - 技巧\n\n    1. 不要过度使用通配符，如果其他操作符能够实现同样的目的那么就使用其他操作符。\n    2. 除非是必要的，否则不要将通配符放在开始处，那样是最慢的\n\n- 使用正则表达式\n\n  使用正则表达式匹配的时候需要使用REGEXP关键字来代替LIKE，REGEXP后所跟的字符串就是正则表达式了。正则表达式怎么写就不在这说了\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/blogs-MySQL必知必会总结（一）.md","raw":"#### 去重\n\nMySQL中不能部分使用DISTINCT，DISTINCT关键字会应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT score,age，除非指定的两个列都不同，否则所有行都将被检索出来。\n\n例如如下的表\n\n| name  | score | age  |\n| ----- | ----- | ---- |\n| test1 | 11    | 11   |\n| test2 | 11    | 11   |\n| test3 | 123   | 123  |\n| test4 | 123   | 11   |\n\n```sql\nSELECT DISTINCT score ,age FROM `student` \n```\n\n结果：\n\n| score | age  |\n| :---- | :--- |\n| 11    | 11   |\n| 123   | 123  |\n| 123   | 11   |\n\n#### 排序\n\n- 按单个列排序\n\n  ```sql\n  SELECT score FROM 'student' ORDER BY score\n  ```\n\n  | score |\n  | ----- |\n  | 11    |\n  | 11    |\n  | 123   |\n  | 123   |\n\n- 按多个列排序\n\n  会先按照第一列排序，如果第一列存在相同的会根据后面的列继续排列，换句话说就是当第一列所有数据全部不同，那么是不会根据后面的列再次排序的\n\n  ```sql\n  SELECT score, age FROM 'student' ORDER BY score, age\n  ```\n\n  | score | age  |\n  | ----- | ---- |\n  | 11    | 11   |\n  | 11    | 11   |\n  | 123   | 11   |\n  | 123   | 123  |\n\n- 指定排序方向\n\n  MySQL中默认为升序排序，如果想用降序排序需要指定DESC关键字，和DISTINCT不同的是DESC只会作用于它前面的列，想要每列都已降序排序就必须对每列都指定DESC关键字。\n\n  ```sql\n  SELECT score, age FROM 'student' ORDER BY score DESC，age\n  ```\n\n  | score | age  |\n  | ----- | ---- |\n  | 123   | 11   |\n  | 123   | 123  |\n  | 11    | 11   |\n  | 11    | 11   |\n\n- 排序规则\n\n  在对文本性的数据排序时，MySQL默认是不区分大小写的，即A和a相同，如果想要区分的话可能需要对数据库的设置做更改\n\n#### 过滤数据\n\n- WHERE语句的操作符\n\n  | 操作符        | 作用             |\n  | ------------- | ---------------- |\n  | =             | 等于             |\n  | <>            | 不等于           |\n  | !=            | 不等于           |\n  | <             |                  |\n  | <=            |                  |\n  | >             |                  |\n  | >=            |                  |\n  | BETWEEN… AND… | 在两个指定值之间 |\n\n- 匹配操作\n\n  MySQL在执行WHERE语句匹配时默认不区分大小写，Abc和abc是一样的\n\n  ```sql\n  select name from tbnaem where name='Abc';\n  select name from tbnaem where name='abc';\n  ```\n\n- 空值检查\n\n  NULL和0、空字符串是不同的，如果要匹配NULL需要用IS NULL子句实现\n\n  ```sql\n  select * from tbname where name IS NULL\n  ```\n\n- 组合过滤\n\n  - AND操作符\n\n    会对每个判断条件取与，满足所有条件才会返回\n\n  - OR操作符\n\n    满足任意一个条件即符合要求\n\n  - 同时使用AND和OR操作符\n\n    MySQL会优先处理AND操作符，例如 ：\n\n    ```sql\n    select name, price from tbname where id = 2 or id = 3 and price<10\n    ```\n\n    上面这个SQL语句会过滤出ID等于2或者ID等于3并且价格小于10的行，这显然和我们的意图不一样（ID等于2或者3，并且价格小于10）。为了解决这个问题，需使用圆括号将操作符分组区分开来，改为下面这种：\n\n    ```sql\n    select name, price from tbname where (id = 2 or id = 3) and price<10\n    ```\n\n    **因此在使用具有AND和OR操作符的where子句时，应当使用圆括号将操作符分组处理，不要依赖于默认的计算顺序以免出现错误。**\n\n- IN操作符\n\n  IN操作符可以指定条件范围，范围中的每个条件都可以进行匹配，类似于之前的OR操作符\n\n  ```sql\n  select name, price from tbname where id in (2,3)\n  ```\n\n  相交于OR操作符，在更多的过滤条件下显得更为简洁直观，会有比OR操作符更好的性能，另外IN操作符可以包含其他的SELECT语句：\n\n- NOT操作符\n\n  NOT操作符只有一个功能，否定它之后所跟的任何条件，例如IN、BETWEEN、EXISTS\n\n  ```sql\n  select name from tbname where id not in (2,3)\n  ```\n\n  选取ID不是2,3的行。\n\n- 通配符过滤（LIKE操作符）\n\n  - 百分号（%）通配符\n\n    %可以表示任何字符串出现任何次数，例如找到name是以`fml`开头的行\n\n    ```sql\n    select name from tbname where name LIKE 'fml%'\n    ```\n\n    或者包含abc的行\n\n    ```sql\n    select name from tbname where name LIKE '%abc%'\n    ```\n\n    或者以a开头c结尾的行\n\n    ```sql\n    select name from tbname where name LIKE 'a%c'\n    ```\n\n    **%看似可以匹配任何东西，但是NULL是例外的， LIKE  ‘’%‘’无法匹配值为NULL的行，另外值得注意的是尾空格可能也会干扰通配符的匹配**\n\n  - 下划线（_）通配符\n\n    _只能匹配单个字符其他的和%一样\n\n  - 技巧\n\n    1. 不要过度使用通配符，如果其他操作符能够实现同样的目的那么就使用其他操作符。\n    2. 除非是必要的，否则不要将通配符放在开始处，那样是最慢的\n\n- 使用正则表达式\n\n  使用正则表达式匹配的时候需要使用REGEXP关键字来代替LIKE，REGEXP后所跟的字符串就是正则表达式了。正则表达式怎么写就不在这说了\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"blogs-MySQL必知必会总结（一）","published":1,"date":"2022-03-16T17:00:47.269Z","updated":"2022-03-16T17:05:36.580Z","_id":"cl0v6kevn001lyms4gzmpe28u","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"去重\"><a href=\"#去重\" class=\"headerlink\" title=\"去重\"></a>去重</h4><p>MySQL中不能部分使用DISTINCT，DISTINCT关键字会应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT score,age，除非指定的两个列都不同，否则所有行都将被检索出来。</p>\n<p>例如如下的表</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>score</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>test1</td>\n<td>11</td>\n<td>11</td>\n</tr>\n<tr>\n<td>test2</td>\n<td>11</td>\n<td>11</td>\n</tr>\n<tr>\n<td>test3</td>\n<td>123</td>\n<td>123</td>\n</tr>\n<tr>\n<td>test4</td>\n<td>123</td>\n<td>11</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> score ,age <span class=\"keyword\">FROM</span> `student` </span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">score</th>\n<th align=\"left\">age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">11</td>\n<td align=\"left\">11</td>\n</tr>\n<tr>\n<td align=\"left\">123</td>\n<td align=\"left\">123</td>\n</tr>\n<tr>\n<td align=\"left\">123</td>\n<td align=\"left\">11</td>\n</tr>\n</tbody></table>\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><ul>\n<li><p>按单个列排序</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> score <span class=\"keyword\">FROM</span> <span class=\"string\">&#x27;student&#x27;</span> <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> score</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>score</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>11</td>\n</tr>\n<tr>\n<td>11</td>\n</tr>\n<tr>\n<td>123</td>\n</tr>\n<tr>\n<td>123</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>按多个列排序</p>\n<p>会先按照第一列排序，如果第一列存在相同的会根据后面的列继续排列，换句话说就是当第一列所有数据全部不同，那么是不会根据后面的列再次排序的</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> score, age <span class=\"keyword\">FROM</span> <span class=\"string\">&#x27;student&#x27;</span> <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> score, age</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>score</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>11</td>\n<td>11</td>\n</tr>\n<tr>\n<td>11</td>\n<td>11</td>\n</tr>\n<tr>\n<td>123</td>\n<td>11</td>\n</tr>\n<tr>\n<td>123</td>\n<td>123</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>指定排序方向</p>\n<p>MySQL中默认为升序排序，如果想用降序排序需要指定DESC关键字，和DISTINCT不同的是DESC只会作用于它前面的列，想要每列都已降序排序就必须对每列都指定DESC关键字。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> score, age <span class=\"keyword\">FROM</span> <span class=\"string\">&#x27;student&#x27;</span> <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> score <span class=\"keyword\">DESC</span>，age</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>score</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>123</td>\n<td>11</td>\n</tr>\n<tr>\n<td>123</td>\n<td>123</td>\n</tr>\n<tr>\n<td>11</td>\n<td>11</td>\n</tr>\n<tr>\n<td>11</td>\n<td>11</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>排序规则</p>\n<p>在对文本性的数据排序时，MySQL默认是不区分大小写的，即A和a相同，如果想要区分的话可能需要对数据库的设置做更改</p>\n</li>\n</ul>\n<h4 id=\"过滤数据\"><a href=\"#过滤数据\" class=\"headerlink\" title=\"过滤数据\"></a>过滤数据</h4><ul>\n<li><p>WHERE语句的操作符</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>=</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>&lt;&gt;</td>\n<td>不等于</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不等于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td></td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td></td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td></td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td></td>\n</tr>\n<tr>\n<td>BETWEEN… AND…</td>\n<td>在两个指定值之间</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>匹配操作</p>\n<p>MySQL在执行WHERE语句匹配时默认不区分大小写，Abc和abc是一样的</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"keyword\">from</span> tbnaem <span class=\"keyword\">where</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;Abc&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"keyword\">from</span> tbnaem <span class=\"keyword\">where</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n<li><p>空值检查</p>\n<p>NULL和0、空字符串是不同的，如果要匹配NULL需要用IS NULL子句实现</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> name <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span></span><br></pre></td></tr></table></figure></li>\n<li><p>组合过滤</p>\n<ul>\n<li><p>AND操作符</p>\n<p>会对每个判断条件取与，满足所有条件才会返回</p>\n</li>\n<li><p>OR操作符</p>\n<p>满足任意一个条件即符合要求</p>\n</li>\n<li><p>同时使用AND和OR操作符</p>\n<p>MySQL会优先处理AND操作符，例如 ：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name, price <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">or</span> id <span class=\"operator\">=</span> <span class=\"number\">3</span> <span class=\"keyword\">and</span> price<span class=\"operator\">&lt;</span><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<p>上面这个SQL语句会过滤出ID等于2或者ID等于3并且价格小于10的行，这显然和我们的意图不一样（ID等于2或者3，并且价格小于10）。为了解决这个问题，需使用圆括号将操作符分组区分开来，改为下面这种：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name, price <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> (id <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">or</span> id <span class=\"operator\">=</span> <span class=\"number\">3</span>) <span class=\"keyword\">and</span> price<span class=\"operator\">&lt;</span><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>因此在使用具有AND和OR操作符的where子句时，应当使用圆括号将操作符分组处理，不要依赖于默认的计算顺序以免出现错误。</strong></p>\n</li>\n</ul>\n</li>\n<li><p>IN操作符</p>\n<p>IN操作符可以指定条件范围，范围中的每个条件都可以进行匹配，类似于之前的OR操作符</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name, price <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> id <span class=\"keyword\">in</span> (<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<p>相交于OR操作符，在更多的过滤条件下显得更为简洁直观，会有比OR操作符更好的性能，另外IN操作符可以包含其他的SELECT语句：</p>\n</li>\n<li><p>NOT操作符</p>\n<p>NOT操作符只有一个功能，否定它之后所跟的任何条件，例如IN、BETWEEN、EXISTS</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> id <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> (<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<p>选取ID不是2,3的行。</p>\n</li>\n<li><p>通配符过滤（LIKE操作符）</p>\n<ul>\n<li><p>百分号（%）通配符</p>\n<p>%可以表示任何字符串出现任何次数，例如找到name是以<code>fml</code>开头的行</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> name <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;fml%&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>或者包含abc的行</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> name <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%abc%&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>或者以a开头c结尾的行</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> name <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;a%c&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>%看似可以匹配任何东西，但是NULL是例外的， LIKE  ‘’%‘’无法匹配值为NULL的行，另外值得注意的是尾空格可能也会干扰通配符的匹配</strong></p>\n</li>\n<li><p>下划线（_）通配符</p>\n<p>_只能匹配单个字符其他的和%一样</p>\n</li>\n<li><p>技巧</p>\n<ol>\n<li>不要过度使用通配符，如果其他操作符能够实现同样的目的那么就使用其他操作符。</li>\n<li>除非是必要的，否则不要将通配符放在开始处，那样是最慢的</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>使用正则表达式</p>\n<p>使用正则表达式匹配的时候需要使用REGEXP关键字来代替LIKE，REGEXP后所跟的字符串就是正则表达式了。正则表达式怎么写就不在这说了</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"去重\"><a href=\"#去重\" class=\"headerlink\" title=\"去重\"></a>去重</h4><p>MySQL中不能部分使用DISTINCT，DISTINCT关键字会应用于所有列而不仅是前置它的列。如果给出SELECT DISTINCT score,age，除非指定的两个列都不同，否则所有行都将被检索出来。</p>\n<p>例如如下的表</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>score</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>test1</td>\n<td>11</td>\n<td>11</td>\n</tr>\n<tr>\n<td>test2</td>\n<td>11</td>\n<td>11</td>\n</tr>\n<tr>\n<td>test3</td>\n<td>123</td>\n<td>123</td>\n</tr>\n<tr>\n<td>test4</td>\n<td>123</td>\n<td>11</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> score ,age <span class=\"keyword\">FROM</span> `student` </span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">score</th>\n<th align=\"left\">age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">11</td>\n<td align=\"left\">11</td>\n</tr>\n<tr>\n<td align=\"left\">123</td>\n<td align=\"left\">123</td>\n</tr>\n<tr>\n<td align=\"left\">123</td>\n<td align=\"left\">11</td>\n</tr>\n</tbody></table>\n<h4 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h4><ul>\n<li><p>按单个列排序</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> score <span class=\"keyword\">FROM</span> <span class=\"string\">&#x27;student&#x27;</span> <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> score</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>score</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>11</td>\n</tr>\n<tr>\n<td>11</td>\n</tr>\n<tr>\n<td>123</td>\n</tr>\n<tr>\n<td>123</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>按多个列排序</p>\n<p>会先按照第一列排序，如果第一列存在相同的会根据后面的列继续排列，换句话说就是当第一列所有数据全部不同，那么是不会根据后面的列再次排序的</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> score, age <span class=\"keyword\">FROM</span> <span class=\"string\">&#x27;student&#x27;</span> <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> score, age</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>score</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>11</td>\n<td>11</td>\n</tr>\n<tr>\n<td>11</td>\n<td>11</td>\n</tr>\n<tr>\n<td>123</td>\n<td>11</td>\n</tr>\n<tr>\n<td>123</td>\n<td>123</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>指定排序方向</p>\n<p>MySQL中默认为升序排序，如果想用降序排序需要指定DESC关键字，和DISTINCT不同的是DESC只会作用于它前面的列，想要每列都已降序排序就必须对每列都指定DESC关键字。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> score, age <span class=\"keyword\">FROM</span> <span class=\"string\">&#x27;student&#x27;</span> <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> score <span class=\"keyword\">DESC</span>，age</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>score</th>\n<th>age</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>123</td>\n<td>11</td>\n</tr>\n<tr>\n<td>123</td>\n<td>123</td>\n</tr>\n<tr>\n<td>11</td>\n<td>11</td>\n</tr>\n<tr>\n<td>11</td>\n<td>11</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>排序规则</p>\n<p>在对文本性的数据排序时，MySQL默认是不区分大小写的，即A和a相同，如果想要区分的话可能需要对数据库的设置做更改</p>\n</li>\n</ul>\n<h4 id=\"过滤数据\"><a href=\"#过滤数据\" class=\"headerlink\" title=\"过滤数据\"></a>过滤数据</h4><ul>\n<li><p>WHERE语句的操作符</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>=</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>&lt;&gt;</td>\n<td>不等于</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>不等于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td></td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td></td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td></td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td></td>\n</tr>\n<tr>\n<td>BETWEEN… AND…</td>\n<td>在两个指定值之间</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>匹配操作</p>\n<p>MySQL在执行WHERE语句匹配时默认不区分大小写，Abc和abc是一样的</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"keyword\">from</span> tbnaem <span class=\"keyword\">where</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;Abc&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"keyword\">from</span> tbnaem <span class=\"keyword\">where</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure></li>\n<li><p>空值检查</p>\n<p>NULL和0、空字符串是不同的，如果要匹配NULL需要用IS NULL子句实现</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> name <span class=\"keyword\">IS</span> <span class=\"keyword\">NULL</span></span><br></pre></td></tr></table></figure></li>\n<li><p>组合过滤</p>\n<ul>\n<li><p>AND操作符</p>\n<p>会对每个判断条件取与，满足所有条件才会返回</p>\n</li>\n<li><p>OR操作符</p>\n<p>满足任意一个条件即符合要求</p>\n</li>\n<li><p>同时使用AND和OR操作符</p>\n<p>MySQL会优先处理AND操作符，例如 ：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name, price <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> id <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">or</span> id <span class=\"operator\">=</span> <span class=\"number\">3</span> <span class=\"keyword\">and</span> price<span class=\"operator\">&lt;</span><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<p>上面这个SQL语句会过滤出ID等于2或者ID等于3并且价格小于10的行，这显然和我们的意图不一样（ID等于2或者3，并且价格小于10）。为了解决这个问题，需使用圆括号将操作符分组区分开来，改为下面这种：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name, price <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> (id <span class=\"operator\">=</span> <span class=\"number\">2</span> <span class=\"keyword\">or</span> id <span class=\"operator\">=</span> <span class=\"number\">3</span>) <span class=\"keyword\">and</span> price<span class=\"operator\">&lt;</span><span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>因此在使用具有AND和OR操作符的where子句时，应当使用圆括号将操作符分组处理，不要依赖于默认的计算顺序以免出现错误。</strong></p>\n</li>\n</ul>\n</li>\n<li><p>IN操作符</p>\n<p>IN操作符可以指定条件范围，范围中的每个条件都可以进行匹配，类似于之前的OR操作符</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name, price <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> id <span class=\"keyword\">in</span> (<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<p>相交于OR操作符，在更多的过滤条件下显得更为简洁直观，会有比OR操作符更好的性能，另外IN操作符可以包含其他的SELECT语句：</p>\n</li>\n<li><p>NOT操作符</p>\n<p>NOT操作符只有一个功能，否定它之后所跟的任何条件，例如IN、BETWEEN、EXISTS</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> id <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> (<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n\n<p>选取ID不是2,3的行。</p>\n</li>\n<li><p>通配符过滤（LIKE操作符）</p>\n<ul>\n<li><p>百分号（%）通配符</p>\n<p>%可以表示任何字符串出现任何次数，例如找到name是以<code>fml</code>开头的行</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> name <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;fml%&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>或者包含abc的行</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> name <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;%abc%&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>或者以a开头c结尾的行</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name <span class=\"keyword\">from</span> tbname <span class=\"keyword\">where</span> name <span class=\"keyword\">LIKE</span> <span class=\"string\">&#x27;a%c&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>%看似可以匹配任何东西，但是NULL是例外的， LIKE  ‘’%‘’无法匹配值为NULL的行，另外值得注意的是尾空格可能也会干扰通配符的匹配</strong></p>\n</li>\n<li><p>下划线（_）通配符</p>\n<p>_只能匹配单个字符其他的和%一样</p>\n</li>\n<li><p>技巧</p>\n<ol>\n<li>不要过度使用通配符，如果其他操作符能够实现同样的目的那么就使用其他操作符。</li>\n<li>除非是必要的，否则不要将通配符放在开始处，那样是最慢的</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p>使用正则表达式</p>\n<p>使用正则表达式匹配的时候需要使用REGEXP关键字来代替LIKE，REGEXP后所跟的字符串就是正则表达式了。正则表达式怎么写就不在这说了</p>\n</li>\n</ul>\n"},{"_content":"\n<h3>连接数据库</h3>\n<p>导入库文件</p>\n<p><pre name=\"code\" class=\"python\">from PyQt5 import QtSql\nfrom PyQt5.QtSql import QSqlQuery</pre><br>\nQtSql类即QT中的QSqlDatabase类，用于处理与数据库的连接</p>\n<p>QSqlQuery类提供了执行和操作SQL语句打方法</p>\n<p><br>\n</p>\n<p>第一步连接sqlite数据库</p>\n<p><pre name=\"code\" class=\"python\">database = QtSql.QSqlDatabase.addDatabase('QSQLITE')\ndatabase.setDatabaseName('test.db')\n</pre>没有test.db这个文件的时候则会在当前目录新建一个test.db文件</p>\n<p>打开数据库，打开成功返回True</p>\n<p><pre name=\"code\" class=\"python\">database.open()</pre></p>\n<p><br>\n</p>\n<h3>新建表</h3>\n<div>建立一个名为student的表，包含id,name,age三个属性，其中ID为主键</div>\n<div><br>\n</div>\n<p><pre name=\"code\" class=\"python\">query.prepare('create table student (id int primary key, name varchar(30),age int)')\nif not query.exec_():\n    query.lastError()\nelse:\n    print('create a table')</pre></p>\n<h3>插入数据</h3>\n<div>addBindValue()将&#20540;添加到列表中，调用顺序决定添加的顺序</div>\n<div><pre name=\"code\" class=\"python\">insert_sql = 'insert into student values (?,?,?)'\nquery.prepare(insert_sql)\nquery.addBindValue(4)\nquery.addBindValue('test3')\nquery.addBindValue(1)\nif not query.exec_():\n    print(query.lastError())\nelse:\n    print('inserted')</pre><br>\n<br>\n</div>\n<h3>查询</h3>\n查询返回数据使用value(int)函数，例如select id,name,age from student&nbsp; &nbsp;value(0)等于返回id属性的&#20540;，value(2)等于age属性\n<p>exec_()查询成功返回true查询 否则返回false</p>\n<p><pre name=\"code\" class=\"python\">query.prepare('select id,name,age from student')\nif not query.exec_():\n    query.lastError()\nelse:\n    while query.next():\n        id = query.value(0)\n        name = query.value(1)\n        age = query.value(2)\n        print(id,name,age)</pre></p>\n<p>可以通过record().indexOf(str)来获取索引&#20540;，<br>\n</p>\n<p><pre name=\"code\" class=\"python\">if query.exec('select id ,name,age from student'):\n    id_index = query.record().indexOf('id')\n    name_index = query.record().indexOf('name')\n    age_index = query.record().indexOf('age')\n    while query.next():\n        id = query.value(id_index)\n        name = query.value(name_index)\n        age = query.value(age_index)\n        print(id, name, age)\n</pre><br>\n<br>\n</p>\n<p><br>\n</p>\n<p><br>\n</p>\n<p>一：使用exec()操作</p>\n<p>指令执行成功则&nbsp;exec_()会返回True并把查询状态设为活跃状态，否则返回false</p>\n<p>另外对于SQLite，查询字符串一次只能包含一条语句。如果给出多个语句，则函数返回false</p>\n<p></p>\n<p><pre name=\"code\" class=\"python\">if query.exec('select id ,name,age from student'):\n    while query.next():\n        id = query.value(0)\n        name = query.value(1)\n        age = query.value(2)\n        print(id, name, age)\n</pre></p>\n<p><br>\n</p>\n二：execBatch()操作\n<p>这个函数是批处理之前准备好的指令，如果数据库不支持批处理他会自己调用exec()来模拟</p>\n<p><pre name=\"code\" class=\"python\">query.prepare('insert into student values (?,?,?)')\nquery.addBindValue([6,7,8])\nquery.addBindValue(['test5','test6','test7'])\nquery.addBindValue([1,1,1])\nif query.execBatch():\n    print(&quot;inserted &quot;)</pre><br>\n</p>\n<p>三：executedQuery()返回最后一个执行成功的指令</p>\n<p><pre name=\"code\" class=\"python\">if query.exec('select id ,name,age from student'):\n    while query.next():\n        id = query.value(0)\n        name = query.value(1)\n        age = query.value(2)\n        print(id, name, age)\n        \nprint(query.executedQuery())</pre>执行结果为：select id ,name,age from student</p>\n<p><br>\n</p>\n<p>四：&nbsp;其他</p>\n<p>finish()终止当前的操作</p>\n<p>isActive()返回当前是否处于活跃状态<br>\nisNull(int&nbsp;field)返回当前是否不活跃</p>\n<p>isSelect()返回是不是一个查询语句</p>\nnext()检索结果中的下一条记录（如果可用），并将查询放在检索到的记录上。请注意，结果必须处于活动状态，并且在调用此函数之前，isSelect（）必须返回true，否则它将不执行任何操作并返回false。\n<p><br>\n</p>\n<div style=\"top:393px\">指令执行成功则&nbsp;exec_()会返回True并把查询状态设为活跃状态，否则返回false</div>\n","source":"_posts/blogs-PyQt5之SQLite数据库操作（1）.md","raw":"\n<h3>连接数据库</h3>\n<p>导入库文件</p>\n<p><pre name=\"code\" class=\"python\">from PyQt5 import QtSql\nfrom PyQt5.QtSql import QSqlQuery</pre><br>\nQtSql类即QT中的QSqlDatabase类，用于处理与数据库的连接</p>\n<p>QSqlQuery类提供了执行和操作SQL语句打方法</p>\n<p><br>\n</p>\n<p>第一步连接sqlite数据库</p>\n<p><pre name=\"code\" class=\"python\">database = QtSql.QSqlDatabase.addDatabase('QSQLITE')\ndatabase.setDatabaseName('test.db')\n</pre>没有test.db这个文件的时候则会在当前目录新建一个test.db文件</p>\n<p>打开数据库，打开成功返回True</p>\n<p><pre name=\"code\" class=\"python\">database.open()</pre></p>\n<p><br>\n</p>\n<h3>新建表</h3>\n<div>建立一个名为student的表，包含id,name,age三个属性，其中ID为主键</div>\n<div><br>\n</div>\n<p><pre name=\"code\" class=\"python\">query.prepare('create table student (id int primary key, name varchar(30),age int)')\nif not query.exec_():\n    query.lastError()\nelse:\n    print('create a table')</pre></p>\n<h3>插入数据</h3>\n<div>addBindValue()将&#20540;添加到列表中，调用顺序决定添加的顺序</div>\n<div><pre name=\"code\" class=\"python\">insert_sql = 'insert into student values (?,?,?)'\nquery.prepare(insert_sql)\nquery.addBindValue(4)\nquery.addBindValue('test3')\nquery.addBindValue(1)\nif not query.exec_():\n    print(query.lastError())\nelse:\n    print('inserted')</pre><br>\n<br>\n</div>\n<h3>查询</h3>\n查询返回数据使用value(int)函数，例如select id,name,age from student&nbsp; &nbsp;value(0)等于返回id属性的&#20540;，value(2)等于age属性\n<p>exec_()查询成功返回true查询 否则返回false</p>\n<p><pre name=\"code\" class=\"python\">query.prepare('select id,name,age from student')\nif not query.exec_():\n    query.lastError()\nelse:\n    while query.next():\n        id = query.value(0)\n        name = query.value(1)\n        age = query.value(2)\n        print(id,name,age)</pre></p>\n<p>可以通过record().indexOf(str)来获取索引&#20540;，<br>\n</p>\n<p><pre name=\"code\" class=\"python\">if query.exec('select id ,name,age from student'):\n    id_index = query.record().indexOf('id')\n    name_index = query.record().indexOf('name')\n    age_index = query.record().indexOf('age')\n    while query.next():\n        id = query.value(id_index)\n        name = query.value(name_index)\n        age = query.value(age_index)\n        print(id, name, age)\n</pre><br>\n<br>\n</p>\n<p><br>\n</p>\n<p><br>\n</p>\n<p>一：使用exec()操作</p>\n<p>指令执行成功则&nbsp;exec_()会返回True并把查询状态设为活跃状态，否则返回false</p>\n<p>另外对于SQLite，查询字符串一次只能包含一条语句。如果给出多个语句，则函数返回false</p>\n<p></p>\n<p><pre name=\"code\" class=\"python\">if query.exec('select id ,name,age from student'):\n    while query.next():\n        id = query.value(0)\n        name = query.value(1)\n        age = query.value(2)\n        print(id, name, age)\n</pre></p>\n<p><br>\n</p>\n二：execBatch()操作\n<p>这个函数是批处理之前准备好的指令，如果数据库不支持批处理他会自己调用exec()来模拟</p>\n<p><pre name=\"code\" class=\"python\">query.prepare('insert into student values (?,?,?)')\nquery.addBindValue([6,7,8])\nquery.addBindValue(['test5','test6','test7'])\nquery.addBindValue([1,1,1])\nif query.execBatch():\n    print(&quot;inserted &quot;)</pre><br>\n</p>\n<p>三：executedQuery()返回最后一个执行成功的指令</p>\n<p><pre name=\"code\" class=\"python\">if query.exec('select id ,name,age from student'):\n    while query.next():\n        id = query.value(0)\n        name = query.value(1)\n        age = query.value(2)\n        print(id, name, age)\n        \nprint(query.executedQuery())</pre>执行结果为：select id ,name,age from student</p>\n<p><br>\n</p>\n<p>四：&nbsp;其他</p>\n<p>finish()终止当前的操作</p>\n<p>isActive()返回当前是否处于活跃状态<br>\nisNull(int&nbsp;field)返回当前是否不活跃</p>\n<p>isSelect()返回是不是一个查询语句</p>\nnext()检索结果中的下一条记录（如果可用），并将查询放在检索到的记录上。请注意，结果必须处于活动状态，并且在调用此函数之前，isSelect（）必须返回true，否则它将不执行任何操作并返回false。\n<p><br>\n</p>\n<div style=\"top:393px\">指令执行成功则&nbsp;exec_()会返回True并把查询状态设为活跃状态，否则返回false</div>\n","slug":"blogs-PyQt5之SQLite数据库操作（1）","published":1,"date":"2022-03-16T17:09:34.215Z","updated":"2022-03-16T17:09:34.215Z","_id":"cl0v6kevn001myms4ftha1309","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>连接数据库</h3>\n<p>导入库文件</p>\n<p><pre name=\"code\" class=\"python\">from PyQt5 import QtSql\nfrom PyQt5.QtSql import QSqlQuery</pre><br>\nQtSql类即QT中的QSqlDatabase类，用于处理与数据库的连接</p>\n<p>QSqlQuery类提供了执行和操作SQL语句打方法</p>\n<p><br>\n</p>\n<p>第一步连接sqlite数据库</p>\n<p><pre name=\"code\" class=\"python\">database = QtSql.QSqlDatabase.addDatabase('QSQLITE')\ndatabase.setDatabaseName('test.db')\n</pre>没有test.db这个文件的时候则会在当前目录新建一个test.db文件</p>\n<p>打开数据库，打开成功返回True</p>\n<p><pre name=\"code\" class=\"python\">database.open()</pre></p>\n<p><br>\n</p>\n<h3>新建表</h3>\n<div>建立一个名为student的表，包含id,name,age三个属性，其中ID为主键</div>\n<div><br>\n</div>\n<p><pre name=\"code\" class=\"python\">query.prepare('create table student (id int primary key, name varchar(30),age int)')\nif not query.exec_():\n    query.lastError()\nelse:\n    print('create a table')</pre></p>\n<h3>插入数据</h3>\n<div>addBindValue()将&#20540;添加到列表中，调用顺序决定添加的顺序</div>\n<div><pre name=\"code\" class=\"python\">insert_sql = 'insert into student values (?,?,?)'\nquery.prepare(insert_sql)\nquery.addBindValue(4)\nquery.addBindValue('test3')\nquery.addBindValue(1)\nif not query.exec_():\n    print(query.lastError())\nelse:\n    print('inserted')</pre><br>\n<br>\n</div>\n<h3>查询</h3>\n查询返回数据使用value(int)函数，例如select id,name,age from student&nbsp; &nbsp;value(0)等于返回id属性的&#20540;，value(2)等于age属性\n<p>exec_()查询成功返回true查询 否则返回false</p>\n<p><pre name=\"code\" class=\"python\">query.prepare('select id,name,age from student')\nif not query.exec_():\n    query.lastError()\nelse:\n    while query.next():\n        id = query.value(0)\n        name = query.value(1)\n        age = query.value(2)\n        print(id,name,age)</pre></p>\n<p>可以通过record().indexOf(str)来获取索引&#20540;，<br>\n</p>\n<p><pre name=\"code\" class=\"python\">if query.exec('select id ,name,age from student'):\n    id_index = query.record().indexOf('id')\n    name_index = query.record().indexOf('name')\n    age_index = query.record().indexOf('age')\n    while query.next():\n        id = query.value(id_index)\n        name = query.value(name_index)\n        age = query.value(age_index)\n        print(id, name, age)\n</pre><br>\n<br>\n</p>\n<p><br>\n</p>\n<p><br>\n</p>\n<p>一：使用exec()操作</p>\n<p>指令执行成功则&nbsp;exec_()会返回True并把查询状态设为活跃状态，否则返回false</p>\n<p>另外对于SQLite，查询字符串一次只能包含一条语句。如果给出多个语句，则函数返回false</p>\n<p></p>\n<p><pre name=\"code\" class=\"python\">if query.exec('select id ,name,age from student'):\n    while query.next():\n        id = query.value(0)\n        name = query.value(1)\n        age = query.value(2)\n        print(id, name, age)\n</pre></p>\n<p><br>\n</p>\n二：execBatch()操作\n<p>这个函数是批处理之前准备好的指令，如果数据库不支持批处理他会自己调用exec()来模拟</p>\n<p><pre name=\"code\" class=\"python\">query.prepare('insert into student values (?,?,?)')\nquery.addBindValue([6,7,8])\nquery.addBindValue(['test5','test6','test7'])\nquery.addBindValue([1,1,1])\nif query.execBatch():\n    print(&quot;inserted &quot;)</pre><br>\n</p>\n<p>三：executedQuery()返回最后一个执行成功的指令</p>\n<p><pre name=\"code\" class=\"python\">if query.exec('select id ,name,age from student'):\n    while query.next():\n        id = query.value(0)\n        name = query.value(1)\n        age = query.value(2)\n        print(id, name, age)\n        \n<p>print(query.executedQuery())</pre>执行结果为：select id ,name,age from student</p></p>\n<p><br>\n</p>\n<p>四：&nbsp;其他</p>\n<p>finish()终止当前的操作</p>\n<p>isActive()返回当前是否处于活跃状态<br>\nisNull(int&nbsp;field)返回当前是否不活跃</p>\n<p>isSelect()返回是不是一个查询语句</p>\nnext()检索结果中的下一条记录（如果可用），并将查询放在检索到的记录上。请注意，结果必须处于活动状态，并且在调用此函数之前，isSelect（）必须返回true，否则它将不执行任何操作并返回false。\n<p><br>\n</p>\n<div style=\"top:393px\">指令执行成功则&nbsp;exec_()会返回True并把查询状态设为活跃状态，否则返回false</div>\n","site":{"data":{}},"excerpt":"","more":"<h3>连接数据库</h3>\n<p>导入库文件</p>\n<p><pre name=\"code\" class=\"python\">from PyQt5 import QtSql\nfrom PyQt5.QtSql import QSqlQuery</pre><br>\nQtSql类即QT中的QSqlDatabase类，用于处理与数据库的连接</p>\n<p>QSqlQuery类提供了执行和操作SQL语句打方法</p>\n<p><br>\n</p>\n<p>第一步连接sqlite数据库</p>\n<p><pre name=\"code\" class=\"python\">database = QtSql.QSqlDatabase.addDatabase('QSQLITE')\ndatabase.setDatabaseName('test.db')\n</pre>没有test.db这个文件的时候则会在当前目录新建一个test.db文件</p>\n<p>打开数据库，打开成功返回True</p>\n<p><pre name=\"code\" class=\"python\">database.open()</pre></p>\n<p><br>\n</p>\n<h3>新建表</h3>\n<div>建立一个名为student的表，包含id,name,age三个属性，其中ID为主键</div>\n<div><br>\n</div>\n<p><pre name=\"code\" class=\"python\">query.prepare('create table student (id int primary key, name varchar(30),age int)')\nif not query.exec_():\n    query.lastError()\nelse:\n    print('create a table')</pre></p>\n<h3>插入数据</h3>\n<div>addBindValue()将&#20540;添加到列表中，调用顺序决定添加的顺序</div>\n<div><pre name=\"code\" class=\"python\">insert_sql = 'insert into student values (?,?,?)'\nquery.prepare(insert_sql)\nquery.addBindValue(4)\nquery.addBindValue('test3')\nquery.addBindValue(1)\nif not query.exec_():\n    print(query.lastError())\nelse:\n    print('inserted')</pre><br>\n<br>\n</div>\n<h3>查询</h3>\n查询返回数据使用value(int)函数，例如select id,name,age from student&nbsp; &nbsp;value(0)等于返回id属性的&#20540;，value(2)等于age属性\n<p>exec_()查询成功返回true查询 否则返回false</p>\n<p><pre name=\"code\" class=\"python\">query.prepare('select id,name,age from student')\nif not query.exec_():\n    query.lastError()\nelse:\n    while query.next():\n        id = query.value(0)\n        name = query.value(1)\n        age = query.value(2)\n        print(id,name,age)</pre></p>\n<p>可以通过record().indexOf(str)来获取索引&#20540;，<br>\n</p>\n<p><pre name=\"code\" class=\"python\">if query.exec('select id ,name,age from student'):\n    id_index = query.record().indexOf('id')\n    name_index = query.record().indexOf('name')\n    age_index = query.record().indexOf('age')\n    while query.next():\n        id = query.value(id_index)\n        name = query.value(name_index)\n        age = query.value(age_index)\n        print(id, name, age)\n</pre><br>\n<br>\n</p>\n<p><br>\n</p>\n<p><br>\n</p>\n<p>一：使用exec()操作</p>\n<p>指令执行成功则&nbsp;exec_()会返回True并把查询状态设为活跃状态，否则返回false</p>\n<p>另外对于SQLite，查询字符串一次只能包含一条语句。如果给出多个语句，则函数返回false</p>\n<p></p>\n<p><pre name=\"code\" class=\"python\">if query.exec('select id ,name,age from student'):\n    while query.next():\n        id = query.value(0)\n        name = query.value(1)\n        age = query.value(2)\n        print(id, name, age)\n</pre></p>\n<p><br>\n</p>\n二：execBatch()操作\n<p>这个函数是批处理之前准备好的指令，如果数据库不支持批处理他会自己调用exec()来模拟</p>\n<p><pre name=\"code\" class=\"python\">query.prepare('insert into student values (?,?,?)')\nquery.addBindValue([6,7,8])\nquery.addBindValue(['test5','test6','test7'])\nquery.addBindValue([1,1,1])\nif query.execBatch():\n    print(&quot;inserted &quot;)</pre><br>\n</p>\n<p>三：executedQuery()返回最后一个执行成功的指令</p>\n<p><pre name=\"code\" class=\"python\">if query.exec('select id ,name,age from student'):\n    while query.next():\n        id = query.value(0)\n        name = query.value(1)\n        age = query.value(2)\n        print(id, name, age)\n        \n<p>print(query.executedQuery())</pre>执行结果为：select id ,name,age from student</p></p>\n<p><br>\n</p>\n<p>四：&nbsp;其他</p>\n<p>finish()终止当前的操作</p>\n<p>isActive()返回当前是否处于活跃状态<br>\nisNull(int&nbsp;field)返回当前是否不活跃</p>\n<p>isSelect()返回是不是一个查询语句</p>\nnext()检索结果中的下一条记录（如果可用），并将查询放在检索到的记录上。请注意，结果必须处于活动状态，并且在调用此函数之前，isSelect（）必须返回true，否则它将不执行任何操作并返回false。\n<p><br>\n</p>\n<div style=\"top:393px\">指令执行成功则&nbsp;exec_()会返回True并把查询状态设为活跃状态，否则返回false</div>\n"},{"_content":"<p>使用QMoive方法实现</p>\n\n<p>导入库文件</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from PyQt5 import QtCore, QtGui, QtWidgets\nfrom PyQt5.QtGui import QMovie</code></pre>\n\n<p><br />\n创建一个带label控件的窗口，label作为GIF的显示窗体</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(\"Form\")\n        Form.resize(517, 361)\n        self.label = QtWidgets.QLabel(Form)\n        self.label.setGeometry(QtCore.QRect(0, 0, 500, 300))\n        self.label.setObjectName(\"label\")\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(\"Form\", \"Form\"))</code></pre>\n\n<p><br />\n在setupUi()函数里面加入</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">self.gif = QMovie('qq.gif')\nself.label.setMovie(self.gif)\nself.gif.start()</code></pre>\n\n<p>第一行 实例化一个QMovie对象，传入GIF图片地址</p>\n\n<p>第二行 使用label的setMovie方法导入QMovie对象</p>\n\n<p>第三行 开始播放GIF动画</p>\n\n<p> </p>\n\n<p>效果图：</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180303221947962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" /></p>\n\n<p> </p>\n\n<p>PyQt的一些其他功能<br />\n#设置窗体无边框<br />\nself.setWindowFlags(Qt.FramelessWindowHint)</p>\n\n<p># 设置背景透明<br />\n# self.setAttribute(Qt.WA_TranslucentBackground)</p>\n\n<p># 显示输入对话框<br />\n# 字符串类型，标题、提示信息、默认输入<br />\n# text,ok=QInputDialog.getText(self, \"title\", \"User name:\", QLineEdit.Normal, '&gt;&gt;&gt;:')</p>\n\n<p># 整型类型  标题、提示信息、默认值，（最小值，最大值）可选<br />\n# num,ok = QInputDialog.getInt(self,\"输入整数\",'输入0-100范围内的数字',30,0,100)</p>\n\n<p><br />\n# 下拉框<br />\n# my_list = ['1','2','3']<br />\n# my_str,ok = QInputDialog.getItem(self,\"下拉框\",'提示',my_list)<br />\n </p>","source":"_posts/blogs-PyQt5显示GIF图片.md","raw":"<p>使用QMoive方法实现</p>\n\n<p>导入库文件</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from PyQt5 import QtCore, QtGui, QtWidgets\nfrom PyQt5.QtGui import QMovie</code></pre>\n\n<p><br />\n创建一个带label控件的窗口，label作为GIF的显示窗体</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(\"Form\")\n        Form.resize(517, 361)\n        self.label = QtWidgets.QLabel(Form)\n        self.label.setGeometry(QtCore.QRect(0, 0, 500, 300))\n        self.label.setObjectName(\"label\")\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(\"Form\", \"Form\"))</code></pre>\n\n<p><br />\n在setupUi()函数里面加入</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">self.gif = QMovie('qq.gif')\nself.label.setMovie(self.gif)\nself.gif.start()</code></pre>\n\n<p>第一行 实例化一个QMovie对象，传入GIF图片地址</p>\n\n<p>第二行 使用label的setMovie方法导入QMovie对象</p>\n\n<p>第三行 开始播放GIF动画</p>\n\n<p> </p>\n\n<p>效果图：</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180303221947962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" /></p>\n\n<p> </p>\n\n<p>PyQt的一些其他功能<br />\n#设置窗体无边框<br />\nself.setWindowFlags(Qt.FramelessWindowHint)</p>\n\n<p># 设置背景透明<br />\n# self.setAttribute(Qt.WA_TranslucentBackground)</p>\n\n<p># 显示输入对话框<br />\n# 字符串类型，标题、提示信息、默认输入<br />\n# text,ok=QInputDialog.getText(self, \"title\", \"User name:\", QLineEdit.Normal, '&gt;&gt;&gt;:')</p>\n\n<p># 整型类型  标题、提示信息、默认值，（最小值，最大值）可选<br />\n# num,ok = QInputDialog.getInt(self,\"输入整数\",'输入0-100范围内的数字',30,0,100)</p>\n\n<p><br />\n# 下拉框<br />\n# my_list = ['1','2','3']<br />\n# my_str,ok = QInputDialog.getItem(self,\"下拉框\",'提示',my_list)<br />\n </p>","slug":"blogs-PyQt5显示GIF图片","published":1,"date":"2022-03-16T17:09:36.621Z","updated":"2022-03-16T17:09:36.621Z","_id":"cl0v6kevo001nyms41by7819m","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>使用QMoive方法实现</p>\n\n<p>导入库文件</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from PyQt5 import QtCore, QtGui, QtWidgets\nfrom PyQt5.QtGui import QMovie</code></pre>\n\n<p><br />\n创建一个带label控件的窗口，label作为GIF的显示窗体</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(\"Form\")\n        Form.resize(517, 361)\n        self.label = QtWidgets.QLabel(Form)\n        self.label.setGeometry(QtCore.QRect(0, 0, 500, 300))\n        self.label.setObjectName(\"label\")\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(\"Form\", \"Form\"))</code></pre>\n\n<p><br />\n在setupUi()函数里面加入</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">self.gif = QMovie('qq.gif')\nself.label.setMovie(self.gif)\nself.gif.start()</code></pre>\n\n<p>第一行 实例化一个QMovie对象，传入GIF图片地址</p>\n\n<p>第二行 使用label的setMovie方法导入QMovie对象</p>\n\n<p>第三行 开始播放GIF动画</p>\n\n<p> </p>\n\n<p>效果图：</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180303221947962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" /></p>\n\n<p> </p>\n\n<p>PyQt的一些其他功能<br />\n#设置窗体无边框<br />\nself.setWindowFlags(Qt.FramelessWindowHint)</p>\n\n<p># 设置背景透明<br />\n# self.setAttribute(Qt.WA_TranslucentBackground)</p>\n\n<p># 显示输入对话框<br />\n# 字符串类型，标题、提示信息、默认输入<br />\n# text,ok=QInputDialog.getText(self, \"title\", \"User name:\", QLineEdit.Normal, '&gt;&gt;&gt;:')</p>\n\n<p># 整型类型  标题、提示信息、默认值，（最小值，最大值）可选<br />\n# num,ok = QInputDialog.getInt(self,\"输入整数\",'输入0-100范围内的数字',30,0,100)</p>\n\n<p><br />\n# 下拉框<br />\n# my_list = ['1','2','3']<br />\n# my_str,ok = QInputDialog.getItem(self,\"下拉框\",'提示',my_list)<br />\n </p>","site":{"data":{}},"excerpt":"","more":"<p>使用QMoive方法实现</p>\n\n<p>导入库文件</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">from PyQt5 import QtCore, QtGui, QtWidgets\nfrom PyQt5.QtGui import QMovie</code></pre>\n\n<p><br />\n创建一个带label控件的窗口，label作为GIF的显示窗体</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class Ui_Form(object):\n    def setupUi(self, Form):\n        Form.setObjectName(\"Form\")\n        Form.resize(517, 361)\n        self.label = QtWidgets.QLabel(Form)\n        self.label.setGeometry(QtCore.QRect(0, 0, 500, 300))\n        self.label.setObjectName(\"label\")\n        self.retranslateUi(Form)\n        QtCore.QMetaObject.connectSlotsByName(Form)\n\n    def retranslateUi(self, Form):\n        _translate = QtCore.QCoreApplication.translate\n        Form.setWindowTitle(_translate(\"Form\", \"Form\"))</code></pre>\n\n<p><br />\n在setupUi()函数里面加入</p>\n\n<p> </p>\n\n<pre class=\"has\">\n<code class=\"language-python\">self.gif = QMovie('qq.gif')\nself.label.setMovie(self.gif)\nself.gif.start()</code></pre>\n\n<p>第一行 实例化一个QMovie对象，传入GIF图片地址</p>\n\n<p>第二行 使用label的setMovie方法导入QMovie对象</p>\n\n<p>第三行 开始播放GIF动画</p>\n\n<p> </p>\n\n<p>效果图：</p>\n\n<p><img alt=\"\" class=\"has\" src=\"https://img-blog.csdn.net/20180303221947962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" /></p>\n\n<p> </p>\n\n<p>PyQt的一些其他功能<br />\n#设置窗体无边框<br />\nself.setWindowFlags(Qt.FramelessWindowHint)</p>\n\n<p># 设置背景透明<br />\n# self.setAttribute(Qt.WA_TranslucentBackground)</p>\n\n<p># 显示输入对话框<br />\n# 字符串类型，标题、提示信息、默认输入<br />\n# text,ok=QInputDialog.getText(self, \"title\", \"User name:\", QLineEdit.Normal, '&gt;&gt;&gt;:')</p>\n\n<p># 整型类型  标题、提示信息、默认值，（最小值，最大值）可选<br />\n# num,ok = QInputDialog.getInt(self,\"输入整数\",'输入0-100范围内的数字',30,0,100)</p>\n\n<p><br />\n# 下拉框<br />\n# my_list = ['1','2','3']<br />\n# my_str,ok = QInputDialog.getItem(self,\"下拉框\",'提示',my_list)<br />\n </p>"},{"_content":"\n<p>由于隐藏了标题栏无法通过点击标题栏来实现窗口的移动，这时候我们可以通过鼠标事件来移动窗口</p>\n<p>第一步：判断鼠标左键是否被按下，如果按下则将flag设为True并获取当前的位置</p>\n<p>第二步：判断鼠标是否移动并且左键被按下，若移动了计算移动的距离在移动窗口</p>\n<p>第三步：若鼠标释放了则将flag设为False</p>\n<p>具体做法：重写窗口类自带的三个函数</p>\n<p><pre name=\"code\" class=\"python\">    def mousePressEvent(self, event):\n        if event.button()==Qt.LeftButton:\n            self.m_flag=True\n            self.m_Position=event.globalPos()-self.pos() #获取鼠标相对窗口的位置\n            event.accept()\n            self.setCursor(QCursor(Qt.OpenHandCursor))  #更改鼠标图标\n            \n    def mouseMoveEvent(self, QMouseEvent):\n        if Qt.LeftButton and self.m_flag:  \n            self.move(QMouseEvent.globalPos()-self.m_Position)#更改窗口位置\n            QMouseEvent.accept()\n            \n    def mouseReleaseEvent(self, QMouseEvent):\n        self.m_flag=False\n        self.setCursor(QCursor(Qt.ArrowCursor))</pre><br>\n最后最小化和关闭可以设置两个按钮，通过点击按钮来触发</p>\n<p><pre name=\"code\" class=\"python\">    @pyqtSlot()\n    def on_pushButton_clicked(self):\n        &quot;&quot;&quot;\n        关闭窗口\n        &quot;&quot;&quot;\n        self.close()\n    \n    @pyqtSlot()\n    def on_pushButton_2_clicked(self):\n        &quot;&quot;&quot;\n        最小化窗口\n        &quot;&quot;&quot;\n        self.showMinimized()</pre></p>\n<p><br>\n</p>\n<p>ps :设置无边框和背景透明</p>\n<p><pre name=\"code\" class=\"python\"># 设置窗体无边框\n# self.setWindowFlags(Qt.FramelessWindowHint)\n# 设置背景透明\n# self.setAttribute(Qt.WA_TranslucentBackground)</pre><br>\n效果图</p>\n<p><img src=\"https://img-blog.csdn.net/20180303221110347\" alt=\"\"><br>\n</p>\n<p>win10自带的录屏只能录当前软件那个区域。。。。。。。</p>\n<p>就这样吧</p>\n","source":"_posts/blogs-PyQt5无边框后窗口的移动方法.md","raw":"\n<p>由于隐藏了标题栏无法通过点击标题栏来实现窗口的移动，这时候我们可以通过鼠标事件来移动窗口</p>\n<p>第一步：判断鼠标左键是否被按下，如果按下则将flag设为True并获取当前的位置</p>\n<p>第二步：判断鼠标是否移动并且左键被按下，若移动了计算移动的距离在移动窗口</p>\n<p>第三步：若鼠标释放了则将flag设为False</p>\n<p>具体做法：重写窗口类自带的三个函数</p>\n<p><pre name=\"code\" class=\"python\">    def mousePressEvent(self, event):\n        if event.button()==Qt.LeftButton:\n            self.m_flag=True\n            self.m_Position=event.globalPos()-self.pos() #获取鼠标相对窗口的位置\n            event.accept()\n            self.setCursor(QCursor(Qt.OpenHandCursor))  #更改鼠标图标\n            \n    def mouseMoveEvent(self, QMouseEvent):\n        if Qt.LeftButton and self.m_flag:  \n            self.move(QMouseEvent.globalPos()-self.m_Position)#更改窗口位置\n            QMouseEvent.accept()\n            \n    def mouseReleaseEvent(self, QMouseEvent):\n        self.m_flag=False\n        self.setCursor(QCursor(Qt.ArrowCursor))</pre><br>\n最后最小化和关闭可以设置两个按钮，通过点击按钮来触发</p>\n<p><pre name=\"code\" class=\"python\">    @pyqtSlot()\n    def on_pushButton_clicked(self):\n        &quot;&quot;&quot;\n        关闭窗口\n        &quot;&quot;&quot;\n        self.close()\n    \n    @pyqtSlot()\n    def on_pushButton_2_clicked(self):\n        &quot;&quot;&quot;\n        最小化窗口\n        &quot;&quot;&quot;\n        self.showMinimized()</pre></p>\n<p><br>\n</p>\n<p>ps :设置无边框和背景透明</p>\n<p><pre name=\"code\" class=\"python\"># 设置窗体无边框\n# self.setWindowFlags(Qt.FramelessWindowHint)\n# 设置背景透明\n# self.setAttribute(Qt.WA_TranslucentBackground)</pre><br>\n效果图</p>\n<p><img src=\"https://img-blog.csdn.net/20180303221110347\" alt=\"\"><br>\n</p>\n<p>win10自带的录屏只能录当前软件那个区域。。。。。。。</p>\n<p>就这样吧</p>\n","slug":"blogs-PyQt5无边框后窗口的移动方法","published":1,"date":"2022-03-16T17:09:35.436Z","updated":"2022-03-16T17:09:35.436Z","_id":"cl0v6kevo001oyms40d3q29ih","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>由于隐藏了标题栏无法通过点击标题栏来实现窗口的移动，这时候我们可以通过鼠标事件来移动窗口</p>\n<p>第一步：判断鼠标左键是否被按下，如果按下则将flag设为True并获取当前的位置</p>\n<p>第二步：判断鼠标是否移动并且左键被按下，若移动了计算移动的距离在移动窗口</p>\n<p>第三步：若鼠标释放了则将flag设为False</p>\n<p>具体做法：重写窗口类自带的三个函数</p>\n<p><pre name=\"code\" class=\"python\">    def mousePressEvent(self, event):\n        if event.button()==Qt.LeftButton:\n            self.m_flag=True\n            self.m_Position=event.globalPos()-self.pos() #获取鼠标相对窗口的位置\n            event.accept()\n            self.setCursor(QCursor(Qt.OpenHandCursor))  #更改鼠标图标\n            \n<pre><code>def mouseMoveEvent(self, QMouseEvent):\n    if Qt.LeftButton and self.m_flag:  \n        self.move(QMouseEvent.globalPos()-self.m_Position)#更改窗口位置\n        QMouseEvent.accept()\n        \ndef mouseReleaseEvent(self, QMouseEvent):\n    self.m_flag=False\n    self.setCursor(QCursor(Qt.ArrowCursor))&lt;/pre&gt;&lt;br&gt;\n</code></pre>\n<p>最后最小化和关闭可以设置两个按钮，通过点击按钮来触发</p></p>\n<p><pre name=\"code\" class=\"python\">    @pyqtSlot()\n    def on_pushButton_clicked(self):\n        &quot;&quot;&quot;\n        关闭窗口\n        &quot;&quot;&quot;\n        self.close()\n    \n<pre><code>@pyqtSlot()\ndef on_pushButton_2_clicked(self):\n    &amp;quot;&amp;quot;&amp;quot;\n    最小化窗口\n    &amp;quot;&amp;quot;&amp;quot;\n    self.showMinimized()&lt;/pre&gt;&lt;/p&gt;\n</code></pre>\n<p><br>\n</p>\n<p>ps :设置无边框和背景透明</p>\n<p><pre name=\"code\" class=\"python\"># 设置窗体无边框\n# self.setWindowFlags(Qt.FramelessWindowHint)\n# 设置背景透明\n# self.setAttribute(Qt.WA_TranslucentBackground)</pre><br>\n效果图</p>\n<p><img src=\"https://img-blog.csdn.net/20180303221110347\" alt=\"\"><br>\n</p>\n<p>win10自带的录屏只能录当前软件那个区域。。。。。。。</p>\n<p>就这样吧</p>\n","site":{"data":{}},"excerpt":"","more":"<p>由于隐藏了标题栏无法通过点击标题栏来实现窗口的移动，这时候我们可以通过鼠标事件来移动窗口</p>\n<p>第一步：判断鼠标左键是否被按下，如果按下则将flag设为True并获取当前的位置</p>\n<p>第二步：判断鼠标是否移动并且左键被按下，若移动了计算移动的距离在移动窗口</p>\n<p>第三步：若鼠标释放了则将flag设为False</p>\n<p>具体做法：重写窗口类自带的三个函数</p>\n<p><pre name=\"code\" class=\"python\">    def mousePressEvent(self, event):\n        if event.button()==Qt.LeftButton:\n            self.m_flag=True\n            self.m_Position=event.globalPos()-self.pos() #获取鼠标相对窗口的位置\n            event.accept()\n            self.setCursor(QCursor(Qt.OpenHandCursor))  #更改鼠标图标\n            \n<pre><code>def mouseMoveEvent(self, QMouseEvent):\n    if Qt.LeftButton and self.m_flag:  \n        self.move(QMouseEvent.globalPos()-self.m_Position)#更改窗口位置\n        QMouseEvent.accept()\n        \ndef mouseReleaseEvent(self, QMouseEvent):\n    self.m_flag=False\n    self.setCursor(QCursor(Qt.ArrowCursor))&lt;/pre&gt;&lt;br&gt;\n</code></pre>\n<p>最后最小化和关闭可以设置两个按钮，通过点击按钮来触发</p></p>\n<p><pre name=\"code\" class=\"python\">    @pyqtSlot()\n    def on_pushButton_clicked(self):\n        &quot;&quot;&quot;\n        关闭窗口\n        &quot;&quot;&quot;\n        self.close()\n    \n<pre><code>@pyqtSlot()\ndef on_pushButton_2_clicked(self):\n    &amp;quot;&amp;quot;&amp;quot;\n    最小化窗口\n    &amp;quot;&amp;quot;&amp;quot;\n    self.showMinimized()&lt;/pre&gt;&lt;/p&gt;\n</code></pre>\n<p><br>\n</p>\n<p>ps :设置无边框和背景透明</p>\n<p><pre name=\"code\" class=\"python\"># 设置窗体无边框\n# self.setWindowFlags(Qt.FramelessWindowHint)\n# 设置背景透明\n# self.setAttribute(Qt.WA_TranslucentBackground)</pre><br>\n效果图</p>\n<p><img src=\"https://img-blog.csdn.net/20180303221110347\" alt=\"\"><br>\n</p>\n<p>win10自带的录屏只能录当前软件那个区域。。。。。。。</p>\n<p>就这样吧</p>\n"},{"_content":"#### 计算字段\n\n一般数据库中存储的数据可能不会是我们所需要的格式，例如存储一个地址，在数据库中可能会将城市、区和街道分别存入不同的列中，但是我们可能需要直接获取一个完整的地址，这时候就需要做一些转换操作了，可以直接取出每个字段的值，然后在我们自己的程序中组合，同样也可以使用SQL直接在数据库中完成，而且一般来说在数据库中完成这些操作要率相对于我们自己去实现要快，下面就是一些常用的计算方法。\n\n表：\n\n| name         | category | number | price |\n| ------------ | -------- | ------ | ----- |\n| 硬盘         | 电子类   | 10     | 399   |\n| 乐事薯片     | 食品类   | 24     | 7.5   |\n| PS4          | 电子类   | 1      | 2799  |\n| 流畅的Python | 书籍类   | 5      | 105   |\n\n- 拼接字段\n\n  在select语句中可以使用Concat()函数实现两列的拼接操作：\n\n  ```sql\n  select concat(name,'(',category,')') as goods from goods\n  ```\n\n  | goods                |\n  | :------------------- |\n  | 硬盘(电子类)         |\n  | 乐事薯片(食品类)     |\n  | PS4(电子类)          |\n  | 流畅的Python(书籍类) |\n\n  其他：RTrim()函数去除右边所有空格，LTrim()去除左边所有空格， as：使用别名\n\n- 执行算术计算\n\n  依然使用上面那个表，如果我们需要取出所有商品的总金额，我们可以取出每行的价格和数量自己计算，同样也可是使用MySQL计算完成之后直接返回总金额。\n\n  ```sql\n  select name, number*price as total_price from goods\n  ```\n\n  | name         | total_price |\n  | ------------ | ----------- |\n  | 硬盘         | 3990        |\n  | 乐事薯片     | 180         |\n  | PS4          | 2799        |\n  | 流畅的Python | 525         |\n\n  MySQL支持的运算符有 +、 -、 *、 /  ，可以使用()来区分计算顺序。\n\n#### 函数\n\n- 文本处理函数\n\n  | 函 数                                                 | 说 明                                                        |\n  | ----------------------------------------------------- | ------------------------------------------------------------ |\n  | Left(str,length)                                      | 返回串左边的字符                                             |\n  | Length(str)                                           | 返回串的长度(字节长度 )， UTF-8编码中文三个字节，英文一个字节 |\n  | Locate([substr](http://xiaolan.gjjblog.com/),str,pos) | 返回子串 substr 在[字符串](http://xiaolan.gjjblog.com/) str 第 pos 位置后中第一次出现的位置。如果子串 substr 在 str 中不存在，返回值为 0   **（pos可选）** |\n  | Lower(str)                                            | 将串转换为小写                                               |\n  | LTrim(str)                                            | 去掉串左边的空格                                             |\n  | Righ(str,length)                                      | 返回串右边的字符                                             |\n  | RTrim(str)                                            | 去掉串右边的空格                                             |\n  | Soundex()                                             | 返回串的SOUNDEX值（不常用）SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法 |\n  | SubString(str, pos, len)                              | 返回字符串第pos位置后的len长度的子串  **第一个字符pos为1，len可选，默认到最后一位** |\n  | Upper()                                               | 将串转换为大写                                               |\n\n- 日期和时间处理函数\n  \n  \n\n  | AddDate()     | 作用                           |\n  | ------------- | ------------------------------ |\n  | AddDate()     | 增加一个日期（天、周等）       |\n  | AddTime()     | 增加一个时间（时、分等）       |\n  | CurDate()     | 返回当前日期                   |\n  | CurTime()     | 返回当前时间                   |\n  | Date()        | 返回日期时间的日期部分         |\n  | DateDiff()    | 计算两个日期之差               |\n  | Date_Add()    | 高度灵活的日期运算函数         |\n  | Date_Format() | 返回一个格式化的日期或时间串   |\n  | Day()         | 返回一个日期的天数部分         |\n  | DayOfWeek()   | 对于一个日期，返回对应的星期几 |\n  | Hour()        | 返回一个时间的小时部分         |\n  | Minute()      | 返回一个时间的分钟部分         |\n  | Month()       | 返回一个日期的月份部分         |\n  | Now()         | 返回当前日期和时间             |\n  | Second()      | 返回一个时间的秒部分           |\n  | Time()        | 返回一个日期时间的时间部分     |\n  | Year()        | 返回一个日期的年份部分         |\n\n- 数值处理函数\n\n  | 函数   | 说明               |\n  | ------ | ------------------ |\n  | Abs()  | 返回一个数的绝对值 |\n  | Cos()  | 返回一个角度的余弦 |\n  | Exp()  | 返回一个数的指数值 |\n  | Mod()  | 返回除操作的余数   |\n  | Pi()   | 返回圆周率         |\n  | Rand() | 返回一个随机数     |\n  | Sin()  | 返回一个角度的正弦 |\n  | Sqrt() | 返回一个数的平方根 |\n  | Tan()  | 返回一个角度的正切 |\n\n- 聚集函数\n\n  默认参数为ALL，可使用DISTINCT关键字\n\n  | 函 数   | 说 明                                  |\n  | ------- | -------------------------------------- |\n  | AVG()   | 返回某列的平均值                       |\n  | COUNT() | 返回某列的行数（指定列名会忽略NULL行） |\n  | MAX()   | 返回某列的最大值                       |\n  | MIN()   | 返回某列的最小值                       |\n  | SUM()   | 返回某列值之和                         |\n\n#### 数据的分组\n\n| name         | category | number | price |\n| ------------ | -------- | ------ | ----- |\n| 硬盘         | 电子类   | 10     | 399   |\n| 乐事薯片     | 食品类   | 24     | 7.5   |\n| PS4          | 电子类   | 1      | 2799  |\n| 流畅的Python | 书籍类   | 5      | 105   |\n\n- GROUP BY\n\n  按照category分组，并计算每组的数量\n\n  ```sql\n  select category , count(*)as num from goods group by category \n  ```\n\n  | category | num  |\n  | -------- | ---- |\n  | 书籍类   | 1    |\n  | 电子类   | 2    |\n  | 食品类   | 1    |\n\n  - GROUP BY子句可以包含任意数目的列\n  - 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。\n  - GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。\n  - 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。\n  - 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。\n  - GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前\n\n- HAVING（过滤分组）\n\n  HAVING类似于WHERE，所有的WHERE子句都可以使用HAVING来代替，两者唯一的差别是WHERE过滤行而HAVING过滤分组，换一句话说，WHERE在数据分组之前过滤，HAVING在分组之后过滤，WHERE排除的行不包含在分组之中。\n\n  选取种类大于等于两个的分组\n\n  ```sql\n  select category, count(*) as num from goods group by category HAVING count(*) >= 2\n  ```\n\n  | category | num  |\n  | -------- | ---- |\n  | 电子类   | 2    |\n\n- 分组排序\n\n  使用GROUP BY分组得到的数据顺序可能不是统一的，如果想实现分组排序还需要用到ORDER BY对分组结果进行排序\n\n  例如按照category分组，并按照数目从小到大排序\n\n  ```sql\n  select category ,count(*) num from goods group by category order by count(*)\n  ```\n\n  | category | num  |\n  | -------- | ---- |\n  | 食品类   | 1    |\n  | 书籍类   | 1    |\n  | 电子类   | 2    |\n\n\n\n**总结一下**\n\n**在SELECT语句中，所有子句的顺序如下**\n\n**SELECT →  FROM  → WHERE → GROUP BY → HAVING → ORDER BY**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/blogs-MySQL必知必会总结（二）.md","raw":"#### 计算字段\n\n一般数据库中存储的数据可能不会是我们所需要的格式，例如存储一个地址，在数据库中可能会将城市、区和街道分别存入不同的列中，但是我们可能需要直接获取一个完整的地址，这时候就需要做一些转换操作了，可以直接取出每个字段的值，然后在我们自己的程序中组合，同样也可以使用SQL直接在数据库中完成，而且一般来说在数据库中完成这些操作要率相对于我们自己去实现要快，下面就是一些常用的计算方法。\n\n表：\n\n| name         | category | number | price |\n| ------------ | -------- | ------ | ----- |\n| 硬盘         | 电子类   | 10     | 399   |\n| 乐事薯片     | 食品类   | 24     | 7.5   |\n| PS4          | 电子类   | 1      | 2799  |\n| 流畅的Python | 书籍类   | 5      | 105   |\n\n- 拼接字段\n\n  在select语句中可以使用Concat()函数实现两列的拼接操作：\n\n  ```sql\n  select concat(name,'(',category,')') as goods from goods\n  ```\n\n  | goods                |\n  | :------------------- |\n  | 硬盘(电子类)         |\n  | 乐事薯片(食品类)     |\n  | PS4(电子类)          |\n  | 流畅的Python(书籍类) |\n\n  其他：RTrim()函数去除右边所有空格，LTrim()去除左边所有空格， as：使用别名\n\n- 执行算术计算\n\n  依然使用上面那个表，如果我们需要取出所有商品的总金额，我们可以取出每行的价格和数量自己计算，同样也可是使用MySQL计算完成之后直接返回总金额。\n\n  ```sql\n  select name, number*price as total_price from goods\n  ```\n\n  | name         | total_price |\n  | ------------ | ----------- |\n  | 硬盘         | 3990        |\n  | 乐事薯片     | 180         |\n  | PS4          | 2799        |\n  | 流畅的Python | 525         |\n\n  MySQL支持的运算符有 +、 -、 *、 /  ，可以使用()来区分计算顺序。\n\n#### 函数\n\n- 文本处理函数\n\n  | 函 数                                                 | 说 明                                                        |\n  | ----------------------------------------------------- | ------------------------------------------------------------ |\n  | Left(str,length)                                      | 返回串左边的字符                                             |\n  | Length(str)                                           | 返回串的长度(字节长度 )， UTF-8编码中文三个字节，英文一个字节 |\n  | Locate([substr](http://xiaolan.gjjblog.com/),str,pos) | 返回子串 substr 在[字符串](http://xiaolan.gjjblog.com/) str 第 pos 位置后中第一次出现的位置。如果子串 substr 在 str 中不存在，返回值为 0   **（pos可选）** |\n  | Lower(str)                                            | 将串转换为小写                                               |\n  | LTrim(str)                                            | 去掉串左边的空格                                             |\n  | Righ(str,length)                                      | 返回串右边的字符                                             |\n  | RTrim(str)                                            | 去掉串右边的空格                                             |\n  | Soundex()                                             | 返回串的SOUNDEX值（不常用）SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法 |\n  | SubString(str, pos, len)                              | 返回字符串第pos位置后的len长度的子串  **第一个字符pos为1，len可选，默认到最后一位** |\n  | Upper()                                               | 将串转换为大写                                               |\n\n- 日期和时间处理函数\n  \n  \n\n  | AddDate()     | 作用                           |\n  | ------------- | ------------------------------ |\n  | AddDate()     | 增加一个日期（天、周等）       |\n  | AddTime()     | 增加一个时间（时、分等）       |\n  | CurDate()     | 返回当前日期                   |\n  | CurTime()     | 返回当前时间                   |\n  | Date()        | 返回日期时间的日期部分         |\n  | DateDiff()    | 计算两个日期之差               |\n  | Date_Add()    | 高度灵活的日期运算函数         |\n  | Date_Format() | 返回一个格式化的日期或时间串   |\n  | Day()         | 返回一个日期的天数部分         |\n  | DayOfWeek()   | 对于一个日期，返回对应的星期几 |\n  | Hour()        | 返回一个时间的小时部分         |\n  | Minute()      | 返回一个时间的分钟部分         |\n  | Month()       | 返回一个日期的月份部分         |\n  | Now()         | 返回当前日期和时间             |\n  | Second()      | 返回一个时间的秒部分           |\n  | Time()        | 返回一个日期时间的时间部分     |\n  | Year()        | 返回一个日期的年份部分         |\n\n- 数值处理函数\n\n  | 函数   | 说明               |\n  | ------ | ------------------ |\n  | Abs()  | 返回一个数的绝对值 |\n  | Cos()  | 返回一个角度的余弦 |\n  | Exp()  | 返回一个数的指数值 |\n  | Mod()  | 返回除操作的余数   |\n  | Pi()   | 返回圆周率         |\n  | Rand() | 返回一个随机数     |\n  | Sin()  | 返回一个角度的正弦 |\n  | Sqrt() | 返回一个数的平方根 |\n  | Tan()  | 返回一个角度的正切 |\n\n- 聚集函数\n\n  默认参数为ALL，可使用DISTINCT关键字\n\n  | 函 数   | 说 明                                  |\n  | ------- | -------------------------------------- |\n  | AVG()   | 返回某列的平均值                       |\n  | COUNT() | 返回某列的行数（指定列名会忽略NULL行） |\n  | MAX()   | 返回某列的最大值                       |\n  | MIN()   | 返回某列的最小值                       |\n  | SUM()   | 返回某列值之和                         |\n\n#### 数据的分组\n\n| name         | category | number | price |\n| ------------ | -------- | ------ | ----- |\n| 硬盘         | 电子类   | 10     | 399   |\n| 乐事薯片     | 食品类   | 24     | 7.5   |\n| PS4          | 电子类   | 1      | 2799  |\n| 流畅的Python | 书籍类   | 5      | 105   |\n\n- GROUP BY\n\n  按照category分组，并计算每组的数量\n\n  ```sql\n  select category , count(*)as num from goods group by category \n  ```\n\n  | category | num  |\n  | -------- | ---- |\n  | 书籍类   | 1    |\n  | 电子类   | 2    |\n  | 食品类   | 1    |\n\n  - GROUP BY子句可以包含任意数目的列\n  - 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。\n  - GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。\n  - 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。\n  - 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。\n  - GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前\n\n- HAVING（过滤分组）\n\n  HAVING类似于WHERE，所有的WHERE子句都可以使用HAVING来代替，两者唯一的差别是WHERE过滤行而HAVING过滤分组，换一句话说，WHERE在数据分组之前过滤，HAVING在分组之后过滤，WHERE排除的行不包含在分组之中。\n\n  选取种类大于等于两个的分组\n\n  ```sql\n  select category, count(*) as num from goods group by category HAVING count(*) >= 2\n  ```\n\n  | category | num  |\n  | -------- | ---- |\n  | 电子类   | 2    |\n\n- 分组排序\n\n  使用GROUP BY分组得到的数据顺序可能不是统一的，如果想实现分组排序还需要用到ORDER BY对分组结果进行排序\n\n  例如按照category分组，并按照数目从小到大排序\n\n  ```sql\n  select category ,count(*) num from goods group by category order by count(*)\n  ```\n\n  | category | num  |\n  | -------- | ---- |\n  | 食品类   | 1    |\n  | 书籍类   | 1    |\n  | 电子类   | 2    |\n\n\n\n**总结一下**\n\n**在SELECT语句中，所有子句的顺序如下**\n\n**SELECT →  FROM  → WHERE → GROUP BY → HAVING → ORDER BY**\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"blogs-MySQL必知必会总结（二）","published":1,"date":"2022-03-16T17:00:46.027Z","updated":"2022-03-16T17:05:35.381Z","_id":"cl0v6kevp001pyms491hc60cw","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"计算字段\"><a href=\"#计算字段\" class=\"headerlink\" title=\"计算字段\"></a>计算字段</h4><p>一般数据库中存储的数据可能不会是我们所需要的格式，例如存储一个地址，在数据库中可能会将城市、区和街道分别存入不同的列中，但是我们可能需要直接获取一个完整的地址，这时候就需要做一些转换操作了，可以直接取出每个字段的值，然后在我们自己的程序中组合，同样也可以使用SQL直接在数据库中完成，而且一般来说在数据库中完成这些操作要率相对于我们自己去实现要快，下面就是一些常用的计算方法。</p>\n<p>表：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>category</th>\n<th>number</th>\n<th>price</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>硬盘</td>\n<td>电子类</td>\n<td>10</td>\n<td>399</td>\n</tr>\n<tr>\n<td>乐事薯片</td>\n<td>食品类</td>\n<td>24</td>\n<td>7.5</td>\n</tr>\n<tr>\n<td>PS4</td>\n<td>电子类</td>\n<td>1</td>\n<td>2799</td>\n</tr>\n<tr>\n<td>流畅的Python</td>\n<td>书籍类</td>\n<td>5</td>\n<td>105</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>拼接字段</p>\n<p>在select语句中可以使用Concat()函数实现两列的拼接操作：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> concat(name,<span class=\"string\">&#x27;(&#x27;</span>,category,<span class=\"string\">&#x27;)&#x27;</span>) <span class=\"keyword\">as</span> goods <span class=\"keyword\">from</span> goods</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">goods</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">硬盘(电子类)</td>\n</tr>\n<tr>\n<td align=\"left\">乐事薯片(食品类)</td>\n</tr>\n<tr>\n<td align=\"left\">PS4(电子类)</td>\n</tr>\n<tr>\n<td align=\"left\">流畅的Python(书籍类)</td>\n</tr>\n</tbody></table>\n<p>其他：RTrim()函数去除右边所有空格，LTrim()去除左边所有空格， as：使用别名</p>\n</li>\n<li><p>执行算术计算</p>\n<p>依然使用上面那个表，如果我们需要取出所有商品的总金额，我们可以取出每行的价格和数量自己计算，同样也可是使用MySQL计算完成之后直接返回总金额。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name, number<span class=\"operator\">*</span>price <span class=\"keyword\">as</span> total_price <span class=\"keyword\">from</span> goods</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>total_price</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>硬盘</td>\n<td>3990</td>\n</tr>\n<tr>\n<td>乐事薯片</td>\n<td>180</td>\n</tr>\n<tr>\n<td>PS4</td>\n<td>2799</td>\n</tr>\n<tr>\n<td>流畅的Python</td>\n<td>525</td>\n</tr>\n</tbody></table>\n<p>MySQL支持的运算符有 +、 -、 *、 /  ，可以使用()来区分计算顺序。</p>\n</li>\n</ul>\n<h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><ul>\n<li><p>文本处理函数</p>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Left(str,length)</td>\n<td>返回串左边的字符</td>\n</tr>\n<tr>\n<td>Length(str)</td>\n<td>返回串的长度(字节长度 )， UTF-8编码中文三个字节，英文一个字节</td>\n</tr>\n<tr>\n<td>Locate(<a href=\"http://xiaolan.gjjblog.com/\">substr</a>,str,pos)</td>\n<td>返回子串 substr 在<a href=\"http://xiaolan.gjjblog.com/\">字符串</a> str 第 pos 位置后中第一次出现的位置。如果子串 substr 在 str 中不存在，返回值为 0   <strong>（pos可选）</strong></td>\n</tr>\n<tr>\n<td>Lower(str)</td>\n<td>将串转换为小写</td>\n</tr>\n<tr>\n<td>LTrim(str)</td>\n<td>去掉串左边的空格</td>\n</tr>\n<tr>\n<td>Righ(str,length)</td>\n<td>返回串右边的字符</td>\n</tr>\n<tr>\n<td>RTrim(str)</td>\n<td>去掉串右边的空格</td>\n</tr>\n<tr>\n<td>Soundex()</td>\n<td>返回串的SOUNDEX值（不常用）SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法</td>\n</tr>\n<tr>\n<td>SubString(str, pos, len)</td>\n<td>返回字符串第pos位置后的len长度的子串  <strong>第一个字符pos为1，len可选，默认到最后一位</strong></td>\n</tr>\n<tr>\n<td>Upper()</td>\n<td>将串转换为大写</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>日期和时间处理函数</p>\n<table>\n<thead>\n<tr>\n<th>AddDate()</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AddDate()</td>\n<td>增加一个日期（天、周等）</td>\n</tr>\n<tr>\n<td>AddTime()</td>\n<td>增加一个时间（时、分等）</td>\n</tr>\n<tr>\n<td>CurDate()</td>\n<td>返回当前日期</td>\n</tr>\n<tr>\n<td>CurTime()</td>\n<td>返回当前时间</td>\n</tr>\n<tr>\n<td>Date()</td>\n<td>返回日期时间的日期部分</td>\n</tr>\n<tr>\n<td>DateDiff()</td>\n<td>计算两个日期之差</td>\n</tr>\n<tr>\n<td>Date_Add()</td>\n<td>高度灵活的日期运算函数</td>\n</tr>\n<tr>\n<td>Date_Format()</td>\n<td>返回一个格式化的日期或时间串</td>\n</tr>\n<tr>\n<td>Day()</td>\n<td>返回一个日期的天数部分</td>\n</tr>\n<tr>\n<td>DayOfWeek()</td>\n<td>对于一个日期，返回对应的星期几</td>\n</tr>\n<tr>\n<td>Hour()</td>\n<td>返回一个时间的小时部分</td>\n</tr>\n<tr>\n<td>Minute()</td>\n<td>返回一个时间的分钟部分</td>\n</tr>\n<tr>\n<td>Month()</td>\n<td>返回一个日期的月份部分</td>\n</tr>\n<tr>\n<td>Now()</td>\n<td>返回当前日期和时间</td>\n</tr>\n<tr>\n<td>Second()</td>\n<td>返回一个时间的秒部分</td>\n</tr>\n<tr>\n<td>Time()</td>\n<td>返回一个日期时间的时间部分</td>\n</tr>\n<tr>\n<td>Year()</td>\n<td>返回一个日期的年份部分</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>数值处理函数</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Abs()</td>\n<td>返回一个数的绝对值</td>\n</tr>\n<tr>\n<td>Cos()</td>\n<td>返回一个角度的余弦</td>\n</tr>\n<tr>\n<td>Exp()</td>\n<td>返回一个数的指数值</td>\n</tr>\n<tr>\n<td>Mod()</td>\n<td>返回除操作的余数</td>\n</tr>\n<tr>\n<td>Pi()</td>\n<td>返回圆周率</td>\n</tr>\n<tr>\n<td>Rand()</td>\n<td>返回一个随机数</td>\n</tr>\n<tr>\n<td>Sin()</td>\n<td>返回一个角度的正弦</td>\n</tr>\n<tr>\n<td>Sqrt()</td>\n<td>返回一个数的平方根</td>\n</tr>\n<tr>\n<td>Tan()</td>\n<td>返回一个角度的正切</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>聚集函数</p>\n<p>默认参数为ALL，可使用DISTINCT关键字</p>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AVG()</td>\n<td>返回某列的平均值</td>\n</tr>\n<tr>\n<td>COUNT()</td>\n<td>返回某列的行数（指定列名会忽略NULL行）</td>\n</tr>\n<tr>\n<td>MAX()</td>\n<td>返回某列的最大值</td>\n</tr>\n<tr>\n<td>MIN()</td>\n<td>返回某列的最小值</td>\n</tr>\n<tr>\n<td>SUM()</td>\n<td>返回某列值之和</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h4 id=\"数据的分组\"><a href=\"#数据的分组\" class=\"headerlink\" title=\"数据的分组\"></a>数据的分组</h4><table>\n<thead>\n<tr>\n<th>name</th>\n<th>category</th>\n<th>number</th>\n<th>price</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>硬盘</td>\n<td>电子类</td>\n<td>10</td>\n<td>399</td>\n</tr>\n<tr>\n<td>乐事薯片</td>\n<td>食品类</td>\n<td>24</td>\n<td>7.5</td>\n</tr>\n<tr>\n<td>PS4</td>\n<td>电子类</td>\n<td>1</td>\n<td>2799</td>\n</tr>\n<tr>\n<td>流畅的Python</td>\n<td>书籍类</td>\n<td>5</td>\n<td>105</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>GROUP BY</p>\n<p>按照category分组，并计算每组的数量</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> category , <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)<span class=\"keyword\">as</span> num <span class=\"keyword\">from</span> goods <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> category </span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>category</th>\n<th>num</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>书籍类</td>\n<td>1</td>\n</tr>\n<tr>\n<td>电子类</td>\n<td>2</td>\n</tr>\n<tr>\n<td>食品类</td>\n<td>1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>GROUP BY子句可以包含任意数目的列</li>\n<li>如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li>\n<li>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</li>\n<li>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</li>\n<li>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</li>\n<li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前</li>\n</ul>\n</li>\n<li><p>HAVING（过滤分组）</p>\n<p>HAVING类似于WHERE，所有的WHERE子句都可以使用HAVING来代替，两者唯一的差别是WHERE过滤行而HAVING过滤分组，换一句话说，WHERE在数据分组之前过滤，HAVING在分组之后过滤，WHERE排除的行不包含在分组之中。</p>\n<p>选取种类大于等于两个的分组</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> category, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">as</span> num <span class=\"keyword\">from</span> goods <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> category <span class=\"keyword\">HAVING</span> <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"operator\">&gt;=</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>category</th>\n<th>num</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>电子类</td>\n<td>2</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>分组排序</p>\n<p>使用GROUP BY分组得到的数据顺序可能不是统一的，如果想实现分组排序还需要用到ORDER BY对分组结果进行排序</p>\n<p>例如按照category分组，并按照数目从小到大排序</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> category ,<span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) num <span class=\"keyword\">from</span> goods <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> category <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>category</th>\n<th>num</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>食品类</td>\n<td>1</td>\n</tr>\n<tr>\n<td>书籍类</td>\n<td>1</td>\n</tr>\n<tr>\n<td>电子类</td>\n<td>2</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p><strong>总结一下</strong></p>\n<p><strong>在SELECT语句中，所有子句的顺序如下</strong></p>\n<p><strong>SELECT →  FROM  → WHERE → GROUP BY → HAVING → ORDER BY</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"计算字段\"><a href=\"#计算字段\" class=\"headerlink\" title=\"计算字段\"></a>计算字段</h4><p>一般数据库中存储的数据可能不会是我们所需要的格式，例如存储一个地址，在数据库中可能会将城市、区和街道分别存入不同的列中，但是我们可能需要直接获取一个完整的地址，这时候就需要做一些转换操作了，可以直接取出每个字段的值，然后在我们自己的程序中组合，同样也可以使用SQL直接在数据库中完成，而且一般来说在数据库中完成这些操作要率相对于我们自己去实现要快，下面就是一些常用的计算方法。</p>\n<p>表：</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>category</th>\n<th>number</th>\n<th>price</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>硬盘</td>\n<td>电子类</td>\n<td>10</td>\n<td>399</td>\n</tr>\n<tr>\n<td>乐事薯片</td>\n<td>食品类</td>\n<td>24</td>\n<td>7.5</td>\n</tr>\n<tr>\n<td>PS4</td>\n<td>电子类</td>\n<td>1</td>\n<td>2799</td>\n</tr>\n<tr>\n<td>流畅的Python</td>\n<td>书籍类</td>\n<td>5</td>\n<td>105</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>拼接字段</p>\n<p>在select语句中可以使用Concat()函数实现两列的拼接操作：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> concat(name,<span class=\"string\">&#x27;(&#x27;</span>,category,<span class=\"string\">&#x27;)&#x27;</span>) <span class=\"keyword\">as</span> goods <span class=\"keyword\">from</span> goods</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">goods</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">硬盘(电子类)</td>\n</tr>\n<tr>\n<td align=\"left\">乐事薯片(食品类)</td>\n</tr>\n<tr>\n<td align=\"left\">PS4(电子类)</td>\n</tr>\n<tr>\n<td align=\"left\">流畅的Python(书籍类)</td>\n</tr>\n</tbody></table>\n<p>其他：RTrim()函数去除右边所有空格，LTrim()去除左边所有空格， as：使用别名</p>\n</li>\n<li><p>执行算术计算</p>\n<p>依然使用上面那个表，如果我们需要取出所有商品的总金额，我们可以取出每行的价格和数量自己计算，同样也可是使用MySQL计算完成之后直接返回总金额。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> name, number<span class=\"operator\">*</span>price <span class=\"keyword\">as</span> total_price <span class=\"keyword\">from</span> goods</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>total_price</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>硬盘</td>\n<td>3990</td>\n</tr>\n<tr>\n<td>乐事薯片</td>\n<td>180</td>\n</tr>\n<tr>\n<td>PS4</td>\n<td>2799</td>\n</tr>\n<tr>\n<td>流畅的Python</td>\n<td>525</td>\n</tr>\n</tbody></table>\n<p>MySQL支持的运算符有 +、 -、 *、 /  ，可以使用()来区分计算顺序。</p>\n</li>\n</ul>\n<h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><ul>\n<li><p>文本处理函数</p>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Left(str,length)</td>\n<td>返回串左边的字符</td>\n</tr>\n<tr>\n<td>Length(str)</td>\n<td>返回串的长度(字节长度 )， UTF-8编码中文三个字节，英文一个字节</td>\n</tr>\n<tr>\n<td>Locate(<a href=\"http://xiaolan.gjjblog.com/\">substr</a>,str,pos)</td>\n<td>返回子串 substr 在<a href=\"http://xiaolan.gjjblog.com/\">字符串</a> str 第 pos 位置后中第一次出现的位置。如果子串 substr 在 str 中不存在，返回值为 0   <strong>（pos可选）</strong></td>\n</tr>\n<tr>\n<td>Lower(str)</td>\n<td>将串转换为小写</td>\n</tr>\n<tr>\n<td>LTrim(str)</td>\n<td>去掉串左边的空格</td>\n</tr>\n<tr>\n<td>Righ(str,length)</td>\n<td>返回串右边的字符</td>\n</tr>\n<tr>\n<td>RTrim(str)</td>\n<td>去掉串右边的空格</td>\n</tr>\n<tr>\n<td>Soundex()</td>\n<td>返回串的SOUNDEX值（不常用）SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法</td>\n</tr>\n<tr>\n<td>SubString(str, pos, len)</td>\n<td>返回字符串第pos位置后的len长度的子串  <strong>第一个字符pos为1，len可选，默认到最后一位</strong></td>\n</tr>\n<tr>\n<td>Upper()</td>\n<td>将串转换为大写</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>日期和时间处理函数</p>\n<table>\n<thead>\n<tr>\n<th>AddDate()</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AddDate()</td>\n<td>增加一个日期（天、周等）</td>\n</tr>\n<tr>\n<td>AddTime()</td>\n<td>增加一个时间（时、分等）</td>\n</tr>\n<tr>\n<td>CurDate()</td>\n<td>返回当前日期</td>\n</tr>\n<tr>\n<td>CurTime()</td>\n<td>返回当前时间</td>\n</tr>\n<tr>\n<td>Date()</td>\n<td>返回日期时间的日期部分</td>\n</tr>\n<tr>\n<td>DateDiff()</td>\n<td>计算两个日期之差</td>\n</tr>\n<tr>\n<td>Date_Add()</td>\n<td>高度灵活的日期运算函数</td>\n</tr>\n<tr>\n<td>Date_Format()</td>\n<td>返回一个格式化的日期或时间串</td>\n</tr>\n<tr>\n<td>Day()</td>\n<td>返回一个日期的天数部分</td>\n</tr>\n<tr>\n<td>DayOfWeek()</td>\n<td>对于一个日期，返回对应的星期几</td>\n</tr>\n<tr>\n<td>Hour()</td>\n<td>返回一个时间的小时部分</td>\n</tr>\n<tr>\n<td>Minute()</td>\n<td>返回一个时间的分钟部分</td>\n</tr>\n<tr>\n<td>Month()</td>\n<td>返回一个日期的月份部分</td>\n</tr>\n<tr>\n<td>Now()</td>\n<td>返回当前日期和时间</td>\n</tr>\n<tr>\n<td>Second()</td>\n<td>返回一个时间的秒部分</td>\n</tr>\n<tr>\n<td>Time()</td>\n<td>返回一个日期时间的时间部分</td>\n</tr>\n<tr>\n<td>Year()</td>\n<td>返回一个日期的年份部分</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>数值处理函数</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Abs()</td>\n<td>返回一个数的绝对值</td>\n</tr>\n<tr>\n<td>Cos()</td>\n<td>返回一个角度的余弦</td>\n</tr>\n<tr>\n<td>Exp()</td>\n<td>返回一个数的指数值</td>\n</tr>\n<tr>\n<td>Mod()</td>\n<td>返回除操作的余数</td>\n</tr>\n<tr>\n<td>Pi()</td>\n<td>返回圆周率</td>\n</tr>\n<tr>\n<td>Rand()</td>\n<td>返回一个随机数</td>\n</tr>\n<tr>\n<td>Sin()</td>\n<td>返回一个角度的正弦</td>\n</tr>\n<tr>\n<td>Sqrt()</td>\n<td>返回一个数的平方根</td>\n</tr>\n<tr>\n<td>Tan()</td>\n<td>返回一个角度的正切</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>聚集函数</p>\n<p>默认参数为ALL，可使用DISTINCT关键字</p>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AVG()</td>\n<td>返回某列的平均值</td>\n</tr>\n<tr>\n<td>COUNT()</td>\n<td>返回某列的行数（指定列名会忽略NULL行）</td>\n</tr>\n<tr>\n<td>MAX()</td>\n<td>返回某列的最大值</td>\n</tr>\n<tr>\n<td>MIN()</td>\n<td>返回某列的最小值</td>\n</tr>\n<tr>\n<td>SUM()</td>\n<td>返回某列值之和</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h4 id=\"数据的分组\"><a href=\"#数据的分组\" class=\"headerlink\" title=\"数据的分组\"></a>数据的分组</h4><table>\n<thead>\n<tr>\n<th>name</th>\n<th>category</th>\n<th>number</th>\n<th>price</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>硬盘</td>\n<td>电子类</td>\n<td>10</td>\n<td>399</td>\n</tr>\n<tr>\n<td>乐事薯片</td>\n<td>食品类</td>\n<td>24</td>\n<td>7.5</td>\n</tr>\n<tr>\n<td>PS4</td>\n<td>电子类</td>\n<td>1</td>\n<td>2799</td>\n</tr>\n<tr>\n<td>流畅的Python</td>\n<td>书籍类</td>\n<td>5</td>\n<td>105</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>GROUP BY</p>\n<p>按照category分组，并计算每组的数量</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> category , <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)<span class=\"keyword\">as</span> num <span class=\"keyword\">from</span> goods <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> category </span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>category</th>\n<th>num</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>书籍类</td>\n<td>1</td>\n</tr>\n<tr>\n<td>电子类</td>\n<td>2</td>\n</tr>\n<tr>\n<td>食品类</td>\n<td>1</td>\n</tr>\n</tbody></table>\n<ul>\n<li>GROUP BY子句可以包含任意数目的列</li>\n<li>如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li>\n<li>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</li>\n<li>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</li>\n<li>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</li>\n<li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前</li>\n</ul>\n</li>\n<li><p>HAVING（过滤分组）</p>\n<p>HAVING类似于WHERE，所有的WHERE子句都可以使用HAVING来代替，两者唯一的差别是WHERE过滤行而HAVING过滤分组，换一句话说，WHERE在数据分组之前过滤，HAVING在分组之后过滤，WHERE排除的行不包含在分组之中。</p>\n<p>选取种类大于等于两个的分组</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> category, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">as</span> num <span class=\"keyword\">from</span> goods <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> category <span class=\"keyword\">HAVING</span> <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"operator\">&gt;=</span> <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>category</th>\n<th>num</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>电子类</td>\n<td>2</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>分组排序</p>\n<p>使用GROUP BY分组得到的数据顺序可能不是统一的，如果想实现分组排序还需要用到ORDER BY对分组结果进行排序</p>\n<p>例如按照category分组，并按照数目从小到大排序</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> category ,<span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) num <span class=\"keyword\">from</span> goods <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> category <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>)</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>category</th>\n<th>num</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>食品类</td>\n<td>1</td>\n</tr>\n<tr>\n<td>书籍类</td>\n<td>1</td>\n</tr>\n<tr>\n<td>电子类</td>\n<td>2</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p><strong>总结一下</strong></p>\n<p><strong>在SELECT语句中，所有子句的顺序如下</strong></p>\n<p><strong>SELECT →  FROM  → WHERE → GROUP BY → HAVING → ORDER BY</strong></p>\n"},{"_content":"\n<h4>安装</h4>\n<div>RabbitMQ是使用Erlang开发的，因此我们需要首先安装Erlang。<a target=\"_blank\" href=\"http://www.erlang.org/downloads\">http://www.erlang.org/downloads</a>下载对应的版本，安装完成后即可进入下一步。</div>\n<div>下载RabbitMQ&nbsp;<a target=\"_blank\" href=\"http://www.rabbitmq.com/download.html\">http://www.rabbitmq.com/download.html</a>&nbsp;选择默认安装即可，安装完成后可在开始菜单中找到</div>\n<div><img src=\"https://img-blog.csdn.net/20180419202452158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></div>\n<div>点击 RabbitMQ Service - start就开始运行了</div>\n<h4>使用Python进行操作</h4>\n<div>这里我们需要用到pika这个模块来实现，安装好之后我们就可以实现最简单的例子了</div>\n<h6>第一个程序Hello world</h6>\n<p>下面两个例子都来自于官方示例</p>\n<p>消息传递模型</p>\n<p><img src=\"https://img-blog.csdn.net/20180421160239802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"><br>\n</p>\n<div>send.py</div>\n<div>\n<pre class=\"python\">import pika\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\n\n\nchannel.queue_declare(queue='hello')\n\nchannel.basic_publish(exchange='',\n                      routing_key='hello',\n                      body='Hello World!')\nprint(&quot; [x] Sent 'Hello World!'&quot;)\nconnection.close()</pre>\nreceive.py</div>\n<div>\n<pre class=\"python\">import pika\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\n\n\nchannel.queue_declare(queue='hello')\n\ndef callback(ch, method, properties, body):\n    print(&quot; [x] Received %r&quot; % body)\n\nchannel.basic_consume(callback,\n                      queue='hello',\n                      no_ack=True)\n\nprint(' [*] Waiting for messages. To exit press CTRL&#43;C')\nchannel.start_consuming()</pre>\n依次运行这两个函数结果如下</div>\n<div><img src=\"https://img-blog.csdn.net/20180419203216036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></div>\n<div><img src=\"https://img-blog.csdn.net/20180419203343047?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></div>\n<div>下面我们再来具体看一看每条语句的具体作用</div>\n<div>\n<pre class=\"python\">connection = pika.BlockingConnection（pika.ConnectionParameters（'localhost'））\nchannel = connection.channel（）</pre>\n第一句是建立连接的，rabbitmq支持本地连接也支持连接到其他机器上，在这里我们选择本地连接。</div>\n<div>第二句是创建一个新的管道，之后的所有操作都是在这个管道上进行的。<br>\n<pre class=\"python\">channel.queue_declare(queue='hello')</pre>\n<div>声明一个队列名为hello，如果你确认这个队列存在那么不声明也是可以的，但是最好声明一下以免造成其他的麻烦。</div>\n</div>\n<div>\n<pre class=\"python\">channel.basic_publish(exchange='',\n                      routing_key='hello',\n                      body='Hello World!')</pre>\n</div>\n<div>向队列中发送一条消息，其中routing_key指定队列名，body为消息内容</div>\n<pre class=\"python\">connection.close()</pre>\n<p>关闭连接</p>\n<p>receive.py中前面几句和send中的作用是一样的，这里不再赘述。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<pre class=\"python\">def callback(ch, method, properties, body):\n    print(&quot; [x] Received %r&quot; % body)</pre>\n<p>callback是回调函数，当程序从队列中获取消息后都会执行回调函数来处理消息&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<pre class=\"python\">channel.basic_consume(callback,\n                      queue='hello',\n                      #no_ack=True\n                      )</pre>\n<p>从队列中获取消息，callback指定回调函数，queue指定获取的队列名，no_ack在以后再说明&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>\n<pre class=\"python\">channel.start_consuming()</pre>\n<p>让程序进入到一个死循环中，不断从队列中取出消息</p>\n<h6>消息队列的循环调度</h6>\n<p>消息传递模型</p>\n<p><img src=\"https://img-blog.csdn.net/20180421160404952?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"></p>\n<p>当我们启动多个程序从同一个队列中接收消息的时候，默认是依次接收，即第一个启动的程序首先接收到然后是第二个启动的程序,直到最后一个程序收到之后又从第一个开始，但是这样会造成一个后果就是，可能每个程序或者机器的处理速度不同，造成有的在等待有的消息过多。如下图启动两个接收程序，并发送从0-4数字，两个程序接收的消息依次为：</p>\n<p><img src=\"https://img-blog.csdn.net/20180421141241831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180421141300490?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"><br>\n</p>\n<h6>消息确认</h6>\n<p>在实际应用中一般程序接收消息后处理需要时间，如果在处理的过程中程序崩溃了那么那个消息就会从消息队列中消失了，这当然不是我们想要的结果，我们需要在程序崩溃之后将那条消息转发到另一个程序中执行，这时候我们需要设置只有在消息被确认后才将消息从队列中删除，RabbitMQ默认消息确认是打开的，但是我们可以添加参数no_ack = True来取消，这样即使消息为处理完成也不会再次发送了，会直接从队列中去除。我们还可以使用手动消息确认即在callback中添加一句：</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"><span style=\"vertical-align:inherit\">ch.basic_ack（delivery_tag = method.delivery_tag）</span></pre>\n<h6>消息持久化</h6>\n<p>上面我们已经说了如何保证消费者崩溃时还保留消息，现在我们将介绍如何在RabbitMQ服务终止后还会保留消息队列。这里需要我们在声明这个队列的时候添加一个参数来实现</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"><span style=\"vertical-align:inherit\">channel.queue_declare（queue = </span><span class=\"hljs-string\" style=\"color:rgb(165,194,97)\">'hello'</span><span style=\"vertical-align:inherit\">，durable = </span><span class=\"hljs-keyword\" style=\"color:rgb(194,98,48)\">True</span><span style=\"vertical-align:inherit\">）</span></pre>\n<p>但是这只是保证了hello队列的持久化（下次重启服务的时候队列依然存在），但是队列中消息内容依然是不会被保留下来的，我们想要同时将消息保留下来还需要在channel.basic_publish()函数中添加下面这个参数</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"> properties=pika.BasicProperties(delivery_mode = <span class=\"hljs-number\" style=\"color:rgb(165,194,97)\">2</span>)</pre>\n<p>需要注意的是消息内用只会暂存于缓存中，并未正真写入磁盘中永久保留，还有就是要实现消息持久化的前提是当前队列也是持久化的（不会报错，但是消息并没有被保留下来）</p>\n<h6>公平派遣</h6>\n<p></p>\n<p>实际应用场景中，有些程序或者是机器处理消息的能力强一些，有些会弱一些，那么按照上面的操作所有的消息都是循环分发的这样就会导致有些机器空闲而有些会出现消息过多处理不过来的情况，为了解决这个问题我们可以在消费者中设置最多可容纳多少条消息，当消息数目满了之后就不会再接收新的消息，直到消息被处理完了留有空余才会再次接收消息。</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"><span style=\"vertical-align:inherit\">channel.basic_qos（prefetch_count = </span><span class=\"hljs-number\" style=\"color:rgb(165,194,97)\">1</span><span style=\"vertical-align:inherit\">）</span></pre>\n<p>需要注意的是prefetch_count参数&#20540;并未实际意义，只要为True即可，也就是设置后消费者每次只能接收一个消息与参数&#20540;无关。</p>\n<h6>广播模式</h6>\n<div>消息传递模型</div>\n<p><img src=\"https://img-blog.csdn.net/2018042117585856?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"></p>\n<p>上面所有的都是一对一的消息传递，下面将说一说一对多的传递模型，即广播模式，就好比收音机收听广播一样，需要一个发布者，其他的都是订阅者，发布者发布消息只要订阅者订阅了这个频道那么所有的订阅者都能收到消息。这里的消息传递模型就与之前的略有不同。消息并不是直接发送到队列中，而是经过一个交易所来分发到不同的队列中如上图所示。那么有人会问了，交易所是如何知道要分发到哪一个队列呢，其实只需要将队列和交易所绑定在一起就可以了，每一次消息过来的时候交易所会将消息转发到所有和他绑定的队列中。</p>\n<pre class=\"python\">channel.exchange_declare(exchange='logs',\n                         exchange_type='fanout')\n\nmessage = &quot;info: Hello World!&quot;\nchannel.basic_publish(exchange='logs',\n                      routing_key='',\n                      body=message)</pre>\n<p><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">其中exchange_type类型有direct、topic、headers、fanout<span style=\"letter-spacing:.16px; text-align:left; white-space:pre-wrap\"><span style=\"color:#333333\">这四种，下面主要说明fanout类型。</span></span>上面这段程序指定了一个名为logs的交易所，类型为fanout，下面向这个exchange里面publish一条message消息，routing_key为空表示使用默认操作或称为无名交换。完成了发送程序，下面再来说说接收程序。</span></p>\n<pre class=\"python\">channel.exchange_declare(exchange='logs',\n                         exchange_type='fanout')\n\nresult = channel.queue_declare(exclusive=True)\nqueue_name = result.method.queue\n\nchannel.queue_bind(exchange='logs',\n                   queue=queue_name)</pre>\n<p><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">在第四行代码中声明了一个随机名称的队列，exclusive=True将会让程序在消费者断开连接的时候删除这个队列&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在第七行代码中我们将生成的随机队列和我们之前的交换所绑定在一起，这样当一个消息过来的时候交易所会将消息分发到我们绑定过的队列中</span></p>\n<h6><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">路由</span></h6>\n<p><img src=\"https://img-blog.csdn.net/20180423153004240?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"></p>\n<p>如上图所示</p>\n<p><br>\n</p>\n<p></p>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<p></p>\n<p></p>\n<p></p>\n<p><br>\n</p>\n<p></p>\n<p><br>\n</p>\n","source":"_posts/blogs-Python---RabbitMQ的使用.md","raw":"\n<h4>安装</h4>\n<div>RabbitMQ是使用Erlang开发的，因此我们需要首先安装Erlang。<a target=\"_blank\" href=\"http://www.erlang.org/downloads\">http://www.erlang.org/downloads</a>下载对应的版本，安装完成后即可进入下一步。</div>\n<div>下载RabbitMQ&nbsp;<a target=\"_blank\" href=\"http://www.rabbitmq.com/download.html\">http://www.rabbitmq.com/download.html</a>&nbsp;选择默认安装即可，安装完成后可在开始菜单中找到</div>\n<div><img src=\"https://img-blog.csdn.net/20180419202452158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></div>\n<div>点击 RabbitMQ Service - start就开始运行了</div>\n<h4>使用Python进行操作</h4>\n<div>这里我们需要用到pika这个模块来实现，安装好之后我们就可以实现最简单的例子了</div>\n<h6>第一个程序Hello world</h6>\n<p>下面两个例子都来自于官方示例</p>\n<p>消息传递模型</p>\n<p><img src=\"https://img-blog.csdn.net/20180421160239802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"><br>\n</p>\n<div>send.py</div>\n<div>\n<pre class=\"python\">import pika\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\n\n\nchannel.queue_declare(queue='hello')\n\nchannel.basic_publish(exchange='',\n                      routing_key='hello',\n                      body='Hello World!')\nprint(&quot; [x] Sent 'Hello World!'&quot;)\nconnection.close()</pre>\nreceive.py</div>\n<div>\n<pre class=\"python\">import pika\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\n\n\nchannel.queue_declare(queue='hello')\n\ndef callback(ch, method, properties, body):\n    print(&quot; [x] Received %r&quot; % body)\n\nchannel.basic_consume(callback,\n                      queue='hello',\n                      no_ack=True)\n\nprint(' [*] Waiting for messages. To exit press CTRL&#43;C')\nchannel.start_consuming()</pre>\n依次运行这两个函数结果如下</div>\n<div><img src=\"https://img-blog.csdn.net/20180419203216036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></div>\n<div><img src=\"https://img-blog.csdn.net/20180419203343047?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></div>\n<div>下面我们再来具体看一看每条语句的具体作用</div>\n<div>\n<pre class=\"python\">connection = pika.BlockingConnection（pika.ConnectionParameters（'localhost'））\nchannel = connection.channel（）</pre>\n第一句是建立连接的，rabbitmq支持本地连接也支持连接到其他机器上，在这里我们选择本地连接。</div>\n<div>第二句是创建一个新的管道，之后的所有操作都是在这个管道上进行的。<br>\n<pre class=\"python\">channel.queue_declare(queue='hello')</pre>\n<div>声明一个队列名为hello，如果你确认这个队列存在那么不声明也是可以的，但是最好声明一下以免造成其他的麻烦。</div>\n</div>\n<div>\n<pre class=\"python\">channel.basic_publish(exchange='',\n                      routing_key='hello',\n                      body='Hello World!')</pre>\n</div>\n<div>向队列中发送一条消息，其中routing_key指定队列名，body为消息内容</div>\n<pre class=\"python\">connection.close()</pre>\n<p>关闭连接</p>\n<p>receive.py中前面几句和send中的作用是一样的，这里不再赘述。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<pre class=\"python\">def callback(ch, method, properties, body):\n    print(&quot; [x] Received %r&quot; % body)</pre>\n<p>callback是回调函数，当程序从队列中获取消息后都会执行回调函数来处理消息&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<pre class=\"python\">channel.basic_consume(callback,\n                      queue='hello',\n                      #no_ack=True\n                      )</pre>\n<p>从队列中获取消息，callback指定回调函数，queue指定获取的队列名，no_ack在以后再说明&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>\n<pre class=\"python\">channel.start_consuming()</pre>\n<p>让程序进入到一个死循环中，不断从队列中取出消息</p>\n<h6>消息队列的循环调度</h6>\n<p>消息传递模型</p>\n<p><img src=\"https://img-blog.csdn.net/20180421160404952?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"></p>\n<p>当我们启动多个程序从同一个队列中接收消息的时候，默认是依次接收，即第一个启动的程序首先接收到然后是第二个启动的程序,直到最后一个程序收到之后又从第一个开始，但是这样会造成一个后果就是，可能每个程序或者机器的处理速度不同，造成有的在等待有的消息过多。如下图启动两个接收程序，并发送从0-4数字，两个程序接收的消息依次为：</p>\n<p><img src=\"https://img-blog.csdn.net/20180421141241831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180421141300490?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"><br>\n</p>\n<h6>消息确认</h6>\n<p>在实际应用中一般程序接收消息后处理需要时间，如果在处理的过程中程序崩溃了那么那个消息就会从消息队列中消失了，这当然不是我们想要的结果，我们需要在程序崩溃之后将那条消息转发到另一个程序中执行，这时候我们需要设置只有在消息被确认后才将消息从队列中删除，RabbitMQ默认消息确认是打开的，但是我们可以添加参数no_ack = True来取消，这样即使消息为处理完成也不会再次发送了，会直接从队列中去除。我们还可以使用手动消息确认即在callback中添加一句：</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"><span style=\"vertical-align:inherit\">ch.basic_ack（delivery_tag = method.delivery_tag）</span></pre>\n<h6>消息持久化</h6>\n<p>上面我们已经说了如何保证消费者崩溃时还保留消息，现在我们将介绍如何在RabbitMQ服务终止后还会保留消息队列。这里需要我们在声明这个队列的时候添加一个参数来实现</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"><span style=\"vertical-align:inherit\">channel.queue_declare（queue = </span><span class=\"hljs-string\" style=\"color:rgb(165,194,97)\">'hello'</span><span style=\"vertical-align:inherit\">，durable = </span><span class=\"hljs-keyword\" style=\"color:rgb(194,98,48)\">True</span><span style=\"vertical-align:inherit\">）</span></pre>\n<p>但是这只是保证了hello队列的持久化（下次重启服务的时候队列依然存在），但是队列中消息内容依然是不会被保留下来的，我们想要同时将消息保留下来还需要在channel.basic_publish()函数中添加下面这个参数</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"> properties=pika.BasicProperties(delivery_mode = <span class=\"hljs-number\" style=\"color:rgb(165,194,97)\">2</span>)</pre>\n<p>需要注意的是消息内用只会暂存于缓存中，并未正真写入磁盘中永久保留，还有就是要实现消息持久化的前提是当前队列也是持久化的（不会报错，但是消息并没有被保留下来）</p>\n<h6>公平派遣</h6>\n<p></p>\n<p>实际应用场景中，有些程序或者是机器处理消息的能力强一些，有些会弱一些，那么按照上面的操作所有的消息都是循环分发的这样就会导致有些机器空闲而有些会出现消息过多处理不过来的情况，为了解决这个问题我们可以在消费者中设置最多可容纳多少条消息，当消息数目满了之后就不会再接收新的消息，直到消息被处理完了留有空余才会再次接收消息。</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"><span style=\"vertical-align:inherit\">channel.basic_qos（prefetch_count = </span><span class=\"hljs-number\" style=\"color:rgb(165,194,97)\">1</span><span style=\"vertical-align:inherit\">）</span></pre>\n<p>需要注意的是prefetch_count参数&#20540;并未实际意义，只要为True即可，也就是设置后消费者每次只能接收一个消息与参数&#20540;无关。</p>\n<h6>广播模式</h6>\n<div>消息传递模型</div>\n<p><img src=\"https://img-blog.csdn.net/2018042117585856?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"></p>\n<p>上面所有的都是一对一的消息传递，下面将说一说一对多的传递模型，即广播模式，就好比收音机收听广播一样，需要一个发布者，其他的都是订阅者，发布者发布消息只要订阅者订阅了这个频道那么所有的订阅者都能收到消息。这里的消息传递模型就与之前的略有不同。消息并不是直接发送到队列中，而是经过一个交易所来分发到不同的队列中如上图所示。那么有人会问了，交易所是如何知道要分发到哪一个队列呢，其实只需要将队列和交易所绑定在一起就可以了，每一次消息过来的时候交易所会将消息转发到所有和他绑定的队列中。</p>\n<pre class=\"python\">channel.exchange_declare(exchange='logs',\n                         exchange_type='fanout')\n\nmessage = &quot;info: Hello World!&quot;\nchannel.basic_publish(exchange='logs',\n                      routing_key='',\n                      body=message)</pre>\n<p><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">其中exchange_type类型有direct、topic、headers、fanout<span style=\"letter-spacing:.16px; text-align:left; white-space:pre-wrap\"><span style=\"color:#333333\">这四种，下面主要说明fanout类型。</span></span>上面这段程序指定了一个名为logs的交易所，类型为fanout，下面向这个exchange里面publish一条message消息，routing_key为空表示使用默认操作或称为无名交换。完成了发送程序，下面再来说说接收程序。</span></p>\n<pre class=\"python\">channel.exchange_declare(exchange='logs',\n                         exchange_type='fanout')\n\nresult = channel.queue_declare(exclusive=True)\nqueue_name = result.method.queue\n\nchannel.queue_bind(exchange='logs',\n                   queue=queue_name)</pre>\n<p><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">在第四行代码中声明了一个随机名称的队列，exclusive=True将会让程序在消费者断开连接的时候删除这个队列&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在第七行代码中我们将生成的随机队列和我们之前的交换所绑定在一起，这样当一个消息过来的时候交易所会将消息分发到我们绑定过的队列中</span></p>\n<h6><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">路由</span></h6>\n<p><img src=\"https://img-blog.csdn.net/20180423153004240?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"></p>\n<p>如上图所示</p>\n<p><br>\n</p>\n<p></p>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<p></p>\n<p></p>\n<p></p>\n<p><br>\n</p>\n<p></p>\n<p><br>\n</p>\n","slug":"blogs-Python---RabbitMQ的使用","published":1,"date":"2022-03-16T17:09:23.340Z","updated":"2022-03-16T17:09:23.340Z","_id":"cl0v6kevq001qyms4f9to9syn","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h4>安装</h4>\n<div>RabbitMQ是使用Erlang开发的，因此我们需要首先安装Erlang。<a target=\"_blank\" href=\"http://www.erlang.org/downloads\">http://www.erlang.org/downloads</a>下载对应的版本，安装完成后即可进入下一步。</div>\n<div>下载RabbitMQ&nbsp;<a target=\"_blank\" href=\"http://www.rabbitmq.com/download.html\">http://www.rabbitmq.com/download.html</a>&nbsp;选择默认安装即可，安装完成后可在开始菜单中找到</div>\n<div><img src=\"https://img-blog.csdn.net/20180419202452158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></div>\n<div>点击 RabbitMQ Service - start就开始运行了</div>\n<h4>使用Python进行操作</h4>\n<div>这里我们需要用到pika这个模块来实现，安装好之后我们就可以实现最简单的例子了</div>\n<h6>第一个程序Hello world</h6>\n<p>下面两个例子都来自于官方示例</p>\n<p>消息传递模型</p>\n<p><img src=\"https://img-blog.csdn.net/20180421160239802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"><br>\n</p>\n<div>send.py</div>\n<div>\n<pre class=\"python\">import pika\n\n<p>connection = pika.BlockingConnection(pika.ConnectionParameters(host=’localhost’))<br>channel = connection.channel()</p>\n<p>channel.queue_declare(queue=’hello’)</p>\n<p>channel.basic_publish(exchange=’’,<br>                      routing_key=’hello’,<br>                      body=’Hello World!’)<br>print(&quot; [x] Sent ‘Hello World!’&quot;)<br>connection.close()</pre><br>receive.py</div></p>\n<div>\n<pre class=\"python\">import pika\n\n<p>connection = pika.BlockingConnection(pika.ConnectionParameters(host=’localhost’))<br>channel = connection.channel()</p>\n<p>channel.queue_declare(queue=’hello’)</p>\n<p>def callback(ch, method, properties, body):<br>    print(&quot; [x] Received %r&quot; % body)</p>\n<p>channel.basic_consume(callback,<br>                      queue=’hello’,<br>                      no_ack=True)</p>\n<p>print(‘ [*] Waiting for messages. To exit press CTRL&#43;C’)<br>channel.start_consuming()</pre><br>依次运行这两个函数结果如下</div></p>\n<div><img src=\"https://img-blog.csdn.net/20180419203216036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></div>\n<div><img src=\"https://img-blog.csdn.net/20180419203343047?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></div>\n<div>下面我们再来具体看一看每条语句的具体作用</div>\n<div>\n<pre class=\"python\">connection = pika.BlockingConnection（pika.ConnectionParameters（'localhost'））\nchannel = connection.channel（）</pre>\n第一句是建立连接的，rabbitmq支持本地连接也支持连接到其他机器上，在这里我们选择本地连接。</div>\n<div>第二句是创建一个新的管道，之后的所有操作都是在这个管道上进行的。<br>\n<pre class=\"python\">channel.queue_declare(queue='hello')</pre>\n<div>声明一个队列名为hello，如果你确认这个队列存在那么不声明也是可以的，但是最好声明一下以免造成其他的麻烦。</div>\n</div>\n<div>\n<pre class=\"python\">channel.basic_publish(exchange='',\n                      routing_key='hello',\n                      body='Hello World!')</pre>\n</div>\n<div>向队列中发送一条消息，其中routing_key指定队列名，body为消息内容</div>\n<pre class=\"python\">connection.close()</pre>\n<p>关闭连接</p>\n<p>receive.py中前面几句和send中的作用是一样的，这里不再赘述。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<pre class=\"python\">def callback(ch, method, properties, body):\n    print(&quot; [x] Received %r&quot; % body)</pre>\n<p>callback是回调函数，当程序从队列中获取消息后都会执行回调函数来处理消息&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<pre class=\"python\">channel.basic_consume(callback,\n                      queue='hello',\n                      #no_ack=True\n                      )</pre>\n<p>从队列中获取消息，callback指定回调函数，queue指定获取的队列名，no_ack在以后再说明&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>\n<pre class=\"python\">channel.start_consuming()</pre>\n<p>让程序进入到一个死循环中，不断从队列中取出消息</p>\n<h6>消息队列的循环调度</h6>\n<p>消息传递模型</p>\n<p><img src=\"https://img-blog.csdn.net/20180421160404952?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"></p>\n<p>当我们启动多个程序从同一个队列中接收消息的时候，默认是依次接收，即第一个启动的程序首先接收到然后是第二个启动的程序,直到最后一个程序收到之后又从第一个开始，但是这样会造成一个后果就是，可能每个程序或者机器的处理速度不同，造成有的在等待有的消息过多。如下图启动两个接收程序，并发送从0-4数字，两个程序接收的消息依次为：</p>\n<p><img src=\"https://img-blog.csdn.net/20180421141241831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180421141300490?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"><br>\n</p>\n<h6>消息确认</h6>\n<p>在实际应用中一般程序接收消息后处理需要时间，如果在处理的过程中程序崩溃了那么那个消息就会从消息队列中消失了，这当然不是我们想要的结果，我们需要在程序崩溃之后将那条消息转发到另一个程序中执行，这时候我们需要设置只有在消息被确认后才将消息从队列中删除，RabbitMQ默认消息确认是打开的，但是我们可以添加参数no_ack = True来取消，这样即使消息为处理完成也不会再次发送了，会直接从队列中去除。我们还可以使用手动消息确认即在callback中添加一句：</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"><span style=\"vertical-align:inherit\">ch.basic_ack（delivery_tag = method.delivery_tag）</span></pre>\n<h6>消息持久化</h6>\n<p>上面我们已经说了如何保证消费者崩溃时还保留消息，现在我们将介绍如何在RabbitMQ服务终止后还会保留消息队列。这里需要我们在声明这个队列的时候添加一个参数来实现</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"><span style=\"vertical-align:inherit\">channel.queue_declare（queue = </span><span class=\"hljs-string\" style=\"color:rgb(165,194,97)\">'hello'</span><span style=\"vertical-align:inherit\">，durable = </span><span class=\"hljs-keyword\" style=\"color:rgb(194,98,48)\">True</span><span style=\"vertical-align:inherit\">）</span></pre>\n<p>但是这只是保证了hello队列的持久化（下次重启服务的时候队列依然存在），但是队列中消息内容依然是不会被保留下来的，我们想要同时将消息保留下来还需要在channel.basic_publish()函数中添加下面这个参数</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"> properties=pika.BasicProperties(delivery_mode = <span class=\"hljs-number\" style=\"color:rgb(165,194,97)\">2</span>)</pre>\n<p>需要注意的是消息内用只会暂存于缓存中，并未正真写入磁盘中永久保留，还有就是要实现消息持久化的前提是当前队列也是持久化的（不会报错，但是消息并没有被保留下来）</p>\n<h6>公平派遣</h6>\n<p></p>\n<p>实际应用场景中，有些程序或者是机器处理消息的能力强一些，有些会弱一些，那么按照上面的操作所有的消息都是循环分发的这样就会导致有些机器空闲而有些会出现消息过多处理不过来的情况，为了解决这个问题我们可以在消费者中设置最多可容纳多少条消息，当消息数目满了之后就不会再接收新的消息，直到消息被处理完了留有空余才会再次接收消息。</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"><span style=\"vertical-align:inherit\">channel.basic_qos（prefetch_count = </span><span class=\"hljs-number\" style=\"color:rgb(165,194,97)\">1</span><span style=\"vertical-align:inherit\">）</span></pre>\n<p>需要注意的是prefetch_count参数&#20540;并未实际意义，只要为True即可，也就是设置后消费者每次只能接收一个消息与参数&#20540;无关。</p>\n<h6>广播模式</h6>\n<div>消息传递模型</div>\n<p><img src=\"https://img-blog.csdn.net/2018042117585856?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"></p>\n<p>上面所有的都是一对一的消息传递，下面将说一说一对多的传递模型，即广播模式，就好比收音机收听广播一样，需要一个发布者，其他的都是订阅者，发布者发布消息只要订阅者订阅了这个频道那么所有的订阅者都能收到消息。这里的消息传递模型就与之前的略有不同。消息并不是直接发送到队列中，而是经过一个交易所来分发到不同的队列中如上图所示。那么有人会问了，交易所是如何知道要分发到哪一个队列呢，其实只需要将队列和交易所绑定在一起就可以了，每一次消息过来的时候交易所会将消息转发到所有和他绑定的队列中。</p>\n<pre class=\"python\">channel.exchange_declare(exchange='logs',\n                         exchange_type='fanout')\n\n<p>message = &quot;info: Hello World!&quot;<br>channel.basic_publish(exchange=’logs’,<br>                      routing_key=’’,<br>                      body=message)</pre></p>\n<p><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">其中exchange_type类型有direct、topic、headers、fanout<span style=\"letter-spacing:.16px; text-align:left; white-space:pre-wrap\"><span style=\"color:#333333\">这四种，下面主要说明fanout类型。</span></span>上面这段程序指定了一个名为logs的交易所，类型为fanout，下面向这个exchange里面publish一条message消息，routing_key为空表示使用默认操作或称为无名交换。完成了发送程序，下面再来说说接收程序。</span></p>\n<pre class=\"python\">channel.exchange_declare(exchange='logs',\n                         exchange_type='fanout')\n\n<p>result = channel.queue_declare(exclusive=True)<br>queue_name = result.method.queue</p>\n<p>channel.queue_bind(exchange=’logs’,<br>                   queue=queue_name)</pre></p>\n<p><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">在第四行代码中声明了一个随机名称的队列，exclusive=True将会让程序在消费者断开连接的时候删除这个队列&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在第七行代码中我们将生成的随机队列和我们之前的交换所绑定在一起，这样当一个消息过来的时候交易所会将消息分发到我们绑定过的队列中</span></p>\n<h6><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">路由</span></h6>\n<p><img src=\"https://img-blog.csdn.net/20180423153004240?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"></p>\n<p>如上图所示</p>\n<p><br>\n</p>\n<p></p>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<p></p>\n<p></p>\n<p></p>\n<p><br>\n</p>\n<p></p>\n<p><br>\n</p>\n","site":{"data":{}},"excerpt":"","more":"<h4>安装</h4>\n<div>RabbitMQ是使用Erlang开发的，因此我们需要首先安装Erlang。<a target=\"_blank\" href=\"http://www.erlang.org/downloads\">http://www.erlang.org/downloads</a>下载对应的版本，安装完成后即可进入下一步。</div>\n<div>下载RabbitMQ&nbsp;<a target=\"_blank\" href=\"http://www.rabbitmq.com/download.html\">http://www.rabbitmq.com/download.html</a>&nbsp;选择默认安装即可，安装完成后可在开始菜单中找到</div>\n<div><img src=\"https://img-blog.csdn.net/20180419202452158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></div>\n<div>点击 RabbitMQ Service - start就开始运行了</div>\n<h4>使用Python进行操作</h4>\n<div>这里我们需要用到pika这个模块来实现，安装好之后我们就可以实现最简单的例子了</div>\n<h6>第一个程序Hello world</h6>\n<p>下面两个例子都来自于官方示例</p>\n<p>消息传递模型</p>\n<p><img src=\"https://img-blog.csdn.net/20180421160239802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"><br>\n</p>\n<div>send.py</div>\n<div>\n<pre class=\"python\">import pika\n\n<p>connection = pika.BlockingConnection(pika.ConnectionParameters(host=’localhost’))<br>channel = connection.channel()</p>\n<p>channel.queue_declare(queue=’hello’)</p>\n<p>channel.basic_publish(exchange=’’,<br>                      routing_key=’hello’,<br>                      body=’Hello World!’)<br>print(&quot; [x] Sent ‘Hello World!’&quot;)<br>connection.close()</pre><br>receive.py</div></p>\n<div>\n<pre class=\"python\">import pika\n\n<p>connection = pika.BlockingConnection(pika.ConnectionParameters(host=’localhost’))<br>channel = connection.channel()</p>\n<p>channel.queue_declare(queue=’hello’)</p>\n<p>def callback(ch, method, properties, body):<br>    print(&quot; [x] Received %r&quot; % body)</p>\n<p>channel.basic_consume(callback,<br>                      queue=’hello’,<br>                      no_ack=True)</p>\n<p>print(‘ [*] Waiting for messages. To exit press CTRL&#43;C’)<br>channel.start_consuming()</pre><br>依次运行这两个函数结果如下</div></p>\n<div><img src=\"https://img-blog.csdn.net/20180419203216036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></div>\n<div><img src=\"https://img-blog.csdn.net/20180419203343047?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></div>\n<div>下面我们再来具体看一看每条语句的具体作用</div>\n<div>\n<pre class=\"python\">connection = pika.BlockingConnection（pika.ConnectionParameters（'localhost'））\nchannel = connection.channel（）</pre>\n第一句是建立连接的，rabbitmq支持本地连接也支持连接到其他机器上，在这里我们选择本地连接。</div>\n<div>第二句是创建一个新的管道，之后的所有操作都是在这个管道上进行的。<br>\n<pre class=\"python\">channel.queue_declare(queue='hello')</pre>\n<div>声明一个队列名为hello，如果你确认这个队列存在那么不声明也是可以的，但是最好声明一下以免造成其他的麻烦。</div>\n</div>\n<div>\n<pre class=\"python\">channel.basic_publish(exchange='',\n                      routing_key='hello',\n                      body='Hello World!')</pre>\n</div>\n<div>向队列中发送一条消息，其中routing_key指定队列名，body为消息内容</div>\n<pre class=\"python\">connection.close()</pre>\n<p>关闭连接</p>\n<p>receive.py中前面几句和send中的作用是一样的，这里不再赘述。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<pre class=\"python\">def callback(ch, method, properties, body):\n    print(&quot; [x] Received %r&quot; % body)</pre>\n<p>callback是回调函数，当程序从队列中获取消息后都会执行回调函数来处理消息&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>\n<pre class=\"python\">channel.basic_consume(callback,\n                      queue='hello',\n                      #no_ack=True\n                      )</pre>\n<p>从队列中获取消息，callback指定回调函数，queue指定获取的队列名，no_ack在以后再说明&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>\n<pre class=\"python\">channel.start_consuming()</pre>\n<p>让程序进入到一个死循环中，不断从队列中取出消息</p>\n<h6>消息队列的循环调度</h6>\n<p>消息传递模型</p>\n<p><img src=\"https://img-blog.csdn.net/20180421160404952?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"></p>\n<p>当我们启动多个程序从同一个队列中接收消息的时候，默认是依次接收，即第一个启动的程序首先接收到然后是第二个启动的程序,直到最后一个程序收到之后又从第一个开始，但是这样会造成一个后果就是，可能每个程序或者机器的处理速度不同，造成有的在等待有的消息过多。如下图启动两个接收程序，并发送从0-4数字，两个程序接收的消息依次为：</p>\n<p><img src=\"https://img-blog.csdn.net/20180421141241831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"><img src=\"https://img-blog.csdn.net/20180421141300490?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"><br>\n</p>\n<h6>消息确认</h6>\n<p>在实际应用中一般程序接收消息后处理需要时间，如果在处理的过程中程序崩溃了那么那个消息就会从消息队列中消失了，这当然不是我们想要的结果，我们需要在程序崩溃之后将那条消息转发到另一个程序中执行，这时候我们需要设置只有在消息被确认后才将消息从队列中删除，RabbitMQ默认消息确认是打开的，但是我们可以添加参数no_ack = True来取消，这样即使消息为处理完成也不会再次发送了，会直接从队列中去除。我们还可以使用手动消息确认即在callback中添加一句：</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"><span style=\"vertical-align:inherit\">ch.basic_ack（delivery_tag = method.delivery_tag）</span></pre>\n<h6>消息持久化</h6>\n<p>上面我们已经说了如何保证消费者崩溃时还保留消息，现在我们将介绍如何在RabbitMQ服务终止后还会保留消息队列。这里需要我们在声明这个队列的时候添加一个参数来实现</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"><span style=\"vertical-align:inherit\">channel.queue_declare（queue = </span><span class=\"hljs-string\" style=\"color:rgb(165,194,97)\">'hello'</span><span style=\"vertical-align:inherit\">，durable = </span><span class=\"hljs-keyword\" style=\"color:rgb(194,98,48)\">True</span><span style=\"vertical-align:inherit\">）</span></pre>\n<p>但是这只是保证了hello队列的持久化（下次重启服务的时候队列依然存在），但是队列中消息内容依然是不会被保留下来的，我们想要同时将消息保留下来还需要在channel.basic_publish()函数中添加下面这个参数</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"> properties=pika.BasicProperties(delivery_mode = <span class=\"hljs-number\" style=\"color:rgb(165,194,97)\">2</span>)</pre>\n<p>需要注意的是消息内用只会暂存于缓存中，并未正真写入磁盘中永久保留，还有就是要实现消息持久化的前提是当前队列也是持久化的（不会报错，但是消息并没有被保留下来）</p>\n<h6>公平派遣</h6>\n<p></p>\n<p>实际应用场景中，有些程序或者是机器处理消息的能力强一些，有些会弱一些，那么按照上面的操作所有的消息都是循环分发的这样就会导致有些机器空闲而有些会出现消息过多处理不过来的情况，为了解决这个问题我们可以在消费者中设置最多可容纳多少条消息，当消息数目满了之后就不会再接收新的消息，直到消息被处理完了留有空余才会再次接收消息。</p>\n<pre class=\"sourcecode python hljs\" style=\"padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left\"><span style=\"vertical-align:inherit\">channel.basic_qos（prefetch_count = </span><span class=\"hljs-number\" style=\"color:rgb(165,194,97)\">1</span><span style=\"vertical-align:inherit\">）</span></pre>\n<p>需要注意的是prefetch_count参数&#20540;并未实际意义，只要为True即可，也就是设置后消费者每次只能接收一个消息与参数&#20540;无关。</p>\n<h6>广播模式</h6>\n<div>消息传递模型</div>\n<p><img src=\"https://img-blog.csdn.net/2018042117585856?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"></p>\n<p>上面所有的都是一对一的消息传递，下面将说一说一对多的传递模型，即广播模式，就好比收音机收听广播一样，需要一个发布者，其他的都是订阅者，发布者发布消息只要订阅者订阅了这个频道那么所有的订阅者都能收到消息。这里的消息传递模型就与之前的略有不同。消息并不是直接发送到队列中，而是经过一个交易所来分发到不同的队列中如上图所示。那么有人会问了，交易所是如何知道要分发到哪一个队列呢，其实只需要将队列和交易所绑定在一起就可以了，每一次消息过来的时候交易所会将消息转发到所有和他绑定的队列中。</p>\n<pre class=\"python\">channel.exchange_declare(exchange='logs',\n                         exchange_type='fanout')\n\n<p>message = &quot;info: Hello World!&quot;<br>channel.basic_publish(exchange=’logs’,<br>                      routing_key=’’,<br>                      body=message)</pre></p>\n<p><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">其中exchange_type类型有direct、topic、headers、fanout<span style=\"letter-spacing:.16px; text-align:left; white-space:pre-wrap\"><span style=\"color:#333333\">这四种，下面主要说明fanout类型。</span></span>上面这段程序指定了一个名为logs的交易所，类型为fanout，下面向这个exchange里面publish一条message消息，routing_key为空表示使用默认操作或称为无名交换。完成了发送程序，下面再来说说接收程序。</span></p>\n<pre class=\"python\">channel.exchange_declare(exchange='logs',\n                         exchange_type='fanout')\n\n<p>result = channel.queue_declare(exclusive=True)<br>queue_name = result.method.queue</p>\n<p>channel.queue_bind(exchange=’logs’,<br>                   queue=queue_name)</pre></p>\n<p><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">在第四行代码中声明了一个随机名称的队列，exclusive=True将会让程序在消费者断开连接的时候删除这个队列&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在第七行代码中我们将生成的随机队列和我们之前的交换所绑定在一起，这样当一个消息过来的时候交易所会将消息分发到我们绑定过的队列中</span></p>\n<h6><span style=\"font-family:'Microsoft YaHei'; font-size:14px\">路由</span></h6>\n<p><img src=\"https://img-blog.csdn.net/20180423153004240?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"\"></p>\n<p>如上图所示</p>\n<p><br>\n</p>\n<p></p>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<p></p>\n<p></p>\n<p></p>\n<p><br>\n</p>\n<p></p>\n<p><br>\n</p>\n"},{"_content":"\n<p><span style=\"color:#ff0000\">自学笔记：逻辑可能比较混乱，想到哪说到哪，可能存在不少的问题欢迎指出。</span></p>\n<h3>创建一个类：</h3>\n<h4>最简单的一个类</h4>\n<div>在python中类的命名必须以字母或者下画线开头，并且只能包含字母、下画线和数字。另外推荐使用驼峰命名方式（大写字母开头，随后的任意一个单词都以大写字母开头）</div>\n<div>python最简单的一个类的创建</div>\n<div><pre name=\"code\" class=\"python\">class MyFirstClass:\n\tpass</pre>\n<h4>类的属性和方法</h4>\n在类中我们还可以为其添加属性和方法</div>\n<div><pre name=\"code\" class=\"python\">class MyFirstClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 1\n\n    def show(self):\n        print(self.x,self.y)\n\nc = MyFirstClass()\nc.show()</pre></div>\n<div>其中self.x和self.y为该类的属性，show()为该类的方法</div>\n<div>类中的方法的定义方式和普通函数相同，都是以关键字def开头，但是有一点不同的是类中的方法有一个必需的参数，通常这个参数被命名为self,但是我们实例化类后调用show方法的时候并没有传入参数，这是因为python自动帮我们做了，当我们调用c对象的show方法的时候，python会自动将c对象传给show方法了。因此下面这个调用方式运行结果是一样的。</div>\n<div><pre name=\"code\" class=\"python\">c = MyFirstClass()\nMyFirstClass.show(c)</pre>其实类中的方法本质上就是一个函数，我们可以在外部调用也可以在类中调用，例如：</div>\n<div><pre name=\"code\" class=\"python\">class Point:\n    def __init__(self, x ,y ):\n        self.x = x\n        self.y = y\n\n    def reset(self):\n        self.x = 0\n        self.y = 0\n        self.show()\n\n    def show(self):\n        print(self.x, self.y)\n\np = Point(1,1)\np.reset()</pre></div>\n<div>运行结果为：0&nbsp; 0</div>\n<div>\n<h4>类的初始化</h4>\n<div>一般的编程语言中都有一个叫构造函数的特殊方法，当它被创建的时候会创建和初始化对象，这一点Python会有些许不同，python有一个构造函数和一个初始化函数，一般情况下构造函数很少被用到，除非是想实现一些特别的操作，所以在此主要说一下类的初始化。我们在之前的示例中有一个方法名为__init__(),其实这个方法就是给类进行初始化操作的。当我们实例化的时候会首先执行__init__()方法，因此当__init__()方法需要传递参数的时候我们在实例化的时候同样需要传递参数，不然会报错。</div>\n<div>由于方法本质上就是函数，当我们不想传递参数的时候也可以同函数的操作一样使用默认参数。</div>\n<div><pre name=\"code\" class=\"python\">def __init__(self, x=0, y=0):\n    self.x = x\n    self.y = y</pre></div>\n</div>\n<h3>面向对象三个基本特征</h3>\n<div>面向对象编程的三个基本特征分别为：封装、继承、多态，下面一一说明。</div>\n<h4>继承</h4>\n<div>继承就是让一个类获得另一个类的属性和方法，在Python中所有的类都是object类的子类，只是在实际的使用中我们并不需要表明，python在后台自己帮我们做了</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<p><br>\n</p>\n","source":"_posts/blogs-Python3面向对象编程总结.md","raw":"\n<p><span style=\"color:#ff0000\">自学笔记：逻辑可能比较混乱，想到哪说到哪，可能存在不少的问题欢迎指出。</span></p>\n<h3>创建一个类：</h3>\n<h4>最简单的一个类</h4>\n<div>在python中类的命名必须以字母或者下画线开头，并且只能包含字母、下画线和数字。另外推荐使用驼峰命名方式（大写字母开头，随后的任意一个单词都以大写字母开头）</div>\n<div>python最简单的一个类的创建</div>\n<div><pre name=\"code\" class=\"python\">class MyFirstClass:\n\tpass</pre>\n<h4>类的属性和方法</h4>\n在类中我们还可以为其添加属性和方法</div>\n<div><pre name=\"code\" class=\"python\">class MyFirstClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 1\n\n    def show(self):\n        print(self.x,self.y)\n\nc = MyFirstClass()\nc.show()</pre></div>\n<div>其中self.x和self.y为该类的属性，show()为该类的方法</div>\n<div>类中的方法的定义方式和普通函数相同，都是以关键字def开头，但是有一点不同的是类中的方法有一个必需的参数，通常这个参数被命名为self,但是我们实例化类后调用show方法的时候并没有传入参数，这是因为python自动帮我们做了，当我们调用c对象的show方法的时候，python会自动将c对象传给show方法了。因此下面这个调用方式运行结果是一样的。</div>\n<div><pre name=\"code\" class=\"python\">c = MyFirstClass()\nMyFirstClass.show(c)</pre>其实类中的方法本质上就是一个函数，我们可以在外部调用也可以在类中调用，例如：</div>\n<div><pre name=\"code\" class=\"python\">class Point:\n    def __init__(self, x ,y ):\n        self.x = x\n        self.y = y\n\n    def reset(self):\n        self.x = 0\n        self.y = 0\n        self.show()\n\n    def show(self):\n        print(self.x, self.y)\n\np = Point(1,1)\np.reset()</pre></div>\n<div>运行结果为：0&nbsp; 0</div>\n<div>\n<h4>类的初始化</h4>\n<div>一般的编程语言中都有一个叫构造函数的特殊方法，当它被创建的时候会创建和初始化对象，这一点Python会有些许不同，python有一个构造函数和一个初始化函数，一般情况下构造函数很少被用到，除非是想实现一些特别的操作，所以在此主要说一下类的初始化。我们在之前的示例中有一个方法名为__init__(),其实这个方法就是给类进行初始化操作的。当我们实例化的时候会首先执行__init__()方法，因此当__init__()方法需要传递参数的时候我们在实例化的时候同样需要传递参数，不然会报错。</div>\n<div>由于方法本质上就是函数，当我们不想传递参数的时候也可以同函数的操作一样使用默认参数。</div>\n<div><pre name=\"code\" class=\"python\">def __init__(self, x=0, y=0):\n    self.x = x\n    self.y = y</pre></div>\n</div>\n<h3>面向对象三个基本特征</h3>\n<div>面向对象编程的三个基本特征分别为：封装、继承、多态，下面一一说明。</div>\n<h4>继承</h4>\n<div>继承就是让一个类获得另一个类的属性和方法，在Python中所有的类都是object类的子类，只是在实际的使用中我们并不需要表明，python在后台自己帮我们做了</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<p><br>\n</p>\n","slug":"blogs-Python3面向对象编程总结","published":1,"date":"2022-03-16T17:09:22.024Z","updated":"2022-03-16T17:09:22.024Z","_id":"cl0v6kevr001ryms44og4ffvg","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p><span style=\"color:#ff0000\">自学笔记：逻辑可能比较混乱，想到哪说到哪，可能存在不少的问题欢迎指出。</span></p>\n<h3>创建一个类：</h3>\n<h4>最简单的一个类</h4>\n<div>在python中类的命名必须以字母或者下画线开头，并且只能包含字母、下画线和数字。另外推荐使用驼峰命名方式（大写字母开头，随后的任意一个单词都以大写字母开头）</div>\n<div>python最简单的一个类的创建</div>\n<div><pre name=\"code\" class=\"python\">class MyFirstClass:\n    pass</pre>\n<h4>类的属性和方法</h4>\n在类中我们还可以为其添加属性和方法</div>\n<div><pre name=\"code\" class=\"python\">class MyFirstClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 1\n\n<pre><code>def show(self):\n    print(self.x,self.y)\n</code></pre>\n<p>c = MyFirstClass()<br>c.show()</pre></div></p>\n<div>其中self.x和self.y为该类的属性，show()为该类的方法</div>\n<div>类中的方法的定义方式和普通函数相同，都是以关键字def开头，但是有一点不同的是类中的方法有一个必需的参数，通常这个参数被命名为self,但是我们实例化类后调用show方法的时候并没有传入参数，这是因为python自动帮我们做了，当我们调用c对象的show方法的时候，python会自动将c对象传给show方法了。因此下面这个调用方式运行结果是一样的。</div>\n<div><pre name=\"code\" class=\"python\">c = MyFirstClass()\nMyFirstClass.show(c)</pre>其实类中的方法本质上就是一个函数，我们可以在外部调用也可以在类中调用，例如：</div>\n<div><pre name=\"code\" class=\"python\">class Point:\n    def __init__(self, x ,y ):\n        self.x = x\n        self.y = y\n\n<pre><code>def reset(self):\n    self.x = 0\n    self.y = 0\n    self.show()\n\ndef show(self):\n    print(self.x, self.y)\n</code></pre>\n<p>p = Point(1,1)<br>p.reset()</pre></div></p>\n<div>运行结果为：0&nbsp; 0</div>\n<div>\n<h4>类的初始化</h4>\n<div>一般的编程语言中都有一个叫构造函数的特殊方法，当它被创建的时候会创建和初始化对象，这一点Python会有些许不同，python有一个构造函数和一个初始化函数，一般情况下构造函数很少被用到，除非是想实现一些特别的操作，所以在此主要说一下类的初始化。我们在之前的示例中有一个方法名为__init__(),其实这个方法就是给类进行初始化操作的。当我们实例化的时候会首先执行__init__()方法，因此当__init__()方法需要传递参数的时候我们在实例化的时候同样需要传递参数，不然会报错。</div>\n<div>由于方法本质上就是函数，当我们不想传递参数的时候也可以同函数的操作一样使用默认参数。</div>\n<div><pre name=\"code\" class=\"python\">def __init__(self, x=0, y=0):\n    self.x = x\n    self.y = y</pre></div>\n</div>\n<h3>面向对象三个基本特征</h3>\n<div>面向对象编程的三个基本特征分别为：封装、继承、多态，下面一一说明。</div>\n<h4>继承</h4>\n<div>继承就是让一个类获得另一个类的属性和方法，在Python中所有的类都是object类的子类，只是在实际的使用中我们并不需要表明，python在后台自己帮我们做了</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<p><br>\n</p>\n","site":{"data":{}},"excerpt":"","more":"<p><span style=\"color:#ff0000\">自学笔记：逻辑可能比较混乱，想到哪说到哪，可能存在不少的问题欢迎指出。</span></p>\n<h3>创建一个类：</h3>\n<h4>最简单的一个类</h4>\n<div>在python中类的命名必须以字母或者下画线开头，并且只能包含字母、下画线和数字。另外推荐使用驼峰命名方式（大写字母开头，随后的任意一个单词都以大写字母开头）</div>\n<div>python最简单的一个类的创建</div>\n<div><pre name=\"code\" class=\"python\">class MyFirstClass:\n    pass</pre>\n<h4>类的属性和方法</h4>\n在类中我们还可以为其添加属性和方法</div>\n<div><pre name=\"code\" class=\"python\">class MyFirstClass:\n    def __init__(self):\n        self.x = 1\n        self.y = 1\n\n<pre><code>def show(self):\n    print(self.x,self.y)\n</code></pre>\n<p>c = MyFirstClass()<br>c.show()</pre></div></p>\n<div>其中self.x和self.y为该类的属性，show()为该类的方法</div>\n<div>类中的方法的定义方式和普通函数相同，都是以关键字def开头，但是有一点不同的是类中的方法有一个必需的参数，通常这个参数被命名为self,但是我们实例化类后调用show方法的时候并没有传入参数，这是因为python自动帮我们做了，当我们调用c对象的show方法的时候，python会自动将c对象传给show方法了。因此下面这个调用方式运行结果是一样的。</div>\n<div><pre name=\"code\" class=\"python\">c = MyFirstClass()\nMyFirstClass.show(c)</pre>其实类中的方法本质上就是一个函数，我们可以在外部调用也可以在类中调用，例如：</div>\n<div><pre name=\"code\" class=\"python\">class Point:\n    def __init__(self, x ,y ):\n        self.x = x\n        self.y = y\n\n<pre><code>def reset(self):\n    self.x = 0\n    self.y = 0\n    self.show()\n\ndef show(self):\n    print(self.x, self.y)\n</code></pre>\n<p>p = Point(1,1)<br>p.reset()</pre></div></p>\n<div>运行结果为：0&nbsp; 0</div>\n<div>\n<h4>类的初始化</h4>\n<div>一般的编程语言中都有一个叫构造函数的特殊方法，当它被创建的时候会创建和初始化对象，这一点Python会有些许不同，python有一个构造函数和一个初始化函数，一般情况下构造函数很少被用到，除非是想实现一些特别的操作，所以在此主要说一下类的初始化。我们在之前的示例中有一个方法名为__init__(),其实这个方法就是给类进行初始化操作的。当我们实例化的时候会首先执行__init__()方法，因此当__init__()方法需要传递参数的时候我们在实例化的时候同样需要传递参数，不然会报错。</div>\n<div>由于方法本质上就是函数，当我们不想传递参数的时候也可以同函数的操作一样使用默认参数。</div>\n<div><pre name=\"code\" class=\"python\">def __init__(self, x=0, y=0):\n    self.x = x\n    self.y = y</pre></div>\n</div>\n<h3>面向对象三个基本特征</h3>\n<div>面向对象编程的三个基本特征分别为：封装、继承、多态，下面一一说明。</div>\n<h4>继承</h4>\n<div>继承就是让一个类获得另一个类的属性和方法，在Python中所有的类都是object类的子类，只是在实际的使用中我们并不需要表明，python在后台自己帮我们做了</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<div><br>\n</div>\n<p><br>\n</p>\n"},{"_content":"\n<h4>调用方式</h4>\n<p>python的线程调用有两种方式。一种是直接调用，一种是继承式调用</p>\n<p>直接调用</p>\n<pre class=\"python\">import threading,time\n\n#方法一\ndef run(n):\n\n    print(n)\n    time.sleep(2)\nt1 = threading.Thread(target=run,args=(&quot;t1&quot;,))\nt2 = threading.Thread(target=run,args=(&quot;t2&quot;,))\nt1.start()\nt2.start()</pre>\n使用类的方法调用\n<pre class=\"python\">#方法二（使用类的方法）\nimport threading,time\nclass MyThread(threading.Thread):\n    def __init__(self,n):\n        super(MyThread,self).__init__()\n        self.n = n\n\n    def run(self):     #函数名必须为run\n        print(self.n)\n        time.sleep(2)\n\nt1 = MyThread(1)\nt2 = MyThread(2)\n\nt1.start()\nt2.start()</pre>\n<p><br>\n</p>\n<h4>join和Daemon</h4>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">join()等待线程结束后再往后继续运行</span></p>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">Daemon()守护线程</span></p>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">使用setDaemon(True)那么主线程不会等待子线程结束才结束，主线程结束后子线程也会直接结束，必须要在start之前设置否则会报错</span></p>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">python中默认为setDaemon(False),主线程结束了子线程依然会执行直到完毕。</span></p>\n<p><span style=\"color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px\">join例子：</span></p>\n<pre class=\"python\">import threading,time\nclass MyThread(threading.Thread):\n    def __init__(self,n):\n        super(MyThread,self).__init__()\n        self.n = n\n\n    def run(self):     #函数名必须为run\n        print(self.n)\n        time.sleep(2)\n        print('end')\n\nt1 = MyThread('t1')\nt2 = MyThread('t2')\nt1.start()\nt1.join()\nt2.start()\nt2.join()</pre>\n结果\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\"><img src=\"https://img-blog.csdn.net/20180310153251692?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></p>\n<p>setDaemon()例子</p>\n<pre class=\"python\">import threading,time\nclass MyThread(threading.Thread):\n    def __init__(self,n):\n        super(MyThread,self).__init__()\n        self.n = n\n\n    def run(self):     #函数名必须为run\n        print(self.n)\n        time.sleep(2)\n        print('end')\n\nt1 = MyThread('t1')\nt2 = MyThread('t2')\nt1.setDaemon(True)\nt2.setDaemon(True)\nt1.start()\nt2.start()</pre>\n<p>结果</p>\n<img src=\"https://img-blog.csdn.net/20180310153422919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<br>\n<p></p>\n<h4><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; color:#333333\"><span style=\"font-size:14px\">线程锁</span></span></h4>\n<div>子线程可以共享父线程的内存空间，当存在多个子线程需要同时修改一个数据的时候就可能出现问题</div>\n<div>假设两个子线程执行的操作都是num&#43;1，由于线程是同时执行的，第一个子线程先取num = 1 ，第二个线程有取出num依然为1，线程一结束后num更改为2，随之线程二结束num依然被改为2，就与我们的目标出现冲突，这个时候就需要用到线程锁了，当线程一访问num的时候线程二是无法访问num的，线程一结束后释放num线程二才能访问num，这就使得num的结果不会产生冲突了。</div>\n<div>\n<pre class=\"python\">#线程锁示例\nimport threading\n\nnum = 0\nt_objs = []\nlock = threading.Lock()\n\ndef run():\n    lock.acquire()  #加锁\n    global num      #声明全局变量\n    num &#43;= 1        #执行加一操作\n    lock.release()  #释放锁\n\nfor i in range(500):\n    t = threading.Thread(target=run)\n    t.start()\n    t_objs.append(t)\n\nfor t in t_objs:    #等待所有线程结束\n    t.join()\n\nprint(num)</pre>\n递归锁则是在一个锁里面又嵌套另外一个线程锁</div>\n<div>\n<pre class=\"python\">#递归锁\nimport threading\n\ndef run1():\n    lock.acquire()\n    global num\n    num &#43;= 1\n    lock.release()\n    return num\n\ndef run2():\n    lock.acquire()\n    global num2\n    num2 &#43;= 1\n    lock.release()\n    return num2\n\ndef run3():\n    lock.acquire()\n    res = run1()\n    res2 = run2()\n    lock.release()\n    print(res, res2)\n\nif __name__ == '__main__':\n\n    num, num2 = 0, 0\n    lock = threading.RLock()\n    for i in range(10):\n        t = threading.Thread(target=run3)\n        t.start()</pre>\n结果<br>\n<img src=\"https://img-blog.csdn.net/20180310173722570?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div><br>\n</div>\n<h4>信号量（Semaphore）</h4>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">线程锁每次只允许一个线程操作数据，Semaphore则可同时允许多个线程操作，当达到允许的最大&#20540;的时候后面的则需要等待，前面的线程执行完毕后才可执行，因此操作同一个数据的时候依然有可能出错</span></span></div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">#信号量\n\nimport threading,time\n\ndef run(num):\n    semaphore.acquire()\n    time.sleep(1)\n    print(num)\n    semaphore.release()\n\nsemaphore = threading.BoundedSemaphore(3) #最多运行三个线程\nfor i in range(10):\n    t = threading.Thread(target=run,args=(i,))\n    t.start()</pre>\n<h4><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">事件（Event）</span></span></h4>\n</div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">Event默认内置了一个标志，初始&#20540;为False<br>\n</span></span></div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">event总共就四中方法：set()、clear()、wait()、is_set()</span></span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">set()设置标志位为True</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">clear()设置标志位为False</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">wait()等待标志位设为True</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">is_set()判断标志位是否被设为True</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\"><br>\n</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">已红绿灯为例说明，首先写出交通灯，event.clear()相当于红灯，event.set()相当于绿灯,红灯为5秒绿灯也为5秒，用count来计数，当count超过10的时候重置count，这样红绿灯就能以5秒为间隔循环运行</span></div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">import time,threading\n\nevent = threading.Event()\n\ndef light():\n    count = 0\n    while True:\n        if count &gt;= 5 and count &lt; 10:\n            event.clear()     #相当于红灯了\n            print(&quot;red light please wait...&quot;)\n        elif count &gt; 10 :\n            event.set()       #相当于绿灯\n            count = 0        \n        else:\n            print(&quot;go go go ...&quot;)\n        time.sleep(1)\n        count &#43;= 1</pre>\n再来写car</div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">def car():\n    while True:\n        if event.is_set():  #判断event是否被set，相当于检测是否为绿灯\n            print('run...')\n            time.sleep(1)\n        else:\n            print('waiting for green light..')\n            event.wait()\n            print('green light is on go...')</pre>\n运行</div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">l = threading.Thread(target=light)\nc = threading.Thread(target=car)\nl.start()\nc.start()</pre>\n最终的结果</div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"><img src=\"https://img-blog.csdn.net/20180310202538695?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<br>\n<br>\n</span></span></div>\n<div></div>\n<p></p>\n","source":"_posts/blogs-Python基础---线程.md","raw":"\n<h4>调用方式</h4>\n<p>python的线程调用有两种方式。一种是直接调用，一种是继承式调用</p>\n<p>直接调用</p>\n<pre class=\"python\">import threading,time\n\n#方法一\ndef run(n):\n\n    print(n)\n    time.sleep(2)\nt1 = threading.Thread(target=run,args=(&quot;t1&quot;,))\nt2 = threading.Thread(target=run,args=(&quot;t2&quot;,))\nt1.start()\nt2.start()</pre>\n使用类的方法调用\n<pre class=\"python\">#方法二（使用类的方法）\nimport threading,time\nclass MyThread(threading.Thread):\n    def __init__(self,n):\n        super(MyThread,self).__init__()\n        self.n = n\n\n    def run(self):     #函数名必须为run\n        print(self.n)\n        time.sleep(2)\n\nt1 = MyThread(1)\nt2 = MyThread(2)\n\nt1.start()\nt2.start()</pre>\n<p><br>\n</p>\n<h4>join和Daemon</h4>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">join()等待线程结束后再往后继续运行</span></p>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">Daemon()守护线程</span></p>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">使用setDaemon(True)那么主线程不会等待子线程结束才结束，主线程结束后子线程也会直接结束，必须要在start之前设置否则会报错</span></p>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">python中默认为setDaemon(False),主线程结束了子线程依然会执行直到完毕。</span></p>\n<p><span style=\"color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px\">join例子：</span></p>\n<pre class=\"python\">import threading,time\nclass MyThread(threading.Thread):\n    def __init__(self,n):\n        super(MyThread,self).__init__()\n        self.n = n\n\n    def run(self):     #函数名必须为run\n        print(self.n)\n        time.sleep(2)\n        print('end')\n\nt1 = MyThread('t1')\nt2 = MyThread('t2')\nt1.start()\nt1.join()\nt2.start()\nt2.join()</pre>\n结果\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\"><img src=\"https://img-blog.csdn.net/20180310153251692?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></p>\n<p>setDaemon()例子</p>\n<pre class=\"python\">import threading,time\nclass MyThread(threading.Thread):\n    def __init__(self,n):\n        super(MyThread,self).__init__()\n        self.n = n\n\n    def run(self):     #函数名必须为run\n        print(self.n)\n        time.sleep(2)\n        print('end')\n\nt1 = MyThread('t1')\nt2 = MyThread('t2')\nt1.setDaemon(True)\nt2.setDaemon(True)\nt1.start()\nt2.start()</pre>\n<p>结果</p>\n<img src=\"https://img-blog.csdn.net/20180310153422919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<br>\n<p></p>\n<h4><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; color:#333333\"><span style=\"font-size:14px\">线程锁</span></span></h4>\n<div>子线程可以共享父线程的内存空间，当存在多个子线程需要同时修改一个数据的时候就可能出现问题</div>\n<div>假设两个子线程执行的操作都是num&#43;1，由于线程是同时执行的，第一个子线程先取num = 1 ，第二个线程有取出num依然为1，线程一结束后num更改为2，随之线程二结束num依然被改为2，就与我们的目标出现冲突，这个时候就需要用到线程锁了，当线程一访问num的时候线程二是无法访问num的，线程一结束后释放num线程二才能访问num，这就使得num的结果不会产生冲突了。</div>\n<div>\n<pre class=\"python\">#线程锁示例\nimport threading\n\nnum = 0\nt_objs = []\nlock = threading.Lock()\n\ndef run():\n    lock.acquire()  #加锁\n    global num      #声明全局变量\n    num &#43;= 1        #执行加一操作\n    lock.release()  #释放锁\n\nfor i in range(500):\n    t = threading.Thread(target=run)\n    t.start()\n    t_objs.append(t)\n\nfor t in t_objs:    #等待所有线程结束\n    t.join()\n\nprint(num)</pre>\n递归锁则是在一个锁里面又嵌套另外一个线程锁</div>\n<div>\n<pre class=\"python\">#递归锁\nimport threading\n\ndef run1():\n    lock.acquire()\n    global num\n    num &#43;= 1\n    lock.release()\n    return num\n\ndef run2():\n    lock.acquire()\n    global num2\n    num2 &#43;= 1\n    lock.release()\n    return num2\n\ndef run3():\n    lock.acquire()\n    res = run1()\n    res2 = run2()\n    lock.release()\n    print(res, res2)\n\nif __name__ == '__main__':\n\n    num, num2 = 0, 0\n    lock = threading.RLock()\n    for i in range(10):\n        t = threading.Thread(target=run3)\n        t.start()</pre>\n结果<br>\n<img src=\"https://img-blog.csdn.net/20180310173722570?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</div>\n<div><br>\n</div>\n<h4>信号量（Semaphore）</h4>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">线程锁每次只允许一个线程操作数据，Semaphore则可同时允许多个线程操作，当达到允许的最大&#20540;的时候后面的则需要等待，前面的线程执行完毕后才可执行，因此操作同一个数据的时候依然有可能出错</span></span></div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">#信号量\n\nimport threading,time\n\ndef run(num):\n    semaphore.acquire()\n    time.sleep(1)\n    print(num)\n    semaphore.release()\n\nsemaphore = threading.BoundedSemaphore(3) #最多运行三个线程\nfor i in range(10):\n    t = threading.Thread(target=run,args=(i,))\n    t.start()</pre>\n<h4><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">事件（Event）</span></span></h4>\n</div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">Event默认内置了一个标志，初始&#20540;为False<br>\n</span></span></div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">event总共就四中方法：set()、clear()、wait()、is_set()</span></span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">set()设置标志位为True</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">clear()设置标志位为False</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">wait()等待标志位设为True</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">is_set()判断标志位是否被设为True</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\"><br>\n</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">已红绿灯为例说明，首先写出交通灯，event.clear()相当于红灯，event.set()相当于绿灯,红灯为5秒绿灯也为5秒，用count来计数，当count超过10的时候重置count，这样红绿灯就能以5秒为间隔循环运行</span></div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">import time,threading\n\nevent = threading.Event()\n\ndef light():\n    count = 0\n    while True:\n        if count &gt;= 5 and count &lt; 10:\n            event.clear()     #相当于红灯了\n            print(&quot;red light please wait...&quot;)\n        elif count &gt; 10 :\n            event.set()       #相当于绿灯\n            count = 0        \n        else:\n            print(&quot;go go go ...&quot;)\n        time.sleep(1)\n        count &#43;= 1</pre>\n再来写car</div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">def car():\n    while True:\n        if event.is_set():  #判断event是否被set，相当于检测是否为绿灯\n            print('run...')\n            time.sleep(1)\n        else:\n            print('waiting for green light..')\n            event.wait()\n            print('green light is on go...')</pre>\n运行</div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">l = threading.Thread(target=light)\nc = threading.Thread(target=car)\nl.start()\nc.start()</pre>\n最终的结果</div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"><img src=\"https://img-blog.csdn.net/20180310202538695?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<br>\n<br>\n</span></span></div>\n<div></div>\n<p></p>\n","slug":"blogs-Python基础---线程","published":1,"date":"2022-03-16T17:09:30.490Z","updated":"2022-03-16T17:09:30.490Z","_id":"cl0v6kevs001syms401cme8ro","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h4>调用方式</h4>\n<p>python的线程调用有两种方式。一种是直接调用，一种是继承式调用</p>\n<p>直接调用</p>\n<pre class=\"python\">import threading,time\n\n<p>#方法一<br>def run(n):</p>\n<pre><code>print(n)\ntime.sleep(2)\n</code></pre>\n<p>t1 = threading.Thread(target=run,args=(&quot;t1&quot;,))<br>t2 = threading.Thread(target=run,args=(&quot;t2&quot;,))<br>t1.start()<br>t2.start()</pre><br>使用类的方法调用</p>\n<pre class=\"python\">#方法二（使用类的方法）\nimport threading,time\nclass MyThread(threading.Thread):\n    def __init__(self,n):\n        super(MyThread,self).__init__()\n        self.n = n\n\n    def run(self):     #函数名必须为run\n        print(self.n)\n        time.sleep(2)\n\nt1 = MyThread(1)\nt2 = MyThread(2)\n\nt1.start()\nt2.start()</pre>\n<p><br>\n</p>\n<h4>join和Daemon</h4>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">join()等待线程结束后再往后继续运行</span></p>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">Daemon()守护线程</span></p>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">使用setDaemon(True)那么主线程不会等待子线程结束才结束，主线程结束后子线程也会直接结束，必须要在start之前设置否则会报错</span></p>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">python中默认为setDaemon(False),主线程结束了子线程依然会执行直到完毕。</span></p>\n<p><span style=\"color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px\">join例子：</span></p>\n<pre class=\"python\">import threading,time\nclass MyThread(threading.Thread):\n    def __init__(self,n):\n        super(MyThread,self).__init__()\n        self.n = n\n\n<pre><code>def run(self):     #函数名必须为run\n    print(self.n)\n    time.sleep(2)\n    print(&#39;end&#39;)\n</code></pre>\n<p>t1 = MyThread(‘t1’)<br>t2 = MyThread(‘t2’)<br>t1.start()<br>t1.join()<br>t2.start()<br>t2.join()</pre><br>结果</p>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\"><img src=\"https://img-blog.csdn.net/20180310153251692?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></p>\n<p>setDaemon()例子</p>\n<pre class=\"python\">import threading,time\nclass MyThread(threading.Thread):\n    def __init__(self,n):\n        super(MyThread,self).__init__()\n        self.n = n\n\n<pre><code>def run(self):     #函数名必须为run\n    print(self.n)\n    time.sleep(2)\n    print(&#39;end&#39;)\n</code></pre>\n<p>t1 = MyThread(‘t1’)<br>t2 = MyThread(‘t2’)<br>t1.setDaemon(True)<br>t2.setDaemon(True)<br>t1.start()<br>t2.start()</pre></p>\n<p>结果</p>\n<img src=\"https://img-blog.csdn.net/20180310153422919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<br>\n<p></p>\n<h4><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; color:#333333\"><span style=\"font-size:14px\">线程锁</span></span></h4>\n<div>子线程可以共享父线程的内存空间，当存在多个子线程需要同时修改一个数据的时候就可能出现问题</div>\n<div>假设两个子线程执行的操作都是num&#43;1，由于线程是同时执行的，第一个子线程先取num = 1 ，第二个线程有取出num依然为1，线程一结束后num更改为2，随之线程二结束num依然被改为2，就与我们的目标出现冲突，这个时候就需要用到线程锁了，当线程一访问num的时候线程二是无法访问num的，线程一结束后释放num线程二才能访问num，这就使得num的结果不会产生冲突了。</div>\n<div>\n<pre class=\"python\">#线程锁示例\nimport threading\n\n<p>num = 0<br>t_objs = []<br>lock = threading.Lock()</p>\n<p>def run():<br>    lock.acquire()  #加锁<br>    global num      #声明全局变量<br>    num &#43;= 1        #执行加一操作<br>    lock.release()  #释放锁</p>\n<p>for i in range(500):<br>    t = threading.Thread(target=run)<br>    t.start()<br>    t_objs.append(t)</p>\n<p>for t in t_objs:    #等待所有线程结束<br>    t.join()</p>\n<p>print(num)</pre><br>递归锁则是在一个锁里面又嵌套另外一个线程锁</div></p>\n<div>\n<pre class=\"python\">#递归锁\nimport threading\n\n<p>def run1():<br>    lock.acquire()<br>    global num<br>    num &#43;= 1<br>    lock.release()<br>    return num</p>\n<p>def run2():<br>    lock.acquire()<br>    global num2<br>    num2 &#43;= 1<br>    lock.release()<br>    return num2</p>\n<p>def run3():<br>    lock.acquire()<br>    res = run1()<br>    res2 = run2()<br>    lock.release()<br>    print(res, res2)</p>\n<p>if <strong>name</strong> == ‘<strong>main</strong>‘:</p>\n<pre><code>num, num2 = 0, 0\nlock = threading.RLock()\nfor i in range(10):\n    t = threading.Thread(target=run3)\n    t.start()&lt;/pre&gt;\n</code></pre>\n<p>结果<br><br><img src=\"https://img-blog.csdn.net/20180310173722570?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br></p>\n</div>\n<div><br>\n</div>\n<h4>信号量（Semaphore）</h4>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">线程锁每次只允许一个线程操作数据，Semaphore则可同时允许多个线程操作，当达到允许的最大&#20540;的时候后面的则需要等待，前面的线程执行完毕后才可执行，因此操作同一个数据的时候依然有可能出错</span></span></div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">#信号量\n\n<p>import threading,time</p>\n<p>def run(num):<br>    semaphore.acquire()<br>    time.sleep(1)<br>    print(num)<br>    semaphore.release()</p>\n<p>semaphore = threading.BoundedSemaphore(3) #最多运行三个线程<br>for i in range(10):<br>    t = threading.Thread(target=run,args=(i,))<br>    t.start()</pre></p>\n<h4><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">事件（Event）</span></span></h4>\n</div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">Event默认内置了一个标志，初始&#20540;为False<br>\n</span></span></div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">event总共就四中方法：set()、clear()、wait()、is_set()</span></span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">set()设置标志位为True</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">clear()设置标志位为False</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">wait()等待标志位设为True</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">is_set()判断标志位是否被设为True</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\"><br>\n</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">已红绿灯为例说明，首先写出交通灯，event.clear()相当于红灯，event.set()相当于绿灯,红灯为5秒绿灯也为5秒，用count来计数，当count超过10的时候重置count，这样红绿灯就能以5秒为间隔循环运行</span></div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">import time,threading\n\n<p>event = threading.Event()</p>\n<p>def light():<br>    count = 0<br>    while True:<br>        if count &gt;= 5 and count &lt; 10:<br>            event.clear()     #相当于红灯了<br>            print(&quot;red light please wait…&quot;)<br>        elif count &gt; 10 :<br>            event.set()       #相当于绿灯<br>            count = 0<br>        else:<br>            print(&quot;go go go …&quot;)<br>        time.sleep(1)<br>        count &#43;= 1</pre><br>再来写car</div></p>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">def car():\n    while True:\n        if event.is_set():  #判断event是否被set，相当于检测是否为绿灯\n            print('run...')\n            time.sleep(1)\n        else:\n            print('waiting for green light..')\n            event.wait()\n            print('green light is on go...')</pre>\n运行</div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">l = threading.Thread(target=light)\nc = threading.Thread(target=car)\nl.start()\nc.start()</pre>\n最终的结果</div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"><img src=\"https://img-blog.csdn.net/20180310202538695?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<br>\n<br>\n</span></span></div>\n<div></div>\n<p></p>\n","site":{"data":{}},"excerpt":"","more":"<h4>调用方式</h4>\n<p>python的线程调用有两种方式。一种是直接调用，一种是继承式调用</p>\n<p>直接调用</p>\n<pre class=\"python\">import threading,time\n\n<p>#方法一<br>def run(n):</p>\n<pre><code>print(n)\ntime.sleep(2)\n</code></pre>\n<p>t1 = threading.Thread(target=run,args=(&quot;t1&quot;,))<br>t2 = threading.Thread(target=run,args=(&quot;t2&quot;,))<br>t1.start()<br>t2.start()</pre><br>使用类的方法调用</p>\n<pre class=\"python\">#方法二（使用类的方法）\nimport threading,time\nclass MyThread(threading.Thread):\n    def __init__(self,n):\n        super(MyThread,self).__init__()\n        self.n = n\n\n    def run(self):     #函数名必须为run\n        print(self.n)\n        time.sleep(2)\n\nt1 = MyThread(1)\nt2 = MyThread(2)\n\nt1.start()\nt2.start()</pre>\n<p><br>\n</p>\n<h4>join和Daemon</h4>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">join()等待线程结束后再往后继续运行</span></p>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">Daemon()守护线程</span></p>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">使用setDaemon(True)那么主线程不会等待子线程结束才结束，主线程结束后子线程也会直接结束，必须要在start之前设置否则会报错</span></p>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">python中默认为setDaemon(False),主线程结束了子线程依然会执行直到完毕。</span></p>\n<p><span style=\"color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px\">join例子：</span></p>\n<pre class=\"python\">import threading,time\nclass MyThread(threading.Thread):\n    def __init__(self,n):\n        super(MyThread,self).__init__()\n        self.n = n\n\n<pre><code>def run(self):     #函数名必须为run\n    print(self.n)\n    time.sleep(2)\n    print(&#39;end&#39;)\n</code></pre>\n<p>t1 = MyThread(‘t1’)<br>t2 = MyThread(‘t2’)<br>t1.start()<br>t1.join()<br>t2.start()<br>t2.join()</pre><br>结果</p>\n<p><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\"><img src=\"https://img-blog.csdn.net/20180310153251692?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n</span></p>\n<p>setDaemon()例子</p>\n<pre class=\"python\">import threading,time\nclass MyThread(threading.Thread):\n    def __init__(self,n):\n        super(MyThread,self).__init__()\n        self.n = n\n\n<pre><code>def run(self):     #函数名必须为run\n    print(self.n)\n    time.sleep(2)\n    print(&#39;end&#39;)\n</code></pre>\n<p>t1 = MyThread(‘t1’)<br>t2 = MyThread(‘t2’)<br>t1.setDaemon(True)<br>t2.setDaemon(True)<br>t1.start()<br>t2.start()</pre></p>\n<p>结果</p>\n<img src=\"https://img-blog.csdn.net/20180310153422919?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<br>\n<p></p>\n<h4><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; color:#333333\"><span style=\"font-size:14px\">线程锁</span></span></h4>\n<div>子线程可以共享父线程的内存空间，当存在多个子线程需要同时修改一个数据的时候就可能出现问题</div>\n<div>假设两个子线程执行的操作都是num&#43;1，由于线程是同时执行的，第一个子线程先取num = 1 ，第二个线程有取出num依然为1，线程一结束后num更改为2，随之线程二结束num依然被改为2，就与我们的目标出现冲突，这个时候就需要用到线程锁了，当线程一访问num的时候线程二是无法访问num的，线程一结束后释放num线程二才能访问num，这就使得num的结果不会产生冲突了。</div>\n<div>\n<pre class=\"python\">#线程锁示例\nimport threading\n\n<p>num = 0<br>t_objs = []<br>lock = threading.Lock()</p>\n<p>def run():<br>    lock.acquire()  #加锁<br>    global num      #声明全局变量<br>    num &#43;= 1        #执行加一操作<br>    lock.release()  #释放锁</p>\n<p>for i in range(500):<br>    t = threading.Thread(target=run)<br>    t.start()<br>    t_objs.append(t)</p>\n<p>for t in t_objs:    #等待所有线程结束<br>    t.join()</p>\n<p>print(num)</pre><br>递归锁则是在一个锁里面又嵌套另外一个线程锁</div></p>\n<div>\n<pre class=\"python\">#递归锁\nimport threading\n\n<p>def run1():<br>    lock.acquire()<br>    global num<br>    num &#43;= 1<br>    lock.release()<br>    return num</p>\n<p>def run2():<br>    lock.acquire()<br>    global num2<br>    num2 &#43;= 1<br>    lock.release()<br>    return num2</p>\n<p>def run3():<br>    lock.acquire()<br>    res = run1()<br>    res2 = run2()<br>    lock.release()<br>    print(res, res2)</p>\n<p>if <strong>name</strong> == ‘<strong>main</strong>‘:</p>\n<pre><code>num, num2 = 0, 0\nlock = threading.RLock()\nfor i in range(10):\n    t = threading.Thread(target=run3)\n    t.start()&lt;/pre&gt;\n</code></pre>\n<p>结果<br><br><img src=\"https://img-blog.csdn.net/20180310173722570?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br></p>\n</div>\n<div><br>\n</div>\n<h4>信号量（Semaphore）</h4>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">线程锁每次只允许一个线程操作数据，Semaphore则可同时允许多个线程操作，当达到允许的最大&#20540;的时候后面的则需要等待，前面的线程执行完毕后才可执行，因此操作同一个数据的时候依然有可能出错</span></span></div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">#信号量\n\n<p>import threading,time</p>\n<p>def run(num):<br>    semaphore.acquire()<br>    time.sleep(1)<br>    print(num)<br>    semaphore.release()</p>\n<p>semaphore = threading.BoundedSemaphore(3) #最多运行三个线程<br>for i in range(10):<br>    t = threading.Thread(target=run,args=(i,))<br>    t.start()</pre></p>\n<h4><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">事件（Event）</span></span></h4>\n</div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">Event默认内置了一个标志，初始&#20540;为False<br>\n</span></span></div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\">event总共就四中方法：set()、clear()、wait()、is_set()</span></span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">set()设置标志位为True</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">clear()设置标志位为False</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">wait()等待标志位设为True</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">is_set()判断标志位是否被设为True</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\"><br>\n</span></div>\n<div><span style=\"font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px; color:#333333\">已红绿灯为例说明，首先写出交通灯，event.clear()相当于红灯，event.set()相当于绿灯,红灯为5秒绿灯也为5秒，用count来计数，当count超过10的时候重置count，这样红绿灯就能以5秒为间隔循环运行</span></div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">import time,threading\n\n<p>event = threading.Event()</p>\n<p>def light():<br>    count = 0<br>    while True:<br>        if count &gt;= 5 and count &lt; 10:<br>            event.clear()     #相当于红灯了<br>            print(&quot;red light please wait…&quot;)<br>        elif count &gt; 10 :<br>            event.set()       #相当于绿灯<br>            count = 0<br>        else:<br>            print(&quot;go go go …&quot;)<br>        time.sleep(1)<br>        count &#43;= 1</pre><br>再来写car</div></p>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">def car():\n    while True:\n        if event.is_set():  #判断event是否被set，相当于检测是否为绿灯\n            print('run...')\n            time.sleep(1)\n        else:\n            print('waiting for green light..')\n            event.wait()\n            print('green light is on go...')</pre>\n运行</div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"></span></span>\n<pre class=\"python\">l = threading.Thread(target=light)\nc = threading.Thread(target=car)\nl.start()\nc.start()</pre>\n最终的结果</div>\n<div><span style=\"margin:0px; padding:0px; color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif\"><span style=\"font-size:10px\"><img src=\"https://img-blog.csdn.net/20180310202538695?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<br>\n<br>\n</span></span></div>\n<div></div>\n<p></p>\n"},{"_content":"\n<p>python的多线程和多进程都是调用系统的原生线程和进程，多进程和多线程在使用上类&#20284;，同样有直接调用和继承调用两种，在进程中还可以创建其他的线程</p>\n<p>可通过os模块中的getpid()获取自己的进程ID，getppid()获取父进程的ID</p>\n<p><pre name=\"code\" class=\"python\">import multiprocessing,time,os\nclass MyProcessing(multiprocessing.Process):\n    def __init__(self):\n        super(MyProcessing,self).__init__()\n    def run(self):\n        print(os.getpid(),os.getppid())\n\np1 = MyProcessing()\np2 = MyProcessing()\np1.start()\np2.start()\n\nprint(os.getpid())</pre><img src=\"https://img-blog.csdn.net/20180311152838710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<h4>进程间通信</h4>\n<div>1：Queue（）</div>\n<p>不同进程中的内存空间是独立的，不同与线程无法直接访问，要想进程间互相通信需要用到进程Queue（multiprocessing.Queue()）不同与线程Queue（queue.Queue()），在使用进程Queue的时候父进程创建子进程的时候会复制一个队列到子进程内存空间里面，当子进程修改队列的时候，进程Queue会序列化到一个中间地方，然后再反序列化到父进程中，但是并不是直接访问的，这样就实现了父进程与子进程的数据访问</p>\n<p><pre name=\"code\" class=\"python\">import multiprocessing,time,os\nclass MyProcessing(multiprocessing.Process):\n    def __init__(self):\n        super(MyProcessing,self).__init__()\n    def run(self):\n        q.put(1)\nq = multiprocessing.Queue()\np1 = MyProcessing()\np1.start()\n\nprint(q.get())</pre><img src=\"https://img-blog.csdn.net/20180311155259697?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p>2：Pipe()</p>\n<p>一个管道生成的时候会返回两个端口，一个可作为父进程访问端口，一个为子进程访问端口，若无数据可接收的时候会阻塞</p>\n<p><pre name=\"code\" class=\"python\">import multiprocessing\nclass MyProcessing(multiprocessing.Process):\n    def __init__(self):\n        super(MyProcessing,self).__init__()\n    def run(self):\n        child_conn.send('f')\n        \nparent_conn, child_conn= multiprocessing.Pipe()\n\np1 = MyProcessing()\np2 = MyProcessing()\np1.start()\np2.start()\n\nprint(parent_conn.recv())\nprint(parent_conn.recv())</pre><img src=\"https://img-blog.csdn.net/20180311160321324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p>3：Manage()</p>\n<p>Manage()支持list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value , Array.</p>\n<p>在使用Manage的时候必须要使用join等待子进程完成后继续运行，但是不知道是什么原因，猜测可能是防止多个进程修改数据导致混乱</p>\n<p><pre name=\"code\" class=\"python\">from multiprocessing import Manager,Process\n\ndef run (l,num):\n    l.append(num)\n\nl = Manager().list() #创建一个可以在进程中传递的空列表\np_list = []\nfor i in range(10):\n    p = Process(target=run, args=(l, i))\n    p.start()\n    p_list.append(p)\n\nfor res in p_list:\n    res.join()\n\nprint(l)</pre><img src=\"https://img-blog.csdn.net/20180311165052147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p>进程锁和线程锁类&#20284;不在赘述</p>\n<h4>进程池Pool()</h4>\n<div>线程池中有两个方法：</div>\n<div>1：apple()&nbsp; #串行方式</div>\n<div>2：apple_async() #并行方式，使用并行方式的时候必须先close再join</div>\n<p><pre name=\"code\" class=\"python\">import os,time\nfrom multiprocessing import Pool\n\ndef run(num):\n    time.sleep(2)\n    print(num,os.getpid())\n    \npool = Pool(5)\nfor i in range(5):\n    #pool.apply(func=run,args=(i,))\n    pool.apply_async(func=run,args=(i,))\nprint('end')\npool.close()\npool.join() #进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</pre><img src=\"https://img-blog.csdn.net/20180311182622059?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<br>\n</p>\n<p><br>\n</p>\n<p><br>\n</p>\n","source":"_posts/blogs-Python基础---进程.md","raw":"\n<p>python的多线程和多进程都是调用系统的原生线程和进程，多进程和多线程在使用上类&#20284;，同样有直接调用和继承调用两种，在进程中还可以创建其他的线程</p>\n<p>可通过os模块中的getpid()获取自己的进程ID，getppid()获取父进程的ID</p>\n<p><pre name=\"code\" class=\"python\">import multiprocessing,time,os\nclass MyProcessing(multiprocessing.Process):\n    def __init__(self):\n        super(MyProcessing,self).__init__()\n    def run(self):\n        print(os.getpid(),os.getppid())\n\np1 = MyProcessing()\np2 = MyProcessing()\np1.start()\np2.start()\n\nprint(os.getpid())</pre><img src=\"https://img-blog.csdn.net/20180311152838710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<h4>进程间通信</h4>\n<div>1：Queue（）</div>\n<p>不同进程中的内存空间是独立的，不同与线程无法直接访问，要想进程间互相通信需要用到进程Queue（multiprocessing.Queue()）不同与线程Queue（queue.Queue()），在使用进程Queue的时候父进程创建子进程的时候会复制一个队列到子进程内存空间里面，当子进程修改队列的时候，进程Queue会序列化到一个中间地方，然后再反序列化到父进程中，但是并不是直接访问的，这样就实现了父进程与子进程的数据访问</p>\n<p><pre name=\"code\" class=\"python\">import multiprocessing,time,os\nclass MyProcessing(multiprocessing.Process):\n    def __init__(self):\n        super(MyProcessing,self).__init__()\n    def run(self):\n        q.put(1)\nq = multiprocessing.Queue()\np1 = MyProcessing()\np1.start()\n\nprint(q.get())</pre><img src=\"https://img-blog.csdn.net/20180311155259697?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p>2：Pipe()</p>\n<p>一个管道生成的时候会返回两个端口，一个可作为父进程访问端口，一个为子进程访问端口，若无数据可接收的时候会阻塞</p>\n<p><pre name=\"code\" class=\"python\">import multiprocessing\nclass MyProcessing(multiprocessing.Process):\n    def __init__(self):\n        super(MyProcessing,self).__init__()\n    def run(self):\n        child_conn.send('f')\n        \nparent_conn, child_conn= multiprocessing.Pipe()\n\np1 = MyProcessing()\np2 = MyProcessing()\np1.start()\np2.start()\n\nprint(parent_conn.recv())\nprint(parent_conn.recv())</pre><img src=\"https://img-blog.csdn.net/20180311160321324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p>3：Manage()</p>\n<p>Manage()支持list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value , Array.</p>\n<p>在使用Manage的时候必须要使用join等待子进程完成后继续运行，但是不知道是什么原因，猜测可能是防止多个进程修改数据导致混乱</p>\n<p><pre name=\"code\" class=\"python\">from multiprocessing import Manager,Process\n\ndef run (l,num):\n    l.append(num)\n\nl = Manager().list() #创建一个可以在进程中传递的空列表\np_list = []\nfor i in range(10):\n    p = Process(target=run, args=(l, i))\n    p.start()\n    p_list.append(p)\n\nfor res in p_list:\n    res.join()\n\nprint(l)</pre><img src=\"https://img-blog.csdn.net/20180311165052147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p>进程锁和线程锁类&#20284;不在赘述</p>\n<h4>进程池Pool()</h4>\n<div>线程池中有两个方法：</div>\n<div>1：apple()&nbsp; #串行方式</div>\n<div>2：apple_async() #并行方式，使用并行方式的时候必须先close再join</div>\n<p><pre name=\"code\" class=\"python\">import os,time\nfrom multiprocessing import Pool\n\ndef run(num):\n    time.sleep(2)\n    print(num,os.getpid())\n    \npool = Pool(5)\nfor i in range(5):\n    #pool.apply(func=run,args=(i,))\n    pool.apply_async(func=run,args=(i,))\nprint('end')\npool.close()\npool.join() #进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</pre><img src=\"https://img-blog.csdn.net/20180311182622059?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<br>\n</p>\n<p><br>\n</p>\n<p><br>\n</p>\n","slug":"blogs-Python基础---进程","published":1,"date":"2022-03-16T17:09:28.107Z","updated":"2022-03-16T17:09:28.107Z","_id":"cl0v6kevu001tyms45bft9f07","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>python的多线程和多进程都是调用系统的原生线程和进程，多进程和多线程在使用上类&#20284;，同样有直接调用和继承调用两种，在进程中还可以创建其他的线程</p>\n<p>可通过os模块中的getpid()获取自己的进程ID，getppid()获取父进程的ID</p>\n<p><pre name=\"code\" class=\"python\">import multiprocessing,time,os\nclass MyProcessing(multiprocessing.Process):\n    def __init__(self):\n        super(MyProcessing,self).__init__()\n    def run(self):\n        print(os.getpid(),os.getppid())\n\n<p>p1 = MyProcessing()<br>p2 = MyProcessing()<br>p1.start()<br>p2.start()</p>\n<p>print(os.getpid())</pre><img src=\"https://img-blog.csdn.net/20180311152838710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p></p>\n<h4>进程间通信</h4>\n<div>1：Queue（）</div>\n<p>不同进程中的内存空间是独立的，不同与线程无法直接访问，要想进程间互相通信需要用到进程Queue（multiprocessing.Queue()）不同与线程Queue（queue.Queue()），在使用进程Queue的时候父进程创建子进程的时候会复制一个队列到子进程内存空间里面，当子进程修改队列的时候，进程Queue会序列化到一个中间地方，然后再反序列化到父进程中，但是并不是直接访问的，这样就实现了父进程与子进程的数据访问</p>\n<p><pre name=\"code\" class=\"python\">import multiprocessing,time,os\nclass MyProcessing(multiprocessing.Process):\n    def __init__(self):\n        super(MyProcessing,self).__init__()\n    def run(self):\n        q.put(1)\nq = multiprocessing.Queue()\np1 = MyProcessing()\np1.start()\n\n<p>print(q.get())</pre><img src=\"https://img-blog.csdn.net/20180311155259697?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br></p>\n</p>\n<p>2：Pipe()</p>\n<p>一个管道生成的时候会返回两个端口，一个可作为父进程访问端口，一个为子进程访问端口，若无数据可接收的时候会阻塞</p>\n<p><pre name=\"code\" class=\"python\">import multiprocessing\nclass MyProcessing(multiprocessing.Process):\n    def __init__(self):\n        super(MyProcessing,self).__init__()\n    def run(self):\n        child_conn.send('f')\n        \n<p>parent_conn, child_conn= multiprocessing.Pipe()</p>\n<p>p1 = MyProcessing()<br>p2 = MyProcessing()<br>p1.start()<br>p2.start()</p>\n<p>print(parent_conn.recv())<br>print(parent_conn.recv())</pre><img src=\"https://img-blog.csdn.net/20180311160321324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br></p>\n</p>\n<p>3：Manage()</p>\n<p>Manage()支持list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value , Array.</p>\n<p>在使用Manage的时候必须要使用join等待子进程完成后继续运行，但是不知道是什么原因，猜测可能是防止多个进程修改数据导致混乱</p>\n<p><pre name=\"code\" class=\"python\">from multiprocessing import Manager,Process\n\n<p>def run (l,num):<br>    l.append(num)</p>\n<p>l = Manager().list() #创建一个可以在进程中传递的空列表<br>p_list = []<br>for i in range(10):<br>    p = Process(target=run, args=(l, i))<br>    p.start()<br>    p_list.append(p)</p>\n<p>for res in p_list:<br>    res.join()</p>\n<p>print(l)</pre><img src=\"https://img-blog.csdn.net/20180311165052147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br></p>\n</p>\n<p>进程锁和线程锁类&#20284;不在赘述</p>\n<h4>进程池Pool()</h4>\n<div>线程池中有两个方法：</div>\n<div>1：apple()&nbsp; #串行方式</div>\n<div>2：apple_async() #并行方式，使用并行方式的时候必须先close再join</div>\n<p><pre name=\"code\" class=\"python\">import os,time\nfrom multiprocessing import Pool\n\n<p>def run(num):<br>    time.sleep(2)<br>    print(num,os.getpid())</p>\n<p>pool = Pool(5)<br>for i in range(5):<br>    #pool.apply(func=run,args=(i,))<br>    pool.apply_async(func=run,args=(i,))<br>print(‘end’)<br>pool.close()<br>pool.join() #进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</pre><img src=\"https://img-blog.csdn.net/20180311182622059?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br><br><br></p>\n</p>\n<p><br>\n</p>\n<p><br>\n</p>\n","site":{"data":{}},"excerpt":"","more":"<p>python的多线程和多进程都是调用系统的原生线程和进程，多进程和多线程在使用上类&#20284;，同样有直接调用和继承调用两种，在进程中还可以创建其他的线程</p>\n<p>可通过os模块中的getpid()获取自己的进程ID，getppid()获取父进程的ID</p>\n<p><pre name=\"code\" class=\"python\">import multiprocessing,time,os\nclass MyProcessing(multiprocessing.Process):\n    def __init__(self):\n        super(MyProcessing,self).__init__()\n    def run(self):\n        print(os.getpid(),os.getppid())\n\n<p>p1 = MyProcessing()<br>p2 = MyProcessing()<br>p1.start()<br>p2.start()</p>\n<p>print(os.getpid())</pre><img src=\"https://img-blog.csdn.net/20180311152838710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p></p>\n<h4>进程间通信</h4>\n<div>1：Queue（）</div>\n<p>不同进程中的内存空间是独立的，不同与线程无法直接访问，要想进程间互相通信需要用到进程Queue（multiprocessing.Queue()）不同与线程Queue（queue.Queue()），在使用进程Queue的时候父进程创建子进程的时候会复制一个队列到子进程内存空间里面，当子进程修改队列的时候，进程Queue会序列化到一个中间地方，然后再反序列化到父进程中，但是并不是直接访问的，这样就实现了父进程与子进程的数据访问</p>\n<p><pre name=\"code\" class=\"python\">import multiprocessing,time,os\nclass MyProcessing(multiprocessing.Process):\n    def __init__(self):\n        super(MyProcessing,self).__init__()\n    def run(self):\n        q.put(1)\nq = multiprocessing.Queue()\np1 = MyProcessing()\np1.start()\n\n<p>print(q.get())</pre><img src=\"https://img-blog.csdn.net/20180311155259697?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br></p>\n</p>\n<p>2：Pipe()</p>\n<p>一个管道生成的时候会返回两个端口，一个可作为父进程访问端口，一个为子进程访问端口，若无数据可接收的时候会阻塞</p>\n<p><pre name=\"code\" class=\"python\">import multiprocessing\nclass MyProcessing(multiprocessing.Process):\n    def __init__(self):\n        super(MyProcessing,self).__init__()\n    def run(self):\n        child_conn.send('f')\n        \n<p>parent_conn, child_conn= multiprocessing.Pipe()</p>\n<p>p1 = MyProcessing()<br>p2 = MyProcessing()<br>p1.start()<br>p2.start()</p>\n<p>print(parent_conn.recv())<br>print(parent_conn.recv())</pre><img src=\"https://img-blog.csdn.net/20180311160321324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br></p>\n</p>\n<p>3：Manage()</p>\n<p>Manage()支持list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value , Array.</p>\n<p>在使用Manage的时候必须要使用join等待子进程完成后继续运行，但是不知道是什么原因，猜测可能是防止多个进程修改数据导致混乱</p>\n<p><pre name=\"code\" class=\"python\">from multiprocessing import Manager,Process\n\n<p>def run (l,num):<br>    l.append(num)</p>\n<p>l = Manager().list() #创建一个可以在进程中传递的空列表<br>p_list = []<br>for i in range(10):<br>    p = Process(target=run, args=(l, i))<br>    p.start()<br>    p_list.append(p)</p>\n<p>for res in p_list:<br>    res.join()</p>\n<p>print(l)</pre><img src=\"https://img-blog.csdn.net/20180311165052147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br></p>\n</p>\n<p>进程锁和线程锁类&#20284;不在赘述</p>\n<h4>进程池Pool()</h4>\n<div>线程池中有两个方法：</div>\n<div>1：apple()&nbsp; #串行方式</div>\n<div>2：apple_async() #并行方式，使用并行方式的时候必须先close再join</div>\n<p><pre name=\"code\" class=\"python\">import os,time\nfrom multiprocessing import Pool\n\n<p>def run(num):<br>    time.sleep(2)<br>    print(num,os.getpid())</p>\n<p>pool = Pool(5)<br>for i in range(5):<br>    #pool.apply(func=run,args=(i,))<br>    pool.apply_async(func=run,args=(i,))<br>print(‘end’)<br>pool.close()<br>pool.join() #进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</pre><img src=\"https://img-blog.csdn.net/20180311182622059?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br><br><br></p>\n</p>\n<p><br>\n</p>\n<p><br>\n</p>\n"},{"_content":"\n协程是一种用户态的轻量级线程，本质上是单线程<br>\n<p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。</p>\n<p>因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。&nbsp;&nbsp;</p>\n<p>使用greenlet实现协程操作，greenlet需要手动进行切换</p>\n<p>首先需要使用greenlet创建类&#20284;与堆栈空间，然后使用switch进行切换</p>\n<p><pre name=\"code\" class=\"python\">from greenlet import greenlet\n\ndef test1():\n    print(12)\n    gr2.switch()\n    print(34)\n    gr2.switch()\n\ndef test2():\n    print(56)\n    gr1.switch()\n    print(78)\n\ngr1 = greenlet(test1)\ngr2 = greenlet(test2)\n\ngr1.switch()</pre><img src=\"https://img-blog.csdn.net/20180311225407524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><br>\n</p>\n<p>使用Gevent实现协程，无需手动切换，遇到IO操作就会进行切换</p>\n<p><pre name=\"code\" class=\"python\">import gevent\n\n\ndef func1(num):\n&nbsp; &nbsp; print('in func1',num)\n&nbsp; &nbsp; gevent.sleep(1) #模仿IO操作\n&nbsp; &nbsp; print('back func1')\n\n\ndef func2():\n&nbsp; &nbsp; print('in func2')\n&nbsp; &nbsp; gevent.sleep(2) #模仿IO操作\n&nbsp; &nbsp; print('back func2')\n\n\ndef func3():\n&nbsp; &nbsp; print('in func3')\n&nbsp; &nbsp; gevent.sleep(3)\n&nbsp; &nbsp; print('back func3')\n\n\ngevent.joinall([\n&nbsp; &nbsp; gevent.spawn(func1,1),&nbsp; #传参的方式\n&nbsp; &nbsp; gevent.spawn(func3),\n&nbsp; &nbsp; gevent.spawn(func2),\n])\n</pre><img src=\"https://img-blog.csdn.net/20180311232911179?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p>先执行func1，打印第一句后遇到IO操作切换到func3又遇到IO，再次切换到func2，遇到IO操作后由于没有可执行的函数，开始等待，func1最先可执行自动跳转到func1打印第二句，然后func2IO操作结束输出func2的第二句，最后func3才结束IO操作，所有func3的第二句最后打印</p>\n<p>事件驱动模式：每次有一个事件发生的时候会首先存入到一个消息队列中，然后会有专门的函数循环不断的从队列中取出事件进行处理，执行完一个事件后一般会执行一个回调函数来告知当前事件处理完毕。</p>\n<p>异步操作也算是一种事件驱动的模式，遇到IO操作的时候交个操作系统来执行，IO操作结束后会执行一个回调函数告知程序IO结束可继续执行<br>\n</p>\n<p><br>\n</p>\n<p><br>\n</p>\n","source":"_posts/blogs-Python基础---协程.md","raw":"\n协程是一种用户态的轻量级线程，本质上是单线程<br>\n<p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。</p>\n<p>因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。&nbsp;&nbsp;</p>\n<p>使用greenlet实现协程操作，greenlet需要手动进行切换</p>\n<p>首先需要使用greenlet创建类&#20284;与堆栈空间，然后使用switch进行切换</p>\n<p><pre name=\"code\" class=\"python\">from greenlet import greenlet\n\ndef test1():\n    print(12)\n    gr2.switch()\n    print(34)\n    gr2.switch()\n\ndef test2():\n    print(56)\n    gr1.switch()\n    print(78)\n\ngr1 = greenlet(test1)\ngr2 = greenlet(test2)\n\ngr1.switch()</pre><img src=\"https://img-blog.csdn.net/20180311225407524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><br>\n</p>\n<p>使用Gevent实现协程，无需手动切换，遇到IO操作就会进行切换</p>\n<p><pre name=\"code\" class=\"python\">import gevent\n\n\ndef func1(num):\n&nbsp; &nbsp; print('in func1',num)\n&nbsp; &nbsp; gevent.sleep(1) #模仿IO操作\n&nbsp; &nbsp; print('back func1')\n\n\ndef func2():\n&nbsp; &nbsp; print('in func2')\n&nbsp; &nbsp; gevent.sleep(2) #模仿IO操作\n&nbsp; &nbsp; print('back func2')\n\n\ndef func3():\n&nbsp; &nbsp; print('in func3')\n&nbsp; &nbsp; gevent.sleep(3)\n&nbsp; &nbsp; print('back func3')\n\n\ngevent.joinall([\n&nbsp; &nbsp; gevent.spawn(func1,1),&nbsp; #传参的方式\n&nbsp; &nbsp; gevent.spawn(func3),\n&nbsp; &nbsp; gevent.spawn(func2),\n])\n</pre><img src=\"https://img-blog.csdn.net/20180311232911179?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p>先执行func1，打印第一句后遇到IO操作切换到func3又遇到IO，再次切换到func2，遇到IO操作后由于没有可执行的函数，开始等待，func1最先可执行自动跳转到func1打印第二句，然后func2IO操作结束输出func2的第二句，最后func3才结束IO操作，所有func3的第二句最后打印</p>\n<p>事件驱动模式：每次有一个事件发生的时候会首先存入到一个消息队列中，然后会有专门的函数循环不断的从队列中取出事件进行处理，执行完一个事件后一般会执行一个回调函数来告知当前事件处理完毕。</p>\n<p>异步操作也算是一种事件驱动的模式，遇到IO操作的时候交个操作系统来执行，IO操作结束后会执行一个回调函数告知程序IO结束可继续执行<br>\n</p>\n<p><br>\n</p>\n<p><br>\n</p>\n","slug":"blogs-Python基础---协程","published":1,"date":"2022-03-16T17:09:26.935Z","updated":"2022-03-16T17:09:26.935Z","_id":"cl0v6kevu001uyms4bheqecxv","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>协程是一种用户态的轻量级线程，本质上是单线程<br></p>\n<p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。</p>\n<p>因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。&nbsp;&nbsp;</p>\n<p>使用greenlet实现协程操作，greenlet需要手动进行切换</p>\n<p>首先需要使用greenlet创建类&#20284;与堆栈空间，然后使用switch进行切换</p>\n<p><pre name=\"code\" class=\"python\">from greenlet import greenlet\n\n<p>def test1():<br>    print(12)<br>    gr2.switch()<br>    print(34)<br>    gr2.switch()</p>\n<p>def test2():<br>    print(56)<br>    gr1.switch()<br>    print(78)</p>\n<p>gr1 = greenlet(test1)<br>gr2 = greenlet(test2)</p>\n<p>gr1.switch()</pre><img src=\"https://img-blog.csdn.net/20180311225407524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p></p>\n<p><br>\n</p>\n<p>使用Gevent实现协程，无需手动切换，遇到IO操作就会进行切换</p>\n<p><pre name=\"code\" class=\"python\">import gevent\n\n\n<p>def func1(num):<br>&nbsp; &nbsp; print(‘in func1’,num)<br>&nbsp; &nbsp; gevent.sleep(1) #模仿IO操作<br>&nbsp; &nbsp; print(‘back func1’)</p>\n<p>def func2():<br>&nbsp; &nbsp; print(‘in func2’)<br>&nbsp; &nbsp; gevent.sleep(2) #模仿IO操作<br>&nbsp; &nbsp; print(‘back func2’)</p>\n<p>def func3():<br>&nbsp; &nbsp; print(‘in func3’)<br>&nbsp; &nbsp; gevent.sleep(3)<br>&nbsp; &nbsp; print(‘back func3’)</p>\n<p>gevent.joinall([<br>&nbsp; &nbsp; gevent.spawn(func1,1),&nbsp; #传参的方式<br>&nbsp; &nbsp; gevent.spawn(func3),<br>&nbsp; &nbsp; gevent.spawn(func2),<br>])<br></pre><img src=\"https://img-blog.csdn.net/20180311232911179?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br></p>\n</p>\n<p>先执行func1，打印第一句后遇到IO操作切换到func3又遇到IO，再次切换到func2，遇到IO操作后由于没有可执行的函数，开始等待，func1最先可执行自动跳转到func1打印第二句，然后func2IO操作结束输出func2的第二句，最后func3才结束IO操作，所有func3的第二句最后打印</p>\n<p>事件驱动模式：每次有一个事件发生的时候会首先存入到一个消息队列中，然后会有专门的函数循环不断的从队列中取出事件进行处理，执行完一个事件后一般会执行一个回调函数来告知当前事件处理完毕。</p>\n<p>异步操作也算是一种事件驱动的模式，遇到IO操作的时候交个操作系统来执行，IO操作结束后会执行一个回调函数告知程序IO结束可继续执行<br>\n</p>\n<p><br>\n</p>\n<p><br>\n</p>\n","site":{"data":{}},"excerpt":"","more":"<p>协程是一种用户态的轻量级线程，本质上是单线程<br></p>\n<p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。</p>\n<p>因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。&nbsp;&nbsp;</p>\n<p>使用greenlet实现协程操作，greenlet需要手动进行切换</p>\n<p>首先需要使用greenlet创建类&#20284;与堆栈空间，然后使用switch进行切换</p>\n<p><pre name=\"code\" class=\"python\">from greenlet import greenlet\n\n<p>def test1():<br>    print(12)<br>    gr2.switch()<br>    print(34)<br>    gr2.switch()</p>\n<p>def test2():<br>    print(56)<br>    gr1.switch()<br>    print(78)</p>\n<p>gr1 = greenlet(test1)<br>gr2 = greenlet(test2)</p>\n<p>gr1.switch()</pre><img src=\"https://img-blog.csdn.net/20180311225407524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p></p>\n<p><br>\n</p>\n<p>使用Gevent实现协程，无需手动切换，遇到IO操作就会进行切换</p>\n<p><pre name=\"code\" class=\"python\">import gevent\n\n\n<p>def func1(num):<br>&nbsp; &nbsp; print(‘in func1’,num)<br>&nbsp; &nbsp; gevent.sleep(1) #模仿IO操作<br>&nbsp; &nbsp; print(‘back func1’)</p>\n<p>def func2():<br>&nbsp; &nbsp; print(‘in func2’)<br>&nbsp; &nbsp; gevent.sleep(2) #模仿IO操作<br>&nbsp; &nbsp; print(‘back func2’)</p>\n<p>def func3():<br>&nbsp; &nbsp; print(‘in func3’)<br>&nbsp; &nbsp; gevent.sleep(3)<br>&nbsp; &nbsp; print(‘back func3’)</p>\n<p>gevent.joinall([<br>&nbsp; &nbsp; gevent.spawn(func1,1),&nbsp; #传参的方式<br>&nbsp; &nbsp; gevent.spawn(func3),<br>&nbsp; &nbsp; gevent.spawn(func2),<br>])<br></pre><img src=\"https://img-blog.csdn.net/20180311232911179?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br></p>\n</p>\n<p>先执行func1，打印第一句后遇到IO操作切换到func3又遇到IO，再次切换到func2，遇到IO操作后由于没有可执行的函数，开始等待，func1最先可执行自动跳转到func1打印第二句，然后func2IO操作结束输出func2的第二句，最后func3才结束IO操作，所有func3的第二句最后打印</p>\n<p>事件驱动模式：每次有一个事件发生的时候会首先存入到一个消息队列中，然后会有专门的函数循环不断的从队列中取出事件进行处理，执行完一个事件后一般会执行一个回调函数来告知当前事件处理完毕。</p>\n<p>异步操作也算是一种事件驱动的模式，遇到IO操作的时候交个操作系统来执行，IO操作结束后会执行一个回调函数告知程序IO结束可继续执行<br>\n</p>\n<p><br>\n</p>\n<p><br>\n</p>\n"},{"_content":"#### 功能描述\n实现一个类似淘宝的搜索功能，例如下面这个例子\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190416194136675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n简单点来说我们需要先根据商品名称创建索引，然后再用索引文件匹配去查询字符串来实现商品的搜索，这种搜索是有别于正则匹配的，他会对字符串进行分词处理，准确度也会更高。\n\n---\n#### 准备工作\n这个项目种主要用到了jieba、whoosh两个库，其中jieba实现对中文的分词处理，whoosh则是创建索引文件。\n安装依赖：\n- 系统：Ubuntu 16.04\n- Python版本： 3.5\n\t```shell\n\tpip install jieba\n\tpip install whoosh\n\t```\n测试数据：\n从github上找到的空气净化器的csv数据，需要的可点击下载[测试数据](https://github.com/Ckend/taobao_scrapy/blob/master/result/%E7%A9%BA%E6%B0%94%E6%B8%85%E6%96%B0%E5%99%A8_result.csv)\n\n---\n#### 正式开始\n- **创建索引文件**\n首先需要利用whoosh提供的接口对csv中的数据进行处理，生成索引文件。\nwhoosh对中文分词处理不是很好，所以选择jieba实现对中文的分词处理，jieba这个库也有对whoosh的支持，所以处理起来很方便，直接将索引模式中的analyzer更换为jieba的ChineseAnalyzer即可。<br>\n`schema`定义了索引的模式，规定了索引的字段信息，其中索引字段包含`ID`、`STROED`、`KEYWORD`、`TEXT`、`NUMERIC`、`BOOLEAN`、`DATETIME`等几种，具体的含义和使用对象还是去看whoosh的官方文档来的直接，另外schema只需要我们创建一次，然后就会和索引一起被保存。（只需在第一次创建的时候声明schema）\n\t```python\n\tfrom whoosh.index import create_in\n\tfrom whoosh.fields import *\n\tfrom jieba.analyse.analyzer import ChineseAnalyzer\n\timport os.path\n\timport csv\n\t\n\tdef create_index():\n    \t\"\"\"\n    \t创建索引文件\n    \t:return: None\n    \t\"\"\"\n    \tanalyzer = ChineseAnalyzer()\n    \tschema = Schema(id=ID(stored=True, unique=True), content=TEXT(stored=True, analyzer=analyzer))  # 声明索引模式\n    \tif not os.path.exists(\"index\"):  # 创建目录\n        \tos.mkdir(\"index\")\n    \tix = create_in(\"index\", schema)\n    \twriter = ix.writer()\n\t\n    \t# csv数据\n    \tcsv_file = open('goods.csv', 'r')  # 读取csv文件\n    \tdata = csv.reader(csv_file)\n    \tfor i in data:\n        \twriter.add_document(\n            \tid=i[3],\n            \tcontent=i[0]\n        \t)\n  \t\twriter.commit()\n\t```\n\t使用`create_in`来创建索引文件，以后对索引文件的更删改查都是使用`open_dir`代开文件。<br>\n\t在读取csv数据的时候，使用`add_document`来新增索引，其中并不是所有在schema中申明的字段都需要存储的可以为空。最后使用`commit`实现索引文件的正式写入，这一点和数据库很像。\n- **简单的查询**\n  ```python\n \tfrom whoosh.index import open_dir\n\tfrom whoosh.qparser import QueryParser\n\tfrom create_index import create_index\n\timport os.path\n\t\n\tdef search(keyword, limit=10):\n    \"\"\"\n    按照关键字搜索商品\n    :param keyword: 商品名称  type: str\n    :param limit: 检索数量  type: int\n    :return: [{'id':'','content':''},{}]  type：list\n    \"\"\"\n    if not os.path.exists(\"index\"):  # 查询时没有缩索引文件，需先创建索引文件\n        create_index()\n    ix = open_dir(\"index\")  # 读取索引文件\n    with ix.searcher() as searcher:\n        parser = QueryParser(\"content\", schema=ix.schema)\n        keyword = parser.parse(keyword)  # 构造查询语句\n        results = searcher.search(keyword, limit=limit)\n        res = []\n        for i in results:\n            res.append({'id': i['id'], 'content': i['content']})\n            print(i['id'], i['content'])\n        print(res)\n  ```\n  在查询的时候需要先调用whoosh的`QueryParser`来构建查询字符串，通过调试我发现在构造查询字符串的时候whoosh默认会分词处理，并且使用`AND`连接符\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019041623572811.png)通过`search(keyword,limit)`去索引文件中匹配相关信息，其中`limit`为匹配到的最大数目，默认为10个。\n- **索引的增删改查**\n  在一个系统中商品的信息必然不会是一成不变的，所以我们的索引文件就不可避免的需要按照商品信息去做调整，whoosh同样给我们提供了这样的接口。\n  - 增：\n    ```python\n    from whoosh.index import open_dir\n\tdef add_index(name, id):\n    \"\"\"\n    新增索引\n    :param name: 商品名称  type: str\n    :param id: 商品id  type: str\n    :return: None\n    \"\"\"\n    ix = open_dir(\"index\")\n    writer = ix.writer()\n    writer.add_document(\n        id=id,\n        content=name\n    )\n    writer.commit(optimize=True)\n    ```\n     索引的增加和创建索引只有稍许不同，在`commit`中增加了`optimize`参数，翻看whoosh的文档在Merging Segments中提到了两个参数分别是`merge`和`optimize`，在默认情况下`merge`为True，意味着whoosh会将多个segments文件合并到一个文件中，如果`merge`为False的时候我们提交commit的时候会重新生成一个单独的索引文件，多个索引文件不会对搜索的结果产生很大的差异，如果过多的存在索引会降低整体的查询速度。通常情况下使用whoosh的合并算法将多个文件合并到一个文件中会更好，这只会让在更新索引的速度变慢，用户查询的速度影响较小，这样的用户体验会更好。\n   - 删:\n\t    ```python\n\t    from whoosh.index import open_dir\n\t    \n\t\tdef add_index(name, id):\n\t\t    \"\"\"\n\t\t    新增索引\n\t\t    :param name: 商品名称  type: str\n\t\t    :param id: 商品id  type: str\n\t\t    :return: None\n\t\t    \"\"\"\n\t    \tix = open_dir(\"index\")\n\t    \twriter = ix.writer()\n\t    \twriter.add_document(\n\t        \tid=id,\n\t        \tcontent=name\n\t    \t)\n\t    \twriter.commit(optimize=True)\n\t    ```\n\t\twhoosh总共有两种删除方式\n\t\t- `delete_by_query(query)`：删除与给定查询匹配的所有文档。\n\t\t- `delete_by_term(fieldname, termtext)`根据字段删除指定的文档，这里的字段需要在创建schema时指定为unique\n\t- 改\n\t  ```python\n\t  from whoosh.index import open_dir\n\n\t  def update_index(name, id):\n    \t\"\"\"\n    \t更新索引文件\n    \t:param name: 商品名称  type: str\n    \t:param id: 商品id  type: str\n    \t:return: None\n    \t\"\"\"\n    \tix = open_dir(\"index\")\n    \twriter = ix.writer()\n    \twriter.update_document(\n        \tid=id,\n        \tcontent=name\n    \t)\n    \twriter.commit()\n\t\t```\n\t\t和删除操作一样索引字段中需要有一个unique\n\n#### 总结\n---\n整个功能算是比较简单的了，各种库都给了对应的接口，很够很方便的实现功能。在实现的过程中也遇到了一个问题，最开始在实现增删改查功能的时候使用的事`create_in`来打开索引文件，这样导致操作完成之后之前的数据被覆盖了，还是自己当初粗心没有仔细看文档导致的。以后要注意这个问题。\n","source":"_posts/blogs-jieba+whoosh实现简单的商品搜索功能.md","raw":"#### 功能描述\n实现一个类似淘宝的搜索功能，例如下面这个例子\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20190416194136675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70)\n简单点来说我们需要先根据商品名称创建索引，然后再用索引文件匹配去查询字符串来实现商品的搜索，这种搜索是有别于正则匹配的，他会对字符串进行分词处理，准确度也会更高。\n\n---\n#### 准备工作\n这个项目种主要用到了jieba、whoosh两个库，其中jieba实现对中文的分词处理，whoosh则是创建索引文件。\n安装依赖：\n- 系统：Ubuntu 16.04\n- Python版本： 3.5\n\t```shell\n\tpip install jieba\n\tpip install whoosh\n\t```\n测试数据：\n从github上找到的空气净化器的csv数据，需要的可点击下载[测试数据](https://github.com/Ckend/taobao_scrapy/blob/master/result/%E7%A9%BA%E6%B0%94%E6%B8%85%E6%96%B0%E5%99%A8_result.csv)\n\n---\n#### 正式开始\n- **创建索引文件**\n首先需要利用whoosh提供的接口对csv中的数据进行处理，生成索引文件。\nwhoosh对中文分词处理不是很好，所以选择jieba实现对中文的分词处理，jieba这个库也有对whoosh的支持，所以处理起来很方便，直接将索引模式中的analyzer更换为jieba的ChineseAnalyzer即可。<br>\n`schema`定义了索引的模式，规定了索引的字段信息，其中索引字段包含`ID`、`STROED`、`KEYWORD`、`TEXT`、`NUMERIC`、`BOOLEAN`、`DATETIME`等几种，具体的含义和使用对象还是去看whoosh的官方文档来的直接，另外schema只需要我们创建一次，然后就会和索引一起被保存。（只需在第一次创建的时候声明schema）\n\t```python\n\tfrom whoosh.index import create_in\n\tfrom whoosh.fields import *\n\tfrom jieba.analyse.analyzer import ChineseAnalyzer\n\timport os.path\n\timport csv\n\t\n\tdef create_index():\n    \t\"\"\"\n    \t创建索引文件\n    \t:return: None\n    \t\"\"\"\n    \tanalyzer = ChineseAnalyzer()\n    \tschema = Schema(id=ID(stored=True, unique=True), content=TEXT(stored=True, analyzer=analyzer))  # 声明索引模式\n    \tif not os.path.exists(\"index\"):  # 创建目录\n        \tos.mkdir(\"index\")\n    \tix = create_in(\"index\", schema)\n    \twriter = ix.writer()\n\t\n    \t# csv数据\n    \tcsv_file = open('goods.csv', 'r')  # 读取csv文件\n    \tdata = csv.reader(csv_file)\n    \tfor i in data:\n        \twriter.add_document(\n            \tid=i[3],\n            \tcontent=i[0]\n        \t)\n  \t\twriter.commit()\n\t```\n\t使用`create_in`来创建索引文件，以后对索引文件的更删改查都是使用`open_dir`代开文件。<br>\n\t在读取csv数据的时候，使用`add_document`来新增索引，其中并不是所有在schema中申明的字段都需要存储的可以为空。最后使用`commit`实现索引文件的正式写入，这一点和数据库很像。\n- **简单的查询**\n  ```python\n \tfrom whoosh.index import open_dir\n\tfrom whoosh.qparser import QueryParser\n\tfrom create_index import create_index\n\timport os.path\n\t\n\tdef search(keyword, limit=10):\n    \"\"\"\n    按照关键字搜索商品\n    :param keyword: 商品名称  type: str\n    :param limit: 检索数量  type: int\n    :return: [{'id':'','content':''},{}]  type：list\n    \"\"\"\n    if not os.path.exists(\"index\"):  # 查询时没有缩索引文件，需先创建索引文件\n        create_index()\n    ix = open_dir(\"index\")  # 读取索引文件\n    with ix.searcher() as searcher:\n        parser = QueryParser(\"content\", schema=ix.schema)\n        keyword = parser.parse(keyword)  # 构造查询语句\n        results = searcher.search(keyword, limit=limit)\n        res = []\n        for i in results:\n            res.append({'id': i['id'], 'content': i['content']})\n            print(i['id'], i['content'])\n        print(res)\n  ```\n  在查询的时候需要先调用whoosh的`QueryParser`来构建查询字符串，通过调试我发现在构造查询字符串的时候whoosh默认会分词处理，并且使用`AND`连接符\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2019041623572811.png)通过`search(keyword,limit)`去索引文件中匹配相关信息，其中`limit`为匹配到的最大数目，默认为10个。\n- **索引的增删改查**\n  在一个系统中商品的信息必然不会是一成不变的，所以我们的索引文件就不可避免的需要按照商品信息去做调整，whoosh同样给我们提供了这样的接口。\n  - 增：\n    ```python\n    from whoosh.index import open_dir\n\tdef add_index(name, id):\n    \"\"\"\n    新增索引\n    :param name: 商品名称  type: str\n    :param id: 商品id  type: str\n    :return: None\n    \"\"\"\n    ix = open_dir(\"index\")\n    writer = ix.writer()\n    writer.add_document(\n        id=id,\n        content=name\n    )\n    writer.commit(optimize=True)\n    ```\n     索引的增加和创建索引只有稍许不同，在`commit`中增加了`optimize`参数，翻看whoosh的文档在Merging Segments中提到了两个参数分别是`merge`和`optimize`，在默认情况下`merge`为True，意味着whoosh会将多个segments文件合并到一个文件中，如果`merge`为False的时候我们提交commit的时候会重新生成一个单独的索引文件，多个索引文件不会对搜索的结果产生很大的差异，如果过多的存在索引会降低整体的查询速度。通常情况下使用whoosh的合并算法将多个文件合并到一个文件中会更好，这只会让在更新索引的速度变慢，用户查询的速度影响较小，这样的用户体验会更好。\n   - 删:\n\t    ```python\n\t    from whoosh.index import open_dir\n\t    \n\t\tdef add_index(name, id):\n\t\t    \"\"\"\n\t\t    新增索引\n\t\t    :param name: 商品名称  type: str\n\t\t    :param id: 商品id  type: str\n\t\t    :return: None\n\t\t    \"\"\"\n\t    \tix = open_dir(\"index\")\n\t    \twriter = ix.writer()\n\t    \twriter.add_document(\n\t        \tid=id,\n\t        \tcontent=name\n\t    \t)\n\t    \twriter.commit(optimize=True)\n\t    ```\n\t\twhoosh总共有两种删除方式\n\t\t- `delete_by_query(query)`：删除与给定查询匹配的所有文档。\n\t\t- `delete_by_term(fieldname, termtext)`根据字段删除指定的文档，这里的字段需要在创建schema时指定为unique\n\t- 改\n\t  ```python\n\t  from whoosh.index import open_dir\n\n\t  def update_index(name, id):\n    \t\"\"\"\n    \t更新索引文件\n    \t:param name: 商品名称  type: str\n    \t:param id: 商品id  type: str\n    \t:return: None\n    \t\"\"\"\n    \tix = open_dir(\"index\")\n    \twriter = ix.writer()\n    \twriter.update_document(\n        \tid=id,\n        \tcontent=name\n    \t)\n    \twriter.commit()\n\t\t```\n\t\t和删除操作一样索引字段中需要有一个unique\n\n#### 总结\n---\n整个功能算是比较简单的了，各种库都给了对应的接口，很够很方便的实现功能。在实现的过程中也遇到了一个问题，最开始在实现增删改查功能的时候使用的事`create_in`来打开索引文件，这样导致操作完成之后之前的数据被覆盖了，还是自己当初粗心没有仔细看文档导致的。以后要注意这个问题。\n","slug":"blogs-jieba+whoosh实现简单的商品搜索功能","published":1,"date":"2022-03-16T17:00:39.882Z","updated":"2022-03-16T17:05:29.079Z","_id":"cl0v6kevv001vyms49bdq5hpj","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h4 id=\"功能描述\"><a href=\"#功能描述\" class=\"headerlink\" title=\"功能描述\"></a>功能描述</h4><p>实现一个类似淘宝的搜索功能，例如下面这个例子<br><img src=\"https://img-blog.csdnimg.cn/20190416194136675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>简单点来说我们需要先根据商品名称创建索引，然后再用索引文件匹配去查询字符串来实现商品的搜索，这种搜索是有别于正则匹配的，他会对字符串进行分词处理，准确度也会更高。</p>\n<hr>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>这个项目种主要用到了jieba、whoosh两个库，其中jieba实现对中文的分词处理，whoosh则是创建索引文件。<br>安装依赖：</p>\n<ul>\n<li>系统：Ubuntu 16.04</li>\n<li>Python版本： 3.5  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install jieba</span><br><span class=\"line\">pip install whoosh</span><br></pre></td></tr></table></figure>\n测试数据：<br>从github上找到的空气净化器的csv数据，需要的可点击下载<a href=\"https://github.com/Ckend/taobao_scrapy/blob/master/result/%E7%A9%BA%E6%B0%94%E6%B8%85%E6%96%B0%E5%99%A8_result.csv\">测试数据</a></li>\n</ul>\n<hr>\n<h4 id=\"正式开始\"><a href=\"#正式开始\" class=\"headerlink\" title=\"正式开始\"></a>正式开始</h4><ul>\n<li><strong>创建索引文件</strong><br>首先需要利用whoosh提供的接口对csv中的数据进行处理，生成索引文件。<br>whoosh对中文分词处理不是很好，所以选择jieba实现对中文的分词处理，jieba这个库也有对whoosh的支持，所以处理起来很方便，直接将索引模式中的analyzer更换为jieba的ChineseAnalyzer即可。<br><br><code>schema</code>定义了索引的模式，规定了索引的字段信息，其中索引字段包含<code>ID</code>、<code>STROED</code>、<code>KEYWORD</code>、<code>TEXT</code>、<code>NUMERIC</code>、<code>BOOLEAN</code>、<code>DATETIME</code>等几种，具体的含义和使用对象还是去看whoosh的官方文档来的直接，另外schema只需要我们创建一次，然后就会和索引一起被保存。（只需在第一次创建的时候声明schema）  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> whoosh.index <span class=\"keyword\">import</span> create_in</span><br><span class=\"line\"><span class=\"keyword\">from</span> whoosh.fields <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> jieba.analyse.analyzer <span class=\"keyword\">import</span> ChineseAnalyzer</span><br><span class=\"line\"><span class=\"keyword\">import</span> os.path</span><br><span class=\"line\"><span class=\"keyword\">import</span> csv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">create_index</span>():</span><br><span class=\"line\">   \t<span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">   \t创建索引文件</span></span><br><span class=\"line\"><span class=\"string\">   \t:return: None</span></span><br><span class=\"line\"><span class=\"string\">   \t&quot;&quot;&quot;</span></span><br><span class=\"line\">   \tanalyzer = ChineseAnalyzer()</span><br><span class=\"line\">   \tschema = Schema(<span class=\"built_in\">id</span>=ID(stored=<span class=\"literal\">True</span>, unique=<span class=\"literal\">True</span>), content=TEXT(stored=<span class=\"literal\">True</span>, analyzer=analyzer))  <span class=\"comment\"># 声明索引模式</span></span><br><span class=\"line\">   \t<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(<span class=\"string\">&quot;index&quot;</span>):  <span class=\"comment\"># 创建目录</span></span><br><span class=\"line\">       \tos.mkdir(<span class=\"string\">&quot;index&quot;</span>)</span><br><span class=\"line\">   \tix = create_in(<span class=\"string\">&quot;index&quot;</span>, schema)</span><br><span class=\"line\">   \twriter = ix.writer()</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"comment\"># csv数据</span></span><br><span class=\"line\">   \tcsv_file = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;goods.csv&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>)  <span class=\"comment\"># 读取csv文件</span></span><br><span class=\"line\">   \tdata = csv.reader(csv_file)</span><br><span class=\"line\">   \t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">       \twriter.add_document(</span><br><span class=\"line\">           \t<span class=\"built_in\">id</span>=i[<span class=\"number\">3</span>],</span><br><span class=\"line\">           \tcontent=i[<span class=\"number\">0</span>]</span><br><span class=\"line\">       \t)</span><br><span class=\"line\"> \t\twriter.commit()</span><br></pre></td></tr></table></figure>\n  使用<code>create_in</code>来创建索引文件，以后对索引文件的更删改查都是使用<code>open_dir</code>代开文件。<br><br>  在读取csv数据的时候，使用<code>add_document</code>来新增索引，其中并不是所有在schema中申明的字段都需要存储的可以为空。最后使用<code>commit</code>实现索引文件的正式写入，这一点和数据库很像。</li>\n<li><strong>简单的查询</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">from</span> whoosh.index <span class=\"keyword\">import</span> open_dir</span><br><span class=\"line\"><span class=\"keyword\">from</span> whoosh.qparser <span class=\"keyword\">import</span> QueryParser</span><br><span class=\"line\"><span class=\"keyword\">from</span> create_index <span class=\"keyword\">import</span> create_index</span><br><span class=\"line\"><span class=\"keyword\">import</span> os.path</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">search</span>(<span class=\"params\">keyword, limit=<span class=\"number\">10</span></span>):</span><br><span class=\"line\">   <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">   按照关键字搜索商品</span></span><br><span class=\"line\"><span class=\"string\">   :param keyword: 商品名称  type: str</span></span><br><span class=\"line\"><span class=\"string\">   :param limit: 检索数量  type: int</span></span><br><span class=\"line\"><span class=\"string\">   :return: [&#123;&#x27;id&#x27;:&#x27;&#x27;,&#x27;content&#x27;:&#x27;&#x27;&#125;,&#123;&#125;]  type：list</span></span><br><span class=\"line\"><span class=\"string\">   &quot;&quot;&quot;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(<span class=\"string\">&quot;index&quot;</span>):  <span class=\"comment\"># 查询时没有缩索引文件，需先创建索引文件</span></span><br><span class=\"line\">       create_index()</span><br><span class=\"line\">   ix = open_dir(<span class=\"string\">&quot;index&quot;</span>)  <span class=\"comment\"># 读取索引文件</span></span><br><span class=\"line\">   <span class=\"keyword\">with</span> ix.searcher() <span class=\"keyword\">as</span> searcher:</span><br><span class=\"line\">       parser = QueryParser(<span class=\"string\">&quot;content&quot;</span>, schema=ix.schema)</span><br><span class=\"line\">       keyword = parser.parse(keyword)  <span class=\"comment\"># 构造查询语句</span></span><br><span class=\"line\">       results = searcher.search(keyword, limit=limit)</span><br><span class=\"line\">       res = []</span><br><span class=\"line\">       <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> results:</span><br><span class=\"line\">           res.append(&#123;<span class=\"string\">&#x27;id&#x27;</span>: i[<span class=\"string\">&#x27;id&#x27;</span>], <span class=\"string\">&#x27;content&#x27;</span>: i[<span class=\"string\">&#x27;content&#x27;</span>]&#125;)</span><br><span class=\"line\">           <span class=\"built_in\">print</span>(i[<span class=\"string\">&#x27;id&#x27;</span>], i[<span class=\"string\">&#x27;content&#x27;</span>])</span><br><span class=\"line\">       <span class=\"built_in\">print</span>(res)</span><br></pre></td></tr></table></figure>\n在查询的时候需要先调用whoosh的<code>QueryParser</code>来构建查询字符串，通过调试我发现在构造查询字符串的时候whoosh默认会分词处理，并且使用<code>AND</code>连接符<br><img src=\"https://img-blog.csdnimg.cn/2019041623572811.png\" alt=\"在这里插入图片描述\">通过<code>search(keyword,limit)</code>去索引文件中匹配相关信息，其中<code>limit</code>为匹配到的最大数目，默认为10个。</li>\n<li><strong>索引的增删改查</strong><br>在一个系统中商品的信息必然不会是一成不变的，所以我们的索引文件就不可避免的需要按照商品信息去做调整，whoosh同样给我们提供了这样的接口。<ul>\n<li>增：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">from</span> whoosh.index <span class=\"keyword\">import</span> open_dir</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add_index</span>(<span class=\"params\">name, <span class=\"built_in\">id</span></span>):</span><br><span class=\"line\">   <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">   新增索引</span></span><br><span class=\"line\"><span class=\"string\">   :param name: 商品名称  type: str</span></span><br><span class=\"line\"><span class=\"string\">   :param id: 商品id  type: str</span></span><br><span class=\"line\"><span class=\"string\">   :return: None</span></span><br><span class=\"line\"><span class=\"string\">   &quot;&quot;&quot;</span></span><br><span class=\"line\">   ix = open_dir(<span class=\"string\">&quot;index&quot;</span>)</span><br><span class=\"line\">   writer = ix.writer()</span><br><span class=\"line\">   writer.add_document(</span><br><span class=\"line\">       <span class=\"built_in\">id</span>=<span class=\"built_in\">id</span>,</span><br><span class=\"line\">       content=name</span><br><span class=\"line\">   )</span><br><span class=\"line\">   writer.commit(optimize=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n 索引的增加和创建索引只有稍许不同，在<code>commit</code>中增加了<code>optimize</code>参数，翻看whoosh的文档在Merging Segments中提到了两个参数分别是<code>merge</code>和<code>optimize</code>，在默认情况下<code>merge</code>为True，意味着whoosh会将多个segments文件合并到一个文件中，如果<code>merge</code>为False的时候我们提交commit的时候会重新生成一个单独的索引文件，多个索引文件不会对搜索的结果产生很大的差异，如果过多的存在索引会降低整体的查询速度。通常情况下使用whoosh的合并算法将多个文件合并到一个文件中会更好，这只会让在更新索引的速度变慢，用户查询的速度影响较小，这样的用户体验会更好。</li>\n<li>删:   <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">from</span> whoosh.index <span class=\"keyword\">import</span> open_dir</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add_index</span>(<span class=\"params\">name, <span class=\"built_in\">id</span></span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    新增索引</span></span><br><span class=\"line\"><span class=\"string\">    :param name: 商品名称  type: str</span></span><br><span class=\"line\"><span class=\"string\">    :param id: 商品id  type: str</span></span><br><span class=\"line\"><span class=\"string\">    :return: None</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">   \tix = open_dir(<span class=\"string\">&quot;index&quot;</span>)</span><br><span class=\"line\">   \twriter = ix.writer()</span><br><span class=\"line\">   \twriter.add_document(</span><br><span class=\"line\">       \t<span class=\"built_in\">id</span>=<span class=\"built_in\">id</span>,</span><br><span class=\"line\">       \tcontent=name</span><br><span class=\"line\">   \t)</span><br><span class=\"line\">   \twriter.commit(optimize=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n   whoosh总共有两种删除方式<ul>\n<li><code>delete_by_query(query)</code>：删除与给定查询匹配的所有文档。</li>\n<li><code>delete_by_term(fieldname, termtext)</code>根据字段删除指定的文档，这里的字段需要在创建schema时指定为unique</li>\n</ul>\n</li>\n<li>改<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> whoosh.index <span class=\"keyword\">import</span> open_dir</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">update_index</span>(<span class=\"params\">name, <span class=\"built_in\">id</span></span>):</span><br><span class=\"line\"> \t<span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\"> \t更新索引文件</span></span><br><span class=\"line\"><span class=\"string\"> \t:param name: 商品名称  type: str</span></span><br><span class=\"line\"><span class=\"string\"> \t:param id: 商品id  type: str</span></span><br><span class=\"line\"><span class=\"string\"> \t:return: None</span></span><br><span class=\"line\"><span class=\"string\"> \t&quot;&quot;&quot;</span></span><br><span class=\"line\"> \tix = open_dir(<span class=\"string\">&quot;index&quot;</span>)</span><br><span class=\"line\"> \twriter = ix.writer()</span><br><span class=\"line\"> \twriter.update_document(</span><br><span class=\"line\">     \t<span class=\"built_in\">id</span>=<span class=\"built_in\">id</span>,</span><br><span class=\"line\">     \tcontent=name</span><br><span class=\"line\"> \t)</span><br><span class=\"line\"> \twriter.commit()</span><br></pre></td></tr></table></figure>\n  和删除操作一样索引字段中需要有一个unique</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><hr>\n<p>整个功能算是比较简单的了，各种库都给了对应的接口，很够很方便的实现功能。在实现的过程中也遇到了一个问题，最开始在实现增删改查功能的时候使用的事<code>create_in</code>来打开索引文件，这样导致操作完成之后之前的数据被覆盖了，还是自己当初粗心没有仔细看文档导致的。以后要注意这个问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"功能描述\"><a href=\"#功能描述\" class=\"headerlink\" title=\"功能描述\"></a>功能描述</h4><p>实现一个类似淘宝的搜索功能，例如下面这个例子<br><img src=\"https://img-blog.csdnimg.cn/20190416194136675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>简单点来说我们需要先根据商品名称创建索引，然后再用索引文件匹配去查询字符串来实现商品的搜索，这种搜索是有别于正则匹配的，他会对字符串进行分词处理，准确度也会更高。</p>\n<hr>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><p>这个项目种主要用到了jieba、whoosh两个库，其中jieba实现对中文的分词处理，whoosh则是创建索引文件。<br>安装依赖：</p>\n<ul>\n<li>系统：Ubuntu 16.04</li>\n<li>Python版本： 3.5  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install jieba</span><br><span class=\"line\">pip install whoosh</span><br></pre></td></tr></table></figure>\n测试数据：<br>从github上找到的空气净化器的csv数据，需要的可点击下载<a href=\"https://github.com/Ckend/taobao_scrapy/blob/master/result/%E7%A9%BA%E6%B0%94%E6%B8%85%E6%96%B0%E5%99%A8_result.csv\">测试数据</a></li>\n</ul>\n<hr>\n<h4 id=\"正式开始\"><a href=\"#正式开始\" class=\"headerlink\" title=\"正式开始\"></a>正式开始</h4><ul>\n<li><strong>创建索引文件</strong><br>首先需要利用whoosh提供的接口对csv中的数据进行处理，生成索引文件。<br>whoosh对中文分词处理不是很好，所以选择jieba实现对中文的分词处理，jieba这个库也有对whoosh的支持，所以处理起来很方便，直接将索引模式中的analyzer更换为jieba的ChineseAnalyzer即可。<br><br><code>schema</code>定义了索引的模式，规定了索引的字段信息，其中索引字段包含<code>ID</code>、<code>STROED</code>、<code>KEYWORD</code>、<code>TEXT</code>、<code>NUMERIC</code>、<code>BOOLEAN</code>、<code>DATETIME</code>等几种，具体的含义和使用对象还是去看whoosh的官方文档来的直接，另外schema只需要我们创建一次，然后就会和索引一起被保存。（只需在第一次创建的时候声明schema）  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> whoosh.index <span class=\"keyword\">import</span> create_in</span><br><span class=\"line\"><span class=\"keyword\">from</span> whoosh.fields <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> jieba.analyse.analyzer <span class=\"keyword\">import</span> ChineseAnalyzer</span><br><span class=\"line\"><span class=\"keyword\">import</span> os.path</span><br><span class=\"line\"><span class=\"keyword\">import</span> csv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">create_index</span>():</span><br><span class=\"line\">   \t<span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">   \t创建索引文件</span></span><br><span class=\"line\"><span class=\"string\">   \t:return: None</span></span><br><span class=\"line\"><span class=\"string\">   \t&quot;&quot;&quot;</span></span><br><span class=\"line\">   \tanalyzer = ChineseAnalyzer()</span><br><span class=\"line\">   \tschema = Schema(<span class=\"built_in\">id</span>=ID(stored=<span class=\"literal\">True</span>, unique=<span class=\"literal\">True</span>), content=TEXT(stored=<span class=\"literal\">True</span>, analyzer=analyzer))  <span class=\"comment\"># 声明索引模式</span></span><br><span class=\"line\">   \t<span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(<span class=\"string\">&quot;index&quot;</span>):  <span class=\"comment\"># 创建目录</span></span><br><span class=\"line\">       \tos.mkdir(<span class=\"string\">&quot;index&quot;</span>)</span><br><span class=\"line\">   \tix = create_in(<span class=\"string\">&quot;index&quot;</span>, schema)</span><br><span class=\"line\">   \twriter = ix.writer()</span><br><span class=\"line\"></span><br><span class=\"line\">   \t<span class=\"comment\"># csv数据</span></span><br><span class=\"line\">   \tcsv_file = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;goods.csv&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>)  <span class=\"comment\"># 读取csv文件</span></span><br><span class=\"line\">   \tdata = csv.reader(csv_file)</span><br><span class=\"line\">   \t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">       \twriter.add_document(</span><br><span class=\"line\">           \t<span class=\"built_in\">id</span>=i[<span class=\"number\">3</span>],</span><br><span class=\"line\">           \tcontent=i[<span class=\"number\">0</span>]</span><br><span class=\"line\">       \t)</span><br><span class=\"line\"> \t\twriter.commit()</span><br></pre></td></tr></table></figure>\n  使用<code>create_in</code>来创建索引文件，以后对索引文件的更删改查都是使用<code>open_dir</code>代开文件。<br><br>  在读取csv数据的时候，使用<code>add_document</code>来新增索引，其中并不是所有在schema中申明的字段都需要存储的可以为空。最后使用<code>commit</code>实现索引文件的正式写入，这一点和数据库很像。</li>\n<li><strong>简单的查询</strong><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"keyword\">from</span> whoosh.index <span class=\"keyword\">import</span> open_dir</span><br><span class=\"line\"><span class=\"keyword\">from</span> whoosh.qparser <span class=\"keyword\">import</span> QueryParser</span><br><span class=\"line\"><span class=\"keyword\">from</span> create_index <span class=\"keyword\">import</span> create_index</span><br><span class=\"line\"><span class=\"keyword\">import</span> os.path</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">search</span>(<span class=\"params\">keyword, limit=<span class=\"number\">10</span></span>):</span><br><span class=\"line\">   <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">   按照关键字搜索商品</span></span><br><span class=\"line\"><span class=\"string\">   :param keyword: 商品名称  type: str</span></span><br><span class=\"line\"><span class=\"string\">   :param limit: 检索数量  type: int</span></span><br><span class=\"line\"><span class=\"string\">   :return: [&#123;&#x27;id&#x27;:&#x27;&#x27;,&#x27;content&#x27;:&#x27;&#x27;&#125;,&#123;&#125;]  type：list</span></span><br><span class=\"line\"><span class=\"string\">   &quot;&quot;&quot;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> os.path.exists(<span class=\"string\">&quot;index&quot;</span>):  <span class=\"comment\"># 查询时没有缩索引文件，需先创建索引文件</span></span><br><span class=\"line\">       create_index()</span><br><span class=\"line\">   ix = open_dir(<span class=\"string\">&quot;index&quot;</span>)  <span class=\"comment\"># 读取索引文件</span></span><br><span class=\"line\">   <span class=\"keyword\">with</span> ix.searcher() <span class=\"keyword\">as</span> searcher:</span><br><span class=\"line\">       parser = QueryParser(<span class=\"string\">&quot;content&quot;</span>, schema=ix.schema)</span><br><span class=\"line\">       keyword = parser.parse(keyword)  <span class=\"comment\"># 构造查询语句</span></span><br><span class=\"line\">       results = searcher.search(keyword, limit=limit)</span><br><span class=\"line\">       res = []</span><br><span class=\"line\">       <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> results:</span><br><span class=\"line\">           res.append(&#123;<span class=\"string\">&#x27;id&#x27;</span>: i[<span class=\"string\">&#x27;id&#x27;</span>], <span class=\"string\">&#x27;content&#x27;</span>: i[<span class=\"string\">&#x27;content&#x27;</span>]&#125;)</span><br><span class=\"line\">           <span class=\"built_in\">print</span>(i[<span class=\"string\">&#x27;id&#x27;</span>], i[<span class=\"string\">&#x27;content&#x27;</span>])</span><br><span class=\"line\">       <span class=\"built_in\">print</span>(res)</span><br></pre></td></tr></table></figure>\n在查询的时候需要先调用whoosh的<code>QueryParser</code>来构建查询字符串，通过调试我发现在构造查询字符串的时候whoosh默认会分词处理，并且使用<code>AND</code>连接符<br><img src=\"https://img-blog.csdnimg.cn/2019041623572811.png\" alt=\"在这里插入图片描述\">通过<code>search(keyword,limit)</code>去索引文件中匹配相关信息，其中<code>limit</code>为匹配到的最大数目，默认为10个。</li>\n<li><strong>索引的增删改查</strong><br>在一个系统中商品的信息必然不会是一成不变的，所以我们的索引文件就不可避免的需要按照商品信息去做调整，whoosh同样给我们提供了这样的接口。<ul>\n<li>增：<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">from</span> whoosh.index <span class=\"keyword\">import</span> open_dir</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add_index</span>(<span class=\"params\">name, <span class=\"built_in\">id</span></span>):</span><br><span class=\"line\">   <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">   新增索引</span></span><br><span class=\"line\"><span class=\"string\">   :param name: 商品名称  type: str</span></span><br><span class=\"line\"><span class=\"string\">   :param id: 商品id  type: str</span></span><br><span class=\"line\"><span class=\"string\">   :return: None</span></span><br><span class=\"line\"><span class=\"string\">   &quot;&quot;&quot;</span></span><br><span class=\"line\">   ix = open_dir(<span class=\"string\">&quot;index&quot;</span>)</span><br><span class=\"line\">   writer = ix.writer()</span><br><span class=\"line\">   writer.add_document(</span><br><span class=\"line\">       <span class=\"built_in\">id</span>=<span class=\"built_in\">id</span>,</span><br><span class=\"line\">       content=name</span><br><span class=\"line\">   )</span><br><span class=\"line\">   writer.commit(optimize=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n 索引的增加和创建索引只有稍许不同，在<code>commit</code>中增加了<code>optimize</code>参数，翻看whoosh的文档在Merging Segments中提到了两个参数分别是<code>merge</code>和<code>optimize</code>，在默认情况下<code>merge</code>为True，意味着whoosh会将多个segments文件合并到一个文件中，如果<code>merge</code>为False的时候我们提交commit的时候会重新生成一个单独的索引文件，多个索引文件不会对搜索的结果产生很大的差异，如果过多的存在索引会降低整体的查询速度。通常情况下使用whoosh的合并算法将多个文件合并到一个文件中会更好，这只会让在更新索引的速度变慢，用户查询的速度影响较小，这样的用户体验会更好。</li>\n<li>删:   <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">from</span> whoosh.index <span class=\"keyword\">import</span> open_dir</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add_index</span>(<span class=\"params\">name, <span class=\"built_in\">id</span></span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    新增索引</span></span><br><span class=\"line\"><span class=\"string\">    :param name: 商品名称  type: str</span></span><br><span class=\"line\"><span class=\"string\">    :param id: 商品id  type: str</span></span><br><span class=\"line\"><span class=\"string\">    :return: None</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">   \tix = open_dir(<span class=\"string\">&quot;index&quot;</span>)</span><br><span class=\"line\">   \twriter = ix.writer()</span><br><span class=\"line\">   \twriter.add_document(</span><br><span class=\"line\">       \t<span class=\"built_in\">id</span>=<span class=\"built_in\">id</span>,</span><br><span class=\"line\">       \tcontent=name</span><br><span class=\"line\">   \t)</span><br><span class=\"line\">   \twriter.commit(optimize=<span class=\"literal\">True</span>)</span><br></pre></td></tr></table></figure>\n   whoosh总共有两种删除方式<ul>\n<li><code>delete_by_query(query)</code>：删除与给定查询匹配的所有文档。</li>\n<li><code>delete_by_term(fieldname, termtext)</code>根据字段删除指定的文档，这里的字段需要在创建schema时指定为unique</li>\n</ul>\n</li>\n<li>改<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> whoosh.index <span class=\"keyword\">import</span> open_dir</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">update_index</span>(<span class=\"params\">name, <span class=\"built_in\">id</span></span>):</span><br><span class=\"line\"> \t<span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\"> \t更新索引文件</span></span><br><span class=\"line\"><span class=\"string\"> \t:param name: 商品名称  type: str</span></span><br><span class=\"line\"><span class=\"string\"> \t:param id: 商品id  type: str</span></span><br><span class=\"line\"><span class=\"string\"> \t:return: None</span></span><br><span class=\"line\"><span class=\"string\"> \t&quot;&quot;&quot;</span></span><br><span class=\"line\"> \tix = open_dir(<span class=\"string\">&quot;index&quot;</span>)</span><br><span class=\"line\"> \twriter = ix.writer()</span><br><span class=\"line\"> \twriter.update_document(</span><br><span class=\"line\">     \t<span class=\"built_in\">id</span>=<span class=\"built_in\">id</span>,</span><br><span class=\"line\">     \tcontent=name</span><br><span class=\"line\"> \t)</span><br><span class=\"line\"> \twriter.commit()</span><br></pre></td></tr></table></figure>\n  和删除操作一样索引字段中需要有一个unique</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><hr>\n<p>整个功能算是比较简单的了，各种库都给了对应的接口，很够很方便的实现功能。在实现的过程中也遇到了一个问题，最开始在实现增删改查功能的时候使用的事<code>create_in</code>来打开索引文件，这样导致操作完成之后之前的数据被覆盖了，还是自己当初粗心没有仔细看文档导致的。以后要注意这个问题。</p>\n"},{"_content":"<h3>list.sort方法和内置函数sorted的异同</h3>\n\n<p>list.sort方法和sorted函数都是对列表进行排序的，但是这两种方法也是有少许不同的，list.sort排序是在原有基础上进行的，不会生成返回一个新的list， 但是sorted函数则不同，他会产生一个新对象并返回。如下</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">t = [1, 3, 4, 2, 5, 0]\nt1 = [1, 3, 4, 2, 5, 0]\nprint(t.sort())\nprint(t)\nprint(sorted(t1))\nprint(t1)</code></pre>\n\n<p><img alt=\"\" class=\"has\" height=\"113\" src=\"https://img-blog.csdn.net/20181011115605325?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"284\" /><br />\n在同时对t和t1 排序并打印结果，t.sort()返回None  sorted(t1) 返回排序好的list，两者都正确，但是只有t的内容发生改变，t1的内容没有改变。</p>\n\n<p>sorted()函数要比list.sort()强大很多，sorted()不仅仅只能将list作为参数传递进去，还可以接收任何形式的可迭代对象作为参数，甚至是不可变序列或者生成器，不管是接收的什么参数sorted()都是返回一个列表。</p>\n\n<p>list.sort()和sorted()都有两个可选的参数：<br />\n 1. reverse：决定是升序还是降序排列，True为降序，默认值为False<br />\n 2. key: 一个只有一个参数的函数，这个函数会被用在序列的每一个元素上，通俗来讲就是排序规则，例如对字符串排序的时候可以使用key=str.lower来实现忽略大小的排序，或者是key=len来按照字符串长度排序等等。默认用元素自己的值来排序。<br /><img alt=\"\" class=\"has\" height=\"103\" src=\"https://img-blog.csdn.net/20181011120952740?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"413\" /></p>\n\n<h3>想要在不打乱次序的情况下如何向有序列表中插入数据呢？</h3>\n\n<p>可借助bisect模块来实现，bisect模块主要包含两个函数 ，bisect和insort ，这两个函数都是利用二分查找算法来实现在有序序列中查找或者插入元素的<br />\n例如使用bisect来搜索可插入的位置：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import bisect\n\nt = [123, 3, 234, 1, 423, 5, 25, 235, 325]\nt.sort()\nprint(bisect.bisect(t, 235))\n\n###  7</code></pre>\n\n<p>返回值为可插入的位置。前提是传入的参数是有序序列，bisect还有两个可选的参数 lo和 hi即搜索范围，lo默认为0，hi默认为序列长度。</p>\n\n<p>如果有序序列中已存在要插入的元素的时候，又是如何处理的呢！这个就有两种情况，插入到原有元素之前或者之后，分别对应两个方法bisect_left和 bisect_right，而我们之前使用的bisect其实就是bisect_right方法。既然获取的插入位置，那么使用list.insert方法插入即可完成向有序序列插入元素。有没有更简单的方法呢，答案是肯定的，那就是我们之前提到的insort方法。</p>\n\n<p>使用insort插入元素：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import bisect\n\nt = [123, 3, 234, 1, 423, 5, 25, 235, 325]\nt.sort()\nbisect.insort(t, 222)\nprint(t)\n\n###   [1, 3, 5, 25, 123, 222, 234, 235, 325, 423]</code></pre>\n\n<p>看了bisect源码之后发现其实insort方法和bisect方法是一样的，只是获取到了插入位置之后紧接着调用insert()方法<br /><img alt=\"\" class=\"has\" height=\"255\" src=\"https://img-blog.csdn.net/20181011145138585?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"602\" /><br />\ninsort方法和bisect方法是一样的也是有两个可选参数lo和hi来缩小范围，也分insort_left和insort_right，默认使用的是insort_right方法 </p>\n\n<p><br />\n </p>","source":"_posts/blogs-list.sort方法和内置函数sorted.md","raw":"<h3>list.sort方法和内置函数sorted的异同</h3>\n\n<p>list.sort方法和sorted函数都是对列表进行排序的，但是这两种方法也是有少许不同的，list.sort排序是在原有基础上进行的，不会生成返回一个新的list， 但是sorted函数则不同，他会产生一个新对象并返回。如下</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">t = [1, 3, 4, 2, 5, 0]\nt1 = [1, 3, 4, 2, 5, 0]\nprint(t.sort())\nprint(t)\nprint(sorted(t1))\nprint(t1)</code></pre>\n\n<p><img alt=\"\" class=\"has\" height=\"113\" src=\"https://img-blog.csdn.net/20181011115605325?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"284\" /><br />\n在同时对t和t1 排序并打印结果，t.sort()返回None  sorted(t1) 返回排序好的list，两者都正确，但是只有t的内容发生改变，t1的内容没有改变。</p>\n\n<p>sorted()函数要比list.sort()强大很多，sorted()不仅仅只能将list作为参数传递进去，还可以接收任何形式的可迭代对象作为参数，甚至是不可变序列或者生成器，不管是接收的什么参数sorted()都是返回一个列表。</p>\n\n<p>list.sort()和sorted()都有两个可选的参数：<br />\n 1. reverse：决定是升序还是降序排列，True为降序，默认值为False<br />\n 2. key: 一个只有一个参数的函数，这个函数会被用在序列的每一个元素上，通俗来讲就是排序规则，例如对字符串排序的时候可以使用key=str.lower来实现忽略大小的排序，或者是key=len来按照字符串长度排序等等。默认用元素自己的值来排序。<br /><img alt=\"\" class=\"has\" height=\"103\" src=\"https://img-blog.csdn.net/20181011120952740?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"413\" /></p>\n\n<h3>想要在不打乱次序的情况下如何向有序列表中插入数据呢？</h3>\n\n<p>可借助bisect模块来实现，bisect模块主要包含两个函数 ，bisect和insort ，这两个函数都是利用二分查找算法来实现在有序序列中查找或者插入元素的<br />\n例如使用bisect来搜索可插入的位置：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import bisect\n\nt = [123, 3, 234, 1, 423, 5, 25, 235, 325]\nt.sort()\nprint(bisect.bisect(t, 235))\n\n###  7</code></pre>\n\n<p>返回值为可插入的位置。前提是传入的参数是有序序列，bisect还有两个可选的参数 lo和 hi即搜索范围，lo默认为0，hi默认为序列长度。</p>\n\n<p>如果有序序列中已存在要插入的元素的时候，又是如何处理的呢！这个就有两种情况，插入到原有元素之前或者之后，分别对应两个方法bisect_left和 bisect_right，而我们之前使用的bisect其实就是bisect_right方法。既然获取的插入位置，那么使用list.insert方法插入即可完成向有序序列插入元素。有没有更简单的方法呢，答案是肯定的，那就是我们之前提到的insort方法。</p>\n\n<p>使用insort插入元素：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import bisect\n\nt = [123, 3, 234, 1, 423, 5, 25, 235, 325]\nt.sort()\nbisect.insort(t, 222)\nprint(t)\n\n###   [1, 3, 5, 25, 123, 222, 234, 235, 325, 423]</code></pre>\n\n<p>看了bisect源码之后发现其实insort方法和bisect方法是一样的，只是获取到了插入位置之后紧接着调用insert()方法<br /><img alt=\"\" class=\"has\" height=\"255\" src=\"https://img-blog.csdn.net/20181011145138585?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"602\" /><br />\ninsort方法和bisect方法是一样的也是有两个可选参数lo和hi来缩小范围，也分insort_left和insort_right，默认使用的是insort_right方法 </p>\n\n<p><br />\n </p>","slug":"blogs-list.sort方法和内置函数sorted","published":1,"date":"2022-03-16T17:01:24.410Z","updated":"2022-03-16T17:06:14.146Z","_id":"cl0v6kevw001wyms4h96ifhp4","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h3>list.sort方法和内置函数sorted的异同</h3>\n\n<p>list.sort方法和sorted函数都是对列表进行排序的，但是这两种方法也是有少许不同的，list.sort排序是在原有基础上进行的，不会生成返回一个新的list， 但是sorted函数则不同，他会产生一个新对象并返回。如下</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">t = [1, 3, 4, 2, 5, 0]\nt1 = [1, 3, 4, 2, 5, 0]\nprint(t.sort())\nprint(t)\nprint(sorted(t1))\nprint(t1)</code></pre>\n\n<p><img alt=\"\" class=\"has\" height=\"113\" src=\"https://img-blog.csdn.net/20181011115605325?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"284\" /><br />\n在同时对t和t1 排序并打印结果，t.sort()返回None  sorted(t1) 返回排序好的list，两者都正确，但是只有t的内容发生改变，t1的内容没有改变。</p>\n\n<p>sorted()函数要比list.sort()强大很多，sorted()不仅仅只能将list作为参数传递进去，还可以接收任何形式的可迭代对象作为参数，甚至是不可变序列或者生成器，不管是接收的什么参数sorted()都是返回一个列表。</p>\n\n<p>list.sort()和sorted()都有两个可选的参数：<br />\n 1. reverse：决定是升序还是降序排列，True为降序，默认值为False<br />\n 2. key: 一个只有一个参数的函数，这个函数会被用在序列的每一个元素上，通俗来讲就是排序规则，例如对字符串排序的时候可以使用key=str.lower来实现忽略大小的排序，或者是key=len来按照字符串长度排序等等。默认用元素自己的值来排序。<br /><img alt=\"\" class=\"has\" height=\"103\" src=\"https://img-blog.csdn.net/20181011120952740?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"413\" /></p>\n\n<h3>想要在不打乱次序的情况下如何向有序列表中插入数据呢？</h3>\n\n<p>可借助bisect模块来实现，bisect模块主要包含两个函数 ，bisect和insort ，这两个函数都是利用二分查找算法来实现在有序序列中查找或者插入元素的<br />\n例如使用bisect来搜索可插入的位置：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import bisect\n\nt = [123, 3, 234, 1, 423, 5, 25, 235, 325]\nt.sort()\nprint(bisect.bisect(t, 235))\n\n###  7</code></pre>\n\n<p>返回值为可插入的位置。前提是传入的参数是有序序列，bisect还有两个可选的参数 lo和 hi即搜索范围，lo默认为0，hi默认为序列长度。</p>\n\n<p>如果有序序列中已存在要插入的元素的时候，又是如何处理的呢！这个就有两种情况，插入到原有元素之前或者之后，分别对应两个方法bisect_left和 bisect_right，而我们之前使用的bisect其实就是bisect_right方法。既然获取的插入位置，那么使用list.insert方法插入即可完成向有序序列插入元素。有没有更简单的方法呢，答案是肯定的，那就是我们之前提到的insort方法。</p>\n\n<p>使用insort插入元素：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import bisect\n\nt = [123, 3, 234, 1, 423, 5, 25, 235, 325]\nt.sort()\nbisect.insort(t, 222)\nprint(t)\n\n###   [1, 3, 5, 25, 123, 222, 234, 235, 325, 423]</code></pre>\n\n<p>看了bisect源码之后发现其实insort方法和bisect方法是一样的，只是获取到了插入位置之后紧接着调用insert()方法<br /><img alt=\"\" class=\"has\" height=\"255\" src=\"https://img-blog.csdn.net/20181011145138585?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"602\" /><br />\ninsort方法和bisect方法是一样的也是有两个可选参数lo和hi来缩小范围，也分insort_left和insort_right，默认使用的是insort_right方法 </p>\n\n<p><br />\n </p>","site":{"data":{}},"excerpt":"","more":"<h3>list.sort方法和内置函数sorted的异同</h3>\n\n<p>list.sort方法和sorted函数都是对列表进行排序的，但是这两种方法也是有少许不同的，list.sort排序是在原有基础上进行的，不会生成返回一个新的list， 但是sorted函数则不同，他会产生一个新对象并返回。如下</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">t = [1, 3, 4, 2, 5, 0]\nt1 = [1, 3, 4, 2, 5, 0]\nprint(t.sort())\nprint(t)\nprint(sorted(t1))\nprint(t1)</code></pre>\n\n<p><img alt=\"\" class=\"has\" height=\"113\" src=\"https://img-blog.csdn.net/20181011115605325?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"284\" /><br />\n在同时对t和t1 排序并打印结果，t.sort()返回None  sorted(t1) 返回排序好的list，两者都正确，但是只有t的内容发生改变，t1的内容没有改变。</p>\n\n<p>sorted()函数要比list.sort()强大很多，sorted()不仅仅只能将list作为参数传递进去，还可以接收任何形式的可迭代对象作为参数，甚至是不可变序列或者生成器，不管是接收的什么参数sorted()都是返回一个列表。</p>\n\n<p>list.sort()和sorted()都有两个可选的参数：<br />\n 1. reverse：决定是升序还是降序排列，True为降序，默认值为False<br />\n 2. key: 一个只有一个参数的函数，这个函数会被用在序列的每一个元素上，通俗来讲就是排序规则，例如对字符串排序的时候可以使用key=str.lower来实现忽略大小的排序，或者是key=len来按照字符串长度排序等等。默认用元素自己的值来排序。<br /><img alt=\"\" class=\"has\" height=\"103\" src=\"https://img-blog.csdn.net/20181011120952740?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"413\" /></p>\n\n<h3>想要在不打乱次序的情况下如何向有序列表中插入数据呢？</h3>\n\n<p>可借助bisect模块来实现，bisect模块主要包含两个函数 ，bisect和insort ，这两个函数都是利用二分查找算法来实现在有序序列中查找或者插入元素的<br />\n例如使用bisect来搜索可插入的位置：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import bisect\n\nt = [123, 3, 234, 1, 423, 5, 25, 235, 325]\nt.sort()\nprint(bisect.bisect(t, 235))\n\n###  7</code></pre>\n\n<p>返回值为可插入的位置。前提是传入的参数是有序序列，bisect还有两个可选的参数 lo和 hi即搜索范围，lo默认为0，hi默认为序列长度。</p>\n\n<p>如果有序序列中已存在要插入的元素的时候，又是如何处理的呢！这个就有两种情况，插入到原有元素之前或者之后，分别对应两个方法bisect_left和 bisect_right，而我们之前使用的bisect其实就是bisect_right方法。既然获取的插入位置，那么使用list.insert方法插入即可完成向有序序列插入元素。有没有更简单的方法呢，答案是肯定的，那就是我们之前提到的insort方法。</p>\n\n<p>使用insort插入元素：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">import bisect\n\nt = [123, 3, 234, 1, 423, 5, 25, 235, 325]\nt.sort()\nbisect.insort(t, 222)\nprint(t)\n\n###   [1, 3, 5, 25, 123, 222, 234, 235, 325, 423]</code></pre>\n\n<p>看了bisect源码之后发现其实insort方法和bisect方法是一样的，只是获取到了插入位置之后紧接着调用insert()方法<br /><img alt=\"\" class=\"has\" height=\"255\" src=\"https://img-blog.csdn.net/20181011145138585?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" width=\"602\" /><br />\ninsort方法和bisect方法是一样的也是有两个可选参数lo和hi来缩小范围，也分insort_left和insort_right，默认使用的是insort_right方法 </p>\n\n<p><br />\n </p>"},{"_content":"\n<p>队列Queue包含三个类&nbsp;</p>\n<p>1：Queue(maxsize=0)&nbsp; 普通模式先进先出</p>\n<p>2：LifoQueue(maxsize=0)&nbsp; 后进先出</p>\n<p>3：PriorityQueue(maxsize=0)&nbsp; 优先级模式</p>\n<p><br>\n</p>\n<p>Queue.qsize()&nbsp;返回当前队列里存在的个数</p>\n<p>Queue.empty()&nbsp;返回队列是否为空</p>\n<p>Queue.full()&nbsp;返回队列是否存满</p>\n<p>Queue.put(item, block=True, timeout=None)<br>\n将item放入队列中。<br>\n如果可选的参数block为True且timeout为空对象（默认的情况，阻塞调用，无超时）。<br>\n如果timeout是个正整数，阻塞调用进程最多timeout秒，如果一直无空空间可用，抛出Full异常（带超时的阻塞调用）。<br>\n如果block为False，如果有空闲空间可用将数据放入队列，否则立即抛出Full异常</p>\n<p>Queue.put_nowait()无阻塞版本,等同于block=False，timeout=None</p>\n<p>Queue.get(block=True, timeout=None)&nbsp;取出数据，其他与put类&#20284;</p>\n<p><br>\n</p>\n<p>Queue()示例</p>\n<pre class=\"python\">import queue\n\nq = queue.Queue()  #普通的（先进先出\n\nq.put(1)\nq.put(2)\nq.put(3)\n\nprint(q.qsize()) #获取当前存在的个数\n\nprint(q.get()) #取出 当超过的时候会报错\nprint(q.get())\nprint(q.get())</pre>\n结果：\n<p>1 2 3&nbsp;</p>\n<p>LifoQueue()示例<br>\n</p>\n<pre class=\"python\">import queue\n\nq = queue.LifoQueue()  #普通的（先进先出\n\nq.put(1)\nq.put(2)\nq.put(3)\n\nprint(q.qsize()) #获取当前存在的个数\n\nprint(q.get()) #取出 当超过的时候会报错\nprint(q.get())\nprint(q.get())</pre>\n<p>结果：</p>\n<p>3&nbsp; 2 1&nbsp;</p>\n<p>PriorityQueue()示例&nbsp;&nbsp;<br>\n</p>\n<p>按照一定的规律确定优先级，例如数字越小优先级越高，或者按字符排序，&#20540;得注意的是只能采用一种模式来确定，全为数字或是全为字符，两者不能混在一起，不然会报错。</p>\n<pre class=\"python\">import queue\n\nq = queue.PriorityQueue()  #普通的（先进先出\n\nq.put((2,'b'))\nq.put((1,'a'))\nq.put((3,'c'))\n\nprint(q.qsize()) #获取当前存在的个数\n\nprint(q.get()) #取出 当超过的时候会报错\nprint(q.get())\nprint(q.get())</pre>\n结果：\n<p>(1, 'a')<br>\n(2, 'b')<br>\n(3, 'c')<br>\n</p>\n<p><br>\n</p>\n<p>简单的生产者和消费者模型</p>\n<pre class=\"python\">import queue,threading,time\nq = queue.Queue()\n\ndef Producer():\n    count = 0\n    while True:\n        q.put('Switch %s' %count)\n        print('Switch %s' %count)\n        count &#43;= 1\n        time.sleep(1)\n\ndef Consumer():\n    while True:\n        if q.qsize() &gt; 0 :\n            print('buy %s'%q.get())\n            time.sleep(2)\n\np = threading.Thread(target=Producer)\nc = threading.Thread(target=Consumer)\n\np.start()\nc.start()</pre>\n结果：\n<p>生成了Switch 0<br>\n购买了 Switch 0<br>\n生成了Switch 1<br>\n购买了 Switch 1<br>\n生成了Switch 2<br>\n生成了Switch 3<br>\n购买了 Switch 2<br>\n生成了Switch 4<br>\n生成了Switch 5<br>\n生成了Switch 6<br>\n购买了 Switch 3<br>\n生成了Switch 7<br>\n购买了 Switch 4<br>\n生成了Switch 8<br>\n<br>\n</p>\n<p><br>\n</p>\n","source":"_posts/blogs-Python基础---队列.md","raw":"\n<p>队列Queue包含三个类&nbsp;</p>\n<p>1：Queue(maxsize=0)&nbsp; 普通模式先进先出</p>\n<p>2：LifoQueue(maxsize=0)&nbsp; 后进先出</p>\n<p>3：PriorityQueue(maxsize=0)&nbsp; 优先级模式</p>\n<p><br>\n</p>\n<p>Queue.qsize()&nbsp;返回当前队列里存在的个数</p>\n<p>Queue.empty()&nbsp;返回队列是否为空</p>\n<p>Queue.full()&nbsp;返回队列是否存满</p>\n<p>Queue.put(item, block=True, timeout=None)<br>\n将item放入队列中。<br>\n如果可选的参数block为True且timeout为空对象（默认的情况，阻塞调用，无超时）。<br>\n如果timeout是个正整数，阻塞调用进程最多timeout秒，如果一直无空空间可用，抛出Full异常（带超时的阻塞调用）。<br>\n如果block为False，如果有空闲空间可用将数据放入队列，否则立即抛出Full异常</p>\n<p>Queue.put_nowait()无阻塞版本,等同于block=False，timeout=None</p>\n<p>Queue.get(block=True, timeout=None)&nbsp;取出数据，其他与put类&#20284;</p>\n<p><br>\n</p>\n<p>Queue()示例</p>\n<pre class=\"python\">import queue\n\nq = queue.Queue()  #普通的（先进先出\n\nq.put(1)\nq.put(2)\nq.put(3)\n\nprint(q.qsize()) #获取当前存在的个数\n\nprint(q.get()) #取出 当超过的时候会报错\nprint(q.get())\nprint(q.get())</pre>\n结果：\n<p>1 2 3&nbsp;</p>\n<p>LifoQueue()示例<br>\n</p>\n<pre class=\"python\">import queue\n\nq = queue.LifoQueue()  #普通的（先进先出\n\nq.put(1)\nq.put(2)\nq.put(3)\n\nprint(q.qsize()) #获取当前存在的个数\n\nprint(q.get()) #取出 当超过的时候会报错\nprint(q.get())\nprint(q.get())</pre>\n<p>结果：</p>\n<p>3&nbsp; 2 1&nbsp;</p>\n<p>PriorityQueue()示例&nbsp;&nbsp;<br>\n</p>\n<p>按照一定的规律确定优先级，例如数字越小优先级越高，或者按字符排序，&#20540;得注意的是只能采用一种模式来确定，全为数字或是全为字符，两者不能混在一起，不然会报错。</p>\n<pre class=\"python\">import queue\n\nq = queue.PriorityQueue()  #普通的（先进先出\n\nq.put((2,'b'))\nq.put((1,'a'))\nq.put((3,'c'))\n\nprint(q.qsize()) #获取当前存在的个数\n\nprint(q.get()) #取出 当超过的时候会报错\nprint(q.get())\nprint(q.get())</pre>\n结果：\n<p>(1, 'a')<br>\n(2, 'b')<br>\n(3, 'c')<br>\n</p>\n<p><br>\n</p>\n<p>简单的生产者和消费者模型</p>\n<pre class=\"python\">import queue,threading,time\nq = queue.Queue()\n\ndef Producer():\n    count = 0\n    while True:\n        q.put('Switch %s' %count)\n        print('Switch %s' %count)\n        count &#43;= 1\n        time.sleep(1)\n\ndef Consumer():\n    while True:\n        if q.qsize() &gt; 0 :\n            print('buy %s'%q.get())\n            time.sleep(2)\n\np = threading.Thread(target=Producer)\nc = threading.Thread(target=Consumer)\n\np.start()\nc.start()</pre>\n结果：\n<p>生成了Switch 0<br>\n购买了 Switch 0<br>\n生成了Switch 1<br>\n购买了 Switch 1<br>\n生成了Switch 2<br>\n生成了Switch 3<br>\n购买了 Switch 2<br>\n生成了Switch 4<br>\n生成了Switch 5<br>\n生成了Switch 6<br>\n购买了 Switch 3<br>\n生成了Switch 7<br>\n购买了 Switch 4<br>\n生成了Switch 8<br>\n<br>\n</p>\n<p><br>\n</p>\n","slug":"blogs-Python基础---队列","published":1,"date":"2022-03-16T17:09:29.277Z","updated":"2022-03-16T17:09:29.278Z","_id":"cl0v6kevx001xyms4g27q1d9b","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>队列Queue包含三个类&nbsp;</p>\n<p>1：Queue(maxsize=0)&nbsp; 普通模式先进先出</p>\n<p>2：LifoQueue(maxsize=0)&nbsp; 后进先出</p>\n<p>3：PriorityQueue(maxsize=0)&nbsp; 优先级模式</p>\n<p><br>\n</p>\n<p>Queue.qsize()&nbsp;返回当前队列里存在的个数</p>\n<p>Queue.empty()&nbsp;返回队列是否为空</p>\n<p>Queue.full()&nbsp;返回队列是否存满</p>\n<p>Queue.put(item, block=True, timeout=None)<br>\n将item放入队列中。<br>\n如果可选的参数block为True且timeout为空对象（默认的情况，阻塞调用，无超时）。<br>\n如果timeout是个正整数，阻塞调用进程最多timeout秒，如果一直无空空间可用，抛出Full异常（带超时的阻塞调用）。<br>\n如果block为False，如果有空闲空间可用将数据放入队列，否则立即抛出Full异常</p>\n<p>Queue.put_nowait()无阻塞版本,等同于block=False，timeout=None</p>\n<p>Queue.get(block=True, timeout=None)&nbsp;取出数据，其他与put类&#20284;</p>\n<p><br>\n</p>\n<p>Queue()示例</p>\n<pre class=\"python\">import queue\n\n<p>q = queue.Queue()  #普通的（先进先出</p>\n<p>q.put(1)<br>q.put(2)<br>q.put(3)</p>\n<p>print(q.qsize()) #获取当前存在的个数</p>\n<p>print(q.get()) #取出 当超过的时候会报错<br>print(q.get())<br>print(q.get())</pre><br>结果：</p>\n<p>1 2 3&nbsp;</p>\n<p>LifoQueue()示例<br>\n</p>\n<pre class=\"python\">import queue\n\n<p>q = queue.LifoQueue()  #普通的（先进先出</p>\n<p>q.put(1)<br>q.put(2)<br>q.put(3)</p>\n<p>print(q.qsize()) #获取当前存在的个数</p>\n<p>print(q.get()) #取出 当超过的时候会报错<br>print(q.get())<br>print(q.get())</pre></p>\n<p>结果：</p>\n<p>3&nbsp; 2 1&nbsp;</p>\n<p>PriorityQueue()示例&nbsp;&nbsp;<br>\n</p>\n<p>按照一定的规律确定优先级，例如数字越小优先级越高，或者按字符排序，&#20540;得注意的是只能采用一种模式来确定，全为数字或是全为字符，两者不能混在一起，不然会报错。</p>\n<pre class=\"python\">import queue\n\n<p>q = queue.PriorityQueue()  #普通的（先进先出</p>\n<p>q.put((2,’b’))<br>q.put((1,’a’))<br>q.put((3,’c’))</p>\n<p>print(q.qsize()) #获取当前存在的个数</p>\n<p>print(q.get()) #取出 当超过的时候会报错<br>print(q.get())<br>print(q.get())</pre><br>结果：</p>\n<p>(1, 'a')<br>\n(2, 'b')<br>\n(3, 'c')<br>\n</p>\n<p><br>\n</p>\n<p>简单的生产者和消费者模型</p>\n<pre class=\"python\">import queue,threading,time\nq = queue.Queue()\n\n<p>def Producer():<br>    count = 0<br>    while True:<br>        q.put(‘Switch %s’ %count)<br>        print(‘Switch %s’ %count)<br>        count &#43;= 1<br>        time.sleep(1)</p>\n<p>def Consumer():<br>    while True:<br>        if q.qsize() &gt; 0 :<br>            print(‘buy %s’%q.get())<br>            time.sleep(2)</p>\n<p>p = threading.Thread(target=Producer)<br>c = threading.Thread(target=Consumer)</p>\n<p>p.start()<br>c.start()</pre><br>结果：</p>\n<p>生成了Switch 0<br>\n购买了 Switch 0<br>\n生成了Switch 1<br>\n购买了 Switch 1<br>\n生成了Switch 2<br>\n生成了Switch 3<br>\n购买了 Switch 2<br>\n生成了Switch 4<br>\n生成了Switch 5<br>\n生成了Switch 6<br>\n购买了 Switch 3<br>\n生成了Switch 7<br>\n购买了 Switch 4<br>\n生成了Switch 8<br>\n<br>\n</p>\n<p><br>\n</p>\n","site":{"data":{}},"excerpt":"","more":"<p>队列Queue包含三个类&nbsp;</p>\n<p>1：Queue(maxsize=0)&nbsp; 普通模式先进先出</p>\n<p>2：LifoQueue(maxsize=0)&nbsp; 后进先出</p>\n<p>3：PriorityQueue(maxsize=0)&nbsp; 优先级模式</p>\n<p><br>\n</p>\n<p>Queue.qsize()&nbsp;返回当前队列里存在的个数</p>\n<p>Queue.empty()&nbsp;返回队列是否为空</p>\n<p>Queue.full()&nbsp;返回队列是否存满</p>\n<p>Queue.put(item, block=True, timeout=None)<br>\n将item放入队列中。<br>\n如果可选的参数block为True且timeout为空对象（默认的情况，阻塞调用，无超时）。<br>\n如果timeout是个正整数，阻塞调用进程最多timeout秒，如果一直无空空间可用，抛出Full异常（带超时的阻塞调用）。<br>\n如果block为False，如果有空闲空间可用将数据放入队列，否则立即抛出Full异常</p>\n<p>Queue.put_nowait()无阻塞版本,等同于block=False，timeout=None</p>\n<p>Queue.get(block=True, timeout=None)&nbsp;取出数据，其他与put类&#20284;</p>\n<p><br>\n</p>\n<p>Queue()示例</p>\n<pre class=\"python\">import queue\n\n<p>q = queue.Queue()  #普通的（先进先出</p>\n<p>q.put(1)<br>q.put(2)<br>q.put(3)</p>\n<p>print(q.qsize()) #获取当前存在的个数</p>\n<p>print(q.get()) #取出 当超过的时候会报错<br>print(q.get())<br>print(q.get())</pre><br>结果：</p>\n<p>1 2 3&nbsp;</p>\n<p>LifoQueue()示例<br>\n</p>\n<pre class=\"python\">import queue\n\n<p>q = queue.LifoQueue()  #普通的（先进先出</p>\n<p>q.put(1)<br>q.put(2)<br>q.put(3)</p>\n<p>print(q.qsize()) #获取当前存在的个数</p>\n<p>print(q.get()) #取出 当超过的时候会报错<br>print(q.get())<br>print(q.get())</pre></p>\n<p>结果：</p>\n<p>3&nbsp; 2 1&nbsp;</p>\n<p>PriorityQueue()示例&nbsp;&nbsp;<br>\n</p>\n<p>按照一定的规律确定优先级，例如数字越小优先级越高，或者按字符排序，&#20540;得注意的是只能采用一种模式来确定，全为数字或是全为字符，两者不能混在一起，不然会报错。</p>\n<pre class=\"python\">import queue\n\n<p>q = queue.PriorityQueue()  #普通的（先进先出</p>\n<p>q.put((2,’b’))<br>q.put((1,’a’))<br>q.put((3,’c’))</p>\n<p>print(q.qsize()) #获取当前存在的个数</p>\n<p>print(q.get()) #取出 当超过的时候会报错<br>print(q.get())<br>print(q.get())</pre><br>结果：</p>\n<p>(1, 'a')<br>\n(2, 'b')<br>\n(3, 'c')<br>\n</p>\n<p><br>\n</p>\n<p>简单的生产者和消费者模型</p>\n<pre class=\"python\">import queue,threading,time\nq = queue.Queue()\n\n<p>def Producer():<br>    count = 0<br>    while True:<br>        q.put(‘Switch %s’ %count)<br>        print(‘Switch %s’ %count)<br>        count &#43;= 1<br>        time.sleep(1)</p>\n<p>def Consumer():<br>    while True:<br>        if q.qsize() &gt; 0 :<br>            print(‘buy %s’%q.get())<br>            time.sleep(2)</p>\n<p>p = threading.Thread(target=Producer)<br>c = threading.Thread(target=Consumer)</p>\n<p>p.start()<br>c.start()</pre><br>结果：</p>\n<p>生成了Switch 0<br>\n购买了 Switch 0<br>\n生成了Switch 1<br>\n购买了 Switch 1<br>\n生成了Switch 2<br>\n生成了Switch 3<br>\n购买了 Switch 2<br>\n生成了Switch 4<br>\n生成了Switch 5<br>\n生成了Switch 6<br>\n购买了 Switch 3<br>\n生成了Switch 7<br>\n购买了 Switch 4<br>\n生成了Switch 8<br>\n<br>\n</p>\n<p><br>\n</p>\n"},{"_content":"<p>以下是自己的学习记录，算是一个总结。</p>\n\n<p style=\"text-indent:0;\">接下来会依次对下面问题做一个解答：<br />\n    1. Python的dict和set为什么是无序的？<br />\n    2. 为什么不是所有的python对象都可以用作dict的键和set中的元素</p>\n\n<p style=\"text-indent:50px;\">要弄懂上面的问题，我们首先要了解Python内部是如何实现dict和set类型的。我们先来看看dict的内部结构，dict其实本质上是一个散列表（散列表即总有空白元素的数组，Python会保证至少有三分之一的数组元素是空的），dict的每个键都占用一个表元，而一个表元中又分为两个部分，分别是对键的引用和对值的引用。当我们存放一个对象的时候，首先会要计算这个元素的散列值，python中使用hash()方法来实现的，这也就回答了第二个问题，因为不是所有的python对象都可以使用hash来获取散列值，获取不到散列值也就不可能存放到dict中，所以只有可hash的对象才能够作为dict的键。值得注意的是内置的hash方法可以用于所有的内置类型对象的，所有用户自定义的对象默认都是可以作为键的，因为自定义对象的散列值是通过id()来获取的。例如：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class T(object):\n    pass\n\n\nt = T()\n\nprint(id(t))\nd = {t: 1}\nprint(d)\n\n###  2133693018240\n###  {&lt;__main__.T object at 0x000001F0CA03B080&gt;: 1}</code></pre>\n\n<p style=\"text-indent:50px;\">现在假设我们已经获取到了元素的散列值，接下来就该计算应当存放位置了，将散列值对数组长度进行取余，得到的结果就是存放位置的索引了。但是不同的key可能会得到相同的散列值，也就是哈希冲突的问题，python内部是使用开放寻址的方法来解决的，开放寻址法就不在此详细说了。关于为什么dict是无序的，这个是因为python内部会保证散列表至少有三分之一的位置为空，当我们增加元素的时候，python有可能会对散列表进行扩容，具体操作就是重新开辟一块更大的空间，将原有的元素添加到新表里面，这个过程中可能又会发生新的散列冲突，导致新的散列表中的键的次序发生变化。当然呢如果想要保存顺序也可以使用OrderedDict来处理</p>\n\n<p style=\"text-indent:0;\"> </p>\n\n<p style=\"text-indent:0;\">dict操作的时间复杂度：</p>\n\n<table><thead><tr><th>操作</th>\n\t\t\t<th>操作说明</th>\n\t\t\t<th>时间复杂度</th>\n\t\t</tr></thead><tbody><tr><td>copy</td>\n\t\t\t<td>复制</td>\n\t\t\t<td>O(n)</td>\n\t\t</tr><tr><td>get(value)</td>\n\t\t\t<td>获取</td>\n\t\t\t<td>O(1)</td>\n\t\t</tr><tr><td>set(value)</td>\n\t\t\t<td>修改</td>\n\t\t\t<td>O(1)</td>\n\t\t</tr><tr><td>delete(value)</td>\n\t\t\t<td>删除</td>\n\t\t\t<td>O(1)</td>\n\t\t</tr><tr><td>search(in)</td>\n\t\t\t<td>字典搜索</td>\n\t\t\t<td>O(1)</td>\n\t\t</tr><tr><td>iterration</td>\n\t\t\t<td>字典迭代</td>\n\t\t\t<td>O(n)</td>\n\t\t</tr></tbody></table><p style=\"text-indent:50px;\">set集合和dict一样也是基于散列表的，只是他的表元只包含值的引用而没有对键的引用，其他的和dict基本上是一致的，所以在此就不再多说了。</p>","source":"_posts/blogs-Python字典的实现原理.md","raw":"<p>以下是自己的学习记录，算是一个总结。</p>\n\n<p style=\"text-indent:0;\">接下来会依次对下面问题做一个解答：<br />\n    1. Python的dict和set为什么是无序的？<br />\n    2. 为什么不是所有的python对象都可以用作dict的键和set中的元素</p>\n\n<p style=\"text-indent:50px;\">要弄懂上面的问题，我们首先要了解Python内部是如何实现dict和set类型的。我们先来看看dict的内部结构，dict其实本质上是一个散列表（散列表即总有空白元素的数组，Python会保证至少有三分之一的数组元素是空的），dict的每个键都占用一个表元，而一个表元中又分为两个部分，分别是对键的引用和对值的引用。当我们存放一个对象的时候，首先会要计算这个元素的散列值，python中使用hash()方法来实现的，这也就回答了第二个问题，因为不是所有的python对象都可以使用hash来获取散列值，获取不到散列值也就不可能存放到dict中，所以只有可hash的对象才能够作为dict的键。值得注意的是内置的hash方法可以用于所有的内置类型对象的，所有用户自定义的对象默认都是可以作为键的，因为自定义对象的散列值是通过id()来获取的。例如：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class T(object):\n    pass\n\n\nt = T()\n\nprint(id(t))\nd = {t: 1}\nprint(d)\n\n###  2133693018240\n###  {&lt;__main__.T object at 0x000001F0CA03B080&gt;: 1}</code></pre>\n\n<p style=\"text-indent:50px;\">现在假设我们已经获取到了元素的散列值，接下来就该计算应当存放位置了，将散列值对数组长度进行取余，得到的结果就是存放位置的索引了。但是不同的key可能会得到相同的散列值，也就是哈希冲突的问题，python内部是使用开放寻址的方法来解决的，开放寻址法就不在此详细说了。关于为什么dict是无序的，这个是因为python内部会保证散列表至少有三分之一的位置为空，当我们增加元素的时候，python有可能会对散列表进行扩容，具体操作就是重新开辟一块更大的空间，将原有的元素添加到新表里面，这个过程中可能又会发生新的散列冲突，导致新的散列表中的键的次序发生变化。当然呢如果想要保存顺序也可以使用OrderedDict来处理</p>\n\n<p style=\"text-indent:0;\"> </p>\n\n<p style=\"text-indent:0;\">dict操作的时间复杂度：</p>\n\n<table><thead><tr><th>操作</th>\n\t\t\t<th>操作说明</th>\n\t\t\t<th>时间复杂度</th>\n\t\t</tr></thead><tbody><tr><td>copy</td>\n\t\t\t<td>复制</td>\n\t\t\t<td>O(n)</td>\n\t\t</tr><tr><td>get(value)</td>\n\t\t\t<td>获取</td>\n\t\t\t<td>O(1)</td>\n\t\t</tr><tr><td>set(value)</td>\n\t\t\t<td>修改</td>\n\t\t\t<td>O(1)</td>\n\t\t</tr><tr><td>delete(value)</td>\n\t\t\t<td>删除</td>\n\t\t\t<td>O(1)</td>\n\t\t</tr><tr><td>search(in)</td>\n\t\t\t<td>字典搜索</td>\n\t\t\t<td>O(1)</td>\n\t\t</tr><tr><td>iterration</td>\n\t\t\t<td>字典迭代</td>\n\t\t\t<td>O(n)</td>\n\t\t</tr></tbody></table><p style=\"text-indent:50px;\">set集合和dict一样也是基于散列表的，只是他的表元只包含值的引用而没有对键的引用，其他的和dict基本上是一致的，所以在此就不再多说了。</p>","slug":"blogs-Python字典的实现原理","published":1,"date":"2022-03-16T17:01:23.172Z","updated":"2022-03-16T17:06:12.959Z","_id":"cl0v6kexl001yyms4ez4k0gql","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>以下是自己的学习记录，算是一个总结。</p>\n\n<p style=\"text-indent:0;\">接下来会依次对下面问题做一个解答：<br />\n    1. Python的dict和set为什么是无序的？<br />\n    2. 为什么不是所有的python对象都可以用作dict的键和set中的元素</p>\n\n<p style=\"text-indent:50px;\">要弄懂上面的问题，我们首先要了解Python内部是如何实现dict和set类型的。我们先来看看dict的内部结构，dict其实本质上是一个散列表（散列表即总有空白元素的数组，Python会保证至少有三分之一的数组元素是空的），dict的每个键都占用一个表元，而一个表元中又分为两个部分，分别是对键的引用和对值的引用。当我们存放一个对象的时候，首先会要计算这个元素的散列值，python中使用hash()方法来实现的，这也就回答了第二个问题，因为不是所有的python对象都可以使用hash来获取散列值，获取不到散列值也就不可能存放到dict中，所以只有可hash的对象才能够作为dict的键。值得注意的是内置的hash方法可以用于所有的内置类型对象的，所有用户自定义的对象默认都是可以作为键的，因为自定义对象的散列值是通过id()来获取的。例如：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class T(object):\n    pass\n\n\nt = T()\n\nprint(id(t))\nd = &#123;t: 1&#125;\nprint(d)\n\n###  2133693018240\n###  &#123;&lt;__main__.T object at 0x000001F0CA03B080&gt;: 1&#125;</code></pre>\n\n<p style=\"text-indent:50px;\">现在假设我们已经获取到了元素的散列值，接下来就该计算应当存放位置了，将散列值对数组长度进行取余，得到的结果就是存放位置的索引了。但是不同的key可能会得到相同的散列值，也就是哈希冲突的问题，python内部是使用开放寻址的方法来解决的，开放寻址法就不在此详细说了。关于为什么dict是无序的，这个是因为python内部会保证散列表至少有三分之一的位置为空，当我们增加元素的时候，python有可能会对散列表进行扩容，具体操作就是重新开辟一块更大的空间，将原有的元素添加到新表里面，这个过程中可能又会发生新的散列冲突，导致新的散列表中的键的次序发生变化。当然呢如果想要保存顺序也可以使用OrderedDict来处理</p>\n\n<p style=\"text-indent:0;\"> </p>\n\n<p style=\"text-indent:0;\">dict操作的时间复杂度：</p>\n\n<table><thead><tr><th>操作</th>\n            <th>操作说明</th>\n            <th>时间复杂度</th>\n        </tr></thead><tbody><tr><td>copy</td>\n            <td>复制</td>\n            <td>O(n)</td>\n        </tr><tr><td>get(value)</td>\n            <td>获取</td>\n            <td>O(1)</td>\n        </tr><tr><td>set(value)</td>\n            <td>修改</td>\n            <td>O(1)</td>\n        </tr><tr><td>delete(value)</td>\n            <td>删除</td>\n            <td>O(1)</td>\n        </tr><tr><td>search(in)</td>\n            <td>字典搜索</td>\n            <td>O(1)</td>\n        </tr><tr><td>iterration</td>\n            <td>字典迭代</td>\n            <td>O(n)</td>\n        </tr></tbody></table><p style=\"text-indent:50px;\">set集合和dict一样也是基于散列表的，只是他的表元只包含值的引用而没有对键的引用，其他的和dict基本上是一致的，所以在此就不再多说了。</p>","site":{"data":{}},"excerpt":"","more":"<p>以下是自己的学习记录，算是一个总结。</p>\n\n<p style=\"text-indent:0;\">接下来会依次对下面问题做一个解答：<br />\n    1. Python的dict和set为什么是无序的？<br />\n    2. 为什么不是所有的python对象都可以用作dict的键和set中的元素</p>\n\n<p style=\"text-indent:50px;\">要弄懂上面的问题，我们首先要了解Python内部是如何实现dict和set类型的。我们先来看看dict的内部结构，dict其实本质上是一个散列表（散列表即总有空白元素的数组，Python会保证至少有三分之一的数组元素是空的），dict的每个键都占用一个表元，而一个表元中又分为两个部分，分别是对键的引用和对值的引用。当我们存放一个对象的时候，首先会要计算这个元素的散列值，python中使用hash()方法来实现的，这也就回答了第二个问题，因为不是所有的python对象都可以使用hash来获取散列值，获取不到散列值也就不可能存放到dict中，所以只有可hash的对象才能够作为dict的键。值得注意的是内置的hash方法可以用于所有的内置类型对象的，所有用户自定义的对象默认都是可以作为键的，因为自定义对象的散列值是通过id()来获取的。例如：</p>\n\n<pre class=\"has\">\n<code class=\"language-python\">class T(object):\n    pass\n\n\nt = T()\n\nprint(id(t))\nd = &#123;t: 1&#125;\nprint(d)\n\n###  2133693018240\n###  &#123;&lt;__main__.T object at 0x000001F0CA03B080&gt;: 1&#125;</code></pre>\n\n<p style=\"text-indent:50px;\">现在假设我们已经获取到了元素的散列值，接下来就该计算应当存放位置了，将散列值对数组长度进行取余，得到的结果就是存放位置的索引了。但是不同的key可能会得到相同的散列值，也就是哈希冲突的问题，python内部是使用开放寻址的方法来解决的，开放寻址法就不在此详细说了。关于为什么dict是无序的，这个是因为python内部会保证散列表至少有三分之一的位置为空，当我们增加元素的时候，python有可能会对散列表进行扩容，具体操作就是重新开辟一块更大的空间，将原有的元素添加到新表里面，这个过程中可能又会发生新的散列冲突，导致新的散列表中的键的次序发生变化。当然呢如果想要保存顺序也可以使用OrderedDict来处理</p>\n\n<p style=\"text-indent:0;\"> </p>\n\n<p style=\"text-indent:0;\">dict操作的时间复杂度：</p>\n\n<table><thead><tr><th>操作</th>\n            <th>操作说明</th>\n            <th>时间复杂度</th>\n        </tr></thead><tbody><tr><td>copy</td>\n            <td>复制</td>\n            <td>O(n)</td>\n        </tr><tr><td>get(value)</td>\n            <td>获取</td>\n            <td>O(1)</td>\n        </tr><tr><td>set(value)</td>\n            <td>修改</td>\n            <td>O(1)</td>\n        </tr><tr><td>delete(value)</td>\n            <td>删除</td>\n            <td>O(1)</td>\n        </tr><tr><td>search(in)</td>\n            <td>字典搜索</td>\n            <td>O(1)</td>\n        </tr><tr><td>iterration</td>\n            <td>字典迭代</td>\n            <td>O(n)</td>\n        </tr></tbody></table><p style=\"text-indent:50px;\">set集合和dict一样也是基于散列表的，只是他的表元只包含值的引用而没有对键的引用，其他的和dict基本上是一致的，所以在此就不再多说了。</p>"},{"_content":"\n<h4>使用python操作redis</h4>\n<p>数据库的连接：</p>\n<p></p>\n<pre class=\"python\">import redis\n#连接数据库\ndb = redis.Redis('localhost',6379)\n#连接池\n# pool = redis.ConnectionPool(host='localhost',port=6379)\n# db = redis.Redis(connection_pool=pool)</pre>\n<p><span style=\"font-size:14px\"><strong>String操作：</strong></span></p>\n<p>使用key-value的模式来存储，相当于每个name对应一个value</p>\n<p><strong><em>set(name, value, ex=None, px=None, nx=False, xx=False)<br>\n</em></strong></p>\n<p><strong><em>ex，过期时间（秒）<br>\npx，过期时间（毫秒）<br>\nnx，如果设置为True，则只有name不存在时，当前set操作才执行<br>\nxx，如果设置为True，则只有name存在时，岗前set操作才执行</em></strong><br>\n</p>\n<p></p>\n<pre class=\"python\">db.set('name','fml')\nprint(db.get('name'))</pre>\n结果：fml\n<p><strong><em>setex(name,value,time)</em></strong></p>\n<p><strong><em>time:过期时间（秒）</em></strong></p>\n<p></p>\n<pre class=\"python\">db.setex('name','1',2)\ntime.sleep(2)\nprint(db.get('name'))</pre>\n结果：None\n<p>同样的还有</p>\n<p><strong><em>setnx(name,value)</em></strong>，相当于set()中的nx参数为True</p>\n<p><strong><em>psetex(name.time,value</em></strong>),time为毫秒数</p>\n<p><em>mset(*args,**kwargs)&nbsp; </em>批量操作，可传入字典</p>\n<p>方式一</p>\n<p></p>\n<pre class=\"python\">db.mset(t1 = 1,t2 = 2)\nprint(db.get('t1'))\nprint(db.get('t2'))</pre>\n结果 1，2<br>\n方式二\n<p></p>\n<pre class=\"python\">d = {'name':'fml','age':22}\ndb.mset(d)\nprint(db.get('name'))\nprint(db.get('age'))</pre>\n结果：&nbsp;fml ， 22<br>\n<br>\n<p><span style=\"font-size:12px\"><em>get(name):</em></span><span style=\"font-size:10px\">返回name的&#20540;</span></p>\n<p><span style=\"font-size:10px\"><strong>mget(keys, *args):</strong>批量操作，返回多个&#20540;（列表的形式），可传入列表<br>\n</span></p>\n<p><span style=\"font-size:10px\"></span></p>\n<pre class=\"python\">print(db.mget('name','age'))\nprint(db.mget(['t1','t2']))</pre>\n<img src=\"https://img-blog.csdn.net/20180312172020750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<em><br>\n</em>\n<p><span style=\"font-size:10px\"><em>getset(name,value):</em>设置新的&#20540;并返回之前的&#20540;</span></p>\n<p><span style=\"font-size:10px\"></span></p>\n<pre class=\"python\">print(db.getset('name','test'))\nprint(db.get('name'))</pre>\n<img src=\"https://img-blog.csdn.net/20180312172409761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><span style=\"font-size:10px\"><em>getrange(key,start,end):</em>获取子序列（根据字节获取，非字符）</span></p>\n<p><span style=\"font-size:10px\"><span style=\"color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px\">start：起始位，end结束位,&#20540;得注意的是这个是按照字节来计算而不是字符个数&nbsp;在utf-8的编码中一个中文汉字占三个字节，一个字符只占一位</span></span></p>\n<p><span style=\"font-size:10px\"><span style=\"color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px\"></span></span></p>\n<pre class=\"python\">db.set('name1','fml')\nprint(db.getrange('name1', 0, 1).decode())\ndb.set('name2','名字')\nprint(db.getrange('name2', 0, 2).decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312182537723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><em>setrange(name, offset, value):&nbsp; &nbsp;</em>从指定字符串索引开始向后替换（新&#20540;太长时，则向后添加）<br>\n</p>\n<p>offset:字符串索引号</p>\n<p></p>\n<pre class=\"python\">db.set('name','test set range')\ndb.setrange('name',1,'ls')  #从第二个字符开始替换\nprint(db.get('name').decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312183816787?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\">\n<p><em>setbit(name, offset, value)：</em>和上面的一个功能类&#20284;，只不过是用bite方式来更改<br>\n</p>\n<p><strong><em>getbit(name, offset)</em></strong>：获取name的二进制表示中的某一位&#20540;<br>\n</p>\n<p><em>bitcount(key, start=None, end=None)：</em>统计name用二进制表示中的为1的个数</p>\n<p>start，位起始位置end，位结束位置</p>\n<p></p>\n<pre class=\"python\">db.set('name','f')\nprint(db.bitcount('name'))\n#f对应的ASCII码的&#20540;为102,102转为二进制为 0110 0110 所以返回&#20540;为4</pre>\n<em>strlen(name):</em>返回name对于&#20540;的<strong>字节长度</strong>，汉字三字节\n<p></p>\n<pre class=\"python\">db.set('name1','发生')\ndb.set('name2','fml')\nprint(db.strlen('name1'))\nprint(db.strlen('name2'))</pre>\n<img src=\"https://img-blog.csdn.net/20180312214428147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><strong><em>incr(self, name, amount=1)：</em></strong> name的对应&#20540;增加amount<br>\n</p>\n<p><strong>自增只适用于整数</strong>，当name不存在的时候会新建一个name&#20540;为amount<br>\n</p>\n<p></p>\n<pre class=\"python\">db.set('num1',2)\ndb.incr('num1', amount=2)\ndb.incr('num2', amount=2)\nprint(db.get('num1').decode())\nprint(db.get('num2').decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312215147018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><strong>incrbyfloat(self, name, amount=1.0)：</strong>同上只不过是浮点型<br>\n</p>\n<p><em>decr(self, name, amount=1)：</em>同上功能为自减<br>\n</p>\n<p><strong><em>append(key, value) ：</em></strong>在name对应&#20540;后面追加value的内容，如果没有name就会新建一个name=value<br>\n</p>\n<p></p>\n<pre class=\"python\">db.set('name','fml')\ndb.append('name','test')\nprint(db.get('name').decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312220700495?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><br>\n</p>\n<p><span style=\"font-weight:bold; font-size:14px\">Hash操作</span><br>\n<span style=\"font-size:10px\">使用字典的方式来存储，name为字典名</span></p>\n<p><strong><em>hset(name, key, value):</em></strong><br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.hset('info','name','fml')\ndb.hset('info','age',22)\nprint(db.hget('info','name').decode())\nprint(db.hget('info','age').decode())</pre><strong style=\"font-style:italic\">hmset(name, mapping)：</strong>批量操作 ，mapping为字典</p>\n<p><pre name=\"code\" class=\"python\">db.hmset('info1',{'name1':'fml','age1':23})\nprint(db.hget('info1','name1').decode())\nprint(db.hget('info1','age1').decode())</pre></p>\n<p><img src=\"https://img-blog.csdn.net/20180313150927616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p><strong style=\"font-style:italic\">hget(name,key)：</strong>同get操作</p>\n<p><strong style=\"font-style:italic\">hmget(name, keys, *args)：</strong>同mget,可传入列表或者多个&#20540;<br>\n</p>\n<p><strong style=\"font-style:italic\">hgetall(name)：</strong>获取name的所有key-和value&#20540;<br>\n</p>\n<p><strong><em>hlen(name)：</em></strong>获取name中key的个数<br>\n</p>\n<p><strong><em>hkeys(name)：</em></strong>获取name中所有的key<br>\n</p>\n<p><strong><em>hvals(name)：</em></strong>获取name中所有的value&#20540;<br>\n</p>\n<p><strong><em>hexists(name, key)：</em></strong>判断name中是否存在传入的key<br>\n</p>\n<p><strong><em>hdel(name,*keys)：</em></strong>删除name中的key，若不存在返回0，删除成功后返回1<br>\n</p>\n<p><strong><em>hincrby(name, key, amount=1)：</em></strong>自增，同string操作一样<br>\n</p>\n<p><strong><em>hincrbyfloat(name, key, amount=1.0)</em></strong>&nbsp;自增浮点型<br>\n</p>\n<p><br>\n</p>\n<p>hscan(name, cursor=0, match=None, count=None)&nbsp;过滤获取多个&#20540;<br>\n</p>\n<p>cursor:起始位置，match：过滤方法 ，count：获取的个数</p>\n<p>过滤方法的例子：1：获取以n开头的key ：n*</p>\n<p><span style=\"white-space:pre\"></span>&nbsp; &nbsp; &nbsp;2：获取包含a的key：*a*</p>\n<p><span style=\"white-space:pre\"></span>&nbsp; &nbsp; &nbsp;3：获取以e结尾的key：*e</p>\n<p><pre name=\"code\" class=\"python\">db.hset('info','name','fml')\ndb.hset('info','age',22)\nprint(db.hscan('info',cursor=0,match= 'n*'))\nprint(db.hscan('info',cursor=0,match= '*e'))\nprint(db.hscan('info',cursor=0,match= '*g*'))</pre><img src=\"https://img-blog.csdn.net/20180313154353952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p><br>\n</p>\n<p><span style=\"font-size:14px; font-weight:700\">List操作</span><br>\n</p>\n<p><span style=\"font-size:14px; font-weight:700\"><br>\n</span></p>\n<p><strong style=\"\"><em style=\"\"><span style=\"font-size:10px\">lpush(name,values):&nbsp;向name添加元素，从左边开始添加</span></em></strong></p>\n<p><pre name=\"code\" class=\"python\" style=\"\"><span style=\"font-size:10px;\">db.lpush('list','1','2','3')\nprint(db.lrange('list',0,-1))</span></pre><span style=\"font-size:14px\"><img src=\"https://img-blog.csdn.net/20180313165641539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></span><br>\n<em><strong style=\"\"><span style=\"font-size:10px\">lpush(name,values):&nbsp;向name添加元素，从右边开始添加</span></strong></em><br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list3','1','2','3')\nprint(db.lrange('list3',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313165843605?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><br>\n<strong><em>lpushx(name,value)：</em></strong>只有当name存在的时候才在左边添加，相同的还有rpushx(name.value)<br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list3','1','2','3')\ndb.lpushx('list3',4)\nprint(db.lrange('list3',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313170111945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><strong><em>llen(name):&nbsp;</em></strong>返回name的存储的长度</p>\n<p><strong><em>linsert(name, where, refvalue, value))&nbsp;</em></strong> 在name的refvalue前面或后面插入value,如果存在多个refvalue的时候只会在从左往右数第一个起作用</p>\n<p>where：BEFORE/AFTER</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list5','1','2','3')\ndb.linsert('list5','BEFORE','2','5')\ndb.linsert('list5','AFTER','2','6')\nprint(db.lrange('list5',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313170630387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<br>\n<strong><em>lset(name, index, value)：</em></strong>修改index索引的&#20540;<br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list6','1','2','3')\ndb.lset('list6',1,4)\nprint(db.lrange('list6',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313171210000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<strong><em>lrem(name, value, num)：</em></strong>删除name中的value，num为需要删除的个数<br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list7',1,2,3,4,1,2,4,5,7)\ndb.lrem('list7',1,1)\ndb.lrem('list7',2,2)\nprint(db.lrange('list7',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313172150477?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><strong><em>lpop(name)：</em></strong>删除左边第一个&#20540;并返回，同样的还有<strong><em>rpop(name)：</em></strong>从右边弹出<br>\n</p>\n<p><strong><em>lindex(name, index)：</em></strong>获取index索引的&#20540;<br>\n</p>\n<p><strong><em>lrange(name, start, end)：</em></strong>返回切片获得的&#20540;<br>\n</p>\n<p><strong><em>ltrim(name, start, end)：</em></strong>删除除start-end之外的所有&#20540;<br>\n</p>\n<p><strong><em>rpoplpush(src, dst) ：</em></strong>删除src的最右的一个&#20540;，并把它添加到dst的最左边<br>\n</p>\n<p><strong><em>blpop(keys, timeout)：</em></strong>将多个列表排列，按照从左到右去pop对应列表的元素&nbsp; 同<strong><em>brpop(keys, timeout)</em></strong><br>\n</p>\n<p><strong style=\"font-style:italic\">brpoplpush(src, dst, timeout=0)：</strong>从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧<br>\n</p>\n<p><br>\n</p>\n<p><span style=\"font-size:14px; font-weight:700\">set集合操作</span><br>\n</p>\n<p><br>\n</p>\n","source":"_posts/blogs-Redis基础.md","raw":"\n<h4>使用python操作redis</h4>\n<p>数据库的连接：</p>\n<p></p>\n<pre class=\"python\">import redis\n#连接数据库\ndb = redis.Redis('localhost',6379)\n#连接池\n# pool = redis.ConnectionPool(host='localhost',port=6379)\n# db = redis.Redis(connection_pool=pool)</pre>\n<p><span style=\"font-size:14px\"><strong>String操作：</strong></span></p>\n<p>使用key-value的模式来存储，相当于每个name对应一个value</p>\n<p><strong><em>set(name, value, ex=None, px=None, nx=False, xx=False)<br>\n</em></strong></p>\n<p><strong><em>ex，过期时间（秒）<br>\npx，过期时间（毫秒）<br>\nnx，如果设置为True，则只有name不存在时，当前set操作才执行<br>\nxx，如果设置为True，则只有name存在时，岗前set操作才执行</em></strong><br>\n</p>\n<p></p>\n<pre class=\"python\">db.set('name','fml')\nprint(db.get('name'))</pre>\n结果：fml\n<p><strong><em>setex(name,value,time)</em></strong></p>\n<p><strong><em>time:过期时间（秒）</em></strong></p>\n<p></p>\n<pre class=\"python\">db.setex('name','1',2)\ntime.sleep(2)\nprint(db.get('name'))</pre>\n结果：None\n<p>同样的还有</p>\n<p><strong><em>setnx(name,value)</em></strong>，相当于set()中的nx参数为True</p>\n<p><strong><em>psetex(name.time,value</em></strong>),time为毫秒数</p>\n<p><em>mset(*args,**kwargs)&nbsp; </em>批量操作，可传入字典</p>\n<p>方式一</p>\n<p></p>\n<pre class=\"python\">db.mset(t1 = 1,t2 = 2)\nprint(db.get('t1'))\nprint(db.get('t2'))</pre>\n结果 1，2<br>\n方式二\n<p></p>\n<pre class=\"python\">d = {'name':'fml','age':22}\ndb.mset(d)\nprint(db.get('name'))\nprint(db.get('age'))</pre>\n结果：&nbsp;fml ， 22<br>\n<br>\n<p><span style=\"font-size:12px\"><em>get(name):</em></span><span style=\"font-size:10px\">返回name的&#20540;</span></p>\n<p><span style=\"font-size:10px\"><strong>mget(keys, *args):</strong>批量操作，返回多个&#20540;（列表的形式），可传入列表<br>\n</span></p>\n<p><span style=\"font-size:10px\"></span></p>\n<pre class=\"python\">print(db.mget('name','age'))\nprint(db.mget(['t1','t2']))</pre>\n<img src=\"https://img-blog.csdn.net/20180312172020750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<em><br>\n</em>\n<p><span style=\"font-size:10px\"><em>getset(name,value):</em>设置新的&#20540;并返回之前的&#20540;</span></p>\n<p><span style=\"font-size:10px\"></span></p>\n<pre class=\"python\">print(db.getset('name','test'))\nprint(db.get('name'))</pre>\n<img src=\"https://img-blog.csdn.net/20180312172409761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><span style=\"font-size:10px\"><em>getrange(key,start,end):</em>获取子序列（根据字节获取，非字符）</span></p>\n<p><span style=\"font-size:10px\"><span style=\"color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px\">start：起始位，end结束位,&#20540;得注意的是这个是按照字节来计算而不是字符个数&nbsp;在utf-8的编码中一个中文汉字占三个字节，一个字符只占一位</span></span></p>\n<p><span style=\"font-size:10px\"><span style=\"color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px\"></span></span></p>\n<pre class=\"python\">db.set('name1','fml')\nprint(db.getrange('name1', 0, 1).decode())\ndb.set('name2','名字')\nprint(db.getrange('name2', 0, 2).decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312182537723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><em>setrange(name, offset, value):&nbsp; &nbsp;</em>从指定字符串索引开始向后替换（新&#20540;太长时，则向后添加）<br>\n</p>\n<p>offset:字符串索引号</p>\n<p></p>\n<pre class=\"python\">db.set('name','test set range')\ndb.setrange('name',1,'ls')  #从第二个字符开始替换\nprint(db.get('name').decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312183816787?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\">\n<p><em>setbit(name, offset, value)：</em>和上面的一个功能类&#20284;，只不过是用bite方式来更改<br>\n</p>\n<p><strong><em>getbit(name, offset)</em></strong>：获取name的二进制表示中的某一位&#20540;<br>\n</p>\n<p><em>bitcount(key, start=None, end=None)：</em>统计name用二进制表示中的为1的个数</p>\n<p>start，位起始位置end，位结束位置</p>\n<p></p>\n<pre class=\"python\">db.set('name','f')\nprint(db.bitcount('name'))\n#f对应的ASCII码的&#20540;为102,102转为二进制为 0110 0110 所以返回&#20540;为4</pre>\n<em>strlen(name):</em>返回name对于&#20540;的<strong>字节长度</strong>，汉字三字节\n<p></p>\n<pre class=\"python\">db.set('name1','发生')\ndb.set('name2','fml')\nprint(db.strlen('name1'))\nprint(db.strlen('name2'))</pre>\n<img src=\"https://img-blog.csdn.net/20180312214428147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><strong><em>incr(self, name, amount=1)：</em></strong> name的对应&#20540;增加amount<br>\n</p>\n<p><strong>自增只适用于整数</strong>，当name不存在的时候会新建一个name&#20540;为amount<br>\n</p>\n<p></p>\n<pre class=\"python\">db.set('num1',2)\ndb.incr('num1', amount=2)\ndb.incr('num2', amount=2)\nprint(db.get('num1').decode())\nprint(db.get('num2').decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312215147018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><strong>incrbyfloat(self, name, amount=1.0)：</strong>同上只不过是浮点型<br>\n</p>\n<p><em>decr(self, name, amount=1)：</em>同上功能为自减<br>\n</p>\n<p><strong><em>append(key, value) ：</em></strong>在name对应&#20540;后面追加value的内容，如果没有name就会新建一个name=value<br>\n</p>\n<p></p>\n<pre class=\"python\">db.set('name','fml')\ndb.append('name','test')\nprint(db.get('name').decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312220700495?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><br>\n</p>\n<p><span style=\"font-weight:bold; font-size:14px\">Hash操作</span><br>\n<span style=\"font-size:10px\">使用字典的方式来存储，name为字典名</span></p>\n<p><strong><em>hset(name, key, value):</em></strong><br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.hset('info','name','fml')\ndb.hset('info','age',22)\nprint(db.hget('info','name').decode())\nprint(db.hget('info','age').decode())</pre><strong style=\"font-style:italic\">hmset(name, mapping)：</strong>批量操作 ，mapping为字典</p>\n<p><pre name=\"code\" class=\"python\">db.hmset('info1',{'name1':'fml','age1':23})\nprint(db.hget('info1','name1').decode())\nprint(db.hget('info1','age1').decode())</pre></p>\n<p><img src=\"https://img-blog.csdn.net/20180313150927616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p><strong style=\"font-style:italic\">hget(name,key)：</strong>同get操作</p>\n<p><strong style=\"font-style:italic\">hmget(name, keys, *args)：</strong>同mget,可传入列表或者多个&#20540;<br>\n</p>\n<p><strong style=\"font-style:italic\">hgetall(name)：</strong>获取name的所有key-和value&#20540;<br>\n</p>\n<p><strong><em>hlen(name)：</em></strong>获取name中key的个数<br>\n</p>\n<p><strong><em>hkeys(name)：</em></strong>获取name中所有的key<br>\n</p>\n<p><strong><em>hvals(name)：</em></strong>获取name中所有的value&#20540;<br>\n</p>\n<p><strong><em>hexists(name, key)：</em></strong>判断name中是否存在传入的key<br>\n</p>\n<p><strong><em>hdel(name,*keys)：</em></strong>删除name中的key，若不存在返回0，删除成功后返回1<br>\n</p>\n<p><strong><em>hincrby(name, key, amount=1)：</em></strong>自增，同string操作一样<br>\n</p>\n<p><strong><em>hincrbyfloat(name, key, amount=1.0)</em></strong>&nbsp;自增浮点型<br>\n</p>\n<p><br>\n</p>\n<p>hscan(name, cursor=0, match=None, count=None)&nbsp;过滤获取多个&#20540;<br>\n</p>\n<p>cursor:起始位置，match：过滤方法 ，count：获取的个数</p>\n<p>过滤方法的例子：1：获取以n开头的key ：n*</p>\n<p><span style=\"white-space:pre\"></span>&nbsp; &nbsp; &nbsp;2：获取包含a的key：*a*</p>\n<p><span style=\"white-space:pre\"></span>&nbsp; &nbsp; &nbsp;3：获取以e结尾的key：*e</p>\n<p><pre name=\"code\" class=\"python\">db.hset('info','name','fml')\ndb.hset('info','age',22)\nprint(db.hscan('info',cursor=0,match= 'n*'))\nprint(db.hscan('info',cursor=0,match= '*e'))\nprint(db.hscan('info',cursor=0,match= '*g*'))</pre><img src=\"https://img-blog.csdn.net/20180313154353952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p><br>\n</p>\n<p><span style=\"font-size:14px; font-weight:700\">List操作</span><br>\n</p>\n<p><span style=\"font-size:14px; font-weight:700\"><br>\n</span></p>\n<p><strong style=\"\"><em style=\"\"><span style=\"font-size:10px\">lpush(name,values):&nbsp;向name添加元素，从左边开始添加</span></em></strong></p>\n<p><pre name=\"code\" class=\"python\" style=\"\"><span style=\"font-size:10px;\">db.lpush('list','1','2','3')\nprint(db.lrange('list',0,-1))</span></pre><span style=\"font-size:14px\"><img src=\"https://img-blog.csdn.net/20180313165641539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></span><br>\n<em><strong style=\"\"><span style=\"font-size:10px\">lpush(name,values):&nbsp;向name添加元素，从右边开始添加</span></strong></em><br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list3','1','2','3')\nprint(db.lrange('list3',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313165843605?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><br>\n<strong><em>lpushx(name,value)：</em></strong>只有当name存在的时候才在左边添加，相同的还有rpushx(name.value)<br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list3','1','2','3')\ndb.lpushx('list3',4)\nprint(db.lrange('list3',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313170111945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><strong><em>llen(name):&nbsp;</em></strong>返回name的存储的长度</p>\n<p><strong><em>linsert(name, where, refvalue, value))&nbsp;</em></strong> 在name的refvalue前面或后面插入value,如果存在多个refvalue的时候只会在从左往右数第一个起作用</p>\n<p>where：BEFORE/AFTER</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list5','1','2','3')\ndb.linsert('list5','BEFORE','2','5')\ndb.linsert('list5','AFTER','2','6')\nprint(db.lrange('list5',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313170630387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<br>\n<strong><em>lset(name, index, value)：</em></strong>修改index索引的&#20540;<br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list6','1','2','3')\ndb.lset('list6',1,4)\nprint(db.lrange('list6',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313171210000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<strong><em>lrem(name, value, num)：</em></strong>删除name中的value，num为需要删除的个数<br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list7',1,2,3,4,1,2,4,5,7)\ndb.lrem('list7',1,1)\ndb.lrem('list7',2,2)\nprint(db.lrange('list7',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313172150477?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><strong><em>lpop(name)：</em></strong>删除左边第一个&#20540;并返回，同样的还有<strong><em>rpop(name)：</em></strong>从右边弹出<br>\n</p>\n<p><strong><em>lindex(name, index)：</em></strong>获取index索引的&#20540;<br>\n</p>\n<p><strong><em>lrange(name, start, end)：</em></strong>返回切片获得的&#20540;<br>\n</p>\n<p><strong><em>ltrim(name, start, end)：</em></strong>删除除start-end之外的所有&#20540;<br>\n</p>\n<p><strong><em>rpoplpush(src, dst) ：</em></strong>删除src的最右的一个&#20540;，并把它添加到dst的最左边<br>\n</p>\n<p><strong><em>blpop(keys, timeout)：</em></strong>将多个列表排列，按照从左到右去pop对应列表的元素&nbsp; 同<strong><em>brpop(keys, timeout)</em></strong><br>\n</p>\n<p><strong style=\"font-style:italic\">brpoplpush(src, dst, timeout=0)：</strong>从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧<br>\n</p>\n<p><br>\n</p>\n<p><span style=\"font-size:14px; font-weight:700\">set集合操作</span><br>\n</p>\n<p><br>\n</p>\n","slug":"blogs-Redis基础","published":1,"date":"2022-03-16T17:09:25.758Z","updated":"2022-03-16T17:09:25.758Z","_id":"cl0v6kexl001zyms48b4obc6c","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<h4>使用python操作redis</h4>\n<p>数据库的连接：</p>\n<p></p>\n<pre class=\"python\">import redis\n#连接数据库\ndb = redis.Redis('localhost',6379)\n#连接池\n# pool = redis.ConnectionPool(host='localhost',port=6379)\n# db = redis.Redis(connection_pool=pool)</pre>\n<p><span style=\"font-size:14px\"><strong>String操作：</strong></span></p>\n<p>使用key-value的模式来存储，相当于每个name对应一个value</p>\n<p><strong><em>set(name, value, ex=None, px=None, nx=False, xx=False)<br>\n</em></strong></p>\n<p><strong><em>ex，过期时间（秒）<br>\npx，过期时间（毫秒）<br>\nnx，如果设置为True，则只有name不存在时，当前set操作才执行<br>\nxx，如果设置为True，则只有name存在时，岗前set操作才执行</em></strong><br>\n</p>\n<p></p>\n<pre class=\"python\">db.set('name','fml')\nprint(db.get('name'))</pre>\n结果：fml\n<p><strong><em>setex(name,value,time)</em></strong></p>\n<p><strong><em>time:过期时间（秒）</em></strong></p>\n<p></p>\n<pre class=\"python\">db.setex('name','1',2)\ntime.sleep(2)\nprint(db.get('name'))</pre>\n结果：None\n<p>同样的还有</p>\n<p><strong><em>setnx(name,value)</em></strong>，相当于set()中的nx参数为True</p>\n<p><strong><em>psetex(name.time,value</em></strong>),time为毫秒数</p>\n<p><em>mset(*args,**kwargs)&nbsp; </em>批量操作，可传入字典</p>\n<p>方式一</p>\n<p></p>\n<pre class=\"python\">db.mset(t1 = 1,t2 = 2)\nprint(db.get('t1'))\nprint(db.get('t2'))</pre>\n结果 1，2<br>\n方式二\n<p></p>\n<pre class=\"python\">d = {'name':'fml','age':22}\ndb.mset(d)\nprint(db.get('name'))\nprint(db.get('age'))</pre>\n结果：&nbsp;fml ， 22<br>\n<br>\n<p><span style=\"font-size:12px\"><em>get(name):</em></span><span style=\"font-size:10px\">返回name的&#20540;</span></p>\n<p><span style=\"font-size:10px\"><strong>mget(keys, *args):</strong>批量操作，返回多个&#20540;（列表的形式），可传入列表<br>\n</span></p>\n<p><span style=\"font-size:10px\"></span></p>\n<pre class=\"python\">print(db.mget('name','age'))\nprint(db.mget(['t1','t2']))</pre>\n<img src=\"https://img-blog.csdn.net/20180312172020750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<em><br>\n</em>\n<p><span style=\"font-size:10px\"><em>getset(name,value):</em>设置新的&#20540;并返回之前的&#20540;</span></p>\n<p><span style=\"font-size:10px\"></span></p>\n<pre class=\"python\">print(db.getset('name','test'))\nprint(db.get('name'))</pre>\n<img src=\"https://img-blog.csdn.net/20180312172409761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><span style=\"font-size:10px\"><em>getrange(key,start,end):</em>获取子序列（根据字节获取，非字符）</span></p>\n<p><span style=\"font-size:10px\"><span style=\"color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px\">start：起始位，end结束位,&#20540;得注意的是这个是按照字节来计算而不是字符个数&nbsp;在utf-8的编码中一个中文汉字占三个字节，一个字符只占一位</span></span></p>\n<p><span style=\"font-size:10px\"><span style=\"color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px\"></span></span></p>\n<pre class=\"python\">db.set('name1','fml')\nprint(db.getrange('name1', 0, 1).decode())\ndb.set('name2','名字')\nprint(db.getrange('name2', 0, 2).decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312182537723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><em>setrange(name, offset, value):&nbsp; &nbsp;</em>从指定字符串索引开始向后替换（新&#20540;太长时，则向后添加）<br>\n</p>\n<p>offset:字符串索引号</p>\n<p></p>\n<pre class=\"python\">db.set('name','test set range')\ndb.setrange('name',1,'ls')  #从第二个字符开始替换\nprint(db.get('name').decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312183816787?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\">\n<p><em>setbit(name, offset, value)：</em>和上面的一个功能类&#20284;，只不过是用bite方式来更改<br>\n</p>\n<p><strong><em>getbit(name, offset)</em></strong>：获取name的二进制表示中的某一位&#20540;<br>\n</p>\n<p><em>bitcount(key, start=None, end=None)：</em>统计name用二进制表示中的为1的个数</p>\n<p>start，位起始位置end，位结束位置</p>\n<p></p>\n<pre class=\"python\">db.set('name','f')\nprint(db.bitcount('name'))\n#f对应的ASCII码的&#20540;为102,102转为二进制为 0110 0110 所以返回&#20540;为4</pre>\n<em>strlen(name):</em>返回name对于&#20540;的<strong>字节长度</strong>，汉字三字节\n<p></p>\n<pre class=\"python\">db.set('name1','发生')\ndb.set('name2','fml')\nprint(db.strlen('name1'))\nprint(db.strlen('name2'))</pre>\n<img src=\"https://img-blog.csdn.net/20180312214428147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><strong><em>incr(self, name, amount=1)：</em></strong> name的对应&#20540;增加amount<br>\n</p>\n<p><strong>自增只适用于整数</strong>，当name不存在的时候会新建一个name&#20540;为amount<br>\n</p>\n<p></p>\n<pre class=\"python\">db.set('num1',2)\ndb.incr('num1', amount=2)\ndb.incr('num2', amount=2)\nprint(db.get('num1').decode())\nprint(db.get('num2').decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312215147018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><strong>incrbyfloat(self, name, amount=1.0)：</strong>同上只不过是浮点型<br>\n</p>\n<p><em>decr(self, name, amount=1)：</em>同上功能为自减<br>\n</p>\n<p><strong><em>append(key, value) ：</em></strong>在name对应&#20540;后面追加value的内容，如果没有name就会新建一个name=value<br>\n</p>\n<p></p>\n<pre class=\"python\">db.set('name','fml')\ndb.append('name','test')\nprint(db.get('name').decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312220700495?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><br>\n</p>\n<p><span style=\"font-weight:bold; font-size:14px\">Hash操作</span><br>\n<span style=\"font-size:10px\">使用字典的方式来存储，name为字典名</span></p>\n<p><strong><em>hset(name, key, value):</em></strong><br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.hset('info','name','fml')\ndb.hset('info','age',22)\nprint(db.hget('info','name').decode())\nprint(db.hget('info','age').decode())</pre><strong style=\"font-style:italic\">hmset(name, mapping)：</strong>批量操作 ，mapping为字典</p>\n<p><pre name=\"code\" class=\"python\">db.hmset('info1',{'name1':'fml','age1':23})\nprint(db.hget('info1','name1').decode())\nprint(db.hget('info1','age1').decode())</pre></p>\n<p><img src=\"https://img-blog.csdn.net/20180313150927616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p><strong style=\"font-style:italic\">hget(name,key)：</strong>同get操作</p>\n<p><strong style=\"font-style:italic\">hmget(name, keys, *args)：</strong>同mget,可传入列表或者多个&#20540;<br>\n</p>\n<p><strong style=\"font-style:italic\">hgetall(name)：</strong>获取name的所有key-和value&#20540;<br>\n</p>\n<p><strong><em>hlen(name)：</em></strong>获取name中key的个数<br>\n</p>\n<p><strong><em>hkeys(name)：</em></strong>获取name中所有的key<br>\n</p>\n<p><strong><em>hvals(name)：</em></strong>获取name中所有的value&#20540;<br>\n</p>\n<p><strong><em>hexists(name, key)：</em></strong>判断name中是否存在传入的key<br>\n</p>\n<p><strong><em>hdel(name,*keys)：</em></strong>删除name中的key，若不存在返回0，删除成功后返回1<br>\n</p>\n<p><strong><em>hincrby(name, key, amount=1)：</em></strong>自增，同string操作一样<br>\n</p>\n<p><strong><em>hincrbyfloat(name, key, amount=1.0)</em></strong>&nbsp;自增浮点型<br>\n</p>\n<p><br>\n</p>\n<p>hscan(name, cursor=0, match=None, count=None)&nbsp;过滤获取多个&#20540;<br>\n</p>\n<p>cursor:起始位置，match：过滤方法 ，count：获取的个数</p>\n<p>过滤方法的例子：1：获取以n开头的key ：n*</p>\n<p><span style=\"white-space:pre\"></span>&nbsp; &nbsp; &nbsp;2：获取包含a的key：*a*</p>\n<p><span style=\"white-space:pre\"></span>&nbsp; &nbsp; &nbsp;3：获取以e结尾的key：*e</p>\n<p><pre name=\"code\" class=\"python\">db.hset('info','name','fml')\ndb.hset('info','age',22)\nprint(db.hscan('info',cursor=0,match= 'n*'))\nprint(db.hscan('info',cursor=0,match= '*e'))\nprint(db.hscan('info',cursor=0,match= '*g*'))</pre><img src=\"https://img-blog.csdn.net/20180313154353952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p><br>\n</p>\n<p><span style=\"font-size:14px; font-weight:700\">List操作</span><br>\n</p>\n<p><span style=\"font-size:14px; font-weight:700\"><br>\n</span></p>\n<p><strong style=\"\"><em style=\"\"><span style=\"font-size:10px\">lpush(name,values):&nbsp;向name添加元素，从左边开始添加</span></em></strong></p>\n<p><pre name=\"code\" class=\"python\" style=\"\"><span style=\"font-size:10px;\">db.lpush('list','1','2','3')\nprint(db.lrange('list',0,-1))</span></pre><span style=\"font-size:14px\"><img src=\"https://img-blog.csdn.net/20180313165641539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></span><br>\n<em><strong style=\"\"><span style=\"font-size:10px\">lpush(name,values):&nbsp;向name添加元素，从右边开始添加</span></strong></em><br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list3','1','2','3')\nprint(db.lrange('list3',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313165843605?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><br>\n<strong><em>lpushx(name,value)：</em></strong>只有当name存在的时候才在左边添加，相同的还有rpushx(name.value)<br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list3','1','2','3')\ndb.lpushx('list3',4)\nprint(db.lrange('list3',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313170111945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><strong><em>llen(name):&nbsp;</em></strong>返回name的存储的长度</p>\n<p><strong><em>linsert(name, where, refvalue, value))&nbsp;</em></strong> 在name的refvalue前面或后面插入value,如果存在多个refvalue的时候只会在从左往右数第一个起作用</p>\n<p>where：BEFORE/AFTER</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list5','1','2','3')\ndb.linsert('list5','BEFORE','2','5')\ndb.linsert('list5','AFTER','2','6')\nprint(db.lrange('list5',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313170630387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<br>\n<strong><em>lset(name, index, value)：</em></strong>修改index索引的&#20540;<br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list6','1','2','3')\ndb.lset('list6',1,4)\nprint(db.lrange('list6',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313171210000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<strong><em>lrem(name, value, num)：</em></strong>删除name中的value，num为需要删除的个数<br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list7',1,2,3,4,1,2,4,5,7)\ndb.lrem('list7',1,1)\ndb.lrem('list7',2,2)\nprint(db.lrange('list7',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313172150477?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><strong><em>lpop(name)：</em></strong>删除左边第一个&#20540;并返回，同样的还有<strong><em>rpop(name)：</em></strong>从右边弹出<br>\n</p>\n<p><strong><em>lindex(name, index)：</em></strong>获取index索引的&#20540;<br>\n</p>\n<p><strong><em>lrange(name, start, end)：</em></strong>返回切片获得的&#20540;<br>\n</p>\n<p><strong><em>ltrim(name, start, end)：</em></strong>删除除start-end之外的所有&#20540;<br>\n</p>\n<p><strong><em>rpoplpush(src, dst) ：</em></strong>删除src的最右的一个&#20540;，并把它添加到dst的最左边<br>\n</p>\n<p><strong><em>blpop(keys, timeout)：</em></strong>将多个列表排列，按照从左到右去pop对应列表的元素&nbsp; 同<strong><em>brpop(keys, timeout)</em></strong><br>\n</p>\n<p><strong style=\"font-style:italic\">brpoplpush(src, dst, timeout=0)：</strong>从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧<br>\n</p>\n<p><br>\n</p>\n<p><span style=\"font-size:14px; font-weight:700\">set集合操作</span><br>\n</p>\n<p><br>\n</p>\n","site":{"data":{}},"excerpt":"","more":"<h4>使用python操作redis</h4>\n<p>数据库的连接：</p>\n<p></p>\n<pre class=\"python\">import redis\n#连接数据库\ndb = redis.Redis('localhost',6379)\n#连接池\n# pool = redis.ConnectionPool(host='localhost',port=6379)\n# db = redis.Redis(connection_pool=pool)</pre>\n<p><span style=\"font-size:14px\"><strong>String操作：</strong></span></p>\n<p>使用key-value的模式来存储，相当于每个name对应一个value</p>\n<p><strong><em>set(name, value, ex=None, px=None, nx=False, xx=False)<br>\n</em></strong></p>\n<p><strong><em>ex，过期时间（秒）<br>\npx，过期时间（毫秒）<br>\nnx，如果设置为True，则只有name不存在时，当前set操作才执行<br>\nxx，如果设置为True，则只有name存在时，岗前set操作才执行</em></strong><br>\n</p>\n<p></p>\n<pre class=\"python\">db.set('name','fml')\nprint(db.get('name'))</pre>\n结果：fml\n<p><strong><em>setex(name,value,time)</em></strong></p>\n<p><strong><em>time:过期时间（秒）</em></strong></p>\n<p></p>\n<pre class=\"python\">db.setex('name','1',2)\ntime.sleep(2)\nprint(db.get('name'))</pre>\n结果：None\n<p>同样的还有</p>\n<p><strong><em>setnx(name,value)</em></strong>，相当于set()中的nx参数为True</p>\n<p><strong><em>psetex(name.time,value</em></strong>),time为毫秒数</p>\n<p><em>mset(*args,**kwargs)&nbsp; </em>批量操作，可传入字典</p>\n<p>方式一</p>\n<p></p>\n<pre class=\"python\">db.mset(t1 = 1,t2 = 2)\nprint(db.get('t1'))\nprint(db.get('t2'))</pre>\n结果 1，2<br>\n方式二\n<p></p>\n<pre class=\"python\">d = {'name':'fml','age':22}\ndb.mset(d)\nprint(db.get('name'))\nprint(db.get('age'))</pre>\n结果：&nbsp;fml ， 22<br>\n<br>\n<p><span style=\"font-size:12px\"><em>get(name):</em></span><span style=\"font-size:10px\">返回name的&#20540;</span></p>\n<p><span style=\"font-size:10px\"><strong>mget(keys, *args):</strong>批量操作，返回多个&#20540;（列表的形式），可传入列表<br>\n</span></p>\n<p><span style=\"font-size:10px\"></span></p>\n<pre class=\"python\">print(db.mget('name','age'))\nprint(db.mget(['t1','t2']))</pre>\n<img src=\"https://img-blog.csdn.net/20180312172020750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<em><br>\n</em>\n<p><span style=\"font-size:10px\"><em>getset(name,value):</em>设置新的&#20540;并返回之前的&#20540;</span></p>\n<p><span style=\"font-size:10px\"></span></p>\n<pre class=\"python\">print(db.getset('name','test'))\nprint(db.get('name'))</pre>\n<img src=\"https://img-blog.csdn.net/20180312172409761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><span style=\"font-size:10px\"><em>getrange(key,start,end):</em>获取子序列（根据字节获取，非字符）</span></p>\n<p><span style=\"font-size:10px\"><span style=\"color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px\">start：起始位，end结束位,&#20540;得注意的是这个是按照字节来计算而不是字符个数&nbsp;在utf-8的编码中一个中文汉字占三个字节，一个字符只占一位</span></span></p>\n<p><span style=\"font-size:10px\"><span style=\"color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px\"></span></span></p>\n<pre class=\"python\">db.set('name1','fml')\nprint(db.getrange('name1', 0, 1).decode())\ndb.set('name2','名字')\nprint(db.getrange('name2', 0, 2).decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312182537723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><em>setrange(name, offset, value):&nbsp; &nbsp;</em>从指定字符串索引开始向后替换（新&#20540;太长时，则向后添加）<br>\n</p>\n<p>offset:字符串索引号</p>\n<p></p>\n<pre class=\"python\">db.set('name','test set range')\ndb.setrange('name',1,'ls')  #从第二个字符开始替换\nprint(db.get('name').decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312183816787?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\">\n<p><em>setbit(name, offset, value)：</em>和上面的一个功能类&#20284;，只不过是用bite方式来更改<br>\n</p>\n<p><strong><em>getbit(name, offset)</em></strong>：获取name的二进制表示中的某一位&#20540;<br>\n</p>\n<p><em>bitcount(key, start=None, end=None)：</em>统计name用二进制表示中的为1的个数</p>\n<p>start，位起始位置end，位结束位置</p>\n<p></p>\n<pre class=\"python\">db.set('name','f')\nprint(db.bitcount('name'))\n#f对应的ASCII码的&#20540;为102,102转为二进制为 0110 0110 所以返回&#20540;为4</pre>\n<em>strlen(name):</em>返回name对于&#20540;的<strong>字节长度</strong>，汉字三字节\n<p></p>\n<pre class=\"python\">db.set('name1','发生')\ndb.set('name2','fml')\nprint(db.strlen('name1'))\nprint(db.strlen('name2'))</pre>\n<img src=\"https://img-blog.csdn.net/20180312214428147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><strong><em>incr(self, name, amount=1)：</em></strong> name的对应&#20540;增加amount<br>\n</p>\n<p><strong>自增只适用于整数</strong>，当name不存在的时候会新建一个name&#20540;为amount<br>\n</p>\n<p></p>\n<pre class=\"python\">db.set('num1',2)\ndb.incr('num1', amount=2)\ndb.incr('num2', amount=2)\nprint(db.get('num1').decode())\nprint(db.get('num2').decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312215147018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><strong>incrbyfloat(self, name, amount=1.0)：</strong>同上只不过是浮点型<br>\n</p>\n<p><em>decr(self, name, amount=1)：</em>同上功能为自减<br>\n</p>\n<p><strong><em>append(key, value) ：</em></strong>在name对应&#20540;后面追加value的内容，如果没有name就会新建一个name=value<br>\n</p>\n<p></p>\n<pre class=\"python\">db.set('name','fml')\ndb.append('name','test')\nprint(db.get('name').decode())</pre>\n<img src=\"https://img-blog.csdn.net/20180312220700495?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<p><br>\n</p>\n<p><span style=\"font-weight:bold; font-size:14px\">Hash操作</span><br>\n<span style=\"font-size:10px\">使用字典的方式来存储，name为字典名</span></p>\n<p><strong><em>hset(name, key, value):</em></strong><br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.hset('info','name','fml')\ndb.hset('info','age',22)\nprint(db.hget('info','name').decode())\nprint(db.hget('info','age').decode())</pre><strong style=\"font-style:italic\">hmset(name, mapping)：</strong>批量操作 ，mapping为字典</p>\n<p><pre name=\"code\" class=\"python\">db.hmset('info1',{'name1':'fml','age1':23})\nprint(db.hget('info1','name1').decode())\nprint(db.hget('info1','age1').decode())</pre></p>\n<p><img src=\"https://img-blog.csdn.net/20180313150927616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p><strong style=\"font-style:italic\">hget(name,key)：</strong>同get操作</p>\n<p><strong style=\"font-style:italic\">hmget(name, keys, *args)：</strong>同mget,可传入列表或者多个&#20540;<br>\n</p>\n<p><strong style=\"font-style:italic\">hgetall(name)：</strong>获取name的所有key-和value&#20540;<br>\n</p>\n<p><strong><em>hlen(name)：</em></strong>获取name中key的个数<br>\n</p>\n<p><strong><em>hkeys(name)：</em></strong>获取name中所有的key<br>\n</p>\n<p><strong><em>hvals(name)：</em></strong>获取name中所有的value&#20540;<br>\n</p>\n<p><strong><em>hexists(name, key)：</em></strong>判断name中是否存在传入的key<br>\n</p>\n<p><strong><em>hdel(name,*keys)：</em></strong>删除name中的key，若不存在返回0，删除成功后返回1<br>\n</p>\n<p><strong><em>hincrby(name, key, amount=1)：</em></strong>自增，同string操作一样<br>\n</p>\n<p><strong><em>hincrbyfloat(name, key, amount=1.0)</em></strong>&nbsp;自增浮点型<br>\n</p>\n<p><br>\n</p>\n<p>hscan(name, cursor=0, match=None, count=None)&nbsp;过滤获取多个&#20540;<br>\n</p>\n<p>cursor:起始位置，match：过滤方法 ，count：获取的个数</p>\n<p>过滤方法的例子：1：获取以n开头的key ：n*</p>\n<p><span style=\"white-space:pre\"></span>&nbsp; &nbsp; &nbsp;2：获取包含a的key：*a*</p>\n<p><span style=\"white-space:pre\"></span>&nbsp; &nbsp; &nbsp;3：获取以e结尾的key：*e</p>\n<p><pre name=\"code\" class=\"python\">db.hset('info','name','fml')\ndb.hset('info','age',22)\nprint(db.hscan('info',cursor=0,match= 'n*'))\nprint(db.hscan('info',cursor=0,match= '*e'))\nprint(db.hscan('info',cursor=0,match= '*g*'))</pre><img src=\"https://img-blog.csdn.net/20180313154353952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n</p>\n<p><br>\n</p>\n<p><span style=\"font-size:14px; font-weight:700\">List操作</span><br>\n</p>\n<p><span style=\"font-size:14px; font-weight:700\"><br>\n</span></p>\n<p><strong style=\"\"><em style=\"\"><span style=\"font-size:10px\">lpush(name,values):&nbsp;向name添加元素，从左边开始添加</span></em></strong></p>\n<p><pre name=\"code\" class=\"python\" style=\"\"><span style=\"font-size:10px;\">db.lpush('list','1','2','3')\nprint(db.lrange('list',0,-1))</span></pre><span style=\"font-size:14px\"><img src=\"https://img-blog.csdn.net/20180313165641539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></span><br>\n<em><strong style=\"\"><span style=\"font-size:10px\">lpush(name,values):&nbsp;向name添加元素，从右边开始添加</span></strong></em><br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list3','1','2','3')\nprint(db.lrange('list3',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313165843605?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><br>\n<strong><em>lpushx(name,value)：</em></strong>只有当name存在的时候才在左边添加，相同的还有rpushx(name.value)<br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list3','1','2','3')\ndb.lpushx('list3',4)\nprint(db.lrange('list3',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313170111945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><strong><em>llen(name):&nbsp;</em></strong>返回name的存储的长度</p>\n<p><strong><em>linsert(name, where, refvalue, value))&nbsp;</em></strong> 在name的refvalue前面或后面插入value,如果存在多个refvalue的时候只会在从左往右数第一个起作用</p>\n<p>where：BEFORE/AFTER</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list5','1','2','3')\ndb.linsert('list5','BEFORE','2','5')\ndb.linsert('list5','AFTER','2','6')\nprint(db.lrange('list5',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313170630387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<br>\n<strong><em>lset(name, index, value)：</em></strong>修改index索引的&#20540;<br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list6','1','2','3')\ndb.lset('list6',1,4)\nprint(db.lrange('list6',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313171210000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n<strong><em>lrem(name, value, num)：</em></strong>删除name中的value，num为需要删除的个数<br>\n</p>\n<p><pre name=\"code\" class=\"python\">db.rpush('list7',1,2,3,4,1,2,4,5,7)\ndb.lrem('list7',1,1)\ndb.lrem('list7',2,2)\nprint(db.lrange('list7',0,-1))</pre><img src=\"https://img-blog.csdn.net/20180313172150477?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<p><strong><em>lpop(name)：</em></strong>删除左边第一个&#20540;并返回，同样的还有<strong><em>rpop(name)：</em></strong>从右边弹出<br>\n</p>\n<p><strong><em>lindex(name, index)：</em></strong>获取index索引的&#20540;<br>\n</p>\n<p><strong><em>lrange(name, start, end)：</em></strong>返回切片获得的&#20540;<br>\n</p>\n<p><strong><em>ltrim(name, start, end)：</em></strong>删除除start-end之外的所有&#20540;<br>\n</p>\n<p><strong><em>rpoplpush(src, dst) ：</em></strong>删除src的最右的一个&#20540;，并把它添加到dst的最左边<br>\n</p>\n<p><strong><em>blpop(keys, timeout)：</em></strong>将多个列表排列，按照从左到右去pop对应列表的元素&nbsp; 同<strong><em>brpop(keys, timeout)</em></strong><br>\n</p>\n<p><strong style=\"font-style:italic\">brpoplpush(src, dst, timeout=0)：</strong>从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧<br>\n</p>\n<p><br>\n</p>\n<p><span style=\"font-size:14px; font-weight:700\">set集合操作</span><br>\n</p>\n<p><br>\n</p>\n"},{"_content":"\n<p>使用&nbsp;progressive&nbsp;库实现</p>\n<p>第一步&nbsp;导入模块</p>\n<p><span style=\"background-color:rgb(240,240,240)\">from progressive.bar import Bar</span></p>\n<p>第二步&nbsp;实例化</p>\n<p><span style=\"background-color:rgb(240,240,240)\">&nbsp; &nbsp; bar = Bar(title=&quot;Progress&quot;, max_value=MAX_VALUE, fallback=True)</span></p>\n在源文件中可以<br>\n可以自定义标题、宽度、颜色等等、、、\n<p><img src=\"https://img-blog.csdn.net/20180210212015819\" alt=\"\"><br>\n</p>\n<p>第三步&nbsp;初始化的一些操作</p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.cursor.clear_lines(1)</span></p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.cursor.save()</span></p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.cursor.restore()</span></p>\n<p>第四步&nbsp;显示进度条</p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.draw(value=NOW_VALUE, newline=False)</span></p>\n在draw这个方法里面value是指当前进度条位置，newline可设置是否在新的一行里面重新显示\n<p>显示效果</p>\n<p><img src=\"https://img-blog.csdn.net/20180210212729278\" alt=\"\"><br>\n</p>\n<p><br>\n</p>\n<br>\n<br>\n<p><br>\n</p>\n","source":"_posts/blogs-Python显示进度条的方法.md","raw":"\n<p>使用&nbsp;progressive&nbsp;库实现</p>\n<p>第一步&nbsp;导入模块</p>\n<p><span style=\"background-color:rgb(240,240,240)\">from progressive.bar import Bar</span></p>\n<p>第二步&nbsp;实例化</p>\n<p><span style=\"background-color:rgb(240,240,240)\">&nbsp; &nbsp; bar = Bar(title=&quot;Progress&quot;, max_value=MAX_VALUE, fallback=True)</span></p>\n在源文件中可以<br>\n可以自定义标题、宽度、颜色等等、、、\n<p><img src=\"https://img-blog.csdn.net/20180210212015819\" alt=\"\"><br>\n</p>\n<p>第三步&nbsp;初始化的一些操作</p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.cursor.clear_lines(1)</span></p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.cursor.save()</span></p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.cursor.restore()</span></p>\n<p>第四步&nbsp;显示进度条</p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.draw(value=NOW_VALUE, newline=False)</span></p>\n在draw这个方法里面value是指当前进度条位置，newline可设置是否在新的一行里面重新显示\n<p>显示效果</p>\n<p><img src=\"https://img-blog.csdn.net/20180210212729278\" alt=\"\"><br>\n</p>\n<p><br>\n</p>\n<br>\n<br>\n<p><br>\n</p>\n","slug":"blogs-Python显示进度条的方法","published":1,"date":"2022-03-16T17:09:37.937Z","updated":"2022-03-16T17:09:37.937Z","_id":"cl0v6kexm0020yms40obu76fz","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p>使用&nbsp;progressive&nbsp;库实现</p>\n<p>第一步&nbsp;导入模块</p>\n<p><span style=\"background-color:rgb(240,240,240)\">from progressive.bar import Bar</span></p>\n<p>第二步&nbsp;实例化</p>\n<p><span style=\"background-color:rgb(240,240,240)\">&nbsp; &nbsp; bar = Bar(title=&quot;Progress&quot;, max_value=MAX_VALUE, fallback=True)</span></p>\n在源文件中可以<br>\n可以自定义标题、宽度、颜色等等、、、\n<p><img src=\"https://img-blog.csdn.net/20180210212015819\" alt=\"\"><br>\n</p>\n<p>第三步&nbsp;初始化的一些操作</p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.cursor.clear_lines(1)</span></p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.cursor.save()</span></p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.cursor.restore()</span></p>\n<p>第四步&nbsp;显示进度条</p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.draw(value=NOW_VALUE, newline=False)</span></p>\n在draw这个方法里面value是指当前进度条位置，newline可设置是否在新的一行里面重新显示\n<p>显示效果</p>\n<p><img src=\"https://img-blog.csdn.net/20180210212729278\" alt=\"\"><br>\n</p>\n<p><br>\n</p>\n<br>\n<br>\n<p><br>\n</p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用&nbsp;progressive&nbsp;库实现</p>\n<p>第一步&nbsp;导入模块</p>\n<p><span style=\"background-color:rgb(240,240,240)\">from progressive.bar import Bar</span></p>\n<p>第二步&nbsp;实例化</p>\n<p><span style=\"background-color:rgb(240,240,240)\">&nbsp; &nbsp; bar = Bar(title=&quot;Progress&quot;, max_value=MAX_VALUE, fallback=True)</span></p>\n在源文件中可以<br>\n可以自定义标题、宽度、颜色等等、、、\n<p><img src=\"https://img-blog.csdn.net/20180210212015819\" alt=\"\"><br>\n</p>\n<p>第三步&nbsp;初始化的一些操作</p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.cursor.clear_lines(1)</span></p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.cursor.save()</span></p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.cursor.restore()</span></p>\n<p>第四步&nbsp;显示进度条</p>\n<p><span style=\"background-color:rgb(240,240,240)\">bar.draw(value=NOW_VALUE, newline=False)</span></p>\n在draw这个方法里面value是指当前进度条位置，newline可设置是否在新的一行里面重新显示\n<p>显示效果</p>\n<p><img src=\"https://img-blog.csdn.net/20180210212729278\" alt=\"\"><br>\n</p>\n<p><br>\n</p>\n<br>\n<br>\n<p><br>\n</p>\n"},{"_content":"\n<p><span style=\"white-space:pre\"></span>virtualenv可以让用户创建独立的python环境，每个环境互不干扰。<span style=\"white-space:pre\">virtualenvwrapper则可以让我们更方便的管理每个环境。</span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>1：安装virtualenv 和 virtualenvwrapper</span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>pip install virtualenv</span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>pip install<span style=\"white-space:pre\">virtualenvwrapper</span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>2：配置<span style=\"white-space:pre\">virtualenvwrapper环境</span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>打开/etc目录，找到bash.bashrc</span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171229203750937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>使用vim 打开 ，在最后加入</span></span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171229203829946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span></span></span></span></span></span></p>\n<p><span style=\"white-space:pre\"></span></p>\n<p>保存退出，使用source bash.bashrc命令就完成了</p>\n<p>安装完成后我们可以使用</p>\n<p>常用的几个命令</p>\n<br>\n<img src=\"https://img-blog.csdn.net/20180310124426258?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n","source":"_posts/blogs-virtualenv和virtualenvwrapper的安装和使用.md","raw":"\n<p><span style=\"white-space:pre\"></span>virtualenv可以让用户创建独立的python环境，每个环境互不干扰。<span style=\"white-space:pre\">virtualenvwrapper则可以让我们更方便的管理每个环境。</span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>1：安装virtualenv 和 virtualenvwrapper</span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>pip install virtualenv</span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>pip install<span style=\"white-space:pre\">virtualenvwrapper</span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>2：配置<span style=\"white-space:pre\">virtualenvwrapper环境</span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>打开/etc目录，找到bash.bashrc</span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171229203750937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>使用vim 打开 ，在最后加入</span></span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171229203829946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span></span></span></span></span></span></p>\n<p><span style=\"white-space:pre\"></span></p>\n<p>保存退出，使用source bash.bashrc命令就完成了</p>\n<p>安装完成后我们可以使用</p>\n<p>常用的几个命令</p>\n<br>\n<img src=\"https://img-blog.csdn.net/20180310124426258?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n","slug":"blogs-virtualenv和virtualenvwrapper的安装和使用","published":1,"date":"2022-03-16T17:09:31.667Z","updated":"2022-03-16T17:09:31.668Z","_id":"cl0v6kexn0021yms4hnjobfd9","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p><span style=\"white-space:pre\"></span>virtualenv可以让用户创建独立的python环境，每个环境互不干扰。<span style=\"white-space:pre\">virtualenvwrapper则可以让我们更方便的管理每个环境。</span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>1：安装virtualenv 和 virtualenvwrapper</span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>pip install virtualenv</span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>pip install<span style=\"white-space:pre\">virtualenvwrapper</span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>2：配置<span style=\"white-space:pre\">virtualenvwrapper环境</span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>打开/etc目录，找到bash.bashrc</span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171229203750937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>使用vim 打开 ，在最后加入</span></span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171229203829946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span></span></span></span></span></span></p>\n<p><span style=\"white-space:pre\"></span></p>\n<p>保存退出，使用source bash.bashrc命令就完成了</p>\n<p>安装完成后我们可以使用</p>\n<p>常用的几个命令</p>\n<br>\n<img src=\"https://img-blog.csdn.net/20180310124426258?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n","site":{"data":{}},"excerpt":"","more":"<p><span style=\"white-space:pre\"></span>virtualenv可以让用户创建独立的python环境，每个环境互不干扰。<span style=\"white-space:pre\">virtualenvwrapper则可以让我们更方便的管理每个环境。</span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>1：安装virtualenv 和 virtualenvwrapper</span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>pip install virtualenv</span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>pip install<span style=\"white-space:pre\">virtualenvwrapper</span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>2：配置<span style=\"white-space:pre\">virtualenvwrapper环境</span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>打开/etc目录，找到bash.bashrc</span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171229203750937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span>使用vim 打开 ，在最后加入</span></span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><img src=\"https://img-blog.csdn.net/20171229203829946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"></span></span></span></span></span></p>\n<p><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"><span style=\"white-space:pre\"></span></span></span></span></span></span></p>\n<p><span style=\"white-space:pre\"></span></p>\n<p>保存退出，使用source bash.bashrc命令就完成了</p>\n<p>安装完成后我们可以使用</p>\n<p>常用的几个命令</p>\n<br>\n<img src=\"https://img-blog.csdn.net/20180310124426258?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n"},{"_content":"\n<p><span style=\"white-space:pre\"></span><span style=\"font-size:18px\">使用WinSCP远程登录ubuntu系统后，再进行文件的拖拽操作的时候会提示错误&nbsp;</span>&nbsp;</p>\n<h2><span style=\"white-space:pre\"></span><img src=\"https://img-blog.csdn.net/20171229194959072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n<p><span style=\"white-space:pre\"></span><span style=\"font-size:18px; font-weight:normal\">原因是没有这个权限，需要我们使用root用户进行操作，但是WinSCP并不能默认使用root用户进行登录，解决方法是：</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>1：使用 sudo passwd root 设置好密码（已设置可忽略这步）。</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>2：然后在/etc/ssh/sshd_config中找到PermitRootLogin 这一行将后面的参数改为yes 保存退出。</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>3：重启service ssh restart 。</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>4：重新打开winscp 重新编辑登录信息，使用root用户登录就可以直接拖拽文件。</span></p>\n</h2>\n","source":"_posts/blogs-WinSCP默认使用root用户登录的方法.md","raw":"\n<p><span style=\"white-space:pre\"></span><span style=\"font-size:18px\">使用WinSCP远程登录ubuntu系统后，再进行文件的拖拽操作的时候会提示错误&nbsp;</span>&nbsp;</p>\n<h2><span style=\"white-space:pre\"></span><img src=\"https://img-blog.csdn.net/20171229194959072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n<p><span style=\"white-space:pre\"></span><span style=\"font-size:18px; font-weight:normal\">原因是没有这个权限，需要我们使用root用户进行操作，但是WinSCP并不能默认使用root用户进行登录，解决方法是：</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>1：使用 sudo passwd root 设置好密码（已设置可忽略这步）。</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>2：然后在/etc/ssh/sshd_config中找到PermitRootLogin 这一行将后面的参数改为yes 保存退出。</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>3：重启service ssh restart 。</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>4：重新打开winscp 重新编辑登录信息，使用root用户登录就可以直接拖拽文件。</span></p>\n</h2>\n","slug":"blogs-WinSCP默认使用root用户登录的方法","published":1,"date":"2022-03-16T17:09:39.165Z","updated":"2022-03-16T17:09:39.165Z","_id":"cl0v6kexo0022yms4a5jjaloy","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<p><span style=\"white-space:pre\"></span><span style=\"font-size:18px\">使用WinSCP远程登录ubuntu系统后，再进行文件的拖拽操作的时候会提示错误&nbsp;</span>&nbsp;</p>\n<h2><span style=\"white-space:pre\"></span><img src=\"https://img-blog.csdn.net/20171229194959072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n<p><span style=\"white-space:pre\"></span><span style=\"font-size:18px; font-weight:normal\">原因是没有这个权限，需要我们使用root用户进行操作，但是WinSCP并不能默认使用root用户进行登录，解决方法是：</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>1：使用 sudo passwd root 设置好密码（已设置可忽略这步）。</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>2：然后在/etc/ssh/sshd_config中找到PermitRootLogin 这一行将后面的参数改为yes 保存退出。</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>3：重启service ssh restart 。</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>4：重新打开winscp 重新编辑登录信息，使用root用户登录就可以直接拖拽文件。</span></p>\n</h2>\n","site":{"data":{}},"excerpt":"","more":"<p><span style=\"white-space:pre\"></span><span style=\"font-size:18px\">使用WinSCP远程登录ubuntu系统后，再进行文件的拖拽操作的时候会提示错误&nbsp;</span>&nbsp;</p>\n<h2><span style=\"white-space:pre\"></span><img src=\"https://img-blog.csdn.net/20171229194959072?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"><br>\n<p><span style=\"white-space:pre\"></span><span style=\"font-size:18px; font-weight:normal\">原因是没有这个权限，需要我们使用root用户进行操作，但是WinSCP并不能默认使用root用户进行登录，解决方法是：</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>1：使用 sudo passwd root 设置好密码（已设置可忽略这步）。</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>2：然后在/etc/ssh/sshd_config中找到PermitRootLogin 这一行将后面的参数改为yes 保存退出。</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>3：重启service ssh restart 。</span></p>\n<p><span style=\"font-size:18px; font-weight:normal\"><span style=\"white-space:pre\"></span>4：重新打开winscp 重新编辑登录信息，使用root用户登录就可以直接拖拽文件。</span></p>\n</h2>\n"},{"title":"test","date":"2022-03-20T16:11:23.000Z","_content":"","source":"_posts/test.md","raw":"---\ntitle: test\ndate: 2022-03-21 00:11:23\ntags:\n---\n","slug":"test","published":1,"updated":"2022-03-20T16:11:23.454Z","_id":"cl0zh7w150000bcs48fps0bm7","comments":1,"layout":"post","photos":[],"link":"","content":"","site":{"data":{}},"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"cl0v6kes6000kyms40l1w9til","category_id":"cl0zfxgxb0008t1s4c0z758ay","_id":"cl0zfxgxd000bt1s495f5b691"},{"post_id":"cl0v6kepl0000yms4eflz2gus","category_id":"cl0zf5cgy0000eis4dp5xbsid","_id":"cl0zgo7jm000ct1s4ejlt9boc"}],"PostTag":[{"post_id":"cl0v6kes6000kyms40l1w9til","tag_id":"cl0zfry0d0001t1s496z96jbx","_id":"cl0zfry0f0005t1s48orr3xx6"},{"post_id":"cl0v6kes6000kyms40l1w9til","tag_id":"cl0zfxgxc0009t1s49p0j13wh","_id":"cl0zfxgxd000at1s4ejs004n8"}],"Tag":[{"name":"jQuery","_id":"cl0zfry0d0001t1s496z96jbx"},{"name":"表格","_id":"cl0zfry0e0002t1s4g3a0evvc"},{"name":"表单验证","_id":"cl0zfry0e0004t1s42clw0seu"},{"name":"网络请求","_id":"cl0zfxgxc0009t1s49p0j13wh"}]}}