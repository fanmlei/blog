### 算法思路：

堆：分为大根堆和小根堆
      - 大根堆：一棵完全二叉树，满足任意一节点都比其孩子节点大。
      - 小根堆：一棵完全二叉树，满足任意一节点都比其孩子节点小。

<p style="text-align:center;"><img alt="" class="has" height="237" src="https://img-blog.csdn.net/20181023151845413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="615" /></p>

<p>堆排序流程： </p>

<ol><li>构造堆</li>
	<li>得到堆顶元素，为最大元素</li>
	<li>去掉堆顶，将堆的最后一个元素放到堆顶，然后调整重新使堆有序</li>
	<li>堆顶元素为第二大的元素</li>
	<li>重复第三步直到堆变空</li>
</ol><p>例如以[4, 5, 3, 6, 1, 2 ]为例：<img alt="" class="has" height="519" src="https://img-blog.csdn.net/20181023163153393?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="1062" /></p>

<p>准备知识：</p>

<p>     在以顺序储存的完全二叉树中，父子节点的关系（下标）：</p>

<ol><li>父节点和左孩子：左孩子下标 = 父节点下标 * 2 + 1</li>
	<li>父节点和右孩子：右孩子下标 = 父节点下标 * 2 + 2</li>
	<li>子节点和父节点： 父节点下标 = (子节点下标 - 1)  // 2</li>
	<li>最后一个非叶子节点：n // 2 -1</li>
</ol><h3>代码实现：  </h3>

<pre class="has">
<code class="language-python">def sift(nums, low, high):
    """
    调整堆，使堆有序
    :param nums: list
    :param low: 根节点
    :param high: 尾节点（树的最后一个）
    :return:
    """
    temp = nums[low]
    i = low
    j = 2 * i + 1
    while j &lt;= high:  # 当前i位置为叶子节点， j超过high了
        # 找更大的子节点
        if j + 1 &lt;= high and nums[j+1] &gt; nums[j]:  #
            j = j + 1
        if temp &lt; nums[j]:
            nums[i] = nums[j]
            i = j
            j = 2 * i + 1
        else:   # temp 大于两个子节点
            break
    nums[i] = temp


def heap_sort(nums):
    # 建堆
    l = len(nums)
    for i in range(l//2-1, -1, -1):
        # i是建堆时要调整的子树的根节点下标
        sift(nums, i, l-1)
    for i in range(l - 1, -1, -1):
        # 当前的high值
        nums[i], nums[0] = nums[0], nums[i]
        sift(nums, 0, i-1)</code></pre>

<h3>内置函数：</h3>

<p style="text-indent:50px;">Python内置模块heapq帮我们实现了堆排序，内置函数用的是小根堆，上面的代码是大根堆，差别不大，heapq模块主要包括三个函数:</p>

<ol><li>
	<p style="text-indent:0;">heapify(list) 建小根堆   把传入的list变成小根堆</p>
	</li>
	<li>
	<p style="text-indent:0;">heappush(heap_list, item)向已经建好的堆中增加数据</p>
	</li>
	<li>
	<p style="text-indent:0;">heappop(heap_list) 输出小根堆中最小值</p>
	</li>
</ol><pre class="has">
<code class="language-python">import heapq

nums = [3, 2, 1, 0, 6]

heapq.heapify(nums)
print(nums)
# [0, 2, 1, 3, 6]
heapq.heappush(nums, 4)
print(nums)
# [0, 2, 1, 3, 6, 4]
print(heapq.heappop(nums))
# 0
print(heapq.heappop(nums))
# 1
print(heapq.heappop(nums))
# 2</code></pre>

<p> </p>