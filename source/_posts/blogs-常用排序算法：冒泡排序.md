<h3>冒泡排序思路：</h3>

<p style="text-indent:50px;">列表中的每两个相邻的数，如果前面比后面的大，则交换这两个数。直到列表变为有序的时候为止，例如下面这个列表<br />
           [ 2,  1,  3,  0,  7,  6,  5,  4]</p>

<p style="text-indent:50px;">第一趟：<br />
                  第一步：列表的第一位和第二位比较：如果第一位大于第二位，则交换两者位置。由于2大于1，所以此时列表 为：[1,  2,  3,  0,  7,  6,  5,  4]<br />
                  第二步：再比较第二位和第三位，重复上面的操作，第一趟排序完成之后列表变为 [1,  2,  3,  0,   6,  5,  4 ,  7]，第一 趟完成之后最大数7跑到列表最后一位了。</p>

<p style="text-indent:50px;">第二趟： 还是从第一位开始比较，1小于2顺序不变，比较第二位和第三位2 小于3依然不变，比较第三位3大于0交换位 置， 此时列表变为[1,  2,  0,   3,   6,  5,  4 ,  7]，这一趟排序完成之后列表最终变为[1,  2,  0,   3,  5,  4,   6,  7]</p>

<p style="text-indent:50px;">冒泡排序的思想还是比较简单的，只是反复不断的比较相邻位置大小，并作交换，不再把每一步都交代明白了，只需重复上述的操作即可实现，最终裂变会变为[0,1,2,3,4,5,6,7],也就达到我们的排序目的了<br />
    </p>

<h3>代码实现：</h3>

<pre class="has">
<code class="language-python">def bubble_sort(nums):
    for i in range(len(nums) - 1):  # i表示第几趟
        for j in range(len(nums) - i - 1):  # j表示是第几个元素在比较
            if nums[j] &gt; nums[j + 1]:  # 如果大于则交换位置
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
                print(nums)
    return nums


bubble_sort([2, 1, 3, 0, 7, 6, 5, 4])

# [1, 2, 3, 0, 7, 6, 5, 4]
# [1, 2, 0, 3, 7, 6, 5, 4]
# [1, 2, 0, 3, 6, 7, 5, 4]
# [1, 2, 0, 3, 6, 5, 7, 4]
# [1, 2, 0, 3, 6, 5, 4, 7]
# [1, 0, 2, 3, 6, 5, 4, 7]
# [1, 0, 2, 3, 5, 6, 4, 7]
# [1, 0, 2, 3, 5, 4, 6, 7]
# [0, 1, 2, 3, 5, 4, 6, 7]
# [0, 1, 2, 3, 4, 5, 6, 7]</code></pre>

<h3>简单优化：   </h3>

<p style="text-indent:50px;">可以知道的是，如果列表是无序的，那么一趟排序的结果必然最少有一次交换，那么反过来想一下，如果一次完整的一趟没有交换任何位置，那么是不是就表明这个列表已经是有序的呢？按照这个思路我们来改进一下上面的代码。</p>

<pre class="has">
<code class="language-python">def bubble_sort(nums):
    for i in range(len(nums) - 1):  # i表示第几趟
        flag = False  # 是否发生交换的标志位
        for j in range(len(nums) - i - 1):  # j表示是第几个元素在比较
            if nums[j] &gt; nums[j + 1]:  # 如果大于则交换位置
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
                flag = True
        if not flag:  # 一趟排序完成没有发生交换直接返回
            return nums     
    return nums</code></pre>

<p> </p>