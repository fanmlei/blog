<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>fanmlei`s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="fanmlei`s blog"><meta name="msapplication-TileImage" content="/img/site/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="fanmlei`s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="fanmlei`s blog"><meta property="og:url" content="https://blog.iotforfml.cn/"><meta property="og:site_name" content="fanmlei`s blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.iotforfml.cn/img/og_image.png"><meta property="article:author" content="fanmlei"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.iotforfml.cn"},"headline":"fanmlei`s blog","image":["https://blog.iotforfml.cn/img/og_image.png"],"author":{"@type":"Person","name":"fanmlei"},"publisher":{"@type":"Organization","name":"fanmlei`s blog","logo":{"@type":"ImageObject","url":"https://blog.iotforfml.cn/img/site/avatar.png"}},"description":""}</script><link rel="icon" href="/img/site/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/site/avatar.png" alt="fanmlei`s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:28.107Z" title="3/17/2022, 1:09:28 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:28.107Z" title="3/17/2022, 1:09:28 AM">2022-03-17</time>更新</span><span class="level-item">5 分钟读完 (大约687个字)</span></div></div><div class="content"><p>python的多线程和多进程都是调用系统的原生线程和进程，多进程和多线程在使用上类&#20284;，同样有直接调用和继承调用两种，在进程中还可以创建其他的线程</p>
<p>可通过os模块中的getpid()获取自己的进程ID，getppid()获取父进程的ID</p>
<p><pre name="code" class="python">import multiprocessing,time,os
class MyProcessing(multiprocessing.Process):
    def __init__(self):
        super(MyProcessing,self).__init__()
    def run(self):
        print(os.getpid(),os.getppid())

<p>p1 &#x3D; MyProcessing()<br>p2 &#x3D; MyProcessing()<br>p1.start()<br>p2.start()</p>
<p>print(os.getpid())</pre><img src="https://img-blog.csdn.net/20180311152838710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p></p>
<h4>进程间通信</h4>
<div>1：Queue（）</div>
<p>不同进程中的内存空间是独立的，不同与线程无法直接访问，要想进程间互相通信需要用到进程Queue（multiprocessing.Queue()）不同与线程Queue（queue.Queue()），在使用进程Queue的时候父进程创建子进程的时候会复制一个队列到子进程内存空间里面，当子进程修改队列的时候，进程Queue会序列化到一个中间地方，然后再反序列化到父进程中，但是并不是直接访问的，这样就实现了父进程与子进程的数据访问</p>
<p><pre name="code" class="python">import multiprocessing,time,os
class MyProcessing(multiprocessing.Process):
    def __init__(self):
        super(MyProcessing,self).__init__()
    def run(self):
        q.put(1)
q = multiprocessing.Queue()
p1 = MyProcessing()
p1.start()

<p>print(q.get())</pre><img src="https://img-blog.csdn.net/20180311155259697?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></p>
</p>
<p>2：Pipe()</p>
<p>一个管道生成的时候会返回两个端口，一个可作为父进程访问端口，一个为子进程访问端口，若无数据可接收的时候会阻塞</p>
<p><pre name="code" class="python">import multiprocessing
class MyProcessing(multiprocessing.Process):
    def __init__(self):
        super(MyProcessing,self).__init__()
    def run(self):
        child_conn.send('f')
        
<p>parent_conn, child_conn&#x3D; multiprocessing.Pipe()</p>
<p>p1 &#x3D; MyProcessing()<br>p2 &#x3D; MyProcessing()<br>p1.start()<br>p2.start()</p>
<p>print(parent_conn.recv())<br>print(parent_conn.recv())</pre><img src="https://img-blog.csdn.net/20180311160321324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></p>
</p>
<p>3：Manage()</p>
<p>Manage()支持list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value , Array.</p>
<p>在使用Manage的时候必须要使用join等待子进程完成后继续运行，但是不知道是什么原因，猜测可能是防止多个进程修改数据导致混乱</p>
<p><pre name="code" class="python">from multiprocessing import Manager,Process

<p>def run (l,num):<br>    l.append(num)</p>
<p>l &#x3D; Manager().list() #创建一个可以在进程中传递的空列表<br>p_list &#x3D; []<br>for i in range(10):<br>    p &#x3D; Process(target&#x3D;run, args&#x3D;(l, i))<br>    p.start()<br>    p_list.append(p)</p>
<p>for res in p_list:<br>    res.join()</p>
<p>print(l)</pre><img src="https://img-blog.csdn.net/20180311165052147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></p>
</p>
<p>进程锁和线程锁类&#20284;不在赘述</p>
<h4>进程池Pool()</h4>
<div>线程池中有两个方法：</div>
<div>1：apple()&nbsp; #串行方式</div>
<div>2：apple_async() #并行方式，使用并行方式的时候必须先close再join</div>
<p><pre name="code" class="python">import os,time
from multiprocessing import Pool

<p>def run(num):<br>    time.sleep(2)<br>    print(num,os.getpid())</p>
<p>pool &#x3D; Pool(5)<br>for i in range(5):<br>    #pool.apply(func&#x3D;run,args&#x3D;(i,))<br>    pool.apply_async(func&#x3D;run,args&#x3D;(i,))<br>print(‘end’)<br>pool.close()<br>pool.join() #进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</pre><img src="https://img-blog.csdn.net/20180311182622059?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br><br></p>
</p>
<p><br>
</p>
<p><br>
</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:26.935Z" title="3/17/2022, 1:09:26 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:26.935Z" title="3/17/2022, 1:09:26 AM">2022-03-17</time>更新</span><span class="level-item">4 分钟读完 (大约611个字)</span></div></div><div class="content"><p>协程是一种用户态的轻量级线程，本质上是单线程<br></p>
<p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。</p>
<p>因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。&nbsp;&nbsp;</p>
<p>使用greenlet实现协程操作，greenlet需要手动进行切换</p>
<p>首先需要使用greenlet创建类&#20284;与堆栈空间，然后使用switch进行切换</p>
<p><pre name="code" class="python">from greenlet import greenlet

<p>def test1():<br>    print(12)<br>    gr2.switch()<br>    print(34)<br>    gr2.switch()</p>
<p>def test2():<br>    print(56)<br>    gr1.switch()<br>    print(78)</p>
<p>gr1 &#x3D; greenlet(test1)<br>gr2 &#x3D; greenlet(test2)</p>
<p>gr1.switch()</pre><img src="https://img-blog.csdn.net/20180311225407524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p></p>
<p><br>
</p>
<p>使用Gevent实现协程，无需手动切换，遇到IO操作就会进行切换</p>
<p><pre name="code" class="python">import gevent


<p>def func1(num):<br>&amp;nbsp; &amp;nbsp; print(‘in func1’,num)<br>&amp;nbsp; &amp;nbsp; gevent.sleep(1) #模仿IO操作<br>&amp;nbsp; &amp;nbsp; print(‘back func1’)</p>
<p>def func2():<br>&amp;nbsp; &amp;nbsp; print(‘in func2’)<br>&amp;nbsp; &amp;nbsp; gevent.sleep(2) #模仿IO操作<br>&amp;nbsp; &amp;nbsp; print(‘back func2’)</p>
<p>def func3():<br>&amp;nbsp; &amp;nbsp; print(‘in func3’)<br>&amp;nbsp; &amp;nbsp; gevent.sleep(3)<br>&amp;nbsp; &amp;nbsp; print(‘back func3’)</p>
<p>gevent.joinall([<br>&amp;nbsp; &amp;nbsp; gevent.spawn(func1,1),&amp;nbsp; #传参的方式<br>&amp;nbsp; &amp;nbsp; gevent.spawn(func3),<br>&amp;nbsp; &amp;nbsp; gevent.spawn(func2),<br>])<br></pre><img src="https://img-blog.csdn.net/20180311232911179?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></p>
</p>
<p>先执行func1，打印第一句后遇到IO操作切换到func3又遇到IO，再次切换到func2，遇到IO操作后由于没有可执行的函数，开始等待，func1最先可执行自动跳转到func1打印第二句，然后func2IO操作结束输出func2的第二句，最后func3才结束IO操作，所有func3的第二句最后打印</p>
<p>事件驱动模式：每次有一个事件发生的时候会首先存入到一个消息队列中，然后会有专门的函数循环不断的从队列中取出事件进行处理，执行完一个事件后一般会执行一个回调函数来告知当前事件处理完毕。</p>
<p>异步操作也算是一种事件驱动的模式，遇到IO操作的时候交个操作系统来执行，IO操作结束后会执行一个回调函数告知程序IO结束可继续执行<br>
</p>
<p><br>
</p>
<p><br>
</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:25.758Z" title="3/17/2022, 1:09:25 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:25.758Z" title="3/17/2022, 1:09:25 AM">2022-03-17</time>更新</span><span class="level-item">10 分钟读完 (大约1460个字)</span></div></div><div class="content"><h4>使用python操作redis</h4>
<p>数据库的连接：</p>
<p></p>
<pre class="python">import redis
#连接数据库
db = redis.Redis('localhost',6379)
#连接池
# pool = redis.ConnectionPool(host='localhost',port=6379)
# db = redis.Redis(connection_pool=pool)</pre>
<p><span style="font-size:14px"><strong>String操作：</strong></span></p>
<p>使用key-value的模式来存储，相当于每个name对应一个value</p>
<p><strong><em>set(name, value, ex=None, px=None, nx=False, xx=False)<br>
</em></strong></p>
<p><strong><em>ex，过期时间（秒）<br>
px，过期时间（毫秒）<br>
nx，如果设置为True，则只有name不存在时，当前set操作才执行<br>
xx，如果设置为True，则只有name存在时，岗前set操作才执行</em></strong><br>
</p>
<p></p>
<pre class="python">db.set('name','fml')
print(db.get('name'))</pre>
结果：fml
<p><strong><em>setex(name,value,time)</em></strong></p>
<p><strong><em>time:过期时间（秒）</em></strong></p>
<p></p>
<pre class="python">db.setex('name','1',2)
time.sleep(2)
print(db.get('name'))</pre>
结果：None
<p>同样的还有</p>
<p><strong><em>setnx(name,value)</em></strong>，相当于set()中的nx参数为True</p>
<p><strong><em>psetex(name.time,value</em></strong>),time为毫秒数</p>
<p><em>mset(*args,**kwargs)&nbsp; </em>批量操作，可传入字典</p>
<p>方式一</p>
<p></p>
<pre class="python">db.mset(t1 = 1,t2 = 2)
print(db.get('t1'))
print(db.get('t2'))</pre>
结果 1，2<br>
方式二
<p></p>
<pre class="python">d = {'name':'fml','age':22}
db.mset(d)
print(db.get('name'))
print(db.get('age'))</pre>
结果：&nbsp;fml ， 22<br>
<br>
<p><span style="font-size:12px"><em>get(name):</em></span><span style="font-size:10px">返回name的&#20540;</span></p>
<p><span style="font-size:10px"><strong>mget(keys, *args):</strong>批量操作，返回多个&#20540;（列表的形式），可传入列表<br>
</span></p>
<p><span style="font-size:10px"></span></p>
<pre class="python">print(db.mget('name','age'))
print(db.mget(['t1','t2']))</pre>
<img src="https://img-blog.csdn.net/20180312172020750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<em><br>
</em>
<p><span style="font-size:10px"><em>getset(name,value):</em>设置新的&#20540;并返回之前的&#20540;</span></p>
<p><span style="font-size:10px"></span></p>
<pre class="python">print(db.getset('name','test'))
print(db.get('name'))</pre>
<img src="https://img-blog.csdn.net/20180312172409761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<p><span style="font-size:10px"><em>getrange(key,start,end):</em>获取子序列（根据字节获取，非字符）</span></p>
<p><span style="font-size:10px"><span style="color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px">start：起始位，end结束位,&#20540;得注意的是这个是按照字节来计算而不是字符个数&nbsp;在utf-8的编码中一个中文汉字占三个字节，一个字符只占一位</span></span></p>
<p><span style="font-size:10px"><span style="color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px"></span></span></p>
<pre class="python">db.set('name1','fml')
print(db.getrange('name1', 0, 1).decode())
db.set('name2','名字')
print(db.getrange('name2', 0, 2).decode())</pre>
<img src="https://img-blog.csdn.net/20180312182537723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<p><em>setrange(name, offset, value):&nbsp; &nbsp;</em>从指定字符串索引开始向后替换（新&#20540;太长时，则向后添加）<br>
</p>
<p>offset:字符串索引号</p>
<p></p>
<pre class="python">db.set('name','test set range')
db.setrange('name',1,'ls')  #从第二个字符开始替换
print(db.get('name').decode())</pre>
<img src="https://img-blog.csdn.net/20180312183816787?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">
<p><em>setbit(name, offset, value)：</em>和上面的一个功能类&#20284;，只不过是用bite方式来更改<br>
</p>
<p><strong><em>getbit(name, offset)</em></strong>：获取name的二进制表示中的某一位&#20540;<br>
</p>
<p><em>bitcount(key, start=None, end=None)：</em>统计name用二进制表示中的为1的个数</p>
<p>start，位起始位置end，位结束位置</p>
<p></p>
<pre class="python">db.set('name','f')
print(db.bitcount('name'))
#f对应的ASCII码的&#20540;为102,102转为二进制为 0110 0110 所以返回&#20540;为4</pre>
<em>strlen(name):</em>返回name对于&#20540;的<strong>字节长度</strong>，汉字三字节
<p></p>
<pre class="python">db.set('name1','发生')
db.set('name2','fml')
print(db.strlen('name1'))
print(db.strlen('name2'))</pre>
<img src="https://img-blog.csdn.net/20180312214428147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<p><strong><em>incr(self, name, amount=1)：</em></strong> name的对应&#20540;增加amount<br>
</p>
<p><strong>自增只适用于整数</strong>，当name不存在的时候会新建一个name&#20540;为amount<br>
</p>
<p></p>
<pre class="python">db.set('num1',2)
db.incr('num1', amount=2)
db.incr('num2', amount=2)
print(db.get('num1').decode())
print(db.get('num2').decode())</pre>
<img src="https://img-blog.csdn.net/20180312215147018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<p><strong>incrbyfloat(self, name, amount=1.0)：</strong>同上只不过是浮点型<br>
</p>
<p><em>decr(self, name, amount=1)：</em>同上功能为自减<br>
</p>
<p><strong><em>append(key, value) ：</em></strong>在name对应&#20540;后面追加value的内容，如果没有name就会新建一个name=value<br>
</p>
<p></p>
<pre class="python">db.set('name','fml')
db.append('name','test')
print(db.get('name').decode())</pre>
<img src="https://img-blog.csdn.net/20180312220700495?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<p><br>
</p>
<p><span style="font-weight:bold; font-size:14px">Hash操作</span><br>
<span style="font-size:10px">使用字典的方式来存储，name为字典名</span></p>
<p><strong><em>hset(name, key, value):</em></strong><br>
</p>
<p><pre name="code" class="python">db.hset('info','name','fml')
db.hset('info','age',22)
print(db.hget('info','name').decode())
print(db.hget('info','age').decode())</pre><strong style="font-style:italic">hmset(name, mapping)：</strong>批量操作 ，mapping为字典</p>
<p><pre name="code" class="python">db.hmset('info1',{'name1':'fml','age1':23})
print(db.hget('info1','name1').decode())
print(db.hget('info1','age1').decode())</pre></p>
<p><img src="https://img-blog.csdn.net/20180313150927616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
</p>
<p><strong style="font-style:italic">hget(name,key)：</strong>同get操作</p>
<p><strong style="font-style:italic">hmget(name, keys, *args)：</strong>同mget,可传入列表或者多个&#20540;<br>
</p>
<p><strong style="font-style:italic">hgetall(name)：</strong>获取name的所有key-和value&#20540;<br>
</p>
<p><strong><em>hlen(name)：</em></strong>获取name中key的个数<br>
</p>
<p><strong><em>hkeys(name)：</em></strong>获取name中所有的key<br>
</p>
<p><strong><em>hvals(name)：</em></strong>获取name中所有的value&#20540;<br>
</p>
<p><strong><em>hexists(name, key)：</em></strong>判断name中是否存在传入的key<br>
</p>
<p><strong><em>hdel(name,*keys)：</em></strong>删除name中的key，若不存在返回0，删除成功后返回1<br>
</p>
<p><strong><em>hincrby(name, key, amount=1)：</em></strong>自增，同string操作一样<br>
</p>
<p><strong><em>hincrbyfloat(name, key, amount=1.0)</em></strong>&nbsp;自增浮点型<br>
</p>
<p><br>
</p>
<p>hscan(name, cursor=0, match=None, count=None)&nbsp;过滤获取多个&#20540;<br>
</p>
<p>cursor:起始位置，match：过滤方法 ，count：获取的个数</p>
<p>过滤方法的例子：1：获取以n开头的key ：n*</p>
<p><span style="white-space:pre"></span>&nbsp; &nbsp; &nbsp;2：获取包含a的key：*a*</p>
<p><span style="white-space:pre"></span>&nbsp; &nbsp; &nbsp;3：获取以e结尾的key：*e</p>
<p><pre name="code" class="python">db.hset('info','name','fml')
db.hset('info','age',22)
print(db.hscan('info',cursor=0,match= 'n*'))
print(db.hscan('info',cursor=0,match= '*e'))
print(db.hscan('info',cursor=0,match= '*g*'))</pre><img src="https://img-blog.csdn.net/20180313154353952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
</p>
<p><br>
</p>
<p><span style="font-size:14px; font-weight:700">List操作</span><br>
</p>
<p><span style="font-size:14px; font-weight:700"><br>
</span></p>
<p><strong style=""><em style=""><span style="font-size:10px">lpush(name,values):&nbsp;向name添加元素，从左边开始添加</span></em></strong></p>
<p><pre name="code" class="python" style=""><span style="font-size:10px;">db.lpush('list','1','2','3')
print(db.lrange('list',0,-1))</span></pre><span style="font-size:14px"><img src="https://img-blog.csdn.net/20180313165641539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span><br>
<em><strong style=""><span style="font-size:10px">lpush(name,values):&nbsp;向name添加元素，从右边开始添加</span></strong></em><br>
</p>
<p><pre name="code" class="python">db.rpush('list3','1','2','3')
print(db.lrange('list3',0,-1))</pre><img src="https://img-blog.csdn.net/20180313165843605?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><br>
<strong><em>lpushx(name,value)：</em></strong>只有当name存在的时候才在左边添加，相同的还有rpushx(name.value)<br>
</p>
<p><pre name="code" class="python">db.rpush('list3','1','2','3')
db.lpushx('list3',4)
print(db.lrange('list3',0,-1))</pre><img src="https://img-blog.csdn.net/20180313170111945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong><em>llen(name):&nbsp;</em></strong>返回name的存储的长度</p>
<p><strong><em>linsert(name, where, refvalue, value))&nbsp;</em></strong> 在name的refvalue前面或后面插入value,如果存在多个refvalue的时候只会在从左往右数第一个起作用</p>
<p>where：BEFORE/AFTER</p>
<p><pre name="code" class="python">db.rpush('list5','1','2','3')
db.linsert('list5','BEFORE','2','5')
db.linsert('list5','AFTER','2','6')
print(db.lrange('list5',0,-1))</pre><img src="https://img-blog.csdn.net/20180313170630387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<br>
<strong><em>lset(name, index, value)：</em></strong>修改index索引的&#20540;<br>
</p>
<p><pre name="code" class="python">db.rpush('list6','1','2','3')
db.lset('list6',1,4)
print(db.lrange('list6',0,-1))</pre><img src="https://img-blog.csdn.net/20180313171210000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<strong><em>lrem(name, value, num)：</em></strong>删除name中的value，num为需要删除的个数<br>
</p>
<p><pre name="code" class="python">db.rpush('list7',1,2,3,4,1,2,4,5,7)
db.lrem('list7',1,1)
db.lrem('list7',2,2)
print(db.lrange('list7',0,-1))</pre><img src="https://img-blog.csdn.net/20180313172150477?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong><em>lpop(name)：</em></strong>删除左边第一个&#20540;并返回，同样的还有<strong><em>rpop(name)：</em></strong>从右边弹出<br>
</p>
<p><strong><em>lindex(name, index)：</em></strong>获取index索引的&#20540;<br>
</p>
<p><strong><em>lrange(name, start, end)：</em></strong>返回切片获得的&#20540;<br>
</p>
<p><strong><em>ltrim(name, start, end)：</em></strong>删除除start-end之外的所有&#20540;<br>
</p>
<p><strong><em>rpoplpush(src, dst) ：</em></strong>删除src的最右的一个&#20540;，并把它添加到dst的最左边<br>
</p>
<p><strong><em>blpop(keys, timeout)：</em></strong>将多个列表排列，按照从左到右去pop对应列表的元素&nbsp; 同<strong><em>brpop(keys, timeout)</em></strong><br>
</p>
<p><strong style="font-style:italic">brpoplpush(src, dst, timeout=0)：</strong>从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧<br>
</p>
<p><br>
</p>
<p><span style="font-size:14px; font-weight:700">set集合操作</span><br>
</p>
<p><br>
</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:24.549Z" title="3/17/2022, 1:09:24 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:24.549Z" title="3/17/2022, 1:09:24 AM">2022-03-17</time>更新</span><span class="level-item">2 分钟读完 (大约270个字)</span></div></div><div class="content"><p>首先需要在APP目录下创建一个templatetags目录</p>

<p>然后在这个目录下新建一个任意名的.py文件 如 test.py</p>

<p>创建一个template对象register</p>

<p> </p>

<pre class="has">
<code class="language-python">from django import template
from django.utils.safestring import mark_safe

register =template.Library()</code></pre>

<p>下面在这个文件中我们就可以写自定义函数了</p>

<p>有两种方式</p>

<p>一种是simple_tag,这种会限制参数的个数，但是不能作为IF的条件来使用</p>

<p> </p>

<pre class="has">
<code class="language-python">@register.simple_tag
def add(a,b):
    return a+b</code></pre>

<p>一种是filter，这个最多只能传递两个参数，可作为if条件使用</p>

<pre class="has">
<code class="language-python">@register.filter
def subtract(a,b):
    return a-b</code></pre>

<p> </p>

<p> </p>

<p> </p>

<p>这时候就可以在模板文件中使用这个函数了</p>

<p>首先在开头位置导入test.py文件</p>

<p>simple_tag直接使用%来调用函数，如果函数需要传参数，需要在函数后直接添加即可（用空格隔开）</p>

<p> </p>

<pre class="has">
<code class="language-python">&#123;% load test %&#125;

&#123;% add 2 3 %&#125;

&#123;&#123; 1|subtract:2 &#125;&#125;</code></pre>

<p><img alt="" class="has" src="https://img-blog.csdn.net/20180329183633434?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" /></p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p> </p>

<p>要注意的是app目录下的templatetags名不能更改 register也不能更改</p>

<p>还需要在settings里面注册这个app</p>

<p> </p>

<p> </p>

<p> </p>

<p> </p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:23.340Z" title="3/17/2022, 1:09:23 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:23.340Z" title="3/17/2022, 1:09:23 AM">2022-03-17</time>更新</span><span class="level-item">14 分钟读完 (大约2085个字)</span></div></div><div class="content"><h4>安装</h4>
<div>RabbitMQ是使用Erlang开发的，因此我们需要首先安装Erlang。<a target="_blank" href="http://www.erlang.org/downloads">http://www.erlang.org/downloads</a>下载对应的版本，安装完成后即可进入下一步。</div>
<div>下载RabbitMQ&nbsp;<a target="_blank" href="http://www.rabbitmq.com/download.html">http://www.rabbitmq.com/download.html</a>&nbsp;选择默认安装即可，安装完成后可在开始菜单中找到</div>
<div><img src="https://img-blog.csdn.net/20180419202452158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></div>
<div>点击 RabbitMQ Service - start就开始运行了</div>
<h4>使用Python进行操作</h4>
<div>这里我们需要用到pika这个模块来实现，安装好之后我们就可以实现最简单的例子了</div>
<h6>第一个程序Hello world</h6>
<p>下面两个例子都来自于官方示例</p>
<p>消息传递模型</p>
<p><img src="https://img-blog.csdn.net/20180421160239802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>
</p>
<div>send.py</div>
<div>
<pre class="python">import pika

<p>connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(host&#x3D;’localhost’))<br>channel &#x3D; connection.channel()</p>
<p>channel.queue_declare(queue&#x3D;’hello’)</p>
<p>channel.basic_publish(exchange&#x3D;’’,<br>                      routing_key&#x3D;’hello’,<br>                      body&#x3D;’Hello World!’)<br>print(&quot; [x] Sent ‘Hello World!’&quot;)<br>connection.close()</pre><br>receive.py</div></p>
<div>
<pre class="python">import pika

<p>connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(host&#x3D;’localhost’))<br>channel &#x3D; connection.channel()</p>
<p>channel.queue_declare(queue&#x3D;’hello’)</p>
<p>def callback(ch, method, properties, body):<br>    print(&quot; [x] Received %r&quot; % body)</p>
<p>channel.basic_consume(callback,<br>                      queue&#x3D;’hello’,<br>                      no_ack&#x3D;True)</p>
<p>print(‘ [*] Waiting for messages. To exit press CTRL&amp;#43;C’)<br>channel.start_consuming()</pre><br>依次运行这两个函数结果如下</div></p>
<div><img src="https://img-blog.csdn.net/20180419203216036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></div>
<div><img src="https://img-blog.csdn.net/20180419203343047?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></div>
<div>下面我们再来具体看一看每条语句的具体作用</div>
<div>
<pre class="python">connection = pika.BlockingConnection（pika.ConnectionParameters（'localhost'））
channel = connection.channel（）</pre>
第一句是建立连接的，rabbitmq支持本地连接也支持连接到其他机器上，在这里我们选择本地连接。</div>
<div>第二句是创建一个新的管道，之后的所有操作都是在这个管道上进行的。<br>
<pre class="python">channel.queue_declare(queue='hello')</pre>
<div>声明一个队列名为hello，如果你确认这个队列存在那么不声明也是可以的，但是最好声明一下以免造成其他的麻烦。</div>
</div>
<div>
<pre class="python">channel.basic_publish(exchange='',
                      routing_key='hello',
                      body='Hello World!')</pre>
</div>
<div>向队列中发送一条消息，其中routing_key指定队列名，body为消息内容</div>
<pre class="python">connection.close()</pre>
<p>关闭连接</p>
<p>receive.py中前面几句和send中的作用是一样的，这里不再赘述。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<pre class="python">def callback(ch, method, properties, body):
    print(&quot; [x] Received %r&quot; % body)</pre>
<p>callback是回调函数，当程序从队列中获取消息后都会执行回调函数来处理消息&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<pre class="python">channel.basic_consume(callback,
                      queue='hello',
                      #no_ack=True
                      )</pre>
<p>从队列中获取消息，callback指定回调函数，queue指定获取的队列名，no_ack在以后再说明&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>
<pre class="python">channel.start_consuming()</pre>
<p>让程序进入到一个死循环中，不断从队列中取出消息</p>
<h6>消息队列的循环调度</h6>
<p>消息传递模型</p>
<p><img src="https://img-blog.csdn.net/20180421160404952?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>当我们启动多个程序从同一个队列中接收消息的时候，默认是依次接收，即第一个启动的程序首先接收到然后是第二个启动的程序,直到最后一个程序收到之后又从第一个开始，但是这样会造成一个后果就是，可能每个程序或者机器的处理速度不同，造成有的在等待有的消息过多。如下图启动两个接收程序，并发送从0-4数字，两个程序接收的消息依次为：</p>
<p><img src="https://img-blog.csdn.net/20180421141241831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><img src="https://img-blog.csdn.net/20180421141300490?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>
</p>
<h6>消息确认</h6>
<p>在实际应用中一般程序接收消息后处理需要时间，如果在处理的过程中程序崩溃了那么那个消息就会从消息队列中消失了，这当然不是我们想要的结果，我们需要在程序崩溃之后将那条消息转发到另一个程序中执行，这时候我们需要设置只有在消息被确认后才将消息从队列中删除，RabbitMQ默认消息确认是打开的，但是我们可以添加参数no_ack = True来取消，这样即使消息为处理完成也不会再次发送了，会直接从队列中去除。我们还可以使用手动消息确认即在callback中添加一句：</p>
<pre class="sourcecode python hljs" style="padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left"><span style="vertical-align:inherit">ch.basic_ack（delivery_tag = method.delivery_tag）</span></pre>
<h6>消息持久化</h6>
<p>上面我们已经说了如何保证消费者崩溃时还保留消息，现在我们将介绍如何在RabbitMQ服务终止后还会保留消息队列。这里需要我们在声明这个队列的时候添加一个参数来实现</p>
<pre class="sourcecode python hljs" style="padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left"><span style="vertical-align:inherit">channel.queue_declare（queue = </span><span class="hljs-string" style="color:rgb(165,194,97)">'hello'</span><span style="vertical-align:inherit">，durable = </span><span class="hljs-keyword" style="color:rgb(194,98,48)">True</span><span style="vertical-align:inherit">）</span></pre>
<p>但是这只是保证了hello队列的持久化（下次重启服务的时候队列依然存在），但是队列中消息内容依然是不会被保留下来的，我们想要同时将消息保留下来还需要在channel.basic_publish()函数中添加下面这个参数</p>
<pre class="sourcecode python hljs" style="padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left"> properties=pika.BasicProperties(delivery_mode = <span class="hljs-number" style="color:rgb(165,194,97)">2</span>)</pre>
<p>需要注意的是消息内用只会暂存于缓存中，并未正真写入磁盘中永久保留，还有就是要实现消息持久化的前提是当前队列也是持久化的（不会报错，但是消息并没有被保留下来）</p>
<h6>公平派遣</h6>
<p></p>
<p>实际应用场景中，有些程序或者是机器处理消息的能力强一些，有些会弱一些，那么按照上面的操作所有的消息都是循环分发的这样就会导致有些机器空闲而有些会出现消息过多处理不过来的情况，为了解决这个问题我们可以在消费者中设置最多可容纳多少条消息，当消息数目满了之后就不会再接收新的消息，直到消息被处理完了留有空余才会再次接收消息。</p>
<pre class="sourcecode python hljs" style="padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left"><span style="vertical-align:inherit">channel.basic_qos（prefetch_count = </span><span class="hljs-number" style="color:rgb(165,194,97)">1</span><span style="vertical-align:inherit">）</span></pre>
<p>需要注意的是prefetch_count参数&#20540;并未实际意义，只要为True即可，也就是设置后消费者每次只能接收一个消息与参数&#20540;无关。</p>
<h6>广播模式</h6>
<div>消息传递模型</div>
<p><img src="https://img-blog.csdn.net/2018042117585856?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>上面所有的都是一对一的消息传递，下面将说一说一对多的传递模型，即广播模式，就好比收音机收听广播一样，需要一个发布者，其他的都是订阅者，发布者发布消息只要订阅者订阅了这个频道那么所有的订阅者都能收到消息。这里的消息传递模型就与之前的略有不同。消息并不是直接发送到队列中，而是经过一个交易所来分发到不同的队列中如上图所示。那么有人会问了，交易所是如何知道要分发到哪一个队列呢，其实只需要将队列和交易所绑定在一起就可以了，每一次消息过来的时候交易所会将消息转发到所有和他绑定的队列中。</p>
<pre class="python">channel.exchange_declare(exchange='logs',
                         exchange_type='fanout')

<p>message &#x3D; &quot;info: Hello World!&quot;<br>channel.basic_publish(exchange&#x3D;’logs’,<br>                      routing_key&#x3D;’’,<br>                      body&#x3D;message)</pre></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px">其中exchange_type类型有direct、topic、headers、fanout<span style="letter-spacing:.16px; text-align:left; white-space:pre-wrap"><span style="color:#333333">这四种，下面主要说明fanout类型。</span></span>上面这段程序指定了一个名为logs的交易所，类型为fanout，下面向这个exchange里面publish一条message消息，routing_key为空表示使用默认操作或称为无名交换。完成了发送程序，下面再来说说接收程序。</span></p>
<pre class="python">channel.exchange_declare(exchange='logs',
                         exchange_type='fanout')

<p>result &#x3D; channel.queue_declare(exclusive&#x3D;True)<br>queue_name &#x3D; result.method.queue</p>
<p>channel.queue_bind(exchange&#x3D;’logs’,<br>                   queue&#x3D;queue_name)</pre></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px">在第四行代码中声明了一个随机名称的队列，exclusive=True将会让程序在消费者断开连接的时候删除这个队列&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在第七行代码中我们将生成的随机队列和我们之前的交换所绑定在一起，这样当一个消息过来的时候交易所会将消息分发到我们绑定过的队列中</span></p>
<h6><span style="font-family:'Microsoft YaHei'; font-size:14px">路由</span></h6>
<p><img src="https://img-blog.csdn.net/20180423153004240?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>如上图所示</p>
<p><br>
</p>
<p></p>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<p></p>
<p></p>
<p></p>
<p><br>
</p>
<p></p>
<p><br>
</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:22.024Z" title="3/17/2022, 1:09:22 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:22.024Z" title="3/17/2022, 1:09:22 AM">2022-03-17</time>更新</span><span class="level-item">5 分钟读完 (大约810个字)</span></div></div><div class="content"><p><span style="color:#ff0000">自学笔记：逻辑可能比较混乱，想到哪说到哪，可能存在不少的问题欢迎指出。</span></p>
<h3>创建一个类：</h3>
<h4>最简单的一个类</h4>
<div>在python中类的命名必须以字母或者下画线开头，并且只能包含字母、下画线和数字。另外推荐使用驼峰命名方式（大写字母开头，随后的任意一个单词都以大写字母开头）</div>
<div>python最简单的一个类的创建</div>
<div><pre name="code" class="python">class MyFirstClass:
    pass</pre>
<h4>类的属性和方法</h4>
在类中我们还可以为其添加属性和方法</div>
<div><pre name="code" class="python">class MyFirstClass:
    def __init__(self):
        self.x = 1
        self.y = 1

<pre><code>def show(self):
    print(self.x,self.y)
</code></pre>
<p>c &#x3D; MyFirstClass()<br>c.show()</pre></div></p>
<div>其中self.x和self.y为该类的属性，show()为该类的方法</div>
<div>类中的方法的定义方式和普通函数相同，都是以关键字def开头，但是有一点不同的是类中的方法有一个必需的参数，通常这个参数被命名为self,但是我们实例化类后调用show方法的时候并没有传入参数，这是因为python自动帮我们做了，当我们调用c对象的show方法的时候，python会自动将c对象传给show方法了。因此下面这个调用方式运行结果是一样的。</div>
<div><pre name="code" class="python">c = MyFirstClass()
MyFirstClass.show(c)</pre>其实类中的方法本质上就是一个函数，我们可以在外部调用也可以在类中调用，例如：</div>
<div><pre name="code" class="python">class Point:
    def __init__(self, x ,y ):
        self.x = x
        self.y = y

<pre><code>def reset(self):
    self.x = 0
    self.y = 0
    self.show()

def show(self):
    print(self.x, self.y)
</code></pre>
<p>p &#x3D; Point(1,1)<br>p.reset()</pre></div></p>
<div>运行结果为：0&nbsp; 0</div>
<div>
<h4>类的初始化</h4>
<div>一般的编程语言中都有一个叫构造函数的特殊方法，当它被创建的时候会创建和初始化对象，这一点Python会有些许不同，python有一个构造函数和一个初始化函数，一般情况下构造函数很少被用到，除非是想实现一些特别的操作，所以在此主要说一下类的初始化。我们在之前的示例中有一个方法名为__init__(),其实这个方法就是给类进行初始化操作的。当我们实例化的时候会首先执行__init__()方法，因此当__init__()方法需要传递参数的时候我们在实例化的时候同样需要传递参数，不然会报错。</div>
<div>由于方法本质上就是函数，当我们不想传递参数的时候也可以同函数的操作一样使用默认参数。</div>
<div><pre name="code" class="python">def __init__(self, x=0, y=0):
    self.x = x
    self.y = y</pre></div>
</div>
<h3>面向对象三个基本特征</h3>
<div>面向对象编程的三个基本特征分别为：封装、继承、多态，下面一一说明。</div>
<h4>继承</h4>
<div>继承就是让一个类获得另一个类的属性和方法，在Python中所有的类都是object类的子类，只是在实际的使用中我们并不需要表明，python在后台自己帮我们做了</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<p><br>
</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:18.485Z" title="3/17/2022, 1:09:18 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:18.485Z" title="3/17/2022, 1:09:18 AM">2022-03-17</time>更新</span><span class="level-item">17 分钟读完 (大约2566个字)</span></div></div><div class="content"><h2>cookie</h2>
<p>cookie:客户端浏览器上的一个文件（键&#20540;对方式存储，类&#20284;于python中的字典），一般用于记录用户状态、和用户信息的，绝大多数的网站自动登录功能都是基于cookie实现的，下面使用Django实现一个用户登陆作为例子展示。<br>
</p>
<p>首先是最简单的登录页面&nbsp;login：</p>
<pre class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;/login/&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;用户名&quot;&gt;
    &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;密码&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
login请求处理函数
<pre class="python">user_infp ={
    &quot;fml&quot;:{&quot;password&quot;:&quot;123&quot;}
}

<p>def login(request):<br>    if request.method &#x3D;&#x3D; &quot;GET&quot;:<br>        return  render(request,&quot;login.html&quot;)<br>    if request.method &#x3D;&#x3D; &quot;POST&quot;:<br>        u &#x3D; request.POST.get(&quot;username&quot;)<br>        p &#x3D; request.POST.get(&quot;password&quot;)<br>        dic &#x3D; user_infp.get(u)<br>        if not dic:<br>            return render(request,&quot;login.html&quot;)<br>        if dic[&quot;password&quot;] &#x3D;&#x3D; p:<br>            res &#x3D; redirect(‘&#x2F;index’)<br>            res.set_cookie(&quot;username&quot;,u)<br>            return res<br>        else:<br>            return render(request,&quot;login.html&quot;)</pre><br>当请求为get方式的时候返回登录页面，为post方式的时候验证表单，这里只使用字典来简化从数据库验证的操作。当验证通过的时候跳转到index页面，并且设置一个cookie，内容为｛&quot;username&quot;:username},否则任然返回当前页面。</p>
<p>index页面：仅仅用来显示登录的用户名</p>
<pre class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;欢迎&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p>index处理函数：</p>
<pre class="html">def index(request):
    user = request.COOKIES.get(&quot;username&quot;)
    if not user:
        return redirect('/login')
    else:
        return render(request,'index.html',{&quot;user&quot;:user})</pre>
如果上面我们如果登录成功浏览器会存储一个cookie，当我们再次请求index页面的时候，同时发送过去的还有本地的cookie，所以可以从request中的cookie中获取我们已经存储的用户名，如果不存在则跳转到login页面，如果有登录信息则显示登录页面<img src="" alt=""><br>
<img src="" alt=""><br>
<p>以上是最简单的cookie使用，其实cookie还有很多其他的用法</p>
<p></p>
<pre class="python">rep = HttpResponse(...) 或 rep ＝ render(request, ...)
 
<p>rep.set_cookie(key,value,…)<br>rep.set_signed_cookie(key,value,salt&#x3D;’加密盐’,…)<br>    参数：<br>        key,              键<br>        value&#x3D;’’,         &amp;#20540;<br>        max_age&#x3D;None,     超时时间<br>        expires&#x3D;None,     超时时间(IE requires expires, so set it if hasn’t been already.)<br>        path&#x3D;’&#x2F;‘,         Cookie生效的路径，&#x2F; 表示根路径，特殊的：跟路径的cookie可以被任何url的页面访问<br>        domain&#x3D;None,      Cookie生效的域名<br>        secure&#x3D;False,     https传输<br>        httponly&#x3D;False    只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖）</pre></p>
<p><img src="" alt=""><br>
<img src="" alt=""><br>
下面再来详细说一说各个参数的作用。<br>
首先是获取cookie，salt：这个参数的具体作用目前我还是不太清除，猜测是cookie加密操作，等我弄懂了再回来修改。<br>
<br>
接下来是设置cookie，key和value不用再说了，<br>
<strong>max_age:</strong>设置超时时间以秒为单位，很多网站上登录页面都有多长时间免登录的功能一般都是通过这个来设置的，当超过了一段时间这个cookie就会失效<br>
<span style="white-space:pre"></span><strong>expires</strong>:&nbsp;同样是设置超时时间的，但是和上面的不太一样，这里的单位不是秒，而是datetime,所以就有两种超时时间的设置方法</p>
<pre class="python">#max_age方法
res.set_cookie(&quot;username&quot;,u,max_age=10)
#expires方法
import datetime
current_time = datetime.datetime.utcnow()
end_time = current_time &#43; datetime.timedelta(seconds=10)
res.set_cookie(&quot;username&quot;,u,expires=end_time)</pre>
<span style="white-space:pre"></span><strong>path</strong>:是指定cookie生效的路径，参数默认为 ' / '&nbsp;可被当前网站任意URL页面访问，下面我们重新写一个页面index1，内容和index相同
<pre class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;这里是index1欢迎&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
index1&nbsp;的处理函数
<pre class="python">def index1(request):
    user = request.COOKIES.get(&quot;username&quot;)
    if not user:
        return HttpResponse(&quot;没有获取到cookie&quot;)
    else:
        return render(request,&quot;index1.html&quot;,{&quot;user&quot;:user})</pre>
<p><br>
</p>
这里我们将login函数里面的cookie设置为
<pre style="background-color:#272822; color:#f8f8f2; font-family:Consolas; font-size:9pt">res.set_cookie(<span style="color:#e6db74">&quot;username&quot;</span><span style="color:#cc7832">,</span>u<span style="color:#cc7832">,</span><span style="color:#aa4926">path</span><span style="color:#f92672">=</span><span style="color:#e6db74">'/index'</span>)</pre>
然后重新运行登录<img src="" alt="">，这里就能看出在index可以正常获取到cookie，而index1获取不到，path设置成功。
<p><strong>domain:</strong>设置生效域名，这里只能设置当前域名的子域名，无法给其他域名设置<br>
<br>
</p>
<h2>session</h2>
<div>和cookie不同的是session是保存在服务器端的键&#20540;对，session基于cookie来使用的，一般情况下本地的cookie会存储session中的key名，然后通过cookie中的key去获取服务器上存储的信息。</div>
下面依然以用户登录作为最简单的示例：<br>
模板还是上面的那两个，这里只重写对应的处理函数<pre name="code" class="python">user_infp ={
    &quot;fml&quot;:{&quot;password&quot;:&quot;123&quot;}
}

<p>def login(request):<br>    if request.method &#x3D;&#x3D; &quot;GET&quot;:<br>        return  render(request,&quot;login.html&quot;)<br>    if request.method &#x3D;&#x3D; &quot;POST&quot;:<br>        u &#x3D; request.POST.get(&quot;username&quot;)<br>        p &#x3D; request.POST.get(&quot;password&quot;)<br>        dic &#x3D; user_infp.get(u)<br>        if not dic:<br>            return render(request,&quot;login.html&quot;)<br>        if dic[&quot;password&quot;] &#x3D;&#x3D; p:<br>            res &#x3D; redirect(‘&#x2F;index’)<br>            request.session[‘username’] &#x3D; u<br>            request.session[&quot;is_login&quot;] &#x3D; True<br>            return res<br>        else:<br>            return render(request,&quot;login.html&quot;)</p>
<p>def index(request):<br>    print(request.session[&quot;is_login&quot;])<br>    if request.session[&quot;is_login&quot;]:<br>        return render(request, ‘index.html’, {&quot;user&quot;: request.session[&quot;username&quot;]})<br>    else:<br>        return redirect(‘&#x2F;login’)</pre>乍一看和cookie的操作类&amp;#20284;，其实这是因为django为我们在后台做了很多工作，例如</p>
<pre style="background-color:#272822; color:#f8f8f2; font-family:'Consolas'; font-size:9.0pt"><span style="color:#fd971f"><em>request</em></span>.session[<span style="color:#e6db74">'username'</span>] <span style="color:#f92672">= </span>u
<span style="color:#fd971f"><em>request</em></span>.session[<span style="color:#e6db74">&quot;is_login&quot;</span>] <span style="color:#f92672">= </span><span style="color:#66d9ef"><em>True</em></span></pre>
<p>这两句就很简单的完成了session的创建，实际上django首先生成了一串随机字符串用来作为key并将这个随机字符串保存到本地的cookie中，然后在将后面的两个内容以字典的形式存到服务器端，django中默认session存储在数据库中。</p>
<p></p>
<p></p>
<pre style="background-color:#272822; color:#f8f8f2; font-family:'Consolas'; font-size:9.0pt"><span style="color:#fd971f"><em>request</em></span>.session[<span style="color:#e6db74">&quot;is_login&quot;</span>]<span style="color:#f92672">:</span></pre>
这一步首先从cookie中回去对应的key，然后再从数据库中获取对应的value进行判断<br>
同样的session和cookie一样也有一些高级功能，例如设置超时时间<br>
<pre name="code" class="python">request.session.set_expiry(value)
            * 如果value是个整数，session会在些秒数后失效。
            * 如果value是个datatime或timedelta，session就会在这个时间后失效。
            * 如果value是0,用户关闭浏览器session就会失效。
            * 如果value是None,session会依赖全局session失效策略。</pre>
<p></p>
<p>除了超时时间设置还有一下功能：</p>
<p><pre name="code" class="python">        # 获取、设置、删除Session中数据
        request.session['k1']
        request.session.get('k1',None)
        request.session['k1'] = 123
        request.session.setdefault('k1',123) # 存在则不设置
        del request.session['k1']
 
<pre><code>    # 所有 键、值、键值对
    request.session.keys()
    request.session.values()
    request.session.items()
    request.session.iterkeys()
    request.session.itervalues()
    request.session.iteritems()


    # 用户session的随机字符串
    request.session.session_key

    # 将所有Session失效日期小于当前日期的数据删除
    request.session.clear_expired()

    # 检查 用户session的随机字符串 在数据库中是否
    request.session.exists(&amp;quot;session_key&amp;quot;)

    # 删除当前用户的所有Session数据
    request.session.delete(&amp;quot;session_key&amp;quot;)&lt;/pre&gt;&lt;br&gt;
</code></pre>
</p>
在django中session共有5种方式来存储：数据库、缓存、文件、缓存加数据库、加密cookie，但是都需要我们在settings里面设置，下面就是每种的配置方式
<p><pre name="code" class="python">#数据库配置

<p>SESSION_ENGINE &#x3D; ‘django.contrib.sessions.backends.db’  # 引擎（默认）</p>
<p>SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）<br>SESSION_COOKIE_PATH ＝ &quot;&#x2F;&quot;  # Session的cookie保存的路径（默认）<br>SESSION_COOKIE_DOMAIN &#x3D; None  # Session的cookie保存的域名（默认）<br>SESSION_COOKIE_SECURE &#x3D; False  # 是否Https传输cookie（默认）<br>SESSION_COOKIE_HTTPONLY &#x3D; True  # 是否Session的cookie只支持http传输（默认）<br>SESSION_COOKIE_AGE &#x3D; 1209600  # Session的cookie失效日期（2周）（默认）<br>SESSION_EXPIRE_AT_BROWSER_CLOSE &#x3D; False  # 是否关闭浏览器使得Session过期（默认）<br>SESSION_SAVE_EVERY_REQUEST &#x3D; False  # 是否每次请求都保存Session，默认修改之后才保存（默认）</p>
<p>#缓存配置<br>SESSION_ENGINE &#x3D; ‘django.contrib.sessions.backends.cache’  # 引擎<br>SESSION_CACHE_ALIAS &#x3D; ‘default’  # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置</p>
<p>SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串<br>SESSION_COOKIE_PATH ＝ &quot;&#x2F;&quot;  # Session的cookie保存的路径<br>SESSION_COOKIE_DOMAIN &#x3D; None  # Session的cookie保存的域名<br>SESSION_COOKIE_SECURE &#x3D; False  # 是否Https传输cookie<br>SESSION_COOKIE_HTTPONLY &#x3D; True  # 是否Session的cookie只支持http传输<br>SESSION_COOKIE_AGE &#x3D; 1209600  # Session的cookie失效日期（2周）<br>SESSION_EXPIRE_AT_BROWSER_CLOSE &#x3D; False  # 是否关闭浏览器使得Session过期<br>SESSION_SAVE_EVERY_REQUEST &#x3D; False  # 是否每次请求都保存Session，默认修改之后才保存</p>
<p>#文件配置<br>SESSION_ENGINE &#x3D; ‘django.contrib.sessions.backends.file’  # 引擎<br>SESSION_FILE_PATH &#x3D; None  # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir()                                                            # 如：&#x2F;var&#x2F;folders&#x2F;d3&#x2F;j9tj0gz93dg06bmwxmhh6_xm0000gn&#x2F;T</p>
<p>SESSION_COOKIE_NAME ＝ &quot;sessionid&quot;  # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串<br>SESSION_COOKIE_PATH ＝ &quot;&#x2F;&quot;  # Session的cookie保存的路径<br>SESSION_COOKIE_DOMAIN &#x3D; None  # Session的cookie保存的域名<br>SESSION_COOKIE_SECURE &#x3D; False  # 是否Https传输cookie<br>SESSION_COOKIE_HTTPONLY &#x3D; True  # 是否Session的cookie只支持http传输<br>SESSION_COOKIE_AGE &#x3D; 1209600  # Session的cookie失效日期（2周）<br>SESSION_EXPIRE_AT_BROWSER_CLOSE &#x3D; False  # 是否关闭浏览器使得Session过期<br>SESSION_SAVE_EVERY_REQUEST &#x3D; False  # 是否每次请求都保存Session，默认修改之后才保存</p>
<p>#缓存加数据库（数据库实现持久化，缓存提高效率）<br>SESSION_ENGINE &#x3D; ‘django.contrib.sessions.backends.cached_db’        # 引擎</p>
<p>#加密Cookie<br>SESSION_ENGINE &#x3D; ‘django.contrib.sessions.backends.signed_cookies’   # 引擎</pre><br><br><br><br><br><br><br><br><br><br><br><br><br></p>
</p>
<p><br>
</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:16.038Z" title="3/17/2022, 1:09:16 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:16.038Z" title="3/17/2022, 1:09:16 AM">2022-03-17</time>更新</span><span class="level-item">1 分钟读完 (大约198个字)</span></div></div><div class="content"><p>Django提供了发送邮件的接口，仅需做简单的设置即可实现发送邮件的功能。<br />首先需要在setting做简单的配置，以163邮箱为例：</p><pre class="python">EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.163.com' 
EMAIL_PORT = 25
EMAIL_HOST_USER = '****' # 帐号
EMAIL_HOST_PASSWORD = '****'  # 密码
DEFAULT_FROM_EMAIL = "*******" #默认发送名</pre>下面是官网的一个示例：<pre class="python">from django.core.mail import send_mail
 
<p>send_mail(‘Subject here’, ‘Here is the message.’, ‘<a href="mailto:&#x66;&#x72;&#111;&#x6d;&#64;&#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;">&#x66;&#x72;&#111;&#x6d;&#64;&#101;&#120;&#x61;&#109;&#112;&#108;&#x65;&#46;&#x63;&#111;&#x6d;</a>‘,<br>    [‘<a href="mailto:&#116;&#x6f;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;">&#116;&#x6f;&#x40;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;</a>‘], fail_silently&#x3D;False)</pre>自定义一个测试的URL地址，传入相应的参数即可成功发送邮件<br /><p><img src="https://img-blog.csdn.net/20180511125242870?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="" /></p><p>如果是放在云服务器上运行的时候需要注意25号端口有没有被禁用，有些服务商会将25号端口默认禁用，需要解禁后才能使用</p></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:14.866Z" title="3/17/2022, 1:09:14 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:14.866Z" title="3/17/2022, 1:09:14 AM">2022-03-17</time>更新</span><span class="level-item">5 分钟读完 (大约722个字)</span></div></div><div class="content"><p>上一篇博客简单的说了说Django发送邮件的方法，这一篇仅仅谈一下如何通过邮件的方式进行验证，以重置密码功能为例。</p>

<p>其实验证方法比较简单，只需要发送指定的链接给目标邮箱，用户点击链接即可通过验证，但是合成和验证这个指定的链接需要我们来处理，我用到的方法是，当用户申请邮箱验证的时候根据其邮箱地址和一个32位随机验证码去合成一个连接，当正常访问的使用后台可通过URL获取邮箱名以及验证码，再根据这两个值去数据库中匹配，看能否成功，若是成功则完成验证失败则提示用户链接无效，接下来是具体的实现方法：</p>

<p>首先我们需要建立一张数据库表，其中内容包括：邮箱地址、32位随机验证码、创建时间。</p>

<pre class="has">
<code class="language-python">class email_reset(models.Model):
    email_address = models.EmailField(null=False,unique=True) #邮箱地址唯一的
    vc_code = models.CharField(max_length=64,null=False) #随机验证码
    send_time = models.DateTimeField(auto_now=True)  #邮箱发送时间</code></pre>

<p>当用户需要用到邮箱验证的时候，则往数据库中新建一条数据之后在将邮箱地址和随机验证码合成为连接发送给目标</p>

<pre class="has">
<code class="language-python">def send_email(email_address):
    vc_code = vc_code_generator()
    msg = '&lt;h2&gt;重置密码&lt;/h1&gt;'\
          '&lt;h6&gt;如果不是你本人操作请忽略本消息,本条消息30分钟内有效,如果被禁止跳转请复制链接在浏览器中重新打开&lt;/h6&gt;'\
          '&lt;a href="http://localhost:8000/iot/resetpwd/?email=%s&amp;code=%s"&gt;点击重置密码&lt;/a&gt;' % (email_address,vc_code)
    u = models.email_reset.objects.filter(email_address=email_address).first()
    if u :
        models.email_reset.objects.filter(email_address=email_address).update(vc_code= vc_code)
    else:
        models.email_reset.objects.create(email_address=email_address,vc_code=vc_code)
    send_mail('重置密码', '请前往这个网址：localhost:8000/forgetpwd重置密码', "*****管理员&lt;****************@163.com&gt;",
              [email_address], fail_silently=False, html_message=msg)

#生成随机验证码
def vc_code_generator(size=32, chars=string.ascii_uppercase + string.ascii_letters + string.digits):
    return ''.join(random.choice(chars) for _ in range(size))</code></pre>

<p>接下来则是处理URL了，根据之前发送的链接格式我们可以通过GET方式获取到其邮箱地址和验证码，再从数据库中查询是否有从 稍作简单的判断即可知道当前</p>

<pre class="has">
<code class="language-python">    if request.method == "GET":
        email = request.GET.get("email")
        code = request.GET.get("code")
        if email and code:
            if models.email_reset.objects.filter(email_address=email).filter(vc_code=code):
                return render(request,'../templates/website/reset.html',&#123;'email':email&#125;)
            else:
                return HttpResponse("&lt;h1&gt;抱歉你访问的网址有误&lt;/h1&gt;")
        else:
            return HttpResponse("&lt;h1&gt;抱歉你访问的网址有误&lt;/h1&gt;")</code></pre>

<p> </p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:13.677Z" title="3/17/2022, 1:09:13 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:13.677Z" title="3/17/2022, 1:09:13 AM">2022-03-17</time>更新</span><span class="level-item">3 分钟读完 (大约384个字)</span></div></div><div class="content"><p>先看一下出错的代码</p>

<pre class="has">
<code class="language-python"># 中间件
class AuthMiddleware(MiddlewareMixin):
    
    def process_request(self, request):
        print(request.path)
        print(request.session.get('is_log'))
        if request.path != '/oa/login':
            if request.session.get('is_log'):
                return redirect('/oa/dashboard')
            else:
                return redirect('/oa/login')
        else:
            return</code></pre>

<p> </p>

<pre class="has">
<code class="language-python"># view
class Login(View):
    def get(self, request):
        return render(request, 'website/signin.html')

    def post(self, request):
        res = &#123;'status': 'succ'&#125;
        user_name = request.POST.get("name", None)
        password = request.POST.get("password", None)
        re_log = request.POST.get("remember", None)
        if user_name == 'root' and password == '123':
            # 设置session
            request.session['user'] = user_name
            request.session['is_log'] = True
            # 如果选择记住状态则保持一周的session信息
            if re_log == 1:
                request.session.set_expiry(1209600)
            res['status'] = 'succ'
        else:
            res['status'] = '密码错误'
        return HttpResponse(json.dumps(res), content_type="application/json")


class Dashboard(View):
    def get(self, request):
        db = DataBase()
        data = db.dashboard()
        return render(request, 'website/dashboard.html', &#123;'data': data&#125;)
       </code></pre>

<p>访问效果：<br /><img alt="" class="has" height="300" src="https://img-blog.csdn.net/20180720102424649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="530" /><br />
登录成功之后一直出现重复的跳转问题。</p>

<p>我们在来重新审视一下代码：<br />
首先我们登录成功之后访问/oa/dashboard这个页面，然后在中间间的处理过程中由于第一个if判断和第二个if判断都满足导致再次跳转到oa/dashboard页面一直重复。而且在访问其他页面的时候依然是一直跳转dashboard这个页面的，逻辑有误。</p>

<p>解决方法：在验证用户登录之后的session之后直接return掉而不是进行跳转。</p>

<pre class="has">
<code class="language-python">class AuthMiddleware(MiddlewareMixin):

    def process_request(self, request):
        if request.path != '/oa/login':
            if request.session.get('is_log'):
                return
            else:
                return redirect('/oa/login')
        else:
            return</code></pre>

<h2>之前逻辑没看清，现在突然发现这个问题好傻逼<br />
 </h2></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/8/">8</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/site/avatar.png" alt="fanmlei"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">fanmlei</p><p class="is-size-6 is-block">努力成为一名GEEK！</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Wuhan, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">75</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">4</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">8</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/fanmlei" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rssa"></i></a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Arduino/"><span class="level-start"><span class="level-item">Arduino</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-16T17:09:40.422Z">2022-03-17</time></p><p class="title"><a href="/2022/03/17/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-16T17:09:39.165Z">2022-03-17</time></p><p class="title"><a href="/2022/03/17/WinSCP%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8root%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-16T17:09:37.937Z">2022-03-17</time></p><p class="title"><a href="/2022/03/17/Python%E6%98%BE%E7%A4%BA%E8%BF%9B%E5%BA%A6%E6%9D%A1%E7%9A%84%E6%96%B9%E6%B3%95/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-16T17:09:36.621Z">2022-03-17</time></p><p class="title"><a href="/2022/03/17/PyQt5%E6%98%BE%E7%A4%BAGIF%E5%9B%BE%E7%89%87/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-16T17:09:35.436Z">2022-03-17</time></p><p class="title"><a href="/2022/03/17/PyQt5%E6%97%A0%E8%BE%B9%E6%A1%86%E5%90%8E%E7%AA%97%E5%8F%A3%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%96%B9%E6%B3%95/"> </a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">55</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">十二月 2017</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arduino/"><span class="tag">Arduino</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jQuery/"><span class="tag">jQuery</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag">排序</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A1%AC%E4%BB%B6/"><span class="tag">硬件</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><span class="tag">编程基础</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="tag">编程语言</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"><span class="tag">网络请求</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/site/avatar.png" alt="fanmlei`s blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 fanmlei</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>