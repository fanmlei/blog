<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>fanmlei`s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="fanmlei`s blog"><meta name="msapplication-TileImage" content="/img/site/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="fanmlei`s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="fanmlei`s blog"><meta property="og:url" content="https://blog.iotforfml.cn/"><meta property="og:site_name" content="fanmlei`s blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.iotforfml.cn/img/og_image.png"><meta property="article:author" content="fanmlei"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.iotforfml.cn"},"headline":"fanmlei`s blog","image":["https://blog.iotforfml.cn/img/og_image.png"],"author":{"@type":"Person","name":"fanmlei"},"publisher":{"@type":"Organization","name":"fanmlei`s blog","logo":{"@type":"ImageObject","url":"https://blog.iotforfml.cn/img/site/avatar.png"}},"description":""}</script><link rel="icon" href="/img/site/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/site/avatar.png" alt="fanmlei`s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/fanmlei/blog"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:28.107Z" title="3/17/2022, 1:09:28 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:28.107Z" title="3/17/2022, 1:09:28 AM">2022-03-17</time>更新</span><span class="level-item">5 分钟读完 (大约687个字)</span></div></div><div class="content"><p>python的多线程和多进程都是调用系统的原生线程和进程，多进程和多线程在使用上类&#20284;，同样有直接调用和继承调用两种，在进程中还可以创建其他的线程</p>
<p>可通过os模块中的getpid()获取自己的进程ID，getppid()获取父进程的ID</p>
<p><pre name="code" class="python">import multiprocessing,time,os
class MyProcessing(multiprocessing.Process):
    def __init__(self):
        super(MyProcessing,self).__init__()
    def run(self):
        print(os.getpid(),os.getppid())

<p>p1 &#x3D; MyProcessing()<br>p2 &#x3D; MyProcessing()<br>p1.start()<br>p2.start()</p>
<p>print(os.getpid())</pre><img src="https://img-blog.csdn.net/20180311152838710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p></p>
<h4>进程间通信</h4>
<div>1：Queue（）</div>
<p>不同进程中的内存空间是独立的，不同与线程无法直接访问，要想进程间互相通信需要用到进程Queue（multiprocessing.Queue()）不同与线程Queue（queue.Queue()），在使用进程Queue的时候父进程创建子进程的时候会复制一个队列到子进程内存空间里面，当子进程修改队列的时候，进程Queue会序列化到一个中间地方，然后再反序列化到父进程中，但是并不是直接访问的，这样就实现了父进程与子进程的数据访问</p>
<p><pre name="code" class="python">import multiprocessing,time,os
class MyProcessing(multiprocessing.Process):
    def __init__(self):
        super(MyProcessing,self).__init__()
    def run(self):
        q.put(1)
q = multiprocessing.Queue()
p1 = MyProcessing()
p1.start()

<p>print(q.get())</pre><img src="https://img-blog.csdn.net/20180311155259697?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></p>
</p>
<p>2：Pipe()</p>
<p>一个管道生成的时候会返回两个端口，一个可作为父进程访问端口，一个为子进程访问端口，若无数据可接收的时候会阻塞</p>
<p><pre name="code" class="python">import multiprocessing
class MyProcessing(multiprocessing.Process):
    def __init__(self):
        super(MyProcessing,self).__init__()
    def run(self):
        child_conn.send('f')
        
<p>parent_conn, child_conn&#x3D; multiprocessing.Pipe()</p>
<p>p1 &#x3D; MyProcessing()<br>p2 &#x3D; MyProcessing()<br>p1.start()<br>p2.start()</p>
<p>print(parent_conn.recv())<br>print(parent_conn.recv())</pre><img src="https://img-blog.csdn.net/20180311160321324?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></p>
</p>
<p>3：Manage()</p>
<p>Manage()支持list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, Queue, Value , Array.</p>
<p>在使用Manage的时候必须要使用join等待子进程完成后继续运行，但是不知道是什么原因，猜测可能是防止多个进程修改数据导致混乱</p>
<p><pre name="code" class="python">from multiprocessing import Manager,Process

<p>def run (l,num):<br>    l.append(num)</p>
<p>l &#x3D; Manager().list() #创建一个可以在进程中传递的空列表<br>p_list &#x3D; []<br>for i in range(10):<br>    p &#x3D; Process(target&#x3D;run, args&#x3D;(l, i))<br>    p.start()<br>    p_list.append(p)</p>
<p>for res in p_list:<br>    res.join()</p>
<p>print(l)</pre><img src="https://img-blog.csdn.net/20180311165052147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></p>
</p>
<p>进程锁和线程锁类&#20284;不在赘述</p>
<h4>进程池Pool()</h4>
<div>线程池中有两个方法：</div>
<div>1：apple()&nbsp; #串行方式</div>
<div>2：apple_async() #并行方式，使用并行方式的时候必须先close再join</div>
<p><pre name="code" class="python">import os,time
from multiprocessing import Pool

<p>def run(num):<br>    time.sleep(2)<br>    print(num,os.getpid())</p>
<p>pool &#x3D; Pool(5)<br>for i in range(5):<br>    #pool.apply(func&#x3D;run,args&#x3D;(i,))<br>    pool.apply_async(func&#x3D;run,args&#x3D;(i,))<br>print(‘end’)<br>pool.close()<br>pool.join() #进程池中进程执行完毕后再关闭，如果注释，那么程序直接关闭。</pre><img src="https://img-blog.csdn.net/20180311182622059?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br><br><br></p>
</p>
<p><br>
</p>
<p><br>
</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:26.935Z" title="3/17/2022, 1:09:26 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:26.935Z" title="3/17/2022, 1:09:26 AM">2022-03-17</time>更新</span><span class="level-item">4 分钟读完 (大约611个字)</span></div></div><div class="content"><p>协程是一种用户态的轻量级线程，本质上是单线程<br></p>
<p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。</p>
<p>因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。&nbsp;&nbsp;</p>
<p>使用greenlet实现协程操作，greenlet需要手动进行切换</p>
<p>首先需要使用greenlet创建类&#20284;与堆栈空间，然后使用switch进行切换</p>
<p><pre name="code" class="python">from greenlet import greenlet

<p>def test1():<br>    print(12)<br>    gr2.switch()<br>    print(34)<br>    gr2.switch()</p>
<p>def test2():<br>    print(56)<br>    gr1.switch()<br>    print(78)</p>
<p>gr1 &#x3D; greenlet(test1)<br>gr2 &#x3D; greenlet(test2)</p>
<p>gr1.switch()</pre><img src="https://img-blog.csdn.net/20180311225407524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p></p>
<p><br>
</p>
<p>使用Gevent实现协程，无需手动切换，遇到IO操作就会进行切换</p>
<p><pre name="code" class="python">import gevent


<p>def func1(num):<br>&amp;nbsp; &amp;nbsp; print(‘in func1’,num)<br>&amp;nbsp; &amp;nbsp; gevent.sleep(1) #模仿IO操作<br>&amp;nbsp; &amp;nbsp; print(‘back func1’)</p>
<p>def func2():<br>&amp;nbsp; &amp;nbsp; print(‘in func2’)<br>&amp;nbsp; &amp;nbsp; gevent.sleep(2) #模仿IO操作<br>&amp;nbsp; &amp;nbsp; print(‘back func2’)</p>
<p>def func3():<br>&amp;nbsp; &amp;nbsp; print(‘in func3’)<br>&amp;nbsp; &amp;nbsp; gevent.sleep(3)<br>&amp;nbsp; &amp;nbsp; print(‘back func3’)</p>
<p>gevent.joinall([<br>&amp;nbsp; &amp;nbsp; gevent.spawn(func1,1),&amp;nbsp; #传参的方式<br>&amp;nbsp; &amp;nbsp; gevent.spawn(func3),<br>&amp;nbsp; &amp;nbsp; gevent.spawn(func2),<br>])<br></pre><img src="https://img-blog.csdn.net/20180311232911179?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br></p>
</p>
<p>先执行func1，打印第一句后遇到IO操作切换到func3又遇到IO，再次切换到func2，遇到IO操作后由于没有可执行的函数，开始等待，func1最先可执行自动跳转到func1打印第二句，然后func2IO操作结束输出func2的第二句，最后func3才结束IO操作，所有func3的第二句最后打印</p>
<p>事件驱动模式：每次有一个事件发生的时候会首先存入到一个消息队列中，然后会有专门的函数循环不断的从队列中取出事件进行处理，执行完一个事件后一般会执行一个回调函数来告知当前事件处理完毕。</p>
<p>异步操作也算是一种事件驱动的模式，遇到IO操作的时候交个操作系统来执行，IO操作结束后会执行一个回调函数告知程序IO结束可继续执行<br>
</p>
<p><br>
</p>
<p><br>
</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:25.758Z" title="3/17/2022, 1:09:25 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:25.758Z" title="3/17/2022, 1:09:25 AM">2022-03-17</time>更新</span><span class="level-item">10 分钟读完 (大约1460个字)</span></div></div><div class="content"><h4>使用python操作redis</h4>
<p>数据库的连接：</p>
<p></p>
<pre class="python">import redis
#连接数据库
db = redis.Redis('localhost',6379)
#连接池
# pool = redis.ConnectionPool(host='localhost',port=6379)
# db = redis.Redis(connection_pool=pool)</pre>
<p><span style="font-size:14px"><strong>String操作：</strong></span></p>
<p>使用key-value的模式来存储，相当于每个name对应一个value</p>
<p><strong><em>set(name, value, ex=None, px=None, nx=False, xx=False)<br>
</em></strong></p>
<p><strong><em>ex，过期时间（秒）<br>
px，过期时间（毫秒）<br>
nx，如果设置为True，则只有name不存在时，当前set操作才执行<br>
xx，如果设置为True，则只有name存在时，岗前set操作才执行</em></strong><br>
</p>
<p></p>
<pre class="python">db.set('name','fml')
print(db.get('name'))</pre>
结果：fml
<p><strong><em>setex(name,value,time)</em></strong></p>
<p><strong><em>time:过期时间（秒）</em></strong></p>
<p></p>
<pre class="python">db.setex('name','1',2)
time.sleep(2)
print(db.get('name'))</pre>
结果：None
<p>同样的还有</p>
<p><strong><em>setnx(name,value)</em></strong>，相当于set()中的nx参数为True</p>
<p><strong><em>psetex(name.time,value</em></strong>),time为毫秒数</p>
<p><em>mset(*args,**kwargs)&nbsp; </em>批量操作，可传入字典</p>
<p>方式一</p>
<p></p>
<pre class="python">db.mset(t1 = 1,t2 = 2)
print(db.get('t1'))
print(db.get('t2'))</pre>
结果 1，2<br>
方式二
<p></p>
<pre class="python">d = {'name':'fml','age':22}
db.mset(d)
print(db.get('name'))
print(db.get('age'))</pre>
结果：&nbsp;fml ， 22<br>
<br>
<p><span style="font-size:12px"><em>get(name):</em></span><span style="font-size:10px">返回name的&#20540;</span></p>
<p><span style="font-size:10px"><strong>mget(keys, *args):</strong>批量操作，返回多个&#20540;（列表的形式），可传入列表<br>
</span></p>
<p><span style="font-size:10px"></span></p>
<pre class="python">print(db.mget('name','age'))
print(db.mget(['t1','t2']))</pre>
<img src="https://img-blog.csdn.net/20180312172020750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<em><br>
</em>
<p><span style="font-size:10px"><em>getset(name,value):</em>设置新的&#20540;并返回之前的&#20540;</span></p>
<p><span style="font-size:10px"></span></p>
<pre class="python">print(db.getset('name','test'))
print(db.get('name'))</pre>
<img src="https://img-blog.csdn.net/20180312172409761?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<p><span style="font-size:10px"><em>getrange(key,start,end):</em>获取子序列（根据字节获取，非字符）</span></p>
<p><span style="font-size:10px"><span style="color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px">start：起始位，end结束位,&#20540;得注意的是这个是按照字节来计算而不是字符个数&nbsp;在utf-8的编码中一个中文汉字占三个字节，一个字符只占一位</span></span></p>
<p><span style="font-size:10px"><span style="color:rgb(51,51,51); font-family:verdana,Arial,Helvetica,sans-serif; font-size:10px"></span></span></p>
<pre class="python">db.set('name1','fml')
print(db.getrange('name1', 0, 1).decode())
db.set('name2','名字')
print(db.getrange('name2', 0, 2).decode())</pre>
<img src="https://img-blog.csdn.net/20180312182537723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<p><em>setrange(name, offset, value):&nbsp; &nbsp;</em>从指定字符串索引开始向后替换（新&#20540;太长时，则向后添加）<br>
</p>
<p>offset:字符串索引号</p>
<p></p>
<pre class="python">db.set('name','test set range')
db.setrange('name',1,'ls')  #从第二个字符开始替换
print(db.get('name').decode())</pre>
<img src="https://img-blog.csdn.net/20180312183816787?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="">
<p><em>setbit(name, offset, value)：</em>和上面的一个功能类&#20284;，只不过是用bite方式来更改<br>
</p>
<p><strong><em>getbit(name, offset)</em></strong>：获取name的二进制表示中的某一位&#20540;<br>
</p>
<p><em>bitcount(key, start=None, end=None)：</em>统计name用二进制表示中的为1的个数</p>
<p>start，位起始位置end，位结束位置</p>
<p></p>
<pre class="python">db.set('name','f')
print(db.bitcount('name'))
#f对应的ASCII码的&#20540;为102,102转为二进制为 0110 0110 所以返回&#20540;为4</pre>
<em>strlen(name):</em>返回name对于&#20540;的<strong>字节长度</strong>，汉字三字节
<p></p>
<pre class="python">db.set('name1','发生')
db.set('name2','fml')
print(db.strlen('name1'))
print(db.strlen('name2'))</pre>
<img src="https://img-blog.csdn.net/20180312214428147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<p><strong><em>incr(self, name, amount=1)：</em></strong> name的对应&#20540;增加amount<br>
</p>
<p><strong>自增只适用于整数</strong>，当name不存在的时候会新建一个name&#20540;为amount<br>
</p>
<p></p>
<pre class="python">db.set('num1',2)
db.incr('num1', amount=2)
db.incr('num2', amount=2)
print(db.get('num1').decode())
print(db.get('num2').decode())</pre>
<img src="https://img-blog.csdn.net/20180312215147018?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<p><strong>incrbyfloat(self, name, amount=1.0)：</strong>同上只不过是浮点型<br>
</p>
<p><em>decr(self, name, amount=1)：</em>同上功能为自减<br>
</p>
<p><strong><em>append(key, value) ：</em></strong>在name对应&#20540;后面追加value的内容，如果没有name就会新建一个name=value<br>
</p>
<p></p>
<pre class="python">db.set('name','fml')
db.append('name','test')
print(db.get('name').decode())</pre>
<img src="https://img-blog.csdn.net/20180312220700495?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<p><br>
</p>
<p><span style="font-weight:bold; font-size:14px">Hash操作</span><br>
<span style="font-size:10px">使用字典的方式来存储，name为字典名</span></p>
<p><strong><em>hset(name, key, value):</em></strong><br>
</p>
<p><pre name="code" class="python">db.hset('info','name','fml')
db.hset('info','age',22)
print(db.hget('info','name').decode())
print(db.hget('info','age').decode())</pre><strong style="font-style:italic">hmset(name, mapping)：</strong>批量操作 ，mapping为字典</p>
<p><pre name="code" class="python">db.hmset('info1',{'name1':'fml','age1':23})
print(db.hget('info1','name1').decode())
print(db.hget('info1','age1').decode())</pre></p>
<p><img src="https://img-blog.csdn.net/20180313150927616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
</p>
<p><strong style="font-style:italic">hget(name,key)：</strong>同get操作</p>
<p><strong style="font-style:italic">hmget(name, keys, *args)：</strong>同mget,可传入列表或者多个&#20540;<br>
</p>
<p><strong style="font-style:italic">hgetall(name)：</strong>获取name的所有key-和value&#20540;<br>
</p>
<p><strong><em>hlen(name)：</em></strong>获取name中key的个数<br>
</p>
<p><strong><em>hkeys(name)：</em></strong>获取name中所有的key<br>
</p>
<p><strong><em>hvals(name)：</em></strong>获取name中所有的value&#20540;<br>
</p>
<p><strong><em>hexists(name, key)：</em></strong>判断name中是否存在传入的key<br>
</p>
<p><strong><em>hdel(name,*keys)：</em></strong>删除name中的key，若不存在返回0，删除成功后返回1<br>
</p>
<p><strong><em>hincrby(name, key, amount=1)：</em></strong>自增，同string操作一样<br>
</p>
<p><strong><em>hincrbyfloat(name, key, amount=1.0)</em></strong>&nbsp;自增浮点型<br>
</p>
<p><br>
</p>
<p>hscan(name, cursor=0, match=None, count=None)&nbsp;过滤获取多个&#20540;<br>
</p>
<p>cursor:起始位置，match：过滤方法 ，count：获取的个数</p>
<p>过滤方法的例子：1：获取以n开头的key ：n*</p>
<p><span style="white-space:pre"></span>&nbsp; &nbsp; &nbsp;2：获取包含a的key：*a*</p>
<p><span style="white-space:pre"></span>&nbsp; &nbsp; &nbsp;3：获取以e结尾的key：*e</p>
<p><pre name="code" class="python">db.hset('info','name','fml')
db.hset('info','age',22)
print(db.hscan('info',cursor=0,match= 'n*'))
print(db.hscan('info',cursor=0,match= '*e'))
print(db.hscan('info',cursor=0,match= '*g*'))</pre><img src="https://img-blog.csdn.net/20180313154353952?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
</p>
<p><br>
</p>
<p><span style="font-size:14px; font-weight:700">List操作</span><br>
</p>
<p><span style="font-size:14px; font-weight:700"><br>
</span></p>
<p><strong style=""><em style=""><span style="font-size:10px">lpush(name,values):&nbsp;向name添加元素，从左边开始添加</span></em></strong></p>
<p><pre name="code" class="python" style=""><span style="font-size:10px;">db.lpush('list','1','2','3')
print(db.lrange('list',0,-1))</span></pre><span style="font-size:14px"><img src="https://img-blog.csdn.net/20180313165641539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></span><br>
<em><strong style=""><span style="font-size:10px">lpush(name,values):&nbsp;向name添加元素，从右边开始添加</span></strong></em><br>
</p>
<p><pre name="code" class="python">db.rpush('list3','1','2','3')
print(db.lrange('list3',0,-1))</pre><img src="https://img-blog.csdn.net/20180313165843605?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><br>
<strong><em>lpushx(name,value)：</em></strong>只有当name存在的时候才在左边添加，相同的还有rpushx(name.value)<br>
</p>
<p><pre name="code" class="python">db.rpush('list3','1','2','3')
db.lpushx('list3',4)
print(db.lrange('list3',0,-1))</pre><img src="https://img-blog.csdn.net/20180313170111945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong><em>llen(name):&nbsp;</em></strong>返回name的存储的长度</p>
<p><strong><em>linsert(name, where, refvalue, value))&nbsp;</em></strong> 在name的refvalue前面或后面插入value,如果存在多个refvalue的时候只会在从左往右数第一个起作用</p>
<p>where：BEFORE/AFTER</p>
<p><pre name="code" class="python">db.rpush('list5','1','2','3')
db.linsert('list5','BEFORE','2','5')
db.linsert('list5','AFTER','2','6')
print(db.lrange('list5',0,-1))</pre><img src="https://img-blog.csdn.net/20180313170630387?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<br>
<strong><em>lset(name, index, value)：</em></strong>修改index索引的&#20540;<br>
</p>
<p><pre name="code" class="python">db.rpush('list6','1','2','3')
db.lset('list6',1,4)
print(db.lrange('list6',0,-1))</pre><img src="https://img-blog.csdn.net/20180313171210000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>
<strong><em>lrem(name, value, num)：</em></strong>删除name中的value，num为需要删除的个数<br>
</p>
<p><pre name="code" class="python">db.rpush('list7',1,2,3,4,1,2,4,5,7)
db.lrem('list7',1,1)
db.lrem('list7',2,2)
print(db.lrange('list7',0,-1))</pre><img src="https://img-blog.csdn.net/20180313172150477?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p><strong><em>lpop(name)：</em></strong>删除左边第一个&#20540;并返回，同样的还有<strong><em>rpop(name)：</em></strong>从右边弹出<br>
</p>
<p><strong><em>lindex(name, index)：</em></strong>获取index索引的&#20540;<br>
</p>
<p><strong><em>lrange(name, start, end)：</em></strong>返回切片获得的&#20540;<br>
</p>
<p><strong><em>ltrim(name, start, end)：</em></strong>删除除start-end之外的所有&#20540;<br>
</p>
<p><strong><em>rpoplpush(src, dst) ：</em></strong>删除src的最右的一个&#20540;，并把它添加到dst的最左边<br>
</p>
<p><strong><em>blpop(keys, timeout)：</em></strong>将多个列表排列，按照从左到右去pop对应列表的元素&nbsp; 同<strong><em>brpop(keys, timeout)</em></strong><br>
</p>
<p><strong style="font-style:italic">brpoplpush(src, dst, timeout=0)：</strong>从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧<br>
</p>
<p><br>
</p>
<p><span style="font-size:14px; font-weight:700">set集合操作</span><br>
</p>
<p><br>
</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:23.340Z" title="3/17/2022, 1:09:23 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:23.340Z" title="3/17/2022, 1:09:23 AM">2022-03-17</time>更新</span><span class="level-item">14 分钟读完 (大约2085个字)</span></div></div><div class="content"><h4>安装</h4>
<div>RabbitMQ是使用Erlang开发的，因此我们需要首先安装Erlang。<a target="_blank" href="http://www.erlang.org/downloads">http://www.erlang.org/downloads</a>下载对应的版本，安装完成后即可进入下一步。</div>
<div>下载RabbitMQ&nbsp;<a target="_blank" href="http://www.rabbitmq.com/download.html">http://www.rabbitmq.com/download.html</a>&nbsp;选择默认安装即可，安装完成后可在开始菜单中找到</div>
<div><img src="https://img-blog.csdn.net/20180419202452158?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></div>
<div>点击 RabbitMQ Service - start就开始运行了</div>
<h4>使用Python进行操作</h4>
<div>这里我们需要用到pika这个模块来实现，安装好之后我们就可以实现最简单的例子了</div>
<h6>第一个程序Hello world</h6>
<p>下面两个例子都来自于官方示例</p>
<p>消息传递模型</p>
<p><img src="https://img-blog.csdn.net/20180421160239802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>
</p>
<div>send.py</div>
<div>
<pre class="python">import pika

<p>connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(host&#x3D;’localhost’))<br>channel &#x3D; connection.channel()</p>
<p>channel.queue_declare(queue&#x3D;’hello’)</p>
<p>channel.basic_publish(exchange&#x3D;’’,<br>                      routing_key&#x3D;’hello’,<br>                      body&#x3D;’Hello World!’)<br>print(&quot; [x] Sent ‘Hello World!’&quot;)<br>connection.close()</pre><br>receive.py</div></p>
<div>
<pre class="python">import pika

<p>connection &#x3D; pika.BlockingConnection(pika.ConnectionParameters(host&#x3D;’localhost’))<br>channel &#x3D; connection.channel()</p>
<p>channel.queue_declare(queue&#x3D;’hello’)</p>
<p>def callback(ch, method, properties, body):<br>    print(&quot; [x] Received %r&quot; % body)</p>
<p>channel.basic_consume(callback,<br>                      queue&#x3D;’hello’,<br>                      no_ack&#x3D;True)</p>
<p>print(‘ [*] Waiting for messages. To exit press CTRL&amp;#43;C’)<br>channel.start_consuming()</pre><br>依次运行这两个函数结果如下</div></p>
<div><img src="https://img-blog.csdn.net/20180419203216036?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></div>
<div><img src="https://img-blog.csdn.net/20180419203343047?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFuTUxlaQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></div>
<div>下面我们再来具体看一看每条语句的具体作用</div>
<div>
<pre class="python">connection = pika.BlockingConnection（pika.ConnectionParameters（'localhost'））
channel = connection.channel（）</pre>
第一句是建立连接的，rabbitmq支持本地连接也支持连接到其他机器上，在这里我们选择本地连接。</div>
<div>第二句是创建一个新的管道，之后的所有操作都是在这个管道上进行的。<br>
<pre class="python">channel.queue_declare(queue='hello')</pre>
<div>声明一个队列名为hello，如果你确认这个队列存在那么不声明也是可以的，但是最好声明一下以免造成其他的麻烦。</div>
</div>
<div>
<pre class="python">channel.basic_publish(exchange='',
                      routing_key='hello',
                      body='Hello World!')</pre>
</div>
<div>向队列中发送一条消息，其中routing_key指定队列名，body为消息内容</div>
<pre class="python">connection.close()</pre>
<p>关闭连接</p>
<p>receive.py中前面几句和send中的作用是一样的，这里不再赘述。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<pre class="python">def callback(ch, method, properties, body):
    print(&quot; [x] Received %r&quot; % body)</pre>
<p>callback是回调函数，当程序从队列中获取消息后都会执行回调函数来处理消息&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p>
<pre class="python">channel.basic_consume(callback,
                      queue='hello',
                      #no_ack=True
                      )</pre>
<p>从队列中获取消息，callback指定回调函数，queue指定获取的队列名，no_ack在以后再说明&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</p>
<pre class="python">channel.start_consuming()</pre>
<p>让程序进入到一个死循环中，不断从队列中取出消息</p>
<h6>消息队列的循环调度</h6>
<p>消息传递模型</p>
<p><img src="https://img-blog.csdn.net/20180421160404952?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>当我们启动多个程序从同一个队列中接收消息的时候，默认是依次接收，即第一个启动的程序首先接收到然后是第二个启动的程序,直到最后一个程序收到之后又从第一个开始，但是这样会造成一个后果就是，可能每个程序或者机器的处理速度不同，造成有的在等待有的消息过多。如下图启动两个接收程序，并发送从0-4数字，两个程序接收的消息依次为：</p>
<p><img src="https://img-blog.csdn.net/20180421141241831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><img src="https://img-blog.csdn.net/20180421141300490?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>
</p>
<h6>消息确认</h6>
<p>在实际应用中一般程序接收消息后处理需要时间，如果在处理的过程中程序崩溃了那么那个消息就会从消息队列中消失了，这当然不是我们想要的结果，我们需要在程序崩溃之后将那条消息转发到另一个程序中执行，这时候我们需要设置只有在消息被确认后才将消息从队列中删除，RabbitMQ默认消息确认是打开的，但是我们可以添加参数no_ack = True来取消，这样即使消息为处理完成也不会再次发送了，会直接从队列中去除。我们还可以使用手动消息确认即在callback中添加一句：</p>
<pre class="sourcecode python hljs" style="padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left"><span style="vertical-align:inherit">ch.basic_ack（delivery_tag = method.delivery_tag）</span></pre>
<h6>消息持久化</h6>
<p>上面我们已经说了如何保证消费者崩溃时还保留消息，现在我们将介绍如何在RabbitMQ服务终止后还会保留消息队列。这里需要我们在声明这个队列的时候添加一个参数来实现</p>
<pre class="sourcecode python hljs" style="padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left"><span style="vertical-align:inherit">channel.queue_declare（queue = </span><span class="hljs-string" style="color:rgb(165,194,97)">'hello'</span><span style="vertical-align:inherit">，durable = </span><span class="hljs-keyword" style="color:rgb(194,98,48)">True</span><span style="vertical-align:inherit">）</span></pre>
<p>但是这只是保证了hello队列的持久化（下次重启服务的时候队列依然存在），但是队列中消息内容依然是不会被保留下来的，我们想要同时将消息保留下来还需要在channel.basic_publish()函数中添加下面这个参数</p>
<pre class="sourcecode python hljs" style="padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left"> properties=pika.BasicProperties(delivery_mode = <span class="hljs-number" style="color:rgb(165,194,97)">2</span>)</pre>
<p>需要注意的是消息内用只会暂存于缓存中，并未正真写入磁盘中永久保留，还有就是要实现消息持久化的前提是当前队列也是持久化的（不会报错，但是消息并没有被保留下来）</p>
<h6>公平派遣</h6>
<p></p>
<p>实际应用场景中，有些程序或者是机器处理消息的能力强一些，有些会弱一些，那么按照上面的操作所有的消息都是循环分发的这样就会导致有些机器空闲而有些会出现消息过多处理不过来的情况，为了解决这个问题我们可以在消费者中设置最多可容纳多少条消息，当消息数目满了之后就不会再接收新的消息，直到消息被处理完了留有空余才会再次接收消息。</p>
<pre class="sourcecode python hljs" style="padding:.5em; background-color:rgb(35,35,35); color:rgb(230,225,220); font-size:14px; white-space:pre-wrap; letter-spacing:.16px; text-align:left"><span style="vertical-align:inherit">channel.basic_qos（prefetch_count = </span><span class="hljs-number" style="color:rgb(165,194,97)">1</span><span style="vertical-align:inherit">）</span></pre>
<p>需要注意的是prefetch_count参数&#20540;并未实际意义，只要为True即可，也就是设置后消费者每次只能接收一个消息与参数&#20540;无关。</p>
<h6>广播模式</h6>
<div>消息传递模型</div>
<p><img src="https://img-blog.csdn.net/2018042117585856?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>上面所有的都是一对一的消息传递，下面将说一说一对多的传递模型，即广播模式，就好比收音机收听广播一样，需要一个发布者，其他的都是订阅者，发布者发布消息只要订阅者订阅了这个频道那么所有的订阅者都能收到消息。这里的消息传递模型就与之前的略有不同。消息并不是直接发送到队列中，而是经过一个交易所来分发到不同的队列中如上图所示。那么有人会问了，交易所是如何知道要分发到哪一个队列呢，其实只需要将队列和交易所绑定在一起就可以了，每一次消息过来的时候交易所会将消息转发到所有和他绑定的队列中。</p>
<pre class="python">channel.exchange_declare(exchange='logs',
                         exchange_type='fanout')

<p>message &#x3D; &quot;info: Hello World!&quot;<br>channel.basic_publish(exchange&#x3D;’logs’,<br>                      routing_key&#x3D;’’,<br>                      body&#x3D;message)</pre></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px">其中exchange_type类型有direct、topic、headers、fanout<span style="letter-spacing:.16px; text-align:left; white-space:pre-wrap"><span style="color:#333333">这四种，下面主要说明fanout类型。</span></span>上面这段程序指定了一个名为logs的交易所，类型为fanout，下面向这个exchange里面publish一条message消息，routing_key为空表示使用默认操作或称为无名交换。完成了发送程序，下面再来说说接收程序。</span></p>
<pre class="python">channel.exchange_declare(exchange='logs',
                         exchange_type='fanout')

<p>result &#x3D; channel.queue_declare(exclusive&#x3D;True)<br>queue_name &#x3D; result.method.queue</p>
<p>channel.queue_bind(exchange&#x3D;’logs’,<br>                   queue&#x3D;queue_name)</pre></p>
<p><span style="font-family:'Microsoft YaHei'; font-size:14px">在第四行代码中声明了一个随机名称的队列，exclusive=True将会让程序在消费者断开连接的时候删除这个队列&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 在第七行代码中我们将生成的随机队列和我们之前的交换所绑定在一起，这样当一个消息过来的时候交易所会将消息分发到我们绑定过的队列中</span></p>
<h6><span style="font-family:'Microsoft YaHei'; font-size:14px">路由</span></h6>
<p><img src="https://img-blog.csdn.net/20180423153004240?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>如上图所示</p>
<p><br>
</p>
<p></p>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<p></p>
<p></p>
<p></p>
<p><br>
</p>
<p></p>
<p><br>
</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:22.024Z" title="3/17/2022, 1:09:22 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:22.024Z" title="3/17/2022, 1:09:22 AM">2022-03-17</time>更新</span><span class="level-item">5 分钟读完 (大约810个字)</span></div></div><div class="content"><p><span style="color:#ff0000">自学笔记：逻辑可能比较混乱，想到哪说到哪，可能存在不少的问题欢迎指出。</span></p>
<h3>创建一个类：</h3>
<h4>最简单的一个类</h4>
<div>在python中类的命名必须以字母或者下画线开头，并且只能包含字母、下画线和数字。另外推荐使用驼峰命名方式（大写字母开头，随后的任意一个单词都以大写字母开头）</div>
<div>python最简单的一个类的创建</div>
<div><pre name="code" class="python">class MyFirstClass:
    pass</pre>
<h4>类的属性和方法</h4>
在类中我们还可以为其添加属性和方法</div>
<div><pre name="code" class="python">class MyFirstClass:
    def __init__(self):
        self.x = 1
        self.y = 1

<pre><code>def show(self):
    print(self.x,self.y)
</code></pre>
<p>c &#x3D; MyFirstClass()<br>c.show()</pre></div></p>
<div>其中self.x和self.y为该类的属性，show()为该类的方法</div>
<div>类中的方法的定义方式和普通函数相同，都是以关键字def开头，但是有一点不同的是类中的方法有一个必需的参数，通常这个参数被命名为self,但是我们实例化类后调用show方法的时候并没有传入参数，这是因为python自动帮我们做了，当我们调用c对象的show方法的时候，python会自动将c对象传给show方法了。因此下面这个调用方式运行结果是一样的。</div>
<div><pre name="code" class="python">c = MyFirstClass()
MyFirstClass.show(c)</pre>其实类中的方法本质上就是一个函数，我们可以在外部调用也可以在类中调用，例如：</div>
<div><pre name="code" class="python">class Point:
    def __init__(self, x ,y ):
        self.x = x
        self.y = y

<pre><code>def reset(self):
    self.x = 0
    self.y = 0
    self.show()

def show(self):
    print(self.x, self.y)
</code></pre>
<p>p &#x3D; Point(1,1)<br>p.reset()</pre></div></p>
<div>运行结果为：0&nbsp; 0</div>
<div>
<h4>类的初始化</h4>
<div>一般的编程语言中都有一个叫构造函数的特殊方法，当它被创建的时候会创建和初始化对象，这一点Python会有些许不同，python有一个构造函数和一个初始化函数，一般情况下构造函数很少被用到，除非是想实现一些特别的操作，所以在此主要说一下类的初始化。我们在之前的示例中有一个方法名为__init__(),其实这个方法就是给类进行初始化操作的。当我们实例化的时候会首先执行__init__()方法，因此当__init__()方法需要传递参数的时候我们在实例化的时候同样需要传递参数，不然会报错。</div>
<div>由于方法本质上就是函数，当我们不想传递参数的时候也可以同函数的操作一样使用默认参数。</div>
<div><pre name="code" class="python">def __init__(self, x=0, y=0):
    self.x = x
    self.y = y</pre></div>
</div>
<h3>面向对象三个基本特征</h3>
<div>面向对象编程的三个基本特征分别为：封装、继承、多态，下面一一说明。</div>
<h4>继承</h4>
<div>继承就是让一个类获得另一个类的属性和方法，在Python中所有的类都是object类的子类，只是在实际的使用中我们并不需要表明，python在后台自己帮我们做了</div>
<div><br>
</div>
<div><br>
</div>
<div><br>
</div>
<p><br>
</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:07.787Z" title="3/17/2022, 1:09:07 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:07.787Z" title="3/17/2022, 1:09:07 AM">2022-03-17</time>更新</span><span class="level-item">10 分钟读完 (大约1476个字)</span></div></div><div class="content"><p style="margin-left:0pt;"><strong><strong>显示所有数据库：</strong></strong>show databases;<br /><img alt="" class="has" height="176" src="https://img-blog.csdn.net/20180818091228226?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="260" /></p>

<p style="margin-left:0pt;"><strong><strong>新建数据库：</strong></strong>create database dbname;</p>

<p style="margin-left:0pt;"><strong><strong>删除数据库：</strong></strong>drop database dbname;</p>

<p style="margin-left:0pt;"><strong><strong>切换数据库：</strong></strong>use dbname;</p>

<p style="margin-left:0pt;"><strong><strong>新建表：</strong></strong>create table tbname(clo1 type ,col2 type,……);<br /><img alt="" class="has" height="158" src="https://img-blog.csdn.net/20180818091257226?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="350" /></p>

<p style="margin-left:0pt;"><strong><strong>显示所有表：</strong></strong>show tables;</p>

<p style="margin-left:0pt;"><strong><strong>根据已有表结构创建新表：</strong></strong></p>

<p style="margin-left:0pt;">create table new_table_name like old_table_name;</p>

<p style="margin-left:0pt;">create table new_table as select col1,col2,…. from old_table only;</p>

<p style="margin-left:0pt;"><strong><strong>显示表结构：</strong></strong>describe table_name;<br /><img alt="" class="has" height="119" src="https://img-blog.csdn.net/20180818091433792?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="412" /></p>

<p style="margin-left:0pt;"><strong><strong>删除表：</strong></strong>drop table table_name;</p>

<p style="margin-left:0pt;"><strong><strong>增加一列：</strong></strong>alter table tbname add column col type;</p>

<p style="margin-left:0pt;"><strong><strong>删除一列：</strong></strong>alter table tbname drop column name;</p>

<p style="margin-left:0pt;"><strong><strong>修改列属性:</strong></strong>alter table tbname modify col typr;</p>

<p style="margin-left:0pt;"><strong><strong>增加主键：</strong></strong>alter table tbname add primary key (col);</p>

<p style="margin-left:0pt;"><strong><strong>删除主键：</strong></strong>alter table tbname drop primary key(col);</p>

<p style="margin-left:0pt;"><strong><strong>修改表名：</strong></strong>alter table tbname rename new;</p>

<p style="margin-left:0pt;"><strong><strong>创建索引：</strong></strong>create index idxname on tbname (col,….);</p>

<p style="margin-left:0pt;"><strong><strong>删除索引：</strong></strong>drop index idxname on tbname;</p>

<p style="margin-left:0pt;"><strong><strong>查看索引：</strong></strong>show index from tbname;</p>

<p style="margin-left:0pt;"><strong><strong>创建视图：</strong></strong>create view name as select (col,….) from tbname;</p>

<p style="margin-left:0pt;"><strong><strong>删除视图：</strong></strong>drop view name;</p>

<p style="margin-left:0pt;"> </p>

<p style="margin-left:0pt;"><strong><strong>增删改查：</strong></strong></p>

<p style="margin-left:0pt;"><strong><strong>增：</strong></strong>insert into tbname (col,col,…) values(value1,value2,…);</p>

<p style="margin-left:0pt;"><strong><strong>删：</strong></strong>delete from tbname where 条件;</p>

<p style="margin-left:0pt;"><strong><strong>改：</strong></strong>update tbname set field=value where条件;</p>

<p style="margin-left:0pt;"><strong><strong>查：</strong></strong>select filed from tbname where 条件;</p>

<p style="margin-left:0pt;"> </p>

<p style="margin-left:0pt;"><strong><strong>求和：</strong></strong>select sum(col) as name from tbname;</p>

<p style="margin-left:0pt;"><strong><strong>平均：</strong></strong>select avg(col) as name from tbname;</p>

<p style="margin-left:0pt;"><strong><strong>最大：</strong></strong>select max(col) as name from tbname;</p>

<p style="margin-left:0pt;"><strong><strong>最小：</strong></strong>select min(col) as name from tbname;</p>

<p style="margin-left:0pt;"> </p>

<p style="margin-left:0pt;"><strong><strong>外键定义：</strong></strong>外键是指引用另一个表中的一列或者多列，被引用的列应该具有主键约束或者唯一约束，外键用于建立和加强两个表数据之间的连接，被引用的表是主表，引用外键的表是从表。</p>

<p style="margin-left:0pt;"><strong><strong>多表操作：</strong></strong></p>

<p style="margin-left:0pt;"><strong><strong>建立外键：</strong></strong>alter table tbname add constraint 外键名 froeign key(外键字段名) references 外表表名(主键字段名);</p>

<p style="margin-left:0pt;">示例：alter table student add constraint fk_id foreign key(gid) references grade(id);</p>

<p style="margin-left:0pt;"><strong><strong>删除外键：</strong></strong>alter table tbname drop foreign key 外键名;</p>

<p style="margin-left:0pt;">示例：alter table student drop foreign key fk_id;</p>

<p style="margin-left:0pt;"><strong><strong>添加数据：</strong></strong>当有外键的表添加数据的时候其字段值只能是被关联表中已有的数据，例如grade中id字段只有1和2，那么student中的gid值只能设为1和2.</p>

<p style="margin-left:0pt;"><strong><strong>删除数据：</strong></strong>因为grade表和student表具有关联关系，参照列中的被参照值是不能被删除的，所以想删除grade表中的数据必须先将student中关联数据都删除掉后再删除grade中的数据。</p>

<p style="margin-left:0pt;"><strong><strong>连接查询：</strong></strong></p>

<p style="margin-left:0pt;">首先建立两个表：</p>

<p style="margin-left:0pt;">表1：create table department (did int not null primary key, dname varchar(32));</p>

<p style="margin-left:0pt;">表2：create table employee(id int not null primary key, name varchar(32), age int, did int not null);</p>

<p style="margin-left:0pt;">插入数据</p>

<p style="margin-left:0pt;">insert into department(did,dname)VALUES (1,'网络部'),(2,'媒体部'),(3,'研发部'),(5,'人事部');</p>

<p style="margin-left:0pt;"><span style="color:#000000;">I</span><span style="color:#000000;">nsert into</span><span style="color:#000000;"> employee(id,name,age,did)</span> <span style="color:#000000;">VALUES (1,'王红',20,1),(2,'李强',22,1),(3,'赵四',20,2),(4,'郝娟',20,4);</span></p>

<p style="margin-left:0pt;"><strong><strong>交叉连接：</strong></strong>交叉连接返回的结果是两个连接表中所有数据的笛卡尔集，即返回第一个表中符合条件的数据乘以第二个表中符合条件的数据。</p>

<p style="margin-left:0pt;">语句：select 字段 from tbname1 cross join tbname2;</p>

<p style="margin-left:0pt;">例如：select * from department cross join employee;</p>

<p style="margin-left:0pt;">返回结果为：有16行（4*4）</p>

<p style="margin-left:0pt;"><strong><strong>内连接：</strong></strong>使用比较运算符对两个表中的数据进行比较，并列出与连接条件匹配的数据</p>

<p style="margin-left:0pt;">语句：select 字段 from tbname1 [inner] join tbname2 on tbname1.关系字段=tbname2.关系字段;</p>

<p style="margin-left:0pt;">例如 select name from employee join department on employee.did=department.did;</p>

<p style="margin-left:0pt;">返回结果为：3行（did为1，2，3的数据）<br /><img alt="" class="has" height="109" src="https://img-blog.csdn.net/20180818091518909?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="123" /></p>

<p style="margin-left:0pt;"><strong><strong>自连接：</strong></strong>如果在一个连接查询中涉及的两个表其实是同一个表，这种查询称为自连接查询</p>

<p style="margin-left:0pt;">语句：select p1.* from tbname as p1 join tbname as p2 on p1.字段 = p2.字段;</p>

<p style="margin-left:0pt;">示例：查询 name为王红的人所属部门员工</p>

<p style="margin-left:0pt;">select p1.* from employee as p1 join employee as p2 on p1.did = p2.did where p2.name = ‘王红’;</p>

<p style="margin-left:0pt;">返回结果为：2行（网络部的两个：王红和李强）<br /><img alt="" class="has" height="114" src="https://img-blog.csdn.net/20180818091540331?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="229" /></p>

<p style="margin-left:0pt;"> </p>

<p style="margin-left:0pt;"><strong><strong>外连接：</strong></strong>外连接分为左连接和右连接，当返回的查询结果不仅需要包括符合条件的数据，还需要包含其中的一个表或者两个表的所有数据的时候，需要用到外连接查询</p>

<p style="margin-left:0pt;">语句：select 字段 from tbname1 left|right [outer] join tbname2;</p>

<p style="margin-left:0pt;">左连接：left join：返回包括左表中的所有记录和右表中符合条件的记录。</p>

<p style="margin-left:0pt;">例如：select department.dname,employee.name from department left join employee on department.did = employee.did;</p>

<p style="margin-left:0pt;"><img alt="" class="has" height="146" src="https://img-blog.csdn.net/20180818091604776?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="157" /></p>

<p style="margin-left:0pt;">右连接：right join：返回包括右表的所有记录和左表符合条件的记录。</p>

<p style="margin-left:0pt;">例如：select department.dname,employee.name from department right join employee on department.did = employee.did;</p>

<p style="margin-left:0pt;"><img alt="" class="has" height="123" src="https://img-blog.csdn.net/20180818091619299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="155" /></p>

<p style="margin-left:0pt;"><strong><strong>子查询：</strong></strong>指一个查询语句嵌套在另一个查询语句内部的查询，在执行的时候会先执行子查询中的语句，然后将返回的结果作为外层查询的过滤条件。<strong><strong>需要注意的是第一个条件的判断字段要包含在第二个查询语句的字段中，否则报错。</strong></strong></p>

<p style="margin-left:0pt;"><strong><em><strong><em>IN/NOT IN语句</em></strong></em></strong>：select 字段from tbname where 条件 in /not in (select 字段 where 条件)  </p>

<p style="margin-left:0pt;"><strong><em><strong><em>EXISTS语句</em></strong></em></strong>：EXISTS关键字后面的参数可以是任何一个子查询，但是不会产生任何数据，只返回TRUE或者FALSE，当返回TRUE的时候外层查询才会执行。</p>

<p style="margin-left:0pt;">语句：select 字段 from tbname where exists (select 字段 from tbname where 条件)</p>

<p style="margin-left:0pt;"><strong><em><strong><em>ANY语句：</em></strong></em></strong>ANY关键字表示只要满足内层子查询中的任意一个条件，就会返回一个结果作为外层查询条件。</p>

<p style="margin-left:0pt;">语句：select 字段from tbname where 字段 比较符 any(select字段 from tbnamewhere条件)</p>

<p style="margin-left:0pt;"><strong><em><strong><em>ALL语句</em></strong></em></strong>：类似于ANY只是他需要满足所有条件</p>

<p style="margin-left:0pt;">语句：select字段 from tbname where 字段 比较符 all(select 字段 from tbname where条件)</p>

<p style="margin-left:0pt;"> </p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:09:04.153Z" title="3/17/2022, 1:09:04 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:09:04.154Z" title="3/17/2022, 1:09:04 AM">2022-03-17</time>更新</span><span class="level-item">42 分钟读完 (大约6243个字)</span></div></div><div class="content"><h1 style="margin-left:0pt;"><strong>原题链接：</strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wupeiqi/p/9078770.html">https://www.cnblogs.com/wupeiqi/p/9078770.html</a></h1>

<p style="margin-left:0pt;">部分图片是从其他博客上整理出来的，时间有些久了当初是写在word上的忘记参考出路了，有些答案我也不知道是否回答准确，如有错误还请提出，谢谢</p>

<p style="margin-left:0pt;"><strong><strong>基础部分</strong></strong></p>

<p><span style="color:#333333;">1.简述解释型和编译型编程语言？</span></p>

<p style="margin-left:18pt;"> 解释型语言在运行之前不会有编译过程，由解释器在运行的过程中解释运行的常见的解释型语言还有PHP、JS、ruby等等。</p>

<p style="margin-left:18pt;"> 编译型语言在运行之前需要使用编译器编译成机器码，计算机就可以直接运行编译过后的文件了。</p>

<p style="margin-left:18pt;">一般来说编译型语言要比解释型语言运行速度要快的，应为解释型语言每执行一次就需要翻译一次，效率比较慢。</p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">2.Python解释器种类以及特点</span></p>

<p style="margin-left:0pt;"><span style="color:#333333;">      常见的解释器有5个CPython</span><span style="color:#333333;">、</span><span style="color:#333333;">IPython</span><span style="color:#333333;">、</span><span style="color:#333333;">PyPy</span><span style="color:#333333;">、</span><span style="color:#333333;">Jython</span><span style="color:#333333;">、IronP</span><span style="color:#333333;">ython</span><span style="color:#333333;">.</span></p>

<p style="margin-left:0pt;"><span style="color:#333333;">      CPython</span><span style="color:#333333;">是官方版本的解释器，由C语言编写，运用也是最为广泛的。</span></p>

<p style="margin-left:0pt;"><span style="color:#333333;">      IPython是基于CPython的，只是在交互上做出了进一步的改善，例如代码补全。</span></p>

<p style="margin-left:0pt;"><span style="color:#333333;">      PyPy采用了JIT技术，可以动态编译python程序，提高其工作效率。</span></p>

<p style="margin-left:0pt;"><span style="color:#333333;">      Jython是在Java平台上运行的解释器，可在将python程序编译成Java字节码运行。</span></p>

<p style="margin-left:0pt;"><span style="color:#333333;">      IronP</span><span style="color:#333333;">ython和Jython类似，运行在.NET平台上。</span></p>

<p style="margin-left:0pt;"> </p>

<p><span style="color:#333333;">3.位和字节的关系？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">位（bit）是计算机存储中的最小单位。只有0、1两种状态</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">字节（Byte）一个字节由8个bit组成，是计算机数据处理的最小单位。</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">4.使用python进制转换</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">二进制转换成十进制：v = “0b1111011”</span> <br /><span style="color:#333333;">十进制转换成二进制：v = 18</span>  <br /><span style="color:#333333;">八进制转换成十进制：v = “011”</span>  <br /><span style="color:#333333;">十进制转换成八进制：v = 30</span>  <br /><span style="color:#333333;">十六进制转换成十进制：v = “0x12”</span>  <br /><span style="color:#333333;">十进制转换成十六进制：v = 87</span><br /><img alt="" class="has" height="200" src="https://img-blog.csdn.net/201809201420160?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="341" /></p>

<p><span style="color:#333333;">5.请编写一个函数实现将IP地址转换成一个整数。</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">如 10.3.9.12 转换规则为：</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">      10          </span> <span style="color:#333333;">00001010</span></p>

<p style="margin-left:18pt;"> <span style="color:#333333;">       3           </span> <span style="color:#333333;">00000011</span> </p>

<p style="margin-left:18pt;"><span style="color:#333333;">       9           </span> <span style="color:#333333;">00001001</span></p>

<p style="margin-left:18pt;"> <span style="color:#333333;">      12          </span> <span style="color:#333333;">00001100</span> </p>

<p style="margin-left:18pt;"><span style="color:#333333;">再将以上二进制拼接起来计算十进制结果：00001010 00000011 00001001 00001100 = ？</span><br /><img alt="" class="has" height="144" src="https://img-blog.csdn.net/20180920142100367?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="488" /></p>

<p><span style="color:#333333;">6.python递归的最大层数？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">P</span><span style="color:#333333;">ython默认递归的最大层数为</span><span style="color:#333333;">998</span><span style="color:#333333;">层。</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">7.求结果：</span><br /><span style="color:#333333;">v1 = 1 or 3</span> <br /><span style="color:#333333;">v2 = 1 and 3</span> <br /><span style="color:#333333;">v3 = 0 and 2 and 1</span><br /><span style="color:#333333;">v4 = 0 and 2 or 1</span><br /><span style="color:#333333;">v5 = 0 and 2 or 1 or 4</span><br /><span style="color:#333333;">v6 = 0 or False and 1</span></p>

<p><span style="color:#333333;">V1 = 1  V2 = 3   V3 = 0   V4 = 1  V5 = 1  V6 = False<br />
(使用and如果第一个条件满足那么结果为第二个条件，如果第一个不满足结果为第一个条件。使用or如果第一个条件满足那么结果为第一个条件，如果第一个条件不满足结果为第二个条件）</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">8.ascii、unicode、utf-8、gbk 区别？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">A</span><span style="color:#333333;">scii只占一个字节，其中包含英文字母、数字和一些符号。无法表示其他的文字。</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">Unicode</span><span style="color:#333333;">占两个字节，生僻字符占四个字节。但是如果全是英文字母的话会比较浪费空间。</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">U</span><span style="color:#333333;">tf-8中英文占一个字节中文占三个字节，其他的生僻字占4-</span><span style="color:#333333;">6</span><span style="color:#333333;">个字节。</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">GBK占两个字节是中国制定的包含大部分汉字和其他的一些符号。</span></p>

<p> </p>

<p><span style="color:#333333;">9.三元运算规则以及应用场景？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">P</span><span style="color:#333333;">ython的三元运算格式为</span><strong><span style="color:#333333;"><strong>res = 值1 if 条件 else 值2 </strong></span></strong><span style="color:#333333;">，</span><span style="color:#333333;">当条件满足时返回值1否则返回值2。</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">可以用于只存在两种结果的if判断语句中。</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">10.列举 Python2和Python3的区别？</span></p>

<ol><li><span style="color:#333333;">P</span><span style="color:#333333;">rint函数：2中不需要括号将输出语句括起来，3中需要使用()</span></li>
    <li><span style="color:#333333;">编码：</span><span style="color:#333333;">Python3</span><span style="color:#333333;">源码文件默认使用utf-8编码，支持中文</span></li>
    <li><span style="color:#333333;">除法运算：</span><br /><span style="color:#333333;">首先是'/'  :</span><br />
        <span style="color:#333333;">python</span><span style="color:#333333;">3:   1 / 2 = 0.5 </span><br />
        p<span style="color:#333333;">ython2:</span>   <span style="color:#333333;">1 / 2 = 0</span>        <span style="color:#333333;">1.0 / 2.0 = 0.5</span></li>
</ol><p style="margin-left:0pt;">         <span style="color:#333333;">其次是</span><span style="color:#333333;">’//’<br />
              Python</span><span style="color:#333333;">3： 1 // 2 = 0<br />
              Python2:    1 // 2 = 0</span></p>

<p><span style="color:#333333;">     4.不等运算符：2中不等于有两种表示!=和&lt;&gt;,3中只有!=</span></p>

<p><span style="color:#333333;">     5.数据类型：3中不支持long类型了只有一种整形int</span> <span style="color:#333333;">和2中的long差不多的操作</span></p>

<p style="margin-left:36pt;"> </p>

<p><span style="color:#333333;">11.用一行代码实现数值交换：</span><span style="color:#333333;">a = 1 ,b = 2</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">(a, b) = (b, a)</span></p>

<p> </p>

<p><span style="color:#333333;">12.Python3和Python2中 int 和 long的区别？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">P</span><span style="color:#333333;">ython3中没有long类型只有int但是</span><span style="color:#333333;">3</span><span style="color:#333333;">中的int操作包含2中的long操作。</span></p>

<p> </p>

<p><span style="color:#333333;">13.xrange和range的区别？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">R</span><span style="color:#333333;">ange([start,]stop</span><span style="color:#333333;">[,step])</span><span style="color:#333333;">更具指定的范围和步长生成一个序列。</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">Xrange()和range操作一样，不同的是它返回的是一个生成器。</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">例如当我们使用range(10)的时候返回的是一个[0,1,2,3,4,5,6,7,8,9]的列表。而xrange(10)不会返回一个列表，而是每次调用的时候返回其中的值。这样在生成一个很大的操作的时候xrange的性能会更好。</span></p>

<p> </p>

<p><span style="color:#333333;">14文件操作时：xreadlines和readlines的区别？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">和上面的range和xrange一样的区别，readlines将文件中读取的数据读取出来生成一个列表存放着，而x</span><span style="color:#333333;">readlines</span><span style="color:#333333;">返回的是一个迭代器每次调用的时候返回下一个值。所以对于数据量比较大的时候使用迭代器的方法会更好一些。</span></p>

<p> </p>

<p><span style="color:#333333;">15.列举布尔值为False的常见值？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">0、None、</span><span style="color:#333333;">””、[]、{}</span></p>

<p> </p>

<p><span style="color:#333333;">16.字符串、列表、元组、字典每个常用的5个方法？</span></p>

<p style="margin-left:5.9pt;"><span style="color:#333333;">字符串：isdigit()判断是否只包含数字 is</span><span style="color:#333333;">lower()</span><span style="color:#333333;">判断是否全为小写 is</span><span style="color:#333333;">upper()</span><span style="color:#333333;">判断是否全为大写  strip()去掉首尾空格  split()以指定字符切片</span></p>

<p style="margin-left:5.9pt;"><span style="color:#333333;">列表：append()在列表后面追加  count()统计次数  pop(</span><span style="color:#333333;">index=-1</span><span style="color:#333333;">)默认移除最后一个元素并返回 </span> <span style="color:#333333;">sort()排序  reverse()反向列表中的元素 min</span><span style="color:#333333;">()、</span><span style="color:#333333;">max</span><span style="color:#333333;">()</span><span style="color:#333333;">返回最小最大值。</span></p>

<p style="margin-left:5.9pt;"><span style="color:#333333;">元组：cmp</span><span style="color:#333333;">(tuple1,tuple2)</span><span style="color:#333333;">比较两个元组元素  len</span><span style="color:#333333;">()</span><span style="color:#333333;">计算元组元素个数  max()返回最大值  min</span><span style="color:#333333;">()</span><span style="color:#333333;">返回最小值 tuple</span><span style="color:#333333;">(list)</span><span style="color:#333333;">将列表转为元组。</span></p>

<p style="margin-left:5.9pt;"><span style="color:#333333;">字典：get</span><span style="color:#333333;">(key,default=None)</span><span style="color:#333333;">返回指定键的值，没有返回默认值  copy</span><span style="color:#333333;">()</span><span style="color:#333333;">返回一个字典的浅复制  update(</span><span style="color:#333333;">dict2</span><span style="color:#333333;">)将dict</span><span style="color:#333333;">2</span><span style="color:#333333;">更新到原字典中 </span> <span style="color:#333333;">value()返回所有值 key</span><span style="color:#333333;">s()</span><span style="color:#333333;">返回所有键  pop</span><span style="color:#333333;">(key)</span><span style="color:#333333;">删除并返回指定的key的值</span><span style="color:#333333;">   popitem()</span><span style="color:#333333;">随机删除并返回一个键值对。</span></p>

<p style="margin-left:5.9pt;"> </p>

<p><span style="color:#333333;">17.lambda表达式格式以及应用场景？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">L</span><span style="color:#333333;">ambda语句中冒号前面的为参数，可以有多个，用逗号隔开。冒号右边的为返回值，如：add</span><span style="color:#333333;"> = lambda x, y : x + y </span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">   add(1,3) </span><span style="color:#333333;">结果为</span><span style="color:#333333;">4</span></p>

<p style="margin-left:18pt;"><span style="color:#ff0000;">L</span><span style="color:#ff0000;">ambda表达式通常是在需要一个函数，但是又不想费神去命名一个函数的时候使用</span><span style="color:#ff0000;">，</span><span style="color:#ff0000;">通常应用在函数式编程中、闭包</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">18.pass的作用？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">P</span><span style="color:#333333;">ass是空语句，为了保持程序结构的完整性，不做任何操作，一般只用做占位语句。</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">19.*arg</span><span style="color:#333333;">s</span><span style="color:#333333;">和**kwarg</span><span style="color:#333333;">s</span><span style="color:#333333;">作用</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">如果我们不确定往一个函数中传入多少参数，或者我们希望以元组tuple或者列表list的形式传参数的时候，我们可以使用*args。如果我们不知道往函数中传递多少个关键词参数或者想传入字典的值作为关键词参数的时候我们可以使用**kwargs，args、kwargs两个标识符是约定俗成的用法。另一种答法：当函数的参数前面有一个星号*号的时候表示这是一个可变的位置参数，两个星号**表示这个是一个可变的关键词参数。星号*把序列或者集合解包（unpack）成位置参数，两个星号**把字典解包成关键词参数。</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">20.is和==的区别</span></p>

<p style="margin-left:0pt;"><span style="color:#333333;">      is比较的是两个实例对象是不是完全相同的，他们是不是同一个对象，占用的内存地址是否相同。</span></p>

<p style="margin-left:0pt;"><span style="color:#333333;">      ==</span><span style="color:#333333;">比较的是两个对象的内容是否相等，内存地址可以不同，内容一样就可以了。</span></p>

<p style="margin-left:0pt;"> </p>

<p><span style="color:#333333;">21.简述Python的深浅拷贝以及应用场景？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">P</span><span style="color:#333333;">ython的变量只存储了这个变量的内存地址，而不是值的本身，对于像list</span> <span style="color:#333333;">set</span> <span style="color:#333333;">dict这种复杂的数据结构来说里面存储的也仅仅是每个元素的地址而已</span><br /><img alt="" class="has" height="440" src="https://img-blog.csdn.net/20180920142752928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="634" /></p>

<p style="margin-left:18pt;"><span style="color:#333333;">赋值：变量的每一次初始化都会在内存里面开辟一个新的空间，并将这个内存地址赋值给变量，例如：</span><br /><img alt="" class="has" height="101" src="https://img-blog.csdn.net/20180920142812348?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="200" /></p>

<p style="margin-left:18pt;"><span style="color:#333333;">给str</span><span style="color:#333333;">1</span><span style="color:#333333;">两次赋值，两次的内存地址发生改变，第一次赋值hello的时候将hello在内存中的地址给了str</span><span style="color:#333333;">1，</span><span style="color:#333333;">第二次赋值world的时候再次将world的内存地址给了str</span><span style="color:#333333;">1，</span><span style="color:#333333;">但是此时hello并没有从内存中消失，只是现在没有变量指向他。当我们再次赋值的时候str1又指向了hello。</span><br /><img alt="" class="has" height="148" src="https://img-blog.csdn.net/20180920142825292?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="177" /></p>

<p style="margin-left:18pt;"><span style="color:#333333;">深拷贝：</span><br /><img alt="" class="has" height="604" src="https://img-blog.csdn.net/20180920142838291?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="687" /></p>

<p style="margin-left:18pt;"><span style="color:#333333;">深拷贝可以完全复制原变量的所有数据，我们修改其中一个的时候不会对复制的那份造成影响。</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">浅拷贝：</span><br /><img alt="" class="has" height="467" src="https://img-blog.csdn.net/20180920142855885?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="648" /></p>

<p style="margin-left:18pt;"><span style="color:#333333;">不管多么复杂的数据结构，浅拷贝只会copy一层。对于像int float str这种单一的数据是可以独立出来，但是对于更为复杂的数据结构就会出问题，因为在复制的时候只是将列表 字典等的整个的存放地址给复制过来了，并没有复制里面元素的内存地址，这样导致修改的时候会同时发生变化。例如：</span><br /><img alt="" class="has" height="287" src="https://img-blog.csdn.net/20180920142907504?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="465" /></p>

<p style="margin-left:18pt;"><img alt="" class="has" height="199" src="https://img-blog.csdn.net/20180920142913193?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="340" /></p>

<p style="margin-left:18pt;"> </p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">22.Python垃圾回收机制？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">P</span><span style="color:#333333;">ython的垃圾回收机制默认的方式是引用计数法，其原理是为每一个对象维护一个ob</span><span style="color:#333333;">_ref</span><span style="color:#333333;">字段，用来记录该对象当前被引用的次数，有新的引用指向过来的时候计数加一，引用失效时计数减一，当对象的引用计数为0的时候，对象会被回收，释放内存空间。除了这个还有标记清除法和分代回收。</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">23.Python的可变类型和不可变类型？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">数字、字符串、元组是不可变的，列表字典是可变的，对于不可变类型的变量重新赋值的时候实际上是重新创建一个新的对象，原变量指向新的对象内存地址，除浮点型变量之外，对于值相同的变量可能都会指向同一个内存地址。可变类型例如列表在新增一个元素的时候，变量还是指向原来的那个内存地址，只是其中的元素指向发生了改变。</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">24.求结果：</span><br />
 <span style="color:#333333;">  v = dict.fromkeys(['k1','k2'],[])</span>  <br /><span style="color:#333333;">   v[‘k1’].append(666)</span><br />
 <span style="color:#333333;">  print(v)</span> <br /><span style="color:#333333;">   v[‘k1’] = 777</span><br />
 <span style="color:#333333;">  print(v)</span></p>

<p style="margin-left:0pt;"><strong><span style="color:#333333;"><strong>{'k1': [666], 'k2': [666]}</strong></span></strong></p>

<p style="margin-left:0pt;"><strong><span style="color:#333333;"><strong>{'k1': 777, 'k2': [666]}</strong></span></strong></p>

<p style="margin-left:0pt;"><strong><span style="color:#333333;"><strong>猜测原因是，在创建v这个字典的时候k1 k2 都指向了同一个空列表，当我们修改了这个列表的内容之后两个会同时发生改变，第二次单独修改k1的时候重新开辟了一个空间并指向新的内存地址。</strong></span></strong></p>

<p style="margin-left:0pt;"> </p>

<p><span style="color:#333333;">25.求结果：</span><br /><img alt="" class="has" height="72" src="https://img-blog.csdn.net/20180920143009219?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="298" /></p>

<p style="margin-left:0pt;"><strong><span style="color:#333333;"><strong>[6, 6, 6, 6]</strong></span></strong></p>

<p style="margin-left:0pt;"><strong><span style="color:#333333;"><strong>解释见：</strong></span></strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/imhurley/p/3898289.html"><strong><u><span style="color:#0563c1;"><strong><u>https://www.cnblogs.com/imhurley/p/3898289.html</u></strong></span></u></strong></a></p>

<p style="margin-left:0pt;"> </p>

<p><span style="color:#333333;">26.列举常见的内置函数？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">abs() </span><span style="color:#333333;">绝对值  len()序列长度 divmod</span><span style="color:#333333;">()</span><span style="color:#333333;">取模 pow</span><span style="color:#333333;">()</span><span style="color:#333333;">乘方 round()浮点数</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">27.filter、map、reduce的作用？</span></p>

<p style="margin-left:18pt;"><strong><span style="color:#333333;"><strong>fi</strong></span></strong><strong><span style="color:#333333;"><strong>lter()函数：</strong></span></strong><span style="color:#333333;">filter()函数接收两个参数，一个是bool函数，一个是序列，依次将序列中的每一个元素传入到bool函数中，返回值为非零的元素添加到新的列表中。</span><br /><img alt="" class="has" height="149" src="https://img-blog.csdn.net/20180920143036526?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="331" /></p>

<p style="margin-left:18pt;"><strong><span style="color:#333333;"><strong>map()</strong></span></strong><strong><span style="color:#333333;"><strong>函数</strong></span></strong><span style="color:#333333;">：map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回</span><br /><img alt="" class="has" height="102" src="https://img-blog.csdn.net/20180920143049468?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="289" /></p>

<p style="margin-left:18pt;"><strong><span style="color:#333333;">reduce</span><span style="color:#333333;">()</span></strong><span style="color:#333333;"><strong>函数</strong>：三个参数，一个需要两个参数的函数，一个序列，一个初始值，执行顺序为：将序列中的第一个值和初始值进行func处理，然后将结果和序列第二个值处理直到结束。</span><br /><img alt="" class="has" height="97" src="https://img-blog.csdn.net/20180920143109928?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="287" /></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">28.一行代码实现9*9乘法表</span></p>

<p style="margin-left:0pt;"><strong><span style="color:#006699;"><strong>      print</strong></span></strong> <span style="color:#0000ff;">"\n"</span><span style="color:#000000;">.join(</span><span style="color:#0000ff;">"\t"</span><span style="color:#000000;">.join([</span><span style="color:#0000ff;">"%s*%s=%s"</span><span style="color:#000000;"> %(x,y,x*y) </span><strong><span style="color:#006699;"><strong>for</strong></span></strong><span style="color:#000000;"> y </span><strong><span style="color:#006699;"><strong>in</strong></span></strong><span style="color:#000000;"> range(1, x+1)]) </span><strong><span style="color:#006699;"><strong>for</strong></span></strong><span style="color:#000000;"> x </span><strong><span style="color:#006699;"><strong>in</strong></span></strong><span style="color:#000000;"> range(1, 10))  </span></p>

<p style="margin-left:0pt;"> </p>

<p><span style="color:#333333;">29.re的match和search区别？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">Match</span><span style="color:#333333;">是从头开始匹配 search从任意位置匹配</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">30.什么是正则的贪婪匹配？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">贪婪匹配就死趋于最大长度的匹配</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">非贪婪匹配就是匹配到结果就好</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">31.def func(a,b=[]) 这种写法有什么坑？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">函数的第二个参数是一个list，当第一次执行的时候实例化了一个list，第二次执行的时候还是用的是第一次实例化的那个list</span></p>

<p style="margin-left:18pt;"><img alt="" class="has" height="179" src="https://img-blog.csdn.net/20180920143300580?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="243" /></p>

<p style="margin-left:18pt;"><span style="color:#333333;">32.如何实现 “1,2,3” 变成 [‘1’,’2’,’3’] ?</span></p>

<p style="margin-left:18pt;"><img alt="" class="has" height="51" src="https://img-blog.csdn.net/20180920143308681?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="185" /></p>

<ol><li><span style="color:#333333;">如何实现[‘1’,’2’,’3’]变成[1,2,3] ?</span></li>
</ol><p style="margin-left:18pt;"><img alt="" class="has" height="51" src="https://img-blog.csdn.net/20180920143312837?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="241" /></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">34.比较： a = [1,2,3] 和 b = [(1),(2),(3) ] 以及 </span><span style="color:#333333;">c</span><span style="color:#333333;"> = [(1,),(2,),(3,) ] 的区别？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">a是一个列表,其中的元素为整数</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">a和b</span> <span style="color:#333333;">的内容一样但是在内存中的地址不同，也就是 a</span><span style="color:#333333;">==b </span><span style="color:#333333;">成立 a</span><span style="color:#333333;"> is b </span><span style="color:#333333;">不成立</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">c也是一个列表，只不过其中的元素为元组</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">35.如何用一行代码生成[1,4,9,16,25,36,49,64,81,100] ?</span></p>

<p style="margin-left:0pt;"><span style="color:#333333;">     1：list(map(lambda x:x*x ,[1,2,3,4,5,6,7,8,9,10]))</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">2：</span><span style="color:#333333;">list</span><span style="color:#333333;">(x*x for x in range(1,11))</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">36.一行代码实现删除列表中重复的值 ?</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">list1 = list(set(list1))</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">37.如何在函数中设置一个全局变量 ?</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">使用global声明变量</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">38.logging模块的作用？以及应用场景？</span></p>

<p style="margin-left:0pt;"><span style="color:#333333;">       l</span><span style="color:#333333;">ogging模块是python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、保存路径、日志文件回滚等。可用于记录程序运行状态。</span></p>

<p style="margin-left:0pt;"> </p>

<p><span style="color:#333333;">39.请用代码</span><span style="color:#333333;">简单</span><span style="color:#333333;">实现stack 。</span></p>

<pre class="has">
<code class="language-python">class Stack(object):
    # 初始化栈为空列表
    def __init__(self):
        self.items = []

    # 判断栈是否为空，返回布尔值
    def is_empty(self):
        return self.items == []

    # 返回栈顶元素
    def peek(self):
        return self.items[len(self.items) - 1]

    # 返回栈的大小
    def size(self):
        return len(self.items)

    # 进栈
    def push(self, item):
        self.items.append(item)

    # 出栈
    def pop(self, item):
        return self.items.pop()</code></pre>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">40.常用字符串格式化哪几种？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">主要有两种 %</span> <span style="color:#333333;">和format</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">示例1：</span><span style="color:#333333;">”%s%d” %(‘hello’,1)</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">示例2：</span><span style="color:#333333;">"i am {} age {} sex:{}".format('alex',38,'male')</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">             "i am {1} age {1} sex:{2}".format('alex',38,'male')</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">41.简述 生成器、迭代器、可迭代对象 以及应用场景？</span></p>

<p style="margin-left:18pt;"><strong><span style="color:#333333;"><strong>生成器：</strong></span></strong><span style="color:#333333;">生成器其实是一种特殊的迭代器，生成器一定是迭代器反之不成立，不需要写__iter__()和__next__()方法，只需要一个yield关键字。<br />
例如：斐波那契的例子</span></p>

<pre class="has">
<code class="language-python">def fib():
    prev, curr = 0, 1
    while True:
        yield curr
        prev, curr = curr, curr + prev

&gt;&gt;&gt; f = fib()
&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; list(islice(f, 0, 10))
[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</code></pre>

<p style="margin-left:0pt;">     <span style="color:#333333;"><strong>生成器表达式</strong>：是列表推倒式的生成器版本，看起来像列表推导式，但是他返回的是一个生成器对象而不是列表对象 </span><br />
    <img alt="" class="has" height="53" src="https://img-blog.csdn.net/20180920143718651?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="330" /></p>

<p style="margin-left:18pt;"><strong><span style="color:#333333;"><strong>迭代器：</strong></span></strong><span style="color:#333333;">可以被next调用并不断返回下一个值的对象称为迭代器，迭代器内部有一个状态，该状态用于记录当前迭代所在的位置，__iter__()返回迭代器本身，__next__()返回容器中的下一个值。</span></p>

<p style="margin-left:18pt;"><strong><span style="color:#333333;"><strong>可迭代对象：</strong></span></strong><span style="color:#333333;">但凡可以返回一个迭代器的对象都可以称之为可迭代对象，更为直观点可以使用for循环的对象，如列表，元组，字典，集合，字符串，打开的文件，socket等。</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">42.用Python实现一个二分查找的函数。 <br />
     </span><img alt="" class="has" height="247" src="https://img-blog.csdn.net/20180920143746615?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="359" /></p>

<p> </p>

<p><span style="color:#333333;">43.谈谈你对闭包的理解？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">闭包就是在一个外部函数中定义一个内函数，内函数里运用了外部函数的临时变量，并且外函数的返回值是内函数的引用。如下是最简单的一个闭包：</span><br /><img alt="" class="has" height="146" src="https://img-blog.csdn.net/20180920143854274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="246" /></p>

<p style="margin-left:18pt;"><span style="color:#333333;">在python中一切皆对象，小到一个变量，大到一个函数一个类都是对象，变量名，函数名类名都是指向内存地址。因此当返回值为一个函数的引用的时候可以跟括号来调用此函数。<br />
一般来说，当一个函数结束的时候，会将临时变量释放掉，但是在闭包中，临时变量会在内部函数中用到，因此在返回内函数的时候会将临时变量和内函数绑定在一起，外函数结束后，在调用内函数的时候依然可以使用外函数的临时变量。每次在调用外函数的时候都会在内存中创建一个内函数，并且返回的是当前的内函数地址，需要知道的的是虽然内函数被重新创建了，但是外函数的临时变量只存在一份，每次创建的内函数都是使用的同一份临时变量。如下两次调用的返回值是不同的</span><br /><img alt="" class="has" height="133" src="https://img-blog.csdn.net/2018092014391017?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="180" /></p>

<p style="margin-left:18pt;"><span style="color:#333333;">Python中内函数想要修改外函数的临时变量可以使用nonlocal关键字来定义变量，如下：</span><br /><img alt="" class="has" height="209" src="https://img-blog.csdn.net/20180920143921274?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="216" /></p>

<p style="margin-left:18pt;"><span style="color:#333333;">闭包的应用：装饰器、单例模式</span></p>

<p><span style="color:#333333;">44.os和sys模块的作用？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">os 模块提供了一种方便的使用操作系统函数的方法。</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">sys模块可供访问由解释器使用或维护的变量和与解释器进行交互的函数。</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">45.如何生成一个随机数？<br />
     </span><img alt="" class="has" height="49" src="https://img-blog.csdn.net/2018092014395514?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="204" /></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">46.如何使用python删除一个文件？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">o</span><span style="color:#333333;">s</span><span style="color:#333333;">.remove(file_path)</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">os.rmdir(dir_path)</span></p>

<p><span style="color:#333333;">47.面向对象深度优先和广度优先是什么？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">Python 中类的多继承分为深度优先和广度优先，新式类会按照深度优先方法查找，金典类会按照广度优先的方式查找。</span><br /><img alt="" class="has" height="266" src="https://img-blog.csdn.net/20180920144033707?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="687" /></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">48.面向对象中super的作用？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">S</span><span style="color:#333333;">uper(</span><span style="color:#333333;">)</span><span style="color:#333333;">可以保证公共的父类仅被执行一次。按照MRO的顺序执行</span><span style="color:#ff0000;">原理待更新：</span></p>

<p style="margin-left:0pt;"> </p>

<p><span style="color:#333333;">49.列举面向对象中带爽下划线的特殊方法，如：__new__、__init__</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">__doc__  </span><span style="color:#333333;">表示类的描述信息</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">__module__ 表示当前操作的对象在那个模块</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">__class__ 表示当前操作的对象的类是什么</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">__init__  </span><span style="color:#333333;">构造方法，通过类创建对象时，自动触发执行</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">__del__ 析构方法，当对象在内存中被释放的时候，自动触发执行</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">_</span><span style="color:#333333;">_call__ </span><span style="color:#333333;">对象后面加括号，触发执行</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">_</span><span style="color:#333333;">_dict__ </span><span style="color:#333333;">类或对象中的所有成员</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">__str__ </span><span style="color:#333333;">如果一个类中定义了这个方法那么在打印对象的时候默认输出该方法的返回值</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">__getitem__、__setitem__、__delitem__ 用于索引操作，如字典。分别表示获取、设置、删除数据</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">__getslice__、__setslice__、__delslice__分别用于切片操作，如列表</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">__iter__ </span><span style="color:#333333;">用于迭代器</span></p>

<p style="margin-left:18pt;"><span style="color:#ff0000;">__new__</span><span style="color:#ff0000;">和__metaclass__</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">50.如何判断是函数还是方法？</span></p>

<p style="margin-left:18pt;"><span style="color:#ff0000;">根据__call__属性判断： if(hasattr(func,</span><span style="color:#ff0000;">’__call__’)):</span></p>

<p style="margin-left:18pt;"><span style="color:#ff0000;">利用callable判断: if(callable(func)):</span></p>

<p style="margin-left:18pt;"><span style="color:#ff0000;">利用isfunction判断：if</span><span style="color:#ff0000;">(isfunction(add)):</span></p>

<p><span style="color:#333333;">51.静态方法和类方法区别？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">类方法必须有一个指向类对象的引用作为第一个参数，但是静态方法可以没有任何参数，</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">52.列举面向对象中的特殊成员以及应用场景</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">53.   1、2、3、4、5 能组成多少个互不相同且无重复的三位数</span></p>

<p style="margin-left:0pt;"><span style="color:#333333;">        A</span><span style="color:#333333;">53 = </span><span style="color:#333333;">60个</span></p>

<p><span style="color:#333333;">54. 什么是反射？以及应用场景？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">其实，反射就是通过字符串的形式，导入模块；通过字符串的形式去模块寻找指定的函数并执行。利用字符串的形式去对象（模块）中操作（查找、获取、删除、添加）成员，是一种基于字符串的事件驱动。</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">g</span><span style="color:#333333;">etattr</span><span style="color:#333333;">(</span><span style="color:#333333;">object, name [,defaukt])函数是python内置函数，用于返回一个对象属性值,若不存在且为设置默认值则触发异常，如果设置了默认值则返回默认值。</span><br /><img alt="" class="has" height="229" src="https://img-blog.csdn.net/20180920144219728?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="450" /><br /><img alt="" class="has" height="146" src="https://img-blog.csdn.net/20180920144237505?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="262" /></p>

<p style="margin-left:18pt;"> </p>

<p style="margin-left:18pt;"><span style="color:#333333;">hasattr</span><span style="color:#333333;">(object,name):</span><span style="color:#333333;">判断对象object是否包含名为name的特性（hasattr是通过调用getattr()是否抛出异常来实现的）。如果有该属性则返回True否则返回False</span><br /><img alt="" class="has" height="162" src="https://img-blog.csdn.net/20180920144248353?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="277" /></p>

<p style="margin-left:18pt;"><span style="color:#333333;">setattr</span><span style="color:#333333;">(object, name, value):</span><span style="color:#333333;">对应函数getattr(),用于设置属性值，或者增加某个属性。</span><br /><img alt="" class="has" height="131" src="https://img-blog.csdn.net/20180920144301230?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="209" /></p>

<p style="margin-left:18pt;"><img alt="" class="has" height="49" src="https://img-blog.csdn.net/20180920144314576?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="231" /><br /><img alt="" class="has" height="115" src="https://img-blog.csdn.net/20180920144359561?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="281" /></p>

<p style="margin-left:18pt;"> </p>

<p style="margin-left:18pt;"> </p>

<p style="margin-left:18pt;"><span style="color:#333333;">delattr</span><span style="color:#333333;">(object, name):</span><span style="color:#333333;">用于删除属性，操作类似不举示例了。</span></p>

<p style="margin-left:18pt;"><strong><span style="color:#333333;"><strong>应用：</strong></span></strong><span style="color:#333333;">实现一个简单的url路由器的功能，实现动态导入模块</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">55.metaclass作用？以及应用场景？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">M</span><span style="color:#333333;">etaclass</span> <span style="color:#333333;">的实例化结果是类。而class实例化结果是instance，metaclass是创建类的模版，所有的类都是通过他来创建的，这使得我们可以自由控制创建类的过程。实现自由的修改、增加、删除 类或者实例中的方法或者属性。可批量对某些方法使用装饰器，而不需要每次都在方法上面增加@decorator_func。</span><span style="color:#333333;">等等</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">56.用尽量多的方法实现单例模式。</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">单例模式的主要目的是确保某一个类只有一个实例存在，主要的实现方式有以下几种：</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">1：使用模块。</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">2：使用装饰器。<br />
      </span><img alt="" class="has" height="119" src="https://img-blog.csdn.net/20180920144440324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="534" /><br />
      <img alt="" class="has" height="146" src="https://img-blog.csdn.net/20180920144453324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="293" /><br />
      <img alt="" class="has" height="71" src="https://img-blog.csdn.net/20180920144514219?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="173" /></p>

<p style="margin-left:18pt;"> </p>

<p style="margin-left:18pt;"><span style="color:#333333;">3：基于__new__方法实现。<br />
      在实例化一个类的时候，首先执行了类的__new__方法，然后执行__init__方法，</span><span style="color:#333333;">在实例化的时候先检查有没有已经实例化过，如果有则返回已经实例化候的对象，否则创建新的。</span></p>

<p style="margin-left:0pt;"><span style="color:#333333;">     4：基于metaclass方法实现<br />
        1.类由type创建，创建类时，type的__init__方法自动执行，类() 执行type的 __call__方法(类的__new__方法,类的__init__       方法)。<br />
        2.对象由类创建，创建对象时，类的__init__方法自动执行，对象()执行类的 __call__ 方法。</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">57.装饰器的写法以及应用场景。</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">python的装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数和闭包一样，所以装饰器是闭包的一种应用，使用装饰器可以不用在更改原函数的前提下给函数增加新的功能，当有多个装饰器的时候从上到下依次执行。<br />
装饰器的原理：和闭包类似<br />
最简单的一个装饰器</span><br /><img alt="" class="has" height="227" src="https://img-blog.csdn.net/2018092014463326?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="292" /></p>

<p style="margin-left:18pt;"><span style="color:#333333;">主要用户一些认证功能，日志，授权</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">58.异常处理写法以及如何主动抛出异常（应用场景）<br />
     </span><img alt="" class="has" height="116" src="https://img-blog.csdn.net/20180920144704838?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="220" /><br />
     <img alt="" class="has" height="272" src="https://img-blog.csdn.net/20180920144712593?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="412" /></p>

<p style="margin-left:18pt;"> </p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">59.什么是面向对象的mro</span></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">60.isinstance作用以及应用场景？<br />
      用来判断一个对象是否是一个已知类型，类似type(),</span><span style="color:#333333;">和type不同的是type()不会认为子类是一种父类类型，不考虑继承关系，而isinstance（）会认为子类是一种父类类型，会考虑继承关系。如果要判断两个类型是否相同的时候最好使用isinstance</span></p>

<p style="margin-left:0pt;"><span style="color:#333333;">61.写代码并实现：</span><br /><span style="color:#333333;">       给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。<br />
       你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</span><br /><span style="color:#333333;">       Example:</span> <br />
         <span style="color:#333333;">       Given nums = [2, 7, 11, 15], target = 9,</span><br />
                 <span style="color:#333333;">Because nums[0] + nums[1] = 2 + 7 = 9,</span> <br />
                <span style="color:#333333;">return [0, 1]   </span><br />
       <img alt="" class="has" height="300" src="https://img-blog.csdn.net/20180920144810113?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="428" /></p>

<p><span style="color:#333333;">62.json序列化时，可以处理的数据类型有哪些？如何定制支持datetime类型？</span></p>

<p style="margin-left:0pt;"><span style="color:#333333;">       可处理的数据类型有:字符串、列表、元组、字典、整数，不支持集合。定制支持datetime:首先写一个类：将用于判断是否         为datetime类型的数据格式，如果是则将其转换成字符串类型。再交给json处理。使用的时候指定cls参数即可。<br />
       </span><img alt="" class="has" height="196" src="https://img-blog.csdn.net/20180920144932516?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="588" /></p>

<p><span style="color:#333333;">63.json序列化时，默认遇到中文会转换成unicode，如果想要保留中文怎么办？<br />
     </span><img alt="" class="has" height="51" src="https://img-blog.csdn.net/20180920144955556?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="348" /></p>

<p style="margin-left:18pt;"> </p>

<p><span style="color:#333333;">64.什么是断言？应用场景？</span></p>

<p style="margin-left:18pt;"><span style="color:#333333;">assert断言用来检查一个条件，如果为真那么不做任何事，如果错误则会抛出AssertionError错误并且包含错误信息，应用场景：程序常量，检查逻辑，检查文，档检查约定</span><span style="color:#333333;">。</span><span style="color:#333333;">格式为 assert</span> <span style="color:#333333;">语句, 报错输出</span><br /><img alt="" class="has" height="85" src="https://img-blog.csdn.net/20180920145015421?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="370" /></p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:01:24.410Z" title="3/17/2022, 1:01:24 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:06:14.146Z" title="3/17/2022, 1:06:14 AM">2022-03-17</time>更新</span><span class="level-item">5 分钟读完 (大约817个字)</span></div></div><div class="content"><h3>list.sort方法和内置函数sorted的异同</h3>

<p>list.sort方法和sorted函数都是对列表进行排序的，但是这两种方法也是有少许不同的，list.sort排序是在原有基础上进行的，不会生成返回一个新的list， 但是sorted函数则不同，他会产生一个新对象并返回。如下</p>

<pre class="has">
<code class="language-python">t = [1, 3, 4, 2, 5, 0]
t1 = [1, 3, 4, 2, 5, 0]
print(t.sort())
print(t)
print(sorted(t1))
print(t1)</code></pre>

<p><img alt="" class="has" height="113" src="https://img-blog.csdn.net/20181011115605325?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="284" /><br />
在同时对t和t1 排序并打印结果，t.sort()返回None  sorted(t1) 返回排序好的list，两者都正确，但是只有t的内容发生改变，t1的内容没有改变。</p>

<p>sorted()函数要比list.sort()强大很多，sorted()不仅仅只能将list作为参数传递进去，还可以接收任何形式的可迭代对象作为参数，甚至是不可变序列或者生成器，不管是接收的什么参数sorted()都是返回一个列表。</p>

<p>list.sort()和sorted()都有两个可选的参数：<br />
 1. reverse：决定是升序还是降序排列，True为降序，默认值为False<br />
 2. key: 一个只有一个参数的函数，这个函数会被用在序列的每一个元素上，通俗来讲就是排序规则，例如对字符串排序的时候可以使用key=str.lower来实现忽略大小的排序，或者是key=len来按照字符串长度排序等等。默认用元素自己的值来排序。<br /><img alt="" class="has" height="103" src="https://img-blog.csdn.net/20181011120952740?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="413" /></p>

<h3>想要在不打乱次序的情况下如何向有序列表中插入数据呢？</h3>

<p>可借助bisect模块来实现，bisect模块主要包含两个函数 ，bisect和insort ，这两个函数都是利用二分查找算法来实现在有序序列中查找或者插入元素的<br />
例如使用bisect来搜索可插入的位置：</p>

<pre class="has">
<code class="language-python">import bisect

t = [123, 3, 234, 1, 423, 5, 25, 235, 325]
t.sort()
print(bisect.bisect(t, 235))

###  7</code></pre>

<p>返回值为可插入的位置。前提是传入的参数是有序序列，bisect还有两个可选的参数 lo和 hi即搜索范围，lo默认为0，hi默认为序列长度。</p>

<p>如果有序序列中已存在要插入的元素的时候，又是如何处理的呢！这个就有两种情况，插入到原有元素之前或者之后，分别对应两个方法bisect_left和 bisect_right，而我们之前使用的bisect其实就是bisect_right方法。既然获取的插入位置，那么使用list.insert方法插入即可完成向有序序列插入元素。有没有更简单的方法呢，答案是肯定的，那就是我们之前提到的insort方法。</p>

<p>使用insort插入元素：</p>

<pre class="has">
<code class="language-python">import bisect

t = [123, 3, 234, 1, 423, 5, 25, 235, 325]
t.sort()
bisect.insort(t, 222)
print(t)

###   [1, 3, 5, 25, 123, 222, 234, 235, 325, 423]</code></pre>

<p>看了bisect源码之后发现其实insort方法和bisect方法是一样的，只是获取到了插入位置之后紧接着调用insert()方法<br /><img alt="" class="has" height="255" src="https://img-blog.csdn.net/20181011145138585?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" width="602" /><br />
insort方法和bisect方法是一样的也是有两个可选参数lo和hi来缩小范围，也分insort_left和insort_right，默认使用的是insort_right方法 </p>

<p><br />
 </p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:01:23.172Z" title="3/17/2022, 1:01:23 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:06:12.959Z" title="3/17/2022, 1:06:12 AM">2022-03-17</time>更新</span><span class="level-item">5 分钟读完 (大约805个字)</span></div></div><div class="content"><p>以下是自己的学习记录，算是一个总结。</p>

<p style="text-indent:0;">接下来会依次对下面问题做一个解答：<br />
    1. Python的dict和set为什么是无序的？<br />
    2. 为什么不是所有的python对象都可以用作dict的键和set中的元素</p>

<p style="text-indent:50px;">要弄懂上面的问题，我们首先要了解Python内部是如何实现dict和set类型的。我们先来看看dict的内部结构，dict其实本质上是一个散列表（散列表即总有空白元素的数组，Python会保证至少有三分之一的数组元素是空的），dict的每个键都占用一个表元，而一个表元中又分为两个部分，分别是对键的引用和对值的引用。当我们存放一个对象的时候，首先会要计算这个元素的散列值，python中使用hash()方法来实现的，这也就回答了第二个问题，因为不是所有的python对象都可以使用hash来获取散列值，获取不到散列值也就不可能存放到dict中，所以只有可hash的对象才能够作为dict的键。值得注意的是内置的hash方法可以用于所有的内置类型对象的，所有用户自定义的对象默认都是可以作为键的，因为自定义对象的散列值是通过id()来获取的。例如：</p>

<pre class="has">
<code class="language-python">class T(object):
    pass


t = T()

print(id(t))
d = &#123;t: 1&#125;
print(d)

###  2133693018240
###  &#123;&lt;__main__.T object at 0x000001F0CA03B080&gt;: 1&#125;</code></pre>

<p style="text-indent:50px;">现在假设我们已经获取到了元素的散列值，接下来就该计算应当存放位置了，将散列值对数组长度进行取余，得到的结果就是存放位置的索引了。但是不同的key可能会得到相同的散列值，也就是哈希冲突的问题，python内部是使用开放寻址的方法来解决的，开放寻址法就不在此详细说了。关于为什么dict是无序的，这个是因为python内部会保证散列表至少有三分之一的位置为空，当我们增加元素的时候，python有可能会对散列表进行扩容，具体操作就是重新开辟一块更大的空间，将原有的元素添加到新表里面，这个过程中可能又会发生新的散列冲突，导致新的散列表中的键的次序发生变化。当然呢如果想要保存顺序也可以使用OrderedDict来处理</p>

<p style="text-indent:0;"> </p>

<p style="text-indent:0;">dict操作的时间复杂度：</p>

<table><thead><tr><th>操作</th>
            <th>操作说明</th>
            <th>时间复杂度</th>
        </tr></thead><tbody><tr><td>copy</td>
            <td>复制</td>
            <td>O(n)</td>
        </tr><tr><td>get(value)</td>
            <td>获取</td>
            <td>O(1)</td>
        </tr><tr><td>set(value)</td>
            <td>修改</td>
            <td>O(1)</td>
        </tr><tr><td>delete(value)</td>
            <td>删除</td>
            <td>O(1)</td>
        </tr><tr><td>search(in)</td>
            <td>字典搜索</td>
            <td>O(1)</td>
        </tr><tr><td>iterration</td>
            <td>字典迭代</td>
            <td>O(n)</td>
        </tr></tbody></table><p style="text-indent:50px;">set集合和dict一样也是基于散列表的，只是他的表元只包含值的引用而没有对键的引用，其他的和dict基本上是一致的，所以在此就不再多说了。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-03-16T17:01:06.370Z" title="3/17/2022, 1:01:06 AM">2022-03-17</time>发表</span><span class="level-item"><time dateTime="2022-03-16T17:05:56.012Z" title="3/17/2022, 1:05:56 AM">2022-03-17</time>更新</span><span class="level-item">6 分钟读完 (大约882个字)</span></div></div><div class="content"><h3>前言：</h3>

<p style="text-indent:50px;">读大学的时候学的是物联网工程，大概是在大二的时候开始接触单片机，那时候特喜欢捣鼓那些东西，就觉得特别酷有极客范。还记得第一次做物联网相关的是一个远程控制的开关，第一次调通的时候真的很兴奋，啥也没干就挂在那用手机控制继电器听咔嗒咔哒的声音，现在想想真的好小儿科，明明只是按照人家的教程改改代码却也能兴奋那么就。但是有一句话不是说所有的编程语言第一个代码都是Hello World，一切都要从最基础的开始，当我们有能力的时候才能做更大的事。</p>

<p style="text-indent:50px;">言归正传，之前也用过一些很成熟的物联网平台例如移动的OneNET、 Yeelink，做的都很好功能也很强大，我也做过一些扩展功能，例如那时候OneNET是没有手机端的，于是就根据OneNET提供的API实现了微信公众号的访问和控制（最开始的几篇博客有介绍），可是觉得这些一点也不极客，无非是在调用API。搭建一个个人的物联网平台这个想法很久之前就有了，只是一直迟迟未开始，现在我觉得是时候开始着手实现这个想法了。关于这个物联网平台我的想法是够用就好，也许它很简单，功能有点low，设计不合理等等，毕竟是我自己做出来的，开心就好【手动滑稽】，当然呢我也会尽力去完善。立一个Flag半年之内完成。</p>

<p style="text-indent:50px;"><span style="color:#f33b45;">最后也是最重要的一点，这不是一个教程，只是我个人的一些开发记录，里面可能会有很多漏洞，不合理的地方，而且之前的操作可能会在后面给推翻重做，所以啊，参考就行了不要当真。</span></p>

<h3>整体构思：</h3>

<p style="text-align:center;"><img alt="" class="has" height="431" src="https://img-blog.csdnimg.cn/20181104024403255.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70" width="805" /></p>

<p style="text-indent:0;">图画的有点low不要介意，简单说一下<br />
        硬件：这里选择Arduino平台开发，之所以不先考虑stm32或者51之类的，是因为那两个我都没完整的了解过，等以后会提供更多的连接例程，目前手上现有一个NodeMCU、和一个ArduinoMEGA2560，考虑到Arduino和ESP8266连线太麻烦了，就以NodeMCU为例。<br />
        平台：协议就使用MQTT好了，后台用Django，数据库MySQL。<br />
        手机：还是借助微信公众号之前也有一些经验，最主要的是APP开发不会。<br />
        电脑：应该会和OneNET类似，前端大概率会用vue开发，这个应该会放到最后实现，vue还在学习阶段。<br />
        大致功能包括： 用户注册、添加设备、上传数据、查看历史数据、发送控制指令、微信提醒，目前想到的就只有这么多了，以后还有新的再来添加。</p>

<p style="text-indent:0;"> </p>

<h3 style="text-indent:0px;"><strong>更新一下：</strong></h3>

<p><strong>项目差不多完成了75%左右，在制作过程中对原有的一些设计做了优化和调整目前项目的整个架构图如下</strong></p>

<p><img alt="" class="has" height="567" src="https://img-blog.csdnimg.cn/20190218132744174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Zhbk1MZWk=,size_16,color_FFFFFF,t_70" width="918" /></p></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/8/">8</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/site/avatar.png" alt="fanmlei"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">fanmlei</p><p class="is-size-6 is-block">努力成为一名GEEK！</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Wuhan, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">75</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">28</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/fanmlei" target="_blank" rel="noopener">关注我</a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Arduino/"><span class="level-start"><span class="level-item">Arduino</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Django/"><span class="level-start"><span class="level-item">Django</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">16</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"><span class="level-start"><span class="level-item">未分类</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-16T17:09:40.422Z">2022-03-17</time></p><p class="title"><a href="/2022/03/17/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E7%9A%84%E7%89%A9%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-16T17:09:39.165Z">2022-03-17</time></p><p class="title"><a href="/2022/03/17/WinSCP%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8root%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-16T17:09:37.937Z">2022-03-17</time></p><p class="title"><a href="/2022/03/17/Python%E6%98%BE%E7%A4%BA%E8%BF%9B%E5%BA%A6%E6%9D%A1%E7%9A%84%E6%96%B9%E6%B3%95/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-16T17:09:36.621Z">2022-03-17</time></p><p class="title"><a href="/2022/03/17/PyQt5%E6%98%BE%E7%A4%BAGIF%E5%9B%BE%E7%89%87/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-03-16T17:09:35.436Z">2022-03-17</time></p><p class="title"><a href="/2022/03/17/PyQt5%E6%97%A0%E8%BE%B9%E6%A1%86%E5%90%8E%E7%AA%97%E5%8F%A3%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%96%B9%E6%B3%95/"> </a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">三月 2022</span></span><span class="level-end"><span class="level-item tag">33</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">十二月 2017</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arduino/"><span class="tag">Arduino</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSRF/"><span class="tag">CSRF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DRF/"><span class="tag">DRF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Django/"><span class="tag">Django</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Django%E6%A8%A1%E7%89%88/"><span class="tag">Django模版</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Excel/"><span class="tag">Excel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTTP/"><span class="tag">HTTP</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WebSocket/"><span class="tag">WebSocket</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bug/"><span class="tag">bug</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jQuery/"><span class="tag">jQuery</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="tag">web中间件</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E8%AF%8D/"><span class="tag">分词</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"><span class="tag">前后端分离</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag">排序</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%94%AF%E4%BB%98/"><span class="tag">支付</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"><span class="tag">文件处理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BA%90%E7%A0%81/"><span class="tag">源码</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%99%BB%E5%BD%95/"><span class="tag">登录</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A1%AC%E4%BB%B6/"><span class="tag">硬件</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="tag">笔记</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><span class="tag">编程基础</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="tag">编程语言</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C/"><span class="tag">网络</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"><span class="tag">网络请求</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%82%AE%E7%AE%B1/"><span class="tag">邮箱</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%83%A8%E7%BD%B2/"><span class="tag">部署</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/site/avatar.png" alt="fanmlei`s blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 fanmlei</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/fanmlei/blog"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>