<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>fanmlei`s blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="fanmlei`s blog"><meta name="msapplication-TileImage" content="/img/site/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="fanmlei`s blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="fanmlei`s blog"><meta property="og:url" content="https://blog.iotforfml.cn/"><meta property="og:site_name" content="fanmlei`s blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.iotforfml.cn/img/og_image.png"><meta property="article:author" content="fanmlei"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.iotforfml.cn"},"headline":"fanmlei`s blog","image":["https://blog.iotforfml.cn/img/og_image.png"],"author":{"@type":"Person","name":"fanmlei"},"publisher":{"@type":"Organization","name":"fanmlei`s blog","logo":{"@type":"ImageObject","url":"https://blog.iotforfml.cn/img/site/avatar.png"}},"description":""}</script><link rel="icon" href="/img/site/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 6.1.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/site/avatar.png" alt="fanmlei`s blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/fanmlei/blog"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-16T02:35:18.000Z" title="8/16/2021, 10:35:18 AM">2021-08-16</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a></span><span class="level-item">25 分钟读完 (大约3700个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/08/16/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B5%85%E6%9E%90/">Python的多线程使用浅析</a></h1><div class="content"><h1 id="Python的多线程使用浅析"><a href="#Python的多线程使用浅析" class="headerlink" title="Python的多线程使用浅析"></a>Python的多线程使用浅析</h1><p>在python中谈到多线程问题就绕不开一个点GIL，一个是资源竞争</p>
<ul>
<li>GIL全称python全局解释器锁，由于GIL的存在，在任意时刻只有一个线程在执行，这也导致python的多线程无法利用到多核CPU的优势，如果是多IO操作的线程影响较小。</li>
<li>在操作系统中进程是资源分配的最小单位，线程是系统调度和分派的最小单位，多个线程是共享同一套资源的，多个线程同时操作同一个资源时就会引发竞争。</li>
</ul>
<p>乍一看由于GIL的存在能够避免多线程出现资源竞争的问题，其实不然，先看下面这个例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">desc</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        a -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=add)</span><br><span class="line">    t2 = threading.Thread(target=desc)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<p>多次运行结束后a的值是不固定的，很多初学者会认为python是一行一行来运行的，如果是这样的话上面的结果必然是0了，事实上python解释器会将我们的代码转换成字节码然后才执行的。通过dis函数可以打印出转换过后的字节码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dis</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a</span>):</span><br><span class="line">    a += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">desc</span>(<span class="params">a</span>):</span><br><span class="line">    a -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dis.dis(add))</span><br><span class="line"><span class="built_in">print</span>(dis.dis(desc))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 25           0 LOAD_FAST                0 (a)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 (1)</span></span><br><span class="line"><span class="string">              4 INPLACE_ADD</span></span><br><span class="line"><span class="string">              6 STORE_FAST               0 (a)</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               0 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string"> 28           0 LOAD_FAST                0 (a)</span></span><br><span class="line"><span class="string">              2 LOAD_CONST               1 (1)</span></span><br><span class="line"><span class="string">              4 INPLACE_SUBTRACT</span></span><br><span class="line"><span class="string">              6 STORE_FAST               0 (a)</span></span><br><span class="line"><span class="string">              8 LOAD_CONST               0 (None)</span></span><br><span class="line"><span class="string">             10 RETURN_VALUE</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>可以看到a+&#x3D;1, a-&#x3D;1, 都被转换成四个字节码了，python在运行过程中执行一定数量的字节码或者运行了一段时间之后可能就会发生切换，从线程1切换到线程2，这个时候如果a+&#x3D;1的操作没有执行完，a的结果就会是错误的。</p>
<p>所以GIL并不能保证线程安全。如何保证请往下看。</p>
<h2 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h2><h4 id="通过Thread类实例化"><a href="#通过Thread类实例化" class="headerlink" title="通过Thread类实例化"></a>通过Thread类实例化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading,time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">t1 = threading.Thread(target=run,args=(<span class="string">&quot;t1&quot;</span>,))</span><br><span class="line">t2 = threading.Thread(target=run,args=(<span class="string">&quot;t2&quot;</span>,))</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>

<h4 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name=name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line">        time.sleep(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">t1 = MyThread(<span class="string">&#x27;t1&#x27;</span>)</span><br><span class="line">t2 = MyThread(<span class="string">&#x27;t2&#x27;</span>)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>

<h4 id="join-amp-setDaemon"><a href="#join-amp-setDaemon" class="headerlink" title="join &amp; setDaemon"></a>join &amp; setDaemon</h4><p>在默认情况下，主线程会在子线程结束后才会退出，这在某些时候不是我们想要的，这时候将子线程设置为守护线程，守护线程的子线程不会阻止主线程的退出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(<span class="title class_ inherited__">Thread</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, sleep</span>):</span><br><span class="line">        self.sleep = sleep</span><br><span class="line">        <span class="built_in">super</span>().__init__(name=name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name)</span><br><span class="line">        time.sleep(self.sleep)</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">&#x27;t1&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">&#x27;t2&#x27;</span>, <span class="number">2</span>)</span><br><span class="line">    t2.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将t2设置为守护线程的结果， 可以看出t1结束后主线程退出，没有打印出t2的结果</span></span><br><span class="line"><span class="comment"># t1</span></span><br><span class="line"><span class="comment"># t2</span></span><br><span class="line"><span class="comment"># t1end</span></span><br></pre></td></tr></table></figure>

<p>join方法则会将线程阻塞，知道该线程执行完成后才继续往下运行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">&#x27;t1&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">&#x27;t2&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># t1阻塞后的结果，t1线程运行结束后才开始运行t2线程</span></span><br><span class="line"><span class="comment"># t1</span></span><br><span class="line"><span class="comment"># t1end</span></span><br><span class="line"><span class="comment"># t2</span></span><br><span class="line"><span class="comment"># t2end</span></span><br></pre></td></tr></table></figure>

<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h4 id="使用全局变量"><a href="#使用全局变量" class="headerlink" title="使用全局变量"></a>使用全局变量</h4><p>在最上面的GIL部分已经使用到了全局变量来实现两个线程的通信，由于多线程资源竞争的关系，单纯的全局变量不是线程安全的，为了让全局变量变成线程安全需要使用线程锁来实现，这点会单独放到线程同步里面详细说明。</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>queue模块中总共包含三种队列模式，Queue（先进先出）LifoQueue（后进先出）PriorityQueue（自定义优先级），这三种队列都是线程安全的通过名称很容易知道每种模式的区别，这里不做详细说明。</p>
<p>Queue提供了 <code>get()</code> <code>put()</code>  方法实现获取以及添加，在实例化的时候通过maxsize参数指定队列的最大容量，默认为0不限制大小。</p>
<p><code>get()</code> <code>put()</code>  方法默认都是阻塞的，可以通过block&#x3D;False 以及 timeout参数实现非阻塞，超时后会抛出异常。同时也有<code>get_nowait()</code> <code>put_nowait()</code> 两个非阻塞的方法，没有get或者put成功会立即抛出异常</p>
<p>下面通过模拟一个简单的爬虫来了解如何通过queue实现两个线程间的通信</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">detail_list_queue = Queue(maxsize=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_detail_html</span>(<span class="params">queue, name</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        url = queue.get()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; start -- &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name, url))</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        queue.task_done()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; end -- &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name, url))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_detail_url</span>(<span class="params">queue</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start get list&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        queue.put(<span class="string">&#x27;www.demo.com/detail/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end get list&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=get_detail_url, args=(detail_list_queue,))</span><br><span class="line">    t2 = threading.Thread(target=get_detail_html, args=(detail_list_queue, <span class="string">&#x27;t2&#x27;</span>))</span><br><span class="line">    t3 = threading.Thread(target=get_detail_html, args=(detail_list_queue, <span class="string">&#x27;t3&#x27;</span>))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br><span class="line">    detail_list_queue.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;---end---&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码里面有一个线程模拟获取URL，另外两个线程模拟从队列里面获取URL并请求对应的HTML，从结果中能够看出，t2、t3线程依次从队列中获取URL并请求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">start get list</span><br><span class="line">---end---</span><br><span class="line">t2 start -- www.demo.com/detail/0</span><br><span class="line">t3 start -- www.demo.com/detail/1</span><br><span class="line">t2 end -- www.demo.com/detail/0</span><br><span class="line">t2 start -- www.demo.com/detail/2</span><br><span class="line">t3 end -- www.demo.com/detail/1</span><br><span class="line">t3 start -- www.demo.com/detail/3</span><br><span class="line">t2 end -- www.demo.com/detail/2</span><br><span class="line">end get list</span><br><span class="line">t3 end -- www.demo.com/detail/3</span><br></pre></td></tr></table></figure>

<p><code>join()</code> <code>task_done()</code> 和线程的 join 一样 queue 的 join 方法也会阻塞，queue 会记录未完成的个数，<code>put()</code> 成功后次数加一  ,  <code>task_done()</code>  次数减一。当未完成个数为0时会解除阻塞。需要注意使用了 join 后 必须调用 task_done 来解除阻塞</p>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>线程同步主要解决的就是最上面介绍的资源竞争问题，防止在不同的线程中同时对同一个变量操作引发资源竞争，导致最终的结果不是预期情况。</p>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>Python多线程中一般通过 “锁” 来实现线程间的同步，Lock 可以让被加锁的代码段同一时刻只有一个能够运行，只有当这把锁释放了才会去运行其他代码，这就避免了当一个代码段没有执行完就切换到另外的线程中去。</p>
<p>这里我们对GIL部分的事例代码做一下优化，让最终的结果符合预期表现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        a += <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">desc</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        a -= <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = threading.Thread(target=add)</span><br><span class="line">    t2 = threading.Thread(target=desc)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<p>上面的事例使用到了 Lock 的 <code>acquire()</code> <code>release()</code> 两个方法，分别对应 获取锁， 释放锁。当获取不到锁的时候会被阻塞，所以在使用锁的时候必须释放，否则我们的代码就会出现死锁。</p>
<p>常见的死锁导致的原因：</p>
<ul>
<li><p>获取锁之后没有释放</p>
</li>
<li><p>互相等待</p>
<p>我们模拟一个银行相互转账的例子来说明（不考虑真实场景）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">lock_a = threading.Lock()</span><br><span class="line">lock_b = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, money</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.money = money</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">recv</span>(<span class="params">self, amount</span>):</span><br><span class="line">        self.money += amount</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&#x27;add&#x27;</span>, amount)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self, amount</span>):</span><br><span class="line">        self.money -= amount</span><br><span class="line">        <span class="built_in">print</span>(self.name, <span class="string">&#x27;desc&#x27;</span>, amount)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相互转账我们分为两个步骤，即A -&gt; B , B -&gt; A</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">a_to_b</span>(<span class="params">account_a, account_b, amount</span>):</span><br><span class="line">    lock_a.acquire()  <span class="comment"># 先获取锁将A账户金额锁住</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 模拟A账户扣减耗时</span></span><br><span class="line">    account_a.send(amount)</span><br><span class="line">    lock_b.acquire()</span><br><span class="line">    account_b.recv(amount)  <span class="comment"># 锁住B账户金额</span></span><br><span class="line">    lock_a.release()</span><br><span class="line">    lock_b.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b_to_a</span>(<span class="params">account_b, account_a, amount</span>):</span><br><span class="line">    lock_b.acquire()  <span class="comment"># 先获取锁将B账户金额锁住</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    account_b.send(amount)</span><br><span class="line">    lock_a.acquire()</span><br><span class="line">    account_a.recv(amount)  <span class="comment"># 锁住A账户金额</span></span><br><span class="line">    lock_b.release()</span><br><span class="line">    lock_a.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    account_a = Account(<span class="string">&#x27;a&#x27;</span>, <span class="number">1000</span>)</span><br><span class="line">    account_b = Account(<span class="string">&#x27;b&#x27;</span>, <span class="number">2000</span>)</span><br><span class="line">    t1 = threading.Thread(target=a_to_b, args=(account_a, account_b, <span class="number">100</span>))</span><br><span class="line">    t2 = threading.Thread(target=b_to_a, args=(account_b, account_a, <span class="number">50</span>))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span>, account_a.money)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;b&#x27;</span>, account_b.money)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- result --   </span></span><br><span class="line"><span class="comment"># a desc 100</span></span><br><span class="line"><span class="comment"># b desc 50</span></span><br></pre></td></tr></table></figure>

<p>先获取账户A的锁等待获取B的锁，此时在另外的一个线程中已经获取了B账户的锁但是又在等待A账户的锁，这就导致两个线程中锁互相等待的情况出现，程序无法向下运行了</p>
</li>
<li><p>调用其他外部方法，外部方法中也调用了锁</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    lock.acquire()</span><br><span class="line">    func1()</span><br><span class="line">    lock.release()</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h4><p>Rlock 和 Lock 功能上是类似的，Rlock在<code>同一个线程</code>内可以 acquire 多次，release 的次数一定要与 acquire 次数一致。</p>
<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><p>这个类可以让一个或多个线程等待，直到其他线程通知，通过这样我们可以让多个线程之间互相切换运行。</p>
<p>Condition 在实例化的时候可以传递一个Lock 或者 RLock 对象，否则会默认创建一个 RLock 作为底层锁。</p>
<p>Condition 提供了四种常用的方法，<code>wait(timeout=None)</code>  <code>notify(n=1)</code>  <code>wait_for(predicate, timeout=None)</code>  <code>notify_all()</code>  ，调用这些方法之前必须获取锁，否则会抛出 RuntimeError 异常</p>
<ul>
<li>wait 方法的时候 Condition 会先释放底层锁，然后阻塞，直到被另外线程的同一 Condition 通过 notify 或者 notify_all 唤醒。</li>
<li>notify 方法可指定唤醒多少个等待这个 Condition 的线程，默认为一个。</li>
<li>wait_for 方法作用同 wait 一样，只是多个 predicate 参数，此参数接收一个 callable 对象，他的返回值必须是可以判断真假的，调用次方法是将会一直等待只有当 predicate 返回为真时才将 predicate 返回值返回。</li>
<li>notify_all  顾名思义唤醒所有等待这个 Condition 的线程。</li>
</ul>
<p>例如下面的这个两个线程循环输出连续的数字</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">cond = threading.Condition()</span><br><span class="line"></span><br><span class="line">list_1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">list_2 = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="keyword">global</span> list_1</span><br><span class="line">    <span class="keyword">global</span> cond</span><br><span class="line">    <span class="keyword">with</span> cond:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> list_1:</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            cond.notify()</span><br><span class="line">            cond.wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():</span><br><span class="line">    <span class="keyword">global</span> list_2</span><br><span class="line">    <span class="keyword">global</span> cond</span><br><span class="line">    <span class="keyword">with</span> cond:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> list_2:</span><br><span class="line">            cond.wait()</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">            cond.notify()</span><br><span class="line"></span><br><span class="line">threading.Thread(target=func2).start()</span><br><span class="line">threading.Thread(target=func1).start()</span><br></pre></td></tr></table></figure>

<h4 id="Semaphore-amp-BoundedSemaphore"><a href="#Semaphore-amp-BoundedSemaphore" class="headerlink" title="Semaphore &amp; BoundedSemaphore"></a>Semaphore &amp; BoundedSemaphore</h4><p>信号量，Python 多线程的一个内置计数器，通过 acquire 和 release 实现计数加减</p>
<ul>
<li>acquire(blocking&#x3D;True, timeout&#x3D;None)  当 blocking 设置为False 时将不会阻塞并立即返回 False，否则将阻塞直到计数大于 0 并返回 True ，timeout 将在超时后返回 False。</li>
<li>release() 释放信号量，计数加一。</li>
</ul>
<p>BoundedSemaphore 继承 Semaphore 类，重载了 release()  方法，使得不能无限制的 release ，当计数值大于等于初始值时会抛出异常。</p>
<p>下面是通过信号量实现同时只有三个线程运行的示例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line">sem = threading.Semaphore(value=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    sem.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;func start&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    sem.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    threading.Thread(target=func).start()</span><br></pre></td></tr></table></figure>

<h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>多线程中的事件对象，管理一个标志位，通过 set () 、clear() 、 wait() 、is_set() 来获取或者管理标志位。</p>
<p>Event 初始化的时候标志位是False。</p>
<ul>
<li>set() 设置标志位为True。</li>
<li>clear() 设置标志位为False。</li>
<li>wait() 等待标志位设为True。</li>
<li>is_set() 判断标志位是否为True。</li>
</ul>
<p>过于简单不写对应的例子了。</p>
<p>回顾上面的 Condition 、Semaphore、Event 从源码上来看底层都是基于 Lock 和 Rlock 来实现的，只是封装了常用的一些用法方便开发者调用，万变不离其宗线程间的同步我们只需要抓住 “ 锁 ” 这个概念，理解和使用起来就没什么大问题。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>在上面我们通过信号量实现了一个简单的线程池，只是功能比较简单。其实 Python 给我们提供了线程池功能，位于 concurrent.futures 模块下面 ThreadPoolExecutor，下面将简单的介绍 Python 线程池所提供的功能。</p>
<h4 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h4><p>实例化 ThreadPoolExecutor 时有四个可选参数，分别是</p>
<ul>
<li>max_workers 设置最大线程数量，默认为当前计算机CPU数量的5倍。</li>
<li>thread_name_prefix 设置线程名称前缀。</li>
<li>initializer 设置每个线程初始化之前的都会调用的方法，参数值必须为可调用的。</li>
<li>initargs 传给 initializer 的参数。</li>
</ul>
<p>通过 submit 方法将需要执行的方法提交到线程池中，非阻塞，会立即返回一个 futures 对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">times</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;run for &#123;&#125; seconds&#x27;</span>.<span class="built_in">format</span>(times))</span><br><span class="line">    time.sleep(times)</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>, initializer=start, initargs=(<span class="string">&#x27;start&#x27;</span>,))</span><br><span class="line">executor.submit(run, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>也可以使用 map 方法批量提交，返回一个 线程执行结果的生成器，此方法是阻塞的，只有等到所有的线程都执行完毕才会继续。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span>  executor.<span class="built_in">map</span>(run, (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)):</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>

<p>关闭线程池  shutdown(wait&#x3D;True) ，关闭后 submit 、map 将会抛出 RuntimeError ，wait 为 True 时将会阻塞直到所有线程执行结束，为 False 立即返回</p>
<h4 id="获取子线程返回结果"><a href="#获取子线程返回结果" class="headerlink" title="获取子线程返回结果"></a>获取子线程返回结果</h4><ul>
<li><p>使用 map 提交线程 </p>
</li>
<li><p>使用 future.result()</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task = executor.submit(run, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(task.result())</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 as_completed  需要传递一个可迭代的 future 对象，将返回一个已完成的 future 生成器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasks = [executor.submit(run, i) <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line"><span class="keyword">for</span> future <span class="keyword">in</span> as_completed(tasks):</span><br><span class="line">    <span class="built_in">print</span>(future.result())</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><p>wait() 阻塞主线程直到 传递进去的 future 满足某些条件，可以通过 return_when 参数决定什么时候阻塞完成，返回值是一个有两个值 namedtuple 第一个是已完成或者已取消的 future 集合，第二个是没有完成的 future 集合</p>
<ul>
<li><p>ALL_COMPLETED（默认）  等待所有 future 完成后返回</p>
</li>
<li><p>FIRST_COMPLETED  某一个 future 完成或者取消是返回</p>
</li>
<li><p>FIRST_EXCEPTION  抛出异常是返回，如果没有异常抛出则和 ALL_COMPLETED 等效</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait, FIRST_COMPLETED</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">times</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;run for &#123;&#125; seconds&#x27;</span>.<span class="built_in">format</span>(times))</span><br><span class="line">    time.sleep(times)</span><br><span class="line">    <span class="keyword">return</span> times</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">tasks = [executor.submit(run, i) <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">future_tuple = wait(tasks, return_when=FIRST_COMPLETED)</span><br><span class="line"><span class="built_in">print</span>(future_tuple.done)</span><br><span class="line"><span class="built_in">print</span>(future_tuple.not_done)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- result --</span></span><br><span class="line"><span class="comment"># run for 1 seconds</span></span><br><span class="line"><span class="comment"># run for 2 seconds</span></span><br><span class="line"><span class="comment"># &#123;&lt;Future at 0x10a96eb38 state=finished returned int&gt;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&lt;Future at 0x10ab38240 state=running&gt;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>cancle() 由 future 提供的方法，可以将还没有运行的线程取消掉，取消成功返回True。</p>
</li>
<li><p>done() 由future 提供的方法，判断是否运行结束。</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-14T08:30:24.000Z" title="5/14/2021, 4:30:24 PM">2021-05-14</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/Django/">Django</a></span><span class="level-item">5 分钟读完 (大约766个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/14/Django%20rest%20framework%20%20%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Django rest framework  认证组件源码分析</a></h1><div class="content"><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>想要弄清楚rest framework的执行过程首先需要明白Django中CBV和FBV执行流程，http请求最最本质的就是一个socket，一个请求过来第一步就是做路由匹配，在FBV中因为视图本身就是一个函数，所以直接调用函数就可以了，但是CBV中视图是一个类而在这个类里面是我们编写的视图函数，所以比FBV多了一步如何找到那个函数并且执行它。</p>
<p>CBV中是基于反射实现请求方式不同执行不同的方法，我们在使用CBV来实现的时候，通常都是在路由中使用as_view方法。<br /></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&#x27;^dashboard$&#x27;, views.Dashboard.as_view())</span><br></pre></td></tr></table></figure>

<p>这个方法存在于我们继承的父类View中，在as_view内部又会调用dispatch方法通过反射去找到对应的函数<br /><br><img src="/2021/05/14/Django%20rest%20framework%20%20%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png"><br><img src="/2021/05/14/Django%20rest%20framework%20%20%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png"></p>
<p>所以总得来说，在CBV中一个请求过来的具体流程：url  → view → as_view → dispatch<br><img src="/2021/05/14/Django%20rest%20framework%20%20%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3.png"></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>有了上面的基础接下来就比较容易理解了</p>
<p>首先在使用rest framework框架的时候 CBV不在是继承django的View了而是 rest framework的APIView，只是这个APIView也是继承django的View的，只不过是在原有的View中增加了很多功能而已，依然还是通过反射来实现的，所以跳过前面的内容直接到dispatch这部分</p>
<p><img src="/2021/05/14/Django%20rest%20framework%20%20%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/4.png"><br><img src="/2021/05/14/Django%20rest%20framework%20%20%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/5.png"></p>
<p>正式进入正题，restframework主要包含认证、解析器、分页和序列化四个大的部分，就对应上图框框内的几个部分，这几个部分流程大致相同，所以就以认证为例来具体说说他的流程</p>
<p>咱们接着上图继续往下一步一步走，首先会获取所有认证类的实例化对象。<br><img src="/2021/05/14/Django%20rest%20framework%20%20%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/6.png"></p>
<p>如果自己写的类里面没有认证类，就会到基类中继续寻找，默认使用rest framework的配置文件中的认证类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES</span><br></pre></td></tr></table></figure>
<p>拿到了认证所需要的类的对象，就继续返回到dispatch中，这时候request已经是增加内容了的request</p>
<p>返回dispatch之后回调用initial方法，在这个方法里面会执行所有之前我们添加的认证类、解析类<br><img src="/2021/05/14/Django%20rest%20framework%20%20%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/7.png"></p>
<p>initial方法里面跳转比较频繁，这里截图就重叠到一起方便看，经过一路的跳转最终是执行了request对象的_authenticate方法<br><img src="/2021/05/14/Django%20rest%20framework%20%20%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/8.png"></p>
<p>在_authenticate方法里面，会依次执行所有认证类的authenticate方法（由此我们也能知道如果我们想编写自己的认证类，那么认证部分需要放在authenticate方法里面），同时会将返回值赋值给request的user和auth属性<br /><br><img src="/2021/05/14/Django%20rest%20framework%20%20%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/9.png"></p>
<p>所以rest framework的认证流程总得来说就是<br><img src="/2021/05/14/Django%20rest%20framework%20%20%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/10.png"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-07T11:42:49.000Z" title="5/7/2021, 7:42:49 PM">2021-05-07</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></span><span class="level-item">24 分钟读完 (大约3570个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/07/HTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/">HTTP协议基础</a></h1><div class="content"><h2 id="HTTP协议基础"><a href="#HTTP协议基础" class="headerlink" title="HTTP协议基础"></a>HTTP协议基础</h2><p><strong>总结于图解HTTP协议</strong></p>
<h3 id="什么是URI和URL？"><a href="#什么是URI和URL？" class="headerlink" title="什么是URI和URL？"></a>什么是URI和URL？</h3><p>URI（统一资源标识符）表示的是某一个互联网资源， URL（统一资源定位符）相交于URI我们对于URL要更为熟悉一些，我们在浏览器上输入的网站地址其实就是一个URL 例如：<a target="_blank" rel="noopener" href="http://www.google.com/">http://www.google.com</a> ，URL表示的是资源的地点，所以呢URL是URI的一个子集，URI中包含URL的。</p>
<p>用一个形象点的例子来说明URI和URL的区别：我们每一个人都有身份证，每一个人的身份证号都是不同的，可以根据这个号码来找到这个唯一的人，这就相当于URI，而URL呢则类似于身份证上的地址信息，例如（某某省&#x2F;某某市&#x2F;某某区&#x2F;某某街道&#x2F;某某门牌号&#x2F;姓名）通过这个地址我们也能找到这个人。</p>
<h3 id="URI格式"><a href="#URI格式" class="headerlink" title="URI格式"></a>URI格式</h3><p>绝对URI格式<br><img src="/2021/05/07/HTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/1.png"><br>一个绝对的URI包含了</p>
<ol>
<li>协议名<ul>
<li>使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号</li>
</ul>
</li>
<li>认证信息（可选）<ul>
<li>指定用户名和密码作为从服务器端获取资源时必要的登录信息</li>
</ul>
</li>
<li>服务器地址<ul>
<li>使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似google.com 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。</li>
</ul>
</li>
<li>服务器端口号（可选）<ul>
<li>指定服务器连接的网络端口号。此项也是可选项，若用户省略则自动使用默认端口号。</li>
</ul>
</li>
<li>带层次的文件路径<ul>
<li>指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件目录结构相似。</li>
</ul>
</li>
<li>查询字符串（可选）<ul>
<li>针对已指定的文件路径内的资源，可以使用查询字符串传入任意参数。</li>
</ul>
</li>
<li>片段标识位（可选）</li>
</ol>
<h3 id="HTTP协议用于客户端和服务器端之间的通信"><a href="#HTTP协议用于客户端和服务器端之间的通信" class="headerlink" title="HTTP协议用于客户端和服务器端之间的通信"></a>HTTP协议用于客户端和服务器端之间的通信</h3><p>在应用HTTP协议的时候必定一端为客户端而另一端为服务端角色，客户端通过请求，服务器端反馈响应实现两者之间的通信（请求必定是客户端发送的，服务器端在没有接收到请求的时候是不能发送响应的）</p>
<ul>
<li><p>发送请求</p>
<p>一个简单的请求报文内容</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>baidu.com</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br></pre></td></tr></table></figure>

<p>起始行首先声明了请求访问服务器的类型为GET ， 随后的字符串<code>/index.html</code>指明了请求访问的资源对象，最后是HTTP协议的版本号</p>
<p>下面的是请求首部字段，这里面通常会有Host、Connection、Content-Type等等，除了这些可能还会包含内容实体用于发送请求的数据</p>
</li>
<li><p>返回响应</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 04 Mar 2019 07:34:18 GMT</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="section">&lt;html&gt;</span></span></span><br><span class="line"><span class="language-apache"><span class="section">&lt;/html&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>同样的在第一行中HTTP&#x2F;1.1 表示了服务器对应的HTTP版本， 200 OK表示请求的处理结构的状态码和原因短语，第二行显示了创建响应的日期和时间，接着空一行，之后的就是响应的资源实体了</p>
</li>
<li><p><strong>HTTP协议是不保存状态的协议</strong></p>
<p>HTTP本身是无状态的协议，自身不会对请求和响应之间的通信状态进行保存，但是往往我们在浏览网页的时候进行页面跳转需要保留我们的登陆信息以便服务器知道每次请求是谁发送的，所以就有了Cookie技术</p>
</li>
<li><p><strong>使用Cooke实现状态管理</strong></p>
<p>Cookie技术通过在请求和响应报文中写入Cookie信息来实现对客户端的状态的控制</p>
<p>首先Cookie会根据服务器端响应报文内的set-cookie字段信息通知客户端保存cookie，下次客户端再请求的时候将接收到的cookie值添加到请求报文中发出</p>
<p>客户端在接收到携带有cookie的请求后会根据cookie值和服务器上的记录进行比对以此来确定客户端的状态</p>
<ul>
<li><p>没有cookie时候的请求报文</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>baidu.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器接收到没有cookie的响应返回</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 04 Mar 2019 07:34:18 GMT</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line">＜Set-Cookie: sid=1342077140226724; path=/; expires=Mon, 04 Mar 2019 07:34:18 GMT＞</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="section">&lt;html&gt;</span></span></span><br><span class="line"><span class="language-apache"><span class="section">&lt;/html&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端携带cookie发送请求</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>baidu.com</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>sid=1342077140226724</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>更进一步：session的使用</strong></p>
<p>session的应用是基于cookie的，cookie无法存储复杂的数据，这时候就需要用到session来实现，session保存于服务器端类似以key-value结构，其中key值可以使用cookie存放，每次请求过来时候服务器端可以通过cookie值去session中获取对应的用户信息，以此记录控制客户端的状态（cookie存放在客户端中，session保存于服务器端）</p>
</li>
<li><p><strong>http请求方法</strong></p>
<ul>
<li><p>GET：获取资源</p>
</li>
<li><p>POST：传输实体主体</p>
</li>
<li><p>PUT：传输文件</p>
</li>
<li><p>DELETE：删除文件</p>
</li>
<li><p>HEAD：获取报文首部</p>
</li>
<li><p>OPTIONS：询问支持的方法</p>
<p>响应报文</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Allow</span><span class="punctuation">: </span>GET, POST, HEAD, OPTIONS</span><br></pre></td></tr></table></figure>
</li>
<li><p>TRACE：追踪路径，让服务器端将之前的请求通信环回给客户端（可以用来查询请求是如何加工或者传递到服务器端的）</p>
</li>
<li><p>CONNECT: 使用隧道协议连接代理</p>
<p>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。</p>
</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/07/HTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/2.png"></p>
<ul>
<li><p>长连接</p>
<p>在早期的http协议中，每次通信就需要断开TCP连接，随着时代的发展一个页面可能需要请求很多次，这样一来就会不断的断开连接增加通信的开销，所以在1.1和部分1.0版本中出现了持久连接，只要一端没有明确提出断开连接，那么就会保持TCP的连接状态</p>
</li>
<li><p>HTTP报文内的HTTP信息</p>
<p>HTTP报文大致可分为报文首部+报文主体两块，两者通过（CR+LF）来划分</p>
</li>
</ul>
<p> <img src="/2021/05/07/HTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/3.png"></p>
<ul>
<li><p>获取部分内容的范围请求</p>
<p>执行范围请求的时候，请求体的首部字段Range需要用来指定资源的byte范围</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>bytes=5001-10000   请求50001-10000字节内容</span><br><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>bytes=5001-        请求5001之后的所有内容    </span><br><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>bytes=-3000, 6000-7000   请求前3000字节和6000-7000字节内容的多重范围</span><br></pre></td></tr></table></figure>

<p>范围请求的响应会返回状态码为206 Partial Content的响应报文，多重范围响应会在首部字段Content-type标明multipart&#x2F;byteranges，如果服务器不支持范围请求那么会返回200 OK和全部实体内容</p>
</li>
</ul>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p><img src="/2021/05/07/HTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/4.png"></p>
<ul>
<li><p>2XX成功   （服务器返回2XX表明请求被正常处理了）</p>
<ul>
<li><p>200 OK</p>
<p>表示客服端发送的请求被服务器端正常处理了</p>
</li>
<li><p>204 No Content</p>
<p>表示客服端发送的请求被服务器端正常处理了，但是在返回的响应报文中不包含实体部分</p>
</li>
<li><p>206 Partial Content</p>
<p>就是上面说的范围请求响应</p>
</li>
</ul>
</li>
<li><p>3XX重定向  （浏览器需要执行某些其他的处理才能服务器端才能正常处理请求）</p>
<ul>
<li><p>301 Moved Permanently</p>
<p>永久性的重定向，表明改请求资源的URI发生更改了，需要请求新的URI</p>
</li>
<li><p><strong>302 Found</strong></p>
<p>临时重定向，和上面的不同，服务器希望本次使用新的URI进行访问，只是临时性的</p>
</li>
<li><p>303 See Other</p>
<p>表示请求的资源存在另一个URI，应该使用GET方法请求该资源，例如使用POST方法访问某个资源，但是服务器处理的结果是希望客户端使用GET方法来请求这个资源</p>
</li>
<li><p>304 Not Modified</p>
<p>该状态码表示客户端使用GET方法并且请求报文中包含 If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since 中任一首部，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。</p>
</li>
<li><p>307 Temporary Redirect</p>
<p>临时重定向和302相同，但是禁止POST变成GET</p>
</li>
</ul>
</li>
<li><p>4XX 客户端错误 （客服端发送的请求服务器无法正确处理）</p>
<ul>
<li><p><strong>400Bad Request</strong></p>
<p>请求报文中存在语法错误</p>
</li>
<li><p>401 Unauthorized</p>
<p>需要通过HTTP认证才可访问（BASIC认证、DIGEST认证）</p>
</li>
<li><p><strong>403 Forbidden</strong></p>
<p>这次请求被服务器拒绝了</p>
</li>
<li><p><strong>404 Not Found</strong></p>
<p>服务器无法找到此次请求的资源</p>
</li>
</ul>
</li>
<li><p>5XX 服务器错误</p>
<ul>
<li><p><strong>500 Internal Server Error</strong></p>
<p>服务器处理请求是发生错误</p>
</li>
<li><p>503 Service Unavailable</p>
<p>服务器超载，无法处理请求</p>
</li>
</ul>
</li>
</ul>
<h3 id="WEB服务器"><a href="#WEB服务器" class="headerlink" title="WEB服务器"></a>WEB服务器</h3><ul>
<li><p>在一台主机上部署多个web站点</p>
<p>在HTTP&#x2F;1.1协议规范中允许一台服务器搭建多个web网站，假如一台服务器中绑定了<a target="_blank" rel="noopener" href="http://www.baidu.com和www.google.com/">www.baidu.com和www.google.com</a> 两个域名的时候，我们输入这两个域名的时候都会解析到同一个IP地址上，这个时候如果想要区分用户请求的是那个域名就必须在请求首部Host指定域名。</p>
</li>
<li><p>代理服务器</p>
<p><img src="/2021/05/07/HTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/5.png"></p>
<p>代理服务器最基本的功能就是接受客户端的请求，并将请求转发给其他的服务器，代理并不会改变请求的URL，会直接将请求进行转发，每次通过代理服务器转发请求的或者响应的时候都会在首部添加Via信息，最常见的代理服务就是我们使用的翻墙服务。</p>
<p>代理服务还细分为正向代理和反向代理，通俗来说正向代理是针对于客户端（服务器端并不知道客户端的真实信息），反向代理是针对于服务器端（客户端不知道服务器端的实际地址）</p>
<p>正向代理的作用：</p>
<ol>
<li>翻墙（访问客户端无法访问的资源）</li>
<li>缓存，加速访问速度</li>
<li>对外隐藏真实的客户端信息</li>
</ol>
<p>反向代理的作用：</p>
<ol>
<li>保证内网的安全</li>
<li>负载均衡</li>
</ol>
</li>
<li><p>网关</p>
<p><img src="/2021/05/07/HTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/6.png"></p>
<p>网关和代理的作用很类似，但是网关能够实现非HTTP协议的服务，利用网关可以提高通信的安全性。</p>
</li>
<li><p>隧道</p>
<p><img src="/2021/05/07/HTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/7.png"></p>
<p>在客户端和服务器端建立一条加密的通信线路，确保客户端和服务器端的安全通信，隧道本身不会解析HTTP请求，会原样将请求转发给服务器。</p>
</li>
</ul>
<h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><p>之前提到过一个HTTP的报文主要分为首部和主体两个部分，主体部分不是客户端和服务器端根据操作生成的所以没有办法去介绍，在此只介绍部分常见的首部字段的作用和用法。</p>
<p>下图是分别是请求报文和响应报文的首部构成：</p>
<p><img src="/2021/05/07/HTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/8.png"></p>
<p>字段结构：<strong>字段名：字段值1, 字段值2….</strong></p>
<p>报文首部主要分为以下四个部分： </p>
<ol>
<li>通用首都字段</li>
<li>实体首部字段</li>
<li>请求实体字段</li>
<li>响应实体字段</li>
</ol>
<p><strong>常见字段一览</strong></p>
<ul>
<li><p>通用首部字段</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的时间和日期</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody></table>
</li>
<li><p>实体首部字段</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源可支持的HTTP方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的范围位置</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主题过期的日期和时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期和时间</td>
</tr>
</tbody></table>
</li>
<li><p>请求首部字段</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的自然语言</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web认证信息</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag)</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（与If-Match想法）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源为更新时发送实体Byte的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与If-Modified-Since相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>User-Agent</td>
<td>HTTP客户端程序的信息</td>
</tr>
</tbody></table>
</li>
<li><p>响应首部字段</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>是否接收字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建经过的时间</td>
</tr>
<tr>
<td>Etag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>命令客户端重定向至指定URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发送请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP服务器安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的管理信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody></table>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-19T18:21:08.000Z" title="4/20/2021, 2:21:08 AM">2021-04-20</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></span><span class="level-item">4 分钟读完 (大约561个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/20/Postgresql%E7%9A%84%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%8A%9F%E8%83%BD/">Postgresql的全文检索功能</a></h1><div class="content"><p>之前做过一个jieba+whoosh的商品搜索功能，后来发现Postgresql数据库自带有全文检索的功能，那么就尝试使用Postgresql的全文检索功能来实现一次</p>
<h3 id="postgresql配置"><a href="#postgresql配置" class="headerlink" title="postgresql配置"></a>postgresql配置</h3><ul>
<li>环境：Ubuntu16.04</li>
<li>版本：v9.5</li>
</ul>
<hr>
<ul>
<li>外部远程访问：<br>数据库配置文件路径为 <code>/etc/postgresql/9.5/main</code>需要修改的配置文件为postgresql.conf和pg_hba.conf<ul>
<li><code>postgresql.conf</code>（这个文件是数据库的配置文件）<br><code>#listen_addresses=&#39;localhost&#39;</code> 修改为 <code>listen_addresses=&#39;*&#39;</code></li>
<li><code>pg_hba.conf</code>（这个文件是数据库的连接配置文件）<br>在最后添加一行：<code>host    all    all    0.0.0.0/0    md5</code>（意思就是允许任何用户从任何IP访问任何数据库，加密方式为MD5）</li>
<li>重启服务：<code>sudo service postgresql restart</code></li>
</ul>
</li>
<li>插件路径：<code>/usr/share/postgresql/9.5/extension</code></li>
</ul>
<h3 id="zhparser插件的安装"><a href="#zhparser插件的安装" class="headerlink" title="zhparser插件的安装"></a>zhparser插件的安装</h3><hr>
<p>postgresql的本身分词并不支持中文，所以需要使用其他的插件实现中文分词的功能，在这里采用的是zhparser+scws，具体的介绍可以看github主页。</p>
<ul>
<li>下载zhparser源码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/amutu/zhparser.git</span><br></pre></td></tr></table></figure></li>
<li>安装SCWS：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.xunsearch.com/scws/down/scws-1.2.3.tar.bz2</span><br><span class="line">tar xvjf scws-1.2.3.tar.bz2</span><br><span class="line">cd scws-1.2.3</span><br><span class="line">./configure</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li>
<li>安装zhparser：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd zhparser</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果安装报错请先安装相关的库和头文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo apt-get install postgresql-server-dev-9.5</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sudo apt-get install postgresql-common</span></span><br></pre></td></tr></table></figure></li>
<li>配置zhparser扩展：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 连接至目标数据库后</span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION zhparser;</span><br><span class="line"># 这里如果报错：ERROR:  could <span class="keyword">not</span> <span class="keyword">open</span> file &quot;/usr/share/postgresql/9.5/tsearch_data/qc_dict_demo_1.txt&quot; <span class="keyword">for</span> writing: Permission denied</span><br><span class="line"># 在那个目录下没有找到这个文件,最后手动创建了那个文件</span><br><span class="line"># 将zhparser解析器作为全文检索配置项</span><br><span class="line"><span class="keyword">CREATE</span> TEXT <span class="keyword">SEARCH</span> CONFIGURATION chinese (PARSER <span class="operator">=</span> zhparser);</span><br><span class="line"><span class="keyword">ALTER</span> TEXT <span class="keyword">SEARCH</span> CONFIGURATION chinese <span class="keyword">ADD</span> MAPPING <span class="keyword">FOR</span> n,v,a,i,e,l,j <span class="keyword">WITH</span> simple;</span><br></pre></td></tr></table></figure>
安装完成后使用<code>\dFp</code>查看是否安装成功。</li>
</ul>
<h3 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h3><hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> to_tsvector(<span class="string">&#x27;chinese&#x27;</span>, name) @@ to_tsquery(<span class="string">&#x27;chinese&#x27;</span>, <span class="string">&#x27;小米Pro&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>插件装好后好像并不需要我们编写代码了，一个简单的SQL语句就实现了之前的功能。那么如果你使用的是Postgresql数据库推荐使用自带的全文检索功能去实现。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-17T11:42:49.000Z" title="4/17/2021, 7:42:49 PM">2021-04-17</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></span><span class="level-item">10 分钟读完 (大约1571个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/17/jieba+whoosh%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/">jieba+whoosh实现简单的商品搜索功能</a></h1><div class="content"><h4 id="功能描述"><a href="#功能描述" class="headerlink" title="功能描述"></a>功能描述</h4><p>实现一个类似淘宝的搜索功能，例如下面这个例子<br><img src="/2021/04/17/jieba+whoosh%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/1.png"><br>简单点来说我们需要先根据商品名称创建索引，然后再用索引文件匹配去查询字符串来实现商品的搜索，这种搜索是有别于正则匹配的，他会对字符串进行分词处理，准确度也会更高。</p>
<hr>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>这个项目种主要用到了jieba、whoosh两个库，其中jieba实现对中文的分词处理，whoosh则是创建索引文件。<br>安装依赖：</p>
<ul>
<li>系统：Ubuntu 16.04</li>
<li>Python版本： 3.5  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install jieba</span><br><span class="line">pip install whoosh</span><br></pre></td></tr></table></figure>
测试数据：<br>从github上找到的空气净化器的csv数据，需要的可点击下载<a target="_blank" rel="noopener" href="https://github.com/Ckend/taobao_scrapy/blob/master/result/%E7%A9%BA%E6%B0%94%E6%B8%85%E6%96%B0%E5%99%A8_result.csv">测试数据</a></li>
</ul>
<hr>
<h4 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h4><ul>
<li><strong>创建索引文件</strong><br>首先需要利用whoosh提供的接口对csv中的数据进行处理，生成索引文件。<br>whoosh对中文分词处理不是很好，所以选择jieba实现对中文的分词处理，jieba这个库也有对whoosh的支持，所以处理起来很方便，直接将索引模式中的analyzer更换为jieba的ChineseAnalyzer即可。<br><br><code>schema</code>定义了索引的模式，规定了索引的字段信息，其中索引字段包含<code>ID</code>、<code>STROED</code>、<code>KEYWORD</code>、<code>TEXT</code>、<code>NUMERIC</code>、<code>BOOLEAN</code>、<code>DATETIME</code>等几种，具体的含义和使用对象还是去看whoosh的官方文档来的直接，另外schema只需要我们创建一次，然后就会和索引一起被保存。（只需在第一次创建的时候声明schema）  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> whoosh.index <span class="keyword">import</span> create_in</span><br><span class="line"><span class="keyword">from</span> whoosh.fields <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> jieba.analyse.analyzer <span class="keyword">import</span> ChineseAnalyzer</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_index</span>():</span><br><span class="line">   	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   	创建索引文件</span></span><br><span class="line"><span class="string">   	:return: None</span></span><br><span class="line"><span class="string">   	&quot;&quot;&quot;</span></span><br><span class="line">   	analyzer = ChineseAnalyzer()</span><br><span class="line">   	schema = Schema(<span class="built_in">id</span>=ID(stored=<span class="literal">True</span>, unique=<span class="literal">True</span>), content=TEXT(stored=<span class="literal">True</span>, analyzer=analyzer))  <span class="comment"># 声明索引模式</span></span><br><span class="line">   	<span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;index&quot;</span>):  <span class="comment"># 创建目录</span></span><br><span class="line">       	os.mkdir(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">   	ix = create_in(<span class="string">&quot;index&quot;</span>, schema)</span><br><span class="line">   	writer = ix.writer()</span><br><span class="line"></span><br><span class="line">   	<span class="comment"># csv数据</span></span><br><span class="line">   	csv_file = <span class="built_in">open</span>(<span class="string">&#x27;goods.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)  <span class="comment"># 读取csv文件</span></span><br><span class="line">   	data = csv.reader(csv_file)</span><br><span class="line">   	<span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">       	writer.add_document(</span><br><span class="line">           	<span class="built_in">id</span>=i[<span class="number">3</span>],</span><br><span class="line">           	content=i[<span class="number">0</span>]</span><br><span class="line">       	)</span><br><span class="line"> 		writer.commit()</span><br></pre></td></tr></table></figure>
  使用<code>create_in</code>来创建索引文件，以后对索引文件的更删改查都是使用<code>open_dir</code>代开文件。<br><br>  在读取csv数据的时候，使用<code>add_document</code>来新增索引，其中并不是所有在schema中申明的字段都需要存储的可以为空。最后使用<code>commit</code>实现索引文件的正式写入，这一点和数据库很像。</li>
<li><strong>简单的查询</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">from</span> whoosh.index <span class="keyword">import</span> open_dir</span><br><span class="line"><span class="keyword">from</span> whoosh.qparser <span class="keyword">import</span> QueryParser</span><br><span class="line"><span class="keyword">from</span> create_index <span class="keyword">import</span> create_index</span><br><span class="line"><span class="keyword">import</span> os.path</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">keyword, limit=<span class="number">10</span></span>):</span><br><span class="line">   <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   按照关键字搜索商品</span></span><br><span class="line"><span class="string">   :param keyword: 商品名称  type: str</span></span><br><span class="line"><span class="string">   :param limit: 检索数量  type: int</span></span><br><span class="line"><span class="string">   :return: [&#123;&#x27;id&#x27;:&#x27;&#x27;,&#x27;content&#x27;:&#x27;&#x27;&#125;,&#123;&#125;]  type：list</span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">&quot;index&quot;</span>):  <span class="comment"># 查询时没有缩索引文件，需先创建索引文件</span></span><br><span class="line">       create_index()</span><br><span class="line">   ix = open_dir(<span class="string">&quot;index&quot;</span>)  <span class="comment"># 读取索引文件</span></span><br><span class="line">   <span class="keyword">with</span> ix.searcher() <span class="keyword">as</span> searcher:</span><br><span class="line">       parser = QueryParser(<span class="string">&quot;content&quot;</span>, schema=ix.schema)</span><br><span class="line">       keyword = parser.parse(keyword)  <span class="comment"># 构造查询语句</span></span><br><span class="line">       results = searcher.search(keyword, limit=limit)</span><br><span class="line">       res = []</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> results:</span><br><span class="line">           res.append(&#123;<span class="string">&#x27;id&#x27;</span>: i[<span class="string">&#x27;id&#x27;</span>], <span class="string">&#x27;content&#x27;</span>: i[<span class="string">&#x27;content&#x27;</span>]&#125;)</span><br><span class="line">           <span class="built_in">print</span>(i[<span class="string">&#x27;id&#x27;</span>], i[<span class="string">&#x27;content&#x27;</span>])</span><br><span class="line">       <span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
在查询的时候需要先调用whoosh的<code>QueryParser</code>来构建查询字符串，通过调试我发现在构造查询字符串的时候whoosh默认会分词处理，并且使用<code>AND</code>连接符<br><img src="/2021/04/17/jieba+whoosh%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/2.png">通过<code>search(keyword,limit)</code>去索引文件中匹配相关信息，其中<code>limit</code>为匹配到的最大数目，默认为10个。</li>
<li><strong>索引的增删改查</strong><br>在一个系统中商品的信息必然不会是一成不变的，所以我们的索引文件就不可避免的需要按照商品信息去做调整，whoosh同样给我们提供了这样的接口。<ul>
<li>增：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">from</span> whoosh.index <span class="keyword">import</span> open_dir</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_index</span>(<span class="params">name, <span class="built_in">id</span></span>):</span><br><span class="line">   <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   新增索引</span></span><br><span class="line"><span class="string">   :param name: 商品名称  type: str</span></span><br><span class="line"><span class="string">   :param id: 商品id  type: str</span></span><br><span class="line"><span class="string">   :return: None</span></span><br><span class="line"><span class="string">   &quot;&quot;&quot;</span></span><br><span class="line">   ix = open_dir(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">   writer = ix.writer()</span><br><span class="line">   writer.add_document(</span><br><span class="line">       <span class="built_in">id</span>=<span class="built_in">id</span>,</span><br><span class="line">       content=name</span><br><span class="line">   )</span><br><span class="line">   writer.commit(optimize=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
 索引的增加和创建索引只有稍许不同，在<code>commit</code>中增加了<code>optimize</code>参数，翻看whoosh的文档在Merging Segments中提到了两个参数分别是<code>merge</code>和<code>optimize</code>，在默认情况下<code>merge</code>为True，意味着whoosh会将多个segments文件合并到一个文件中，如果<code>merge</code>为False的时候我们提交commit的时候会重新生成一个单独的索引文件，多个索引文件不会对搜索的结果产生很大的差异，如果过多的存在索引会降低整体的查询速度。通常情况下使用whoosh的合并算法将多个文件合并到一个文件中会更好，这只会让在更新索引的速度变慢，用户查询的速度影响较小，这样的用户体验会更好。</li>
<li>删:   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">from</span> whoosh.index <span class="keyword">import</span> open_dir</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_index</span>(<span class="params">name, <span class="built_in">id</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    新增索引</span></span><br><span class="line"><span class="string">    :param name: 商品名称  type: str</span></span><br><span class="line"><span class="string">    :param id: 商品id  type: str</span></span><br><span class="line"><span class="string">    :return: None</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">   	ix = open_dir(<span class="string">&quot;index&quot;</span>)</span><br><span class="line">   	writer = ix.writer()</span><br><span class="line">   	writer.add_document(</span><br><span class="line">       	<span class="built_in">id</span>=<span class="built_in">id</span>,</span><br><span class="line">       	content=name</span><br><span class="line">   	)</span><br><span class="line">   	writer.commit(optimize=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
   whoosh总共有两种删除方式<ul>
<li><code>delete_by_query(query)</code>：删除与给定查询匹配的所有文档。</li>
<li><code>delete_by_term(fieldname, termtext)</code>根据字段删除指定的文档，这里的字段需要在创建schema时指定为unique</li>
</ul>
</li>
<li>改<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> whoosh.index <span class="keyword">import</span> open_dir</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_index</span>(<span class="params">name, <span class="built_in">id</span></span>):</span><br><span class="line"> 	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> 	更新索引文件</span></span><br><span class="line"><span class="string"> 	:param name: 商品名称  type: str</span></span><br><span class="line"><span class="string"> 	:param id: 商品id  type: str</span></span><br><span class="line"><span class="string"> 	:return: None</span></span><br><span class="line"><span class="string"> 	&quot;&quot;&quot;</span></span><br><span class="line"> 	ix = open_dir(<span class="string">&quot;index&quot;</span>)</span><br><span class="line"> 	writer = ix.writer()</span><br><span class="line"> 	writer.update_document(</span><br><span class="line">     	<span class="built_in">id</span>=<span class="built_in">id</span>,</span><br><span class="line">     	content=name</span><br><span class="line"> 	)</span><br><span class="line"> 	writer.commit()</span><br></pre></td></tr></table></figure>
  和删除操作一样索引字段中需要有一个unique</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><hr>
<p>整个功能算是比较简单的了，各种库都给了对应的接口，很够很方便的实现功能。在实现的过程中也遇到了一个问题，最开始在实现增删改查功能的时候使用的事<code>create_in</code>来打开索引文件，这样导致操作完成之后之前的数据被覆盖了，还是自己当初粗心没有仔细看文档导致的。以后要注意这个问题。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-06T18:21:08.000Z" title="4/7/2021, 2:21:08 AM">2021-04-07</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a></span><span class="level-item">7 分钟读完 (大约1041个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/">微信小程序组件设计</a></h1><div class="content"><h2 id="微信小程序组件设计"><a href="#微信小程序组件设计" class="headerlink" title="微信小程序组件设计"></a>微信小程序组件设计</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote>
<p>最近有这么一个需求，商城的数量输入框用户点击的时候清空当前的值，如果用户不输入则还原原来的数量，输入新值则替换。需求很简单，但是之前的代码不是自己写的，整个项目一共6处使用到了，大量重复的逻辑，为了以后维护方便决定将数量加减器封装为一个通用组件。</p>
</blockquote>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul>
<li>有最大值，最小值设置，不可超过范围</li>
<li>加减可以设置步长</li>
<li>点击输入框时清空输入框内容，无输入则还原，否则替换</li>
<li>为增加可复用性，只将最后的结果返回出去，不实现其他业务逻辑部分</li>
<li>考虑到可能会有弹窗提示或者其他的交互，也需要返回输入方式、输入校验结果类型<ul>
<li>输入方式分为：点击加号（add）点击减号（reduce）输入框输入（input）</li>
<li>校验结果：超过最大值（overflow_max）超过最小值（overflow_min）有效输入（success）</li>
</ul>
</li>
</ul>
<h3 id="开始开发"><a href="#开始开发" class="headerlink" title="开始开发"></a>开始开发</h3><h4 id="组件页面布局"><a href="#组件页面布局" class="headerlink" title="组件页面布局"></a>组件页面布局</h4><p>首先我们先将组件的样式以及页面布局确定下来</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--wxml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;counter-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;reduce-btn &#123;&#123;currentCount&lt;=min? &#x27;disabled&#x27; : &#x27;&#x27;&#125;&#125;&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span>  <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;currentCount&#125;&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;add-btn &#123;&#123;currentCount&gt;=max? &#x27;disabled&#x27; : &#x27;&#x27;&#125;&#125;&quot;</span> &gt;</span>+<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* wxss */</span></span><br><span class="line"><span class="selector-class">.counter-container</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">164</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">48</span>rpx;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">48</span>rpx;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">24</span>rpx;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">8</span>rpx <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.counter-container</span> <span class="selector-class">.reduce-btn</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">48</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">1</span>rpx solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1</span>rpx solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1</span>rpx solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-bottom-left-radius</span>: <span class="number">6</span>rpx;</span><br><span class="line">  <span class="attribute">border-top-left-radius</span>: <span class="number">6</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.counter-container</span> <span class="selector-class">.reduce-btn</span><span class="selector-class">.disabled</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f5f5f9</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">1</span>rpx solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1</span>rpx solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1</span>rpx solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.counter-container</span> <span class="selector-class">.add-btn</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">48</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">1</span>rpx solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1</span>rpx solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1</span>rpx solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-bottom-right-radius</span>: <span class="number">6</span>rpx;</span><br><span class="line">  <span class="attribute">border-top-right-radius</span>: <span class="number">6</span>rpx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.counter-container</span> <span class="selector-class">.add-btn</span><span class="selector-class">.disabled</span>&#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f5f5f9</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">1</span>rpx solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1</span>rpx solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1</span>rpx solid <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.counter-container</span> <span class="selector-tag">input</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">68</span>rpx;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">48</span>rpx;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">48</span>rpx;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">24</span>rpx;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1</span>rpx solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后的效果图</p>
<p><img src="/2021/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%E8%AE%BE%E8%AE%A1/1.png"></p>
<h4 id="组件逻辑实现"><a href="#组件逻辑实现" class="headerlink" title="组件逻辑实现"></a>组件逻辑实现</h4><p>通过对需求的分析，需要传入的参数有：步长、最大值、最小值、当前值，另外输入前清空输入框这个也做成一个可选项方便满足其他不必须清空的情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">properties</span>: &#123;</span><br><span class="line">  <span class="attr">count</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Number</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">min</span>:&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">max</span>:&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">clear</span>:&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Boolean</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">step</span>:&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>由于有清空的动作，所以在不能直接显示传入的count，需要定义一个内部数据来显示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">  <span class="attr">currentCount</span>: <span class="number">0</span>  <span class="comment">// 用于显示的数量</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>在组件挂载到页面时候设置currentCount，同时由于不是直接显示count的当我们的页面更新count的时候还需要同步更新currentCount，这时候就需要使用到数据监听器来实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lifetimes</span>: &#123;</span><br><span class="line">  <span class="attr">attached</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">currentCount</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">count</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">observers</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;count&#x27;</span>: <span class="keyword">function</span>(<span class="params">count</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">currentCount</span>: count</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>currentCount的计算逻辑，同时通过监听事件触发父组件的逻辑，返回当前count值，输入校验结果类型，以及输入方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">addTap</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;count, check&#125; = <span class="variable language_">this</span>.<span class="title function_">computeCount</span>(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentCount</span> + <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">step</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">changeCount</span>(count, <span class="string">&#x27;add&#x27;</span>, check)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">reduceTap</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123;count, check&#125; = <span class="variable language_">this</span>.<span class="title function_">computeCount</span>(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">currentCount</span> - <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">step</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">changeCount</span>(count, <span class="string">&#x27;reduce&#x27;</span>, check)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">computeCount</span>: <span class="keyword">function</span>(<span class="params">count</span>)&#123;</span><br><span class="line">  <span class="comment">// 判断数字是否处在范围之间</span></span><br><span class="line">  <span class="keyword">if</span>(count &gt; <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">max</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">max</span>, <span class="attr">check</span>: <span class="string">&#x27;overflow_max&#x27;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(count &lt; <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">min</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">min</span>, <span class="attr">check</span>: <span class="string">&#x27;overflow_min&#x27;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>: count , <span class="attr">check</span>: <span class="string">&#x27;success&#x27;</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">changeCount</span>: <span class="keyword">function</span>(<span class="params">count, type, check</span>)&#123;</span><br><span class="line">  <span class="comment">// 修改count和currentCount，同时调用父组件的方法</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    <span class="attr">currentCount</span>: count,</span><br><span class="line">    <span class="attr">count</span>: count</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&#x27;change&#x27;</span>, &#123;count, type, check&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入框的清空与还原，先定义两个方法分别对应输入框的聚焦时和焦点丢失情况</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">focusOn</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="comment">// 输入框获得焦点</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">clear</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">currentCount</span>: <span class="literal">null</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">focusOut</span>: <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line"><span class="comment">// 输入框失去焦点</span></span><br><span class="line">  <span class="keyword">let</span> value = <span class="built_in">parseInt</span>(e.<span class="property">detail</span>.<span class="property">value</span>)</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(value)) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;count, check&#125; = <span class="variable language_">this</span>.<span class="title function_">computeCount</span>(value)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">changeCount</span>(count, <span class="string">&#x27;input&#x27;</span>, check)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">currentCount</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">count</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h4 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--wxml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">counter</span> <span class="attr">count</span>=<span class="string">&quot;1&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">clear</span>=<span class="string">&quot;&#123;&#123;true&#125;&#125;&quot;</span> <span class="attr">bind:change</span>=<span class="string">&quot;changeNum&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">changeNum</span>: <span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="comment">// e.detail就是组件返回的所有数据，在这里就是实现各自的业务逻辑了</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">detail</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-06T18:21:08.000Z" title="4/7/2021, 2:21:08 AM">2021-04-07</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/Odoo/">Odoo</a></span><span class="level-item">24 分钟读完 (大约3592个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/07/odoo/">Odoo</a></h1><div class="content"><h3 id="Odoo的配置项"><a href="#Odoo的配置项" class="headerlink" title="Odoo的配置项"></a>Odoo的配置项</h3><hr>
<p>odoo生成配置文件：.&#x2F;odoo-bin -s -c &lt;保存路径&gt;</p>
<p>odoo使用指定的配置文件进行加载 .&#x2F;odoo-bin -c &lt;配置文件的路径&gt;</p>
<p>odoo脚手架工具-创建简单的模块 ： .&#x2F;odoo-bin scaffold module-name save-path</p>
<p>odoo的addons路径在命令行中是相对路径，配置文件中为绝对路径</p>
<h3 id="odoo模块的基本文件结构："><a href="#odoo模块的基本文件结构：" class="headerlink" title="odoo模块的基本文件结构："></a>odoo模块的基本文件结构：</h3><hr>
<ul>
<li>controllers：网页控制器</li>
<li>demo：测试数据</li>
<li>models：模型结构</li>
<li>security：权限安全相关的文件<ul>
<li>ir.model.access.csv：控制访问权限<ul>
<li>id：外部标识符</li>
<li>name：描述性标题</li>
<li>model_id：model的名称（对应model的_name值，具体的值为model_+（_name的值，将.更换成_）</li>
<li>group_id：指明授权的安全组</li>
<li>perm_read：是否可读</li>
<li>perm_write：是否可写</li>
<li>perm_create：是否可新建</li>
<li>perm_read：是否可删除</li>
</ul>
</li>
</ul>
</li>
<li>views ：视图文件</li>
<li>__init__.py：模块初始化</li>
<li>__manufest__.py: 模块的配置和介绍：<ul>
<li>name：模块名称</li>
<li>summary：模块副标题</li>
<li>description：模块描述</li>
<li>author：模块作者</li>
<li>category：功能性分类字符串</li>
<li>version：版本号</li>
<li>depends：模块依赖</li>
<li>data：安装或更新时需要加载的模块列表</li>
<li>application：是否在应用列表种以APP形式展现</li>
<li>demo：测试数据的文件路径</li>
</ul>
</li>
</ul>
<h3 id="一个简单的APP"><a href="#一个简单的APP" class="headerlink" title="一个简单的APP"></a>一个简单的APP</h3><hr>
<h3 id="Odoo模块继承"><a href="#Odoo模块继承" class="headerlink" title="Odoo模块继承"></a>Odoo模块继承</h3><hr>
<h3 id="Odoo-模型"><a href="#Odoo-模型" class="headerlink" title="Odoo-模型"></a>Odoo-模型</h3><hr>
<p><strong>模型的属性：</strong></p>
<ul>
<li>_name：我们创建模型的内部标识，必填属性。（一般来说命名规则是以点连接小写单词，模型名必须全局唯一）</li>
<li>_description：模型的别称，让用户可以更好的记录，选填属性。</li>
<li>_inherit</li>
<li>_inherits</li>
<li>_order：设置浏览模型记录或者列表视图时的默认排序，对应SQL语句中的order by的值</li>
<li>_rec_name：指定关联字段引用描述，默认使用name字段。</li>
<li>_table：模型对应数据库中的表名。</li>
<li>_log_access&#x3D;False：用于设置不自动创建审计追踪的字段：create_uid, create_date, write_uid, write_date.</li>
<li>_auto&#x3D;False： 设置不自动创建模型对应的数据表，这样设置之后可通过init()方法创建数据库对象。</li>
</ul>
<p><strong>模型的常用字段：</strong></p>
<ul>
<li>Char(string,size,translate,trim)：单行文本，size设置最大长度，translate使字段内容可翻译，trim默认为True去除空格</li>
<li>Text(string)：多行文本</li>
<li>Selection(selection, string)：下拉选项，选项参数为元组列表第一个元素是数据库存储的值，第二个值为界面的显示内容。</li>
<li>Html(string)：针对HTML内容的特殊处理。</li>
<li>Integer(string)：整数类型</li>
<li>Float(string,digits)：浮点型，digits指定字段的精度，是一个元组(x,y)，x为总长度，y为小数位。</li>
<li>Monetary(string,currency_field)：货币类型，与浮点型类似，currency_field用于存储使用的货币种类，默认使用currency_id字段。</li>
<li>Date(string)：日期字段（没有时分秒）</li>
<li>Datetime(string)：日期字段（包含时分秒信息）</li>
<li>Boolean(string)：bool类型，只能为True和False</li>
<li>Binary(string)：存储二进制数据。</li>
</ul>
<p><strong>字段的常见属性：</strong></p>
<ul>
<li>string：字段的标签名，会在页面中显示，如果不设置默认使用字段名</li>
<li>default：设置字段的默认值，可以是具体值，也可以是调用、引用、函数、匿名函数等</li>
<li>help：界面中鼠标悬停时的提示文本</li>
<li>readonly&#x3D;True：在界面中不可编辑</li>
<li>required&#x3D;True：使字段为必填的不可为空值</li>
<li>index&#x3D;True：建立索引</li>
<li>copy&#x3D;False：使用ORM的copy方法时忽略该字段</li>
<li>groups：限制字段仅对一些组可见，值为逗号分隔的安全组XML ID列表</li>
<li>states:</li>
<li>deprecated&#x3D;True：字段在被使用的时候会记录一条warning日志</li>
<li>oldname</li>
</ul>
<p><strong>特殊的字段：</strong></p>
<p>Odoo的ORM保留字段，除id字段外，下面的字段只要在模型中没有设置_log_access&#x3D;False都会自动创建。</p>
<ul>
<li>create_uid：创建记录的用户</li>
<li>create_date：创建记录的时间</li>
<li>write_uid：最后写入记录的用户</li>
<li>write_date：最后写入记录的日期</li>
<li>name(Char类型)：默认作为记录的显示名称</li>
<li>active(Boolean类型)：允许是否关闭记录</li>
<li>state(Selection类型)：记录生命周期的基本状态，允许使用states字段属性来根据记录状态以具备不同的UI行为</li>
<li>parent_id(Integer类型)：父子层级关系</li>
<li>parent_path(Char类型)：父子层级关系</li>
</ul>
<p><strong>模型间的关系</strong></p>
<p>以图书、出版社、作者为例。</p>
<ul>
<li><strong>many-to-one:</strong><br><br> many-to-one关联是对其他模型记录的引用，基本的使用：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publisher_id = fields.Many2one(<span class="string">&#x27;res.partner&#x27;</span>, string=<span class="string">&#x27;Publisher&#x27;</span>)</span><br></pre></td></tr></table></figure>
  第一个位置参数是关联模型（<code>comodel</code>关键字参数），第二个位置参数为字段标签（<code>string</code>关键字参数）<ul>
<li><code>ondelete</code>关键字参数：定义关联记录被删除时的操作：<ul>
<li>set nulll(默认值)：关联字段被删除时置为空</li>
<li>restricted：抛出错误阻止删除</li>
<li>cascade：关联记录被删除的时候同时删除当前记录</li>
</ul>
</li>
<li><code>context</code>：</li>
<li><code>domain</code>：</li>
<li><code>auto_join=True</code>：允许ORM在使用关联进行搜索的时候使用SQL连接，使用时会跳过访问安全规则，用户可以访问安全规则不允许访问的关联记录，可以加快SQL的查询效率。</li>
<li><code>delegate=True</code>：创建一个关联记录的代理继承，使用时必须设置<code>required=True</code>和<code>ondelete=cascade</code></li>
</ul>
</li>
<li><strong>one-to-many:</strong><br><br>one-to-many关联是many-to-one的反向关联<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">published_book_ids = fields.One2many(</span><br><span class="line">      <span class="string">&#x27;library.book&#x27;</span>, </span><br><span class="line">      <span class="string">&#x27;publisher_id&#x27;</span>,</span><br><span class="line">      string=<span class="string">&#x27;Published Books&#x27;</span>)</span><br></pre></td></tr></table></figure>
三个参数分别是关联模型、被引用的字段名、字段标签，其他的参数和many-to-one相同，（context、domain、ondelete只用于关联中的many一方）</li>
<li><strong>many-to-many：</strong><br><br>在两端都存在to-many关联的时候就可以使用many-to-many关联：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Book model</span></span><br><span class="line">author_ids = fields.Many2many(<span class="string">&#x27;res.partner&#x27;</span>,string=<span class="string">&quot;Authors&quot;</span>)</span><br><span class="line"><span class="comment"># Partner model</span></span><br><span class="line">book_ids = fields.Many2many(<span class="string">&#x27;library.book&#x27;</span>, string=<span class="string">&#x27;Authored Books&#x27;</span>)</span><br></pre></td></tr></table></figure>
Many2many最少要包含一个关联模型位置参数（comodel_name关键字参数），在数据库层面上many-to-many关联不会在已有的表中添加任何列，而是自动创建一个关联表来存储记录间的关联，和django的多对多一样的关联表中仅有两个ID字段，为两张关联表的外键，默认的关联表名由两个表名中间加下划线并在最后加上<code>\_rel</code>组成<br><br>在默认情况下有可能会出现表名长度过长，超出Postgresql数据库63个字符的上限，这时候我们可以选择手动模式，指定关联表<br><br><strong>使用手动方式设置关联表</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用位置参数的方式：</span></span><br><span class="line">author_ids = fields.Many2many(</span><br><span class="line">  <span class="string">&#x27;res.partner&#x27;</span>, <span class="comment"># 关联模型（必填）</span></span><br><span class="line">  <span class="string">&#x27;library_book_res_partner_rel&#x27;</span>, <span class="comment"># 要使用的关联表名</span></span><br><span class="line">  <span class="string">&#x27;a_id&#x27;</span>, <span class="comment"># 本记录关联表字段</span></span><br><span class="line">  <span class="string">&#x27;p_id&#x27;</span>, <span class="comment"># 关联记录关联表字段</span></span><br><span class="line">  <span class="string">&#x27;Authors&#x27;</span>) <span class="comment"># string标签文本</span></span><br><span class="line"><span class="comment"># 使用关键字参数的方式：</span></span><br><span class="line">author_ids = fields.Many2many(</span><br><span class="line">  comodel_name=<span class="string">&#x27;res.partner&#x27;</span>, <span class="comment"># 关联模型(必填)</span></span><br><span class="line">  relation=<span class="string">&#x27;library_book_res_partner_rel&#x27;</span>, <span class="comment"># 关联表名</span></span><br><span class="line">  column1=<span class="string">&#x27;a_id&#x27;</span>, <span class="comment"># 本记录关联表字段</span></span><br><span class="line">  column2=<span class="string">&#x27;p_id&#x27;</span>, <span class="comment"># 关联记录关联表字段</span></span><br><span class="line">  string=<span class="string">&#x27;Authors&#x27;</span>) <span class="comment"># string标签文本</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>使用引用字段的弹性关联：</strong><br><br>  普通关联字段指定固定的引用模型，但是Reference字段可不受限，支持弹性关联，例如：<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">highlighted_id = fields.Reference(</span><br><span class="line">    [(<span class="string">&#x27;library.book&#x27;</span>,Book),(<span class="string">&#x27;res.partner&#x27;</span>,<span class="string">&#x27;Author&#x27;</span>)] , <span class="comment"># [(model, id),()]</span></span><br><span class="line">    <span class="string">&#x27;Category Highlight&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>  用户可以在操作界面中选择模型，然后选择模型中的记录</p>
<p><strong>计算字段：</strong><br><br>  字段值除了普通的读取数据库存储外，还可以实现函数计算，计算字段和普通的字段相似，只是增加了一个额外的compute参数来定义用于计算的函数<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">publisher_country_id = fields.Many2many(</span><br><span class="line">    <span class="string">&#x27;res.country&#x27;</span>, string=<span class="string">&quot;publisher Country&quot;</span>,</span><br><span class="line">    compute=<span class="string">&#x27;_compute_publisher_country&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="meta">@api.depends(<span class="params"><span class="string">&#x27;publisher_id.country_id&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_compute_publisher_country</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> book <span class="keyword">in</span> self:</span><br><span class="line">        book.publisher_country_id = book.publisher_id.country_id</span><br></pre></td></tr></table></figure><br>  compute的值为定义的计算函数名，如果计算函数需要使用其他字段就需要使用<code>@api.depends</code>装饰器，参数为一个或多个字段名。</p>
<ul>
<li>搜索和写入计算字段<br><br>上面简单的例子只能读取，还不能搜索和写入，默认情况下计算字段是实时计算，不会存储到数据库中，如果需要写入数据库可以通过现实特殊的方法来开启搜索和写入的操作，计算字段可预compute方法一起设置实现搜索逻辑的search方法，以及实现写入逻辑的inverse方法，例如：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">publisher_country_id = fields.Many2many(</span><br><span class="line">    <span class="string">&#x27;res.country&#x27;</span>, string=<span class="string">&#x27;Publisher Country&#x27;</span>,</span><br><span class="line">    compute = <span class="string">&#x27;_compute_publish_country&#x27;</span>,</span><br><span class="line">    inverser = <span class="string">&#x27;_inverser_publish_country&#x27;</span>,</span><br><span class="line">    search = <span class="string">&#x27;_serach_publish_country&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_inverse_publisher_country</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> book <span class="keyword">in</span> self:</span><br><span class="line">        book.publisher_id.country_id = book.publisher_country_id</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_search_publisher_country</span>(<span class="params">self, opearator, value</span>):</span><br><span class="line">    <span class="keyword">return</span> [(<span class="string">&#x27;publisher_id.country_id&#x27;</span>, operator, value)]</span><br></pre></td></tr></table></figure>
计算字段的写入是计算的反向逻辑</li>
</ul>
<p><strong>存储计算字段：</strong><br><br>   通过在定义时设置<code>store=True</code>还可以将计算字段值保存到数据库中。在任意依赖变更时值就会重新计算。因为值已被存储，所以可以像普通字段一样被搜索，也就不需要使用search方法了。</p>
<p><strong>关联字段：</strong><br><br>   创建关联字段的时候，我们像普通计算字段一样声明一个所需字段类型，使用related属性设置用点号标记链来使用所需的字段，可以使用引用字段来获取与上例publisher_country_id计算字段相同的效果：<br>   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">publisher_country_id = fields.Many2one(</span><br><span class="line">    <span class="string">&#x27;res.country&#x27;</span>, string=<span class="string">&#x27;Publisher Country&#x27;</span>,</span><br><span class="line">     related=<span class="string">&#x27;publisher_id.country_id&#x27;</span>,</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><br>   本质上关联字段仅仅是快捷实现<code>search</code>和<code>inverse</code>方法的计算字段。也就是说可以直接对其进行搜索和写入，而无需书写额外的代码。默认关联字段是只读的，因inverse写操作不可用，可通过readonly&#x3D;False字段属性来开启写操作。</p>
<p><strong>模型约束：</strong></p>
<ul>
<li>SQL模型约束：<br><br>SQL约束加在数据表定义中，并由Postgresql直接执行，使用_sql_constraints类属性来定义，值一般是一个由元组组成的列表，每个元组格式为(name,code,error):<ul>
<li>name:约束标识名</li>
<li>code:SQL语句</li>
<li>error:是在约束验证为通过时向用户显示的错误信息<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_sql_constraints = [</span><br><span class="line">        (<span class="string">&#x27;library_book_name_date_uq&#x27;</span>, <span class="comment"># 约束唯一标识符</span></span><br><span class="line">        <span class="string">&#x27;UNIQUE (name, date_published)&#x27;</span>, <span class="comment"># 约束 SQL 语法</span></span><br><span class="line">        <span class="string">&#x27;Book title and publication date must be unique&#x27;</span>), <span class="comment"># 消息</span></span><br><span class="line">        (<span class="string">&#x27;library_book_check_date&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;CHECK (date_published &lt;= current_date)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Publication date must not be in the future.&#x27;</span>),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Python模型约束：<br><br>Python约束可以自定义代码来检查条件。检查方法应添加@api.constrains装饰器，并且包含要检查的字段列表，其中任意字段被修改就会触发验证，并且在未满足条件时抛出异常。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@api.constrains(<span class="params"><span class="string">&#x27;isbn&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_constrain_isbn_valid</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> book <span class="keyword">in</span> self:</span><br><span class="line">        <span class="keyword">if</span> book.isbn <span class="keyword">and</span> <span class="keyword">not</span> book._check_isbn():</span><br><span class="line">            <span class="keyword">raise</span> ValidationError(<span class="string">&#x27;%s is an invalid ISBN&#x27;</span> % book.isbn)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>base模型</strong></p>
<p>Odoo自带有base插件，提供了Odoo应用所需的基本功能，base模块中包含两类模型：</p>
<ul>
<li>ir模型：信息仓库，存储Odoo所需的数据<ul>
<li>ir.actions.act_window：用于窗口操作</li>
<li>ir.ui.menu：用于菜单选项</li>
<li>ir.ui.view：用于视图</li>
<li>ir.model：用于模型</li>
<li>ir.model.fields：用于模型字段</li>
<li>ir.model.data：用于XML ID</li>
</ul>
</li>
<li>res模型：资源，包含基本数据<ul>
<li>res.partner：用于业务伙伴，如客户、供应商和地址等等</li>
<li>res.company：用于公司数据</li>
<li>res.currency：用于货币</li>
<li>res.country：用于国家</li>
<li>res.users：用于应用用户</li>
<li>res.groups：用于应用安全组</li>
</ul>
</li>
</ul>
<h3 id="使用模型数据"><a href="#使用模型数据" class="headerlink" title="使用模型数据"></a>使用模型数据</h3><hr>
<p>shell命令行工具：.&#x2F;odoo-bin shell -d dbname</p>
<ul>
<li>环境属性：<ul>
<li>env.cr：正在使用的数据库游标</li>
<li>env.user： 当前用户的记录</li>
<li>env.uid：会话用户ID，与env.user.id相同</li>
<li>env.context：会话上下文的不可变字典</li>
</ul>
</li>
</ul>
<p>环境提供了对所有已安装模型注册表的访问，如self.env[‘res.partent’]返回一条对partner模型的引用，然后可以使用<code>search()</code>或<code>browse()</code>方法来获取记录集。</p>
<ul>
<li>环境上下文：<br><br>环境上下文是一个带有会话数据的字典，用于客户端用户界面以及ORM和业务逻辑中，在客户端中可以把信息从一个视图带到另一个视图，在服务器端中一些记录集的值会依赖与上下文提供多的本地化设置，也可为服务端代码提供信号。</li>
<li>修改记录集执行环境：<br><br>记录集执行环境是不可变的，如果想要修改可以创建一个变更环境并使用它来执行操作。</li>
</ul>
<h3 id="业务逻辑的处理"><a href="#业务逻辑的处理" class="headerlink" title="业务逻辑的处理"></a>业务逻辑的处理</h3><hr>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ul>
<li><p>增加字段出现问题<br><br>修改类似与res.partner这种基础表的结构需要先使用命令更新数据库方可运行</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./odoo-bin -d database_name  -u module_name</span><br></pre></td></tr></table></figure></li>
<li><p>第一次运行使用命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./odoo-bin --addons-path=addons,./odoo/addons --ddatabase=scm_erp -i base</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建模块</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./odoo-bin scaffold purchase_separate my_addons</span><br></pre></td></tr></table></figure></li>
</ul>
<p>odoo的api修饰符</p>
<ul>
<li>@api.returns</li>
<li>@api.one：自动遍历记录集，self会变成当前的记录集（类似于一个for循环的遍历）</li>
<li>@api.multi：不遍历，self保持为当前的记录集</li>
<li>@api.model：将旧的API函数转换为带有新API函数，使得代码可以平滑迁移</li>
<li>@api.constrains：被修饰函数会在create、write、unlink时被调用</li>
<li>@api.depends：添加依赖字段</li>
<li>@api.onchange</li>
<li>@api.noguess</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-12-06T18:21:08.000Z" title="12/7/2020, 2:21:08 AM">2020-12-07</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/Django/">Django</a></span><span class="level-item">6 分钟读完 (大约967个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/07/Django%E6%96%87%E6%A1%A3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">Django文档阅读笔记</a></h1><div class="content"><h2 id="模型（Model）"><a href="#模型（Model）" class="headerlink" title="模型（Model）"></a>模型（Model）</h2><h4 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h4><ul>
<li><p>null和blank的区别</p>
<p>null和blank默认都是为false的，不能为空，而null是数据库层面的不为空，blank则会影响form验证（blank&#x3D;True表单验证的时候可以为空，blank&#x3D;False表单验证不能为空）</p>
</li>
<li><p>choice</p>
<p>choice参数值为列表或元组，可以通过<code>get_FOO_display()</code>方法获取其显示的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(models.Model):</span><br><span class="line">    SHIRT_SIZES = (</span><br><span class="line">        (<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;Small&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;Medium&#x27;</span>),</span><br><span class="line">        (<span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;Large&#x27;</span>),</span><br><span class="line">    )</span><br><span class="line">    name = models.CharField(max_length=<span class="number">60</span>)</span><br><span class="line">    shirt_size = models.CharField(max_length=<span class="number">1</span>, choices=SHIRT_SIZES)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Person(name=<span class="string">&quot;Fred Flintstone&quot;</span>, shirt_size=<span class="string">&quot;L&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.save()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.shirt_size</span><br><span class="line"><span class="string">&#x27;L&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.get_shirt_size_display()</span><br><span class="line"><span class="string">&#x27;Large&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>primary_key</p>
<p>在Django的一个模型中必须有一个主键字段，如果没有设置过primary_key &#x3D; True，Django会自动创建一个自增的字段作为主键</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span> = models.AutoField(primary_key=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>related_name</p>
<p>  ForeignKey 的 related_name 可以为反向关系定义一个有意义的名称</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span>:</span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">    first_name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    last_name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">    company = models.ForeignKey(Company, on_delete=models.CASCADE, related_name=<span class="string">&#x27;employees&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>  上面代码意味着， Company 有一个employees特殊属性, 该属性将返回一个 QuerySet，其中包含与此公司相关的所有员工实例</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">google = Company.objects.get(name=<span class="string">&#x27;Google&#x27;</span>)</span><br><span class="line">google.employees.<span class="built_in">all</span>()</span><br></pre></td></tr></table></figure>
<p>  你也可以通过反向关系， 来更新Company的employees字段.</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vitor = Employee.objects.get(first_name=<span class="string">&#x27;Vitor&#x27;</span>)</span><br><span class="line">google = Company.objects.get(name=<span class="string">&#x27;Google&#x27;</span>)</span><br><span class="line">google.employees.add(vitor)</span><br></pre></td></tr></table></figure></li>
<li><p>related_query_name</p>
<p>这种关系也是用于查询过滤器， 比如我们要查询雇佣名为「Vitor」的所有公司:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">companies = Company.objects.<span class="built_in">filter</span>(employee__first_name=<span class="string">&#x27;Vitor&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果你想自定义此关系的查询名称可以这样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>:</span><br><span class="line">first_name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">last_name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line">company = models.ForeignKey(</span><br><span class="line">    Company,</span><br><span class="line">    on_delete=models.CASCADE,</span><br><span class="line">    related_name=<span class="string">&#x27;employees&#x27;</span>,</span><br><span class="line">    related_query_name=<span class="string">&#x27;person&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>然后这样查询</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">companies = Company.objects.<span class="built_in">filter</span>(person__first_name=<span class="string">&#x27;Vitor&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Meta选项"><a href="#Meta选项" class="headerlink" title="Meta选项"></a>Meta选项</h4><ul>
<li><p>app_label：string</p>
<p>定义APP名称（模型不是在APP中定义的，需要声明）</p>
</li>
<li><p>db_table：string</p>
<p>自定义数据库表名</p>
</li>
<li><p>ordering：[string, ]</p>
<p>对象的默认排序，参数值为包含字段名的列表， 其中如果字段名前缀加了<code>-</code> 为降序，否则为升序</p>
</li>
<li><p>managed：Boolean</p>
<p>默认为True，Django会在迁移过程中创建或删除数据库表，如果为False时则不会执行数据库表创建或删除操作，（如果模型中包含多对多的关联字段则不会创建多对多联接中间表，但是托管模型和非托管模型之间的中间表，想要修改这个行为需要将中间表设为自定义模型）</p>
</li>
<li><p>order_with_respect_to: string</p>
<p>可用于使相关对象相对于父对象可排序，<strong>需要注意的是不能和ordering一起使用</strong>  例如问题和回答的排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Question</span>(models.Model):</span><br><span class="line">    text = models.TextField()</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Answer</span>(models.Model):</span><br><span class="line">    question = models.ForeignKey(Question, on_delete=models.CASCADE)</span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Meta</span>:</span><br><span class="line">        order_with_respect_to = <span class="string">&#x27;question&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提供两个默认的方法来设置相关对象的顺序</span></span><br><span class="line"><span class="comment"># 1.get_RELATED_order() 返回包含相关对象的主键列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>question = Question.objects.get(<span class="built_in">id</span>=<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>question.get_answer_order()</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 2.set_RELATED_order() 通过传入主键列表来设置排序结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>question.set_answer_order([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># get_next_in_order() get_previous_in_order() 获取下一个、前一个对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>answer = Answer.objects.get(<span class="built_in">id</span>=<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>answer.get_next_in_order()</span><br><span class="line">&lt;Answer: <span class="number">3</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>answer.get_previous_in_order()</span><br><span class="line">&lt;Answer: <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>permission：[(permission_code, human_readable_permission_name),]</p>
<p>Django会自动为每个模型创建添加，修改，删除和查看的权限，permission可以添加新的自定义权限</p>
</li>
<li><p>default_permission: []</p>
<p>默认权限</p>
</li>
<li><p>required_db_features</p>
<p>仅在某些功能（数据库的）打开的情况下同步</p>
</li>
<li><p>required_db_vendor</p>
<p>指定数据库类型，满足条件才会同步</p>
</li>
<li><p>indexes</p>
<p>指定模型上的索引列表</p>
</li>
<li><p>unique_together: tuple(tuple)</p>
<p>联合唯一</p>
</li>
</ul>
<h4 id="管理器"><a href="#管理器" class="headerlink" title="管理器"></a>管理器</h4></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-09-24T08:42:49.000Z" title="9/24/2020, 4:42:49 PM">2020-09-24</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/Django/">Django</a></span><span class="level-item">2 分钟读完 (大约364个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/09/24/Django%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CCSRF%E9%AA%8C%E8%AF%81/">Django中间件执行流程和CSRF验证</a></h1><div class="content"><h3 id="中间件执行流程"><a href="#中间件执行流程" class="headerlink" title="中间件执行流程"></a>中间件执行流程</h3><p>django的中间件是一个轻量级的插件，可以改变django的输入和输出，中间件共有5种方法，分别为</p>
<ol>
<li>process_request(self,request)</li>
<li>process_view(self, request, callback, callback_args, callback_kwargs)</li>
<li>process_template_response(self,request,response)</li>
<li>process_exception(self, request, exception)</li>
<li>process_response(self, request, response)</li>
</ol>
<p>前两个方法 都是自上而下的执行每个中间件，后面的三个都是反着来的<br><img src="/2020/09/24/Django%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%92%8CCSRF%E9%AA%8C%E8%AF%81/1.png"></p>
<h3 id="CSRF验证"><a href="#CSRF验证" class="headerlink" title="CSRF验证"></a>CSRF验证</h3><p>django的CSRF是基于中间件来实现的，而且是放在中间件中的view方法中，原因是：django的中间件是作用于全局的，但是某些情况某个函数可能不需要用到CSRF验证，所以在执行路由匹配的时候找到视图函数，看看他是否需要用到CSRF认证，如果不需要则会跳过CSRF。</p>
<p>免除认证的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FBV</span></span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="meta">@csrf_exempt</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在CBV的方式中，单独给某个方法通过装饰器来免除是无效的，需要加到dispatch函数上面</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法1</span></span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_exempt</span><br><span class="line"><span class="keyword">from</span> django.utils.decorators <span class="keyword">import</span> method_decorator</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test1</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line"><span class="meta">    @method_decorator(<span class="params">csrf_exempt</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dispatch</span>(<span class="params">self, request, *args, **kwargs</span>):</span><br><span class="line">        ret = <span class="built_in">super</span>(Test1,self).dispatch(request, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line"><span class="meta">@method_decorator(<span class="params">csrf_exempt,name=<span class="string">&#x27;dispatch&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test2</span>(<span class="title class_ inherited__">APIView</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>单独想用CSRF的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.去掉setting中CSRF中间件</span></span><br><span class="line"><span class="keyword">from</span> django.views.decorators.csrf <span class="keyword">import</span> csrf_protect</span><br><span class="line"><span class="meta">@csrf_protect</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2019-12-22T18:21:08.000Z" title="12/23/2019, 2:21:08 AM">2019-12-23</time>发表</span><span class="level-item"><a class="link-muted" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></span><span class="level-item">11 分钟读完 (大约1614个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/23/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/">MySQL必知必会总结（二）</a></h1><div class="content"><h4 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h4><p>一般数据库中存储的数据可能不会是我们所需要的格式，例如存储一个地址，在数据库中可能会将城市、区和街道分别存入不同的列中，但是我们可能需要直接获取一个完整的地址，这时候就需要做一些转换操作了，可以直接取出每个字段的值，然后在我们自己的程序中组合，同样也可以使用SQL直接在数据库中完成，而且一般来说在数据库中完成这些操作要率相对于我们自己去实现要快，下面就是一些常用的计算方法。</p>
<p>表：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>category</th>
<th>number</th>
<th>price</th>
</tr>
</thead>
<tbody><tr>
<td>硬盘</td>
<td>电子类</td>
<td>10</td>
<td>399</td>
</tr>
<tr>
<td>乐事薯片</td>
<td>食品类</td>
<td>24</td>
<td>7.5</td>
</tr>
<tr>
<td>PS4</td>
<td>电子类</td>
<td>1</td>
<td>2799</td>
</tr>
<tr>
<td>流畅的Python</td>
<td>书籍类</td>
<td>5</td>
<td>105</td>
</tr>
</tbody></table>
<ul>
<li><p>拼接字段</p>
<p>在select语句中可以使用Concat()函数实现两列的拼接操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(name,<span class="string">&#x27;(&#x27;</span>,category,<span class="string">&#x27;)&#x27;</span>) <span class="keyword">as</span> goods <span class="keyword">from</span> goods</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">goods</th>
</tr>
</thead>
<tbody><tr>
<td align="left">硬盘(电子类)</td>
</tr>
<tr>
<td align="left">乐事薯片(食品类)</td>
</tr>
<tr>
<td align="left">PS4(电子类)</td>
</tr>
<tr>
<td align="left">流畅的Python(书籍类)</td>
</tr>
</tbody></table>
<p>其他：RTrim()函数去除右边所有空格，LTrim()去除左边所有空格， as：使用别名</p>
</li>
<li><p>执行算术计算</p>
<p>依然使用上面那个表，如果我们需要取出所有商品的总金额，我们可以取出每行的价格和数量自己计算，同样也可是使用MySQL计算完成之后直接返回总金额。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, number<span class="operator">*</span>price <span class="keyword">as</span> total_price <span class="keyword">from</span> goods</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>name</th>
<th>total_price</th>
</tr>
</thead>
<tbody><tr>
<td>硬盘</td>
<td>3990</td>
</tr>
<tr>
<td>乐事薯片</td>
<td>180</td>
</tr>
<tr>
<td>PS4</td>
<td>2799</td>
</tr>
<tr>
<td>流畅的Python</td>
<td>525</td>
</tr>
</tbody></table>
<p>MySQL支持的运算符有 +、 -、 *、 &#x2F;  ，可以使用()来区分计算顺序。</p>
</li>
</ul>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul>
<li><p>文本处理函数</p>
<table>
<thead>
<tr>
<th>函 数</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>Left(str,length)</td>
<td>返回串左边的字符</td>
</tr>
<tr>
<td>Length(str)</td>
<td>返回串的长度(字节长度 )， UTF-8编码中文三个字节，英文一个字节</td>
</tr>
<tr>
<td>Locate(<a target="_blank" rel="noopener" href="http://xiaolan.gjjblog.com/">substr</a>,str,pos)</td>
<td>返回子串 substr 在<a target="_blank" rel="noopener" href="http://xiaolan.gjjblog.com/">字符串</a> str 第 pos 位置后中第一次出现的位置。如果子串 substr 在 str 中不存在，返回值为 0   <strong>（pos可选）</strong></td>
</tr>
<tr>
<td>Lower(str)</td>
<td>将串转换为小写</td>
</tr>
<tr>
<td>LTrim(str)</td>
<td>去掉串左边的空格</td>
</tr>
<tr>
<td>Righ(str,length)</td>
<td>返回串右边的字符</td>
</tr>
<tr>
<td>RTrim(str)</td>
<td>去掉串右边的空格</td>
</tr>
<tr>
<td>Soundex()</td>
<td>返回串的SOUNDEX值（不常用）SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法</td>
</tr>
<tr>
<td>SubString(str, pos, len)</td>
<td>返回字符串第pos位置后的len长度的子串  <strong>第一个字符pos为1，len可选，默认到最后一位</strong></td>
</tr>
<tr>
<td>Upper()</td>
<td>将串转换为大写</td>
</tr>
</tbody></table>
</li>
<li><p>日期和时间处理函数</p>
<table>
<thead>
<tr>
<th>AddDate()</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>AddDate()</td>
<td>增加一个日期（天、周等）</td>
</tr>
<tr>
<td>AddTime()</td>
<td>增加一个时间（时、分等）</td>
</tr>
<tr>
<td>CurDate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CurTime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>Date()</td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td>DateDiff()</td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td>Date_Add()</td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr>
<td>Date_Format()</td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td>Day()</td>
<td>返回一个日期的天数部分</td>
</tr>
<tr>
<td>DayOfWeek()</td>
<td>对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td>Hour()</td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td>Minute()</td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td>Month()</td>
<td>返回一个日期的月份部分</td>
</tr>
<tr>
<td>Now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>Second()</td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td>Time()</td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td>Year()</td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody></table>
</li>
<li><p>数值处理函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Abs()</td>
<td>返回一个数的绝对值</td>
</tr>
<tr>
<td>Cos()</td>
<td>返回一个角度的余弦</td>
</tr>
<tr>
<td>Exp()</td>
<td>返回一个数的指数值</td>
</tr>
<tr>
<td>Mod()</td>
<td>返回除操作的余数</td>
</tr>
<tr>
<td>Pi()</td>
<td>返回圆周率</td>
</tr>
<tr>
<td>Rand()</td>
<td>返回一个随机数</td>
</tr>
<tr>
<td>Sin()</td>
<td>返回一个角度的正弦</td>
</tr>
<tr>
<td>Sqrt()</td>
<td>返回一个数的平方根</td>
</tr>
<tr>
<td>Tan()</td>
<td>返回一个角度的正切</td>
</tr>
</tbody></table>
</li>
<li><p>聚集函数</p>
<p>默认参数为ALL，可使用DISTINCT关键字</p>
<table>
<thead>
<tr>
<th>函 数</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>AVG()</td>
<td>返回某列的平均值</td>
</tr>
<tr>
<td>COUNT()</td>
<td>返回某列的行数（指定列名会忽略NULL行）</td>
</tr>
<tr>
<td>MAX()</td>
<td>返回某列的最大值</td>
</tr>
<tr>
<td>MIN()</td>
<td>返回某列的最小值</td>
</tr>
<tr>
<td>SUM()</td>
<td>返回某列值之和</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="数据的分组"><a href="#数据的分组" class="headerlink" title="数据的分组"></a>数据的分组</h4><table>
<thead>
<tr>
<th>name</th>
<th>category</th>
<th>number</th>
<th>price</th>
</tr>
</thead>
<tbody><tr>
<td>硬盘</td>
<td>电子类</td>
<td>10</td>
<td>399</td>
</tr>
<tr>
<td>乐事薯片</td>
<td>食品类</td>
<td>24</td>
<td>7.5</td>
</tr>
<tr>
<td>PS4</td>
<td>电子类</td>
<td>1</td>
<td>2799</td>
</tr>
<tr>
<td>流畅的Python</td>
<td>书籍类</td>
<td>5</td>
<td>105</td>
</tr>
</tbody></table>
<ul>
<li><p>GROUP BY</p>
<p>按照category分组，并计算每组的数量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> category , <span class="built_in">count</span>(<span class="operator">*</span>)<span class="keyword">as</span> num <span class="keyword">from</span> goods <span class="keyword">group</span> <span class="keyword">by</span> category </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>category</th>
<th>num</th>
</tr>
</thead>
<tbody><tr>
<td>书籍类</td>
<td>1</td>
</tr>
<tr>
<td>电子类</td>
<td>2</td>
</tr>
<tr>
<td>食品类</td>
<td>1</td>
</tr>
</tbody></table>
<ul>
<li>GROUP BY子句可以包含任意数目的列</li>
<li>如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li>
<li>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</li>
<li>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</li>
<li>如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</li>
<li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前</li>
</ul>
</li>
<li><p>HAVING（过滤分组）</p>
<p>HAVING类似于WHERE，所有的WHERE子句都可以使用HAVING来代替，两者唯一的差别是WHERE过滤行而HAVING过滤分组，换一句话说，WHERE在数据分组之前过滤，HAVING在分组之后过滤，WHERE排除的行不包含在分组之中。</p>
<p>选取种类大于等于两个的分组</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> category, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> num <span class="keyword">from</span> goods <span class="keyword">group</span> <span class="keyword">by</span> category <span class="keyword">HAVING</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>category</th>
<th>num</th>
</tr>
</thead>
<tbody><tr>
<td>电子类</td>
<td>2</td>
</tr>
</tbody></table>
</li>
<li><p>分组排序</p>
<p>使用GROUP BY分组得到的数据顺序可能不是统一的，如果想实现分组排序还需要用到ORDER BY对分组结果进行排序</p>
<p>例如按照category分组，并按照数目从小到大排序</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> category ,<span class="built_in">count</span>(<span class="operator">*</span>) num <span class="keyword">from</span> goods <span class="keyword">group</span> <span class="keyword">by</span> category <span class="keyword">order</span> <span class="keyword">by</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>category</th>
<th>num</th>
</tr>
</thead>
<tbody><tr>
<td>食品类</td>
<td>1</td>
</tr>
<tr>
<td>书籍类</td>
<td>1</td>
</tr>
<tr>
<td>电子类</td>
<td>2</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>总结一下</strong></p>
<p><strong>在SELECT语句中，所有子句的顺序如下</strong></p>
<p><strong>SELECT →  FROM  → WHERE → GROUP BY → HAVING → ORDER BY</strong></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/9/">9</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/site/avatar.png" alt="fanmlei"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">fanmlei</p><p class="is-size-6 is-block">努力成为一名GEEK！</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Wuhan, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">81</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">12</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">37</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/fanmlei" target="_blank" rel="noopener">关注我</a></div></div></div><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Arduino/"><span class="level-start"><span class="level-item">Arduino</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Django/"><span class="level-start"><span class="level-item">Django</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Odoo/"><span class="level-start"><span class="level-item">Odoo</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Python/"><span class="level-start"><span class="level-item">Python</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/Python/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="level-start"><span class="level-item">微信小程序</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"><span class="level-start"><span class="level-item">未分类</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%89%A9%E8%81%94%E7%BD%91/"><span class="level-start"><span class="level-item">物联网</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-16T02:35:18.000Z">2021-08-16</time></p><p class="title"><a href="/2021/08/16/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B5%85%E6%9E%90/">Python的多线程使用浅析</a></p><p class="categories"><a href="/categories/Python/">Python</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-14T08:30:24.000Z">2021-05-14</time></p><p class="title"><a href="/2021/05/14/Django%20rest%20framework%20%20%E8%AE%A4%E8%AF%81%E7%BB%84%E4%BB%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Django rest framework  认证组件源码分析</a></p><p class="categories"><a href="/categories/Django/">Django</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-05-07T11:42:49.000Z">2021-05-07</time></p><p class="title"><a href="/2021/05/07/HTTP%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/">HTTP协议基础</a></p><p class="categories"><a href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-19T18:21:08.000Z">2021-04-20</time></p><p class="title"><a href="/2021/04/20/Postgresql%E7%9A%84%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%8A%9F%E8%83%BD/">Postgresql的全文检索功能</a></p><p class="categories"><a href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-04-17T11:42:49.000Z">2021-04-17</time></p><p class="title"><a href="/2021/04/17/jieba+whoosh%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E5%95%86%E5%93%81%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/">jieba+whoosh实现简单的商品搜索功能</a></p><p class="categories"><a href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/02/"><span class="level-start"><span class="level-item">二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/12/"><span class="level-start"><span class="level-item">十二月 2018</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/11/"><span class="level-start"><span class="level-item">十一月 2018</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/10/"><span class="level-start"><span class="level-item">十月 2018</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/06/"><span class="level-start"><span class="level-item">六月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/05/"><span class="level-start"><span class="level-item">五月 2018</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/12/"><span class="level-start"><span class="level-item">十二月 2017</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2017/11/"><span class="level-start"><span class="level-item">十一月 2017</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Arduino/"><span class="tag">Arduino</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CSRF/"><span class="tag">CSRF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/DRF/"><span class="tag">DRF</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Django/"><span class="tag">Django</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Django%E6%A8%A1%E7%89%88/"><span class="tag">Django模版</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Excel/"><span class="tag">Excel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HTTP/"><span class="tag">HTTP</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MQ/"><span class="tag">MQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PyQt/"><span class="tag">PyQt</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Reids/"><span class="tag">Reids</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/WebSocket/"><span class="tag">WebSocket</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/bug/"><span class="tag">bug</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/jQuery/"><span class="tag">jQuery</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/odoo/"><span class="tag">odoo</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/web%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="tag">web中间件</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E8%AF%8D/"><span class="tag">分词</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"><span class="tag">前后端分离</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tag">前端</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%8E%E7%AB%AF/"><span class="tag">后端</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"><span class="tag">小程序</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8E%92%E5%BA%8F/"><span class="tag">排序</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%94%AF%E4%BB%98/"><span class="tag">支付</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"><span class="tag">文件处理</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%BA%90%E7%A0%81/"><span class="tag">源码</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%89%A9%E8%81%94%E7%BD%91/"><span class="tag">物联网</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%99%BB%E5%BD%95/"><span class="tag">登录</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%A1%AC%E4%BB%B6/"><span class="tag">硬件</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="tag">笔记</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><span class="tag">编程基础</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="tag">编程语言</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C/"><span class="tag">网络</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/"><span class="tag">网络请求</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%82%AE%E7%AE%B1/"><span class="tag">邮箱</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%83%A8%E7%BD%B2/"><span class="tag">部署</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%98%9F%E5%88%97/"><span class="tag">队列</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/site/avatar.png" alt="fanmlei`s blog" height="28"></a><p class="is-size-7"><span>&copy; 2022 fanmlei</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/fanmlei/blog"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>